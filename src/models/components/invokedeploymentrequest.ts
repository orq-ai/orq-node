/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The role of the messages author, in this case tool.
 */
export const InvokeDeploymentRequestPrefixMessages5Role = {
  Tool: "tool",
} as const;
/**
 * The role of the messages author, in this case tool.
 */
export type InvokeDeploymentRequestPrefixMessages5Role = ClosedEnum<
  typeof InvokeDeploymentRequestPrefixMessages5Role
>;

/**
 * The contents of the tool message.
 */
export type InvokeDeploymentRequestPrefixMessagesContent =
  | string
  | Array<string>;

export type ToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: InvokeDeploymentRequestPrefixMessages5Role;
  /**
   * The contents of the tool message.
   */
  content: string | Array<string>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
};

/**
 * The type of the content part.
 */
export const InvokeDeploymentRequest2PrefixMessages4ContentType = {
  Refusal: "refusal",
} as const;
/**
 * The type of the content part.
 */
export type InvokeDeploymentRequest2PrefixMessages4ContentType = ClosedEnum<
  typeof InvokeDeploymentRequest2PrefixMessages4ContentType
>;

export type RefusalContentPart = {
  /**
   * The type of the content part.
   */
  type: InvokeDeploymentRequest2PrefixMessages4ContentType;
  /**
   * The refusal message generated by the model.
   */
  refusal: string;
};

/**
 * The type of the content part.
 */
export const InvokeDeploymentRequest2PrefixMessages4Type = {
  Text: "text",
} as const;
/**
 * The type of the content part.
 */
export type InvokeDeploymentRequest2PrefixMessages4Type = ClosedEnum<
  typeof InvokeDeploymentRequest2PrefixMessages4Type
>;

export const InvokeDeploymentRequestAnnotationsType = {
  FilePath: "file_path",
} as const;
export type InvokeDeploymentRequestAnnotationsType = ClosedEnum<
  typeof InvokeDeploymentRequestAnnotationsType
>;

export type FilePath = {
  fileId: string;
};

export type Annotations2 = {
  type: InvokeDeploymentRequestAnnotationsType;
  text: string;
  filePath: FilePath;
  startIndex: number;
  endIndex: number;
};

export const AnnotationsType = {
  FileCitation: "file_citation",
} as const;
export type AnnotationsType = ClosedEnum<typeof AnnotationsType>;

export type FileCitation = {
  fileId: string;
  quote?: string | undefined;
};

export type Annotations1 = {
  type: AnnotationsType;
  text: string;
  fileCitation: FileCitation;
  startIndex: number;
  endIndex: number;
};

export type Annotations = Annotations1 | Annotations2;

export type TextContentPart = {
  /**
   * The type of the content part.
   */
  type: InvokeDeploymentRequest2PrefixMessages4Type;
  /**
   * The text content.
   */
  text: string;
  /**
   * Annotations for the text content.
   */
  annotations?: Array<Annotations1 | Annotations2> | undefined;
};

export type Content2 = TextContentPart | RefusalContentPart;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type PrefixMessagesContent =
  | string
  | Array<TextContentPart | RefusalContentPart>;

/**
 * The role of the messages author, in this case `assistant`.
 */
export const InvokeDeploymentRequestPrefixMessages4Role = {
  Assistant: "assistant",
} as const;
/**
 * The role of the messages author, in this case `assistant`.
 */
export type InvokeDeploymentRequestPrefixMessages4Role = ClosedEnum<
  typeof InvokeDeploymentRequestPrefixMessages4Role
>;

/**
 * Data about a previous audio response from the model.
 */
export type Audio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type Type = ClosedEnum<typeof Type>;

export type FunctionT = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type ToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: Type;
  function: FunctionT;
};

export type AssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<TextContentPart | RefusalContentPart>
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: InvokeDeploymentRequestPrefixMessages4Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: Audio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<ToolCalls> | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the messages author, in this case `user`.
 */
export const InvokeDeploymentRequestPrefixMessagesRole = {
  User: "user",
} as const;
/**
 * The role of the messages author, in this case `user`.
 */
export type InvokeDeploymentRequestPrefixMessagesRole = ClosedEnum<
  typeof InvokeDeploymentRequestPrefixMessagesRole
>;

/**
 * The type of the content part. Always `file`.
 */
export const InvokeDeploymentRequest2PrefixMessagesType = {
  File: "file",
} as const;
/**
 * The type of the content part. Always `file`.
 */
export type InvokeDeploymentRequest2PrefixMessagesType = ClosedEnum<
  typeof InvokeDeploymentRequest2PrefixMessagesType
>;

/**
 * File data for the content part. Must contain either file_data or uri, but not both.
 */
export type FileT = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Four = {
  /**
   * The type of the content part. Always `file`.
   */
  type: InvokeDeploymentRequest2PrefixMessagesType;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: FileT;
};

export const InvokeDeploymentRequest2Type = {
  InputAudio: "input_audio",
} as const;
export type InvokeDeploymentRequest2Type = ClosedEnum<
  typeof InvokeDeploymentRequest2Type
>;

/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export const Format = {
  Mp3: "mp3",
  Wav: "wav",
} as const;
/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export type Format = ClosedEnum<typeof Format>;

export type InputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports `wav` and `mp3`.
   */
  format: Format;
};

export type Three = {
  type: InvokeDeploymentRequest2Type;
  inputAudio: InputAudio;
};

export const TwoType = {
  ImageUrl: "image_url",
} as const;
export type TwoType = ClosedEnum<typeof TwoType>;

/**
 * Specifies the detail level of the image.
 */
export const Detail = {
  Low: "low",
  High: "high",
  Auto: "auto",
} as const;
/**
 * Specifies the detail level of the image.
 */
export type Detail = ClosedEnum<typeof Detail>;

export type ImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded image data.
   */
  url: string;
  /**
   * Specifies the detail level of the image.
   */
  detail?: Detail | undefined;
};

export type Two2 = {
  type: TwoType;
  imageUrl: ImageUrl;
};

export const InvokeDeploymentRequest2PrefixMessages3Type = {
  Text: "text",
} as const;
export type InvokeDeploymentRequest2PrefixMessages3Type = ClosedEnum<
  typeof InvokeDeploymentRequest2PrefixMessages3Type
>;

export type InvokeDeploymentRequest21 = {
  type: InvokeDeploymentRequest2PrefixMessages3Type;
  text: string;
};

export type Two = InvokeDeploymentRequest21 | Two2 | Three | Four;

/**
 * The contents of the user message.
 */
export type Content =
  | string
  | Array<InvokeDeploymentRequest21 | Two2 | Three | Four>;

export type UserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: InvokeDeploymentRequestPrefixMessagesRole;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content: string | Array<InvokeDeploymentRequest21 | Two2 | Three | Four>;
};

/**
 * The role of the messages author, in this case `system`.
 */
export const PrefixMessagesRole = {
  System: "system",
} as const;
/**
 * The role of the messages author, in this case `system`.
 */
export type PrefixMessagesRole = ClosedEnum<typeof PrefixMessagesRole>;

export type SystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: PrefixMessagesRole;
  /**
   * The contents of the system message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The role of the messages author, in this case  `developer`.
 */
export const Role = {
  Developer: "developer",
} as const;
/**
 * The role of the messages author, in this case  `developer`.
 */
export type Role = ClosedEnum<typeof Role>;

export type DeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: Role;
  /**
   * The contents of the developer message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type PrefixMessages =
  | ToolMessage
  | DeveloperMessage
  | SystemMessage
  | UserMessage
  | AssistantMessage;

/**
 * The role of the messages author, in this case tool.
 */
export const InvokeDeploymentRequestMessages5Role = {
  Tool: "tool",
} as const;
/**
 * The role of the messages author, in this case tool.
 */
export type InvokeDeploymentRequestMessages5Role = ClosedEnum<
  typeof InvokeDeploymentRequestMessages5Role
>;

/**
 * The contents of the tool message.
 */
export type InvokeDeploymentRequestMessages5Content = string | Array<string>;

export type MessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: InvokeDeploymentRequestMessages5Role;
  /**
   * The contents of the tool message.
   */
  content: string | Array<string>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
};

/**
 * The type of the content part.
 */
export const InvokeDeploymentRequest2Messages4ContentType = {
  Refusal: "refusal",
} as const;
/**
 * The type of the content part.
 */
export type InvokeDeploymentRequest2Messages4ContentType = ClosedEnum<
  typeof InvokeDeploymentRequest2Messages4ContentType
>;

export type TwoRefusalContentPart = {
  /**
   * The type of the content part.
   */
  type: InvokeDeploymentRequest2Messages4ContentType;
  /**
   * The refusal message generated by the model.
   */
  refusal: string;
};

/**
 * The type of the content part.
 */
export const InvokeDeploymentRequest2Messages4Type = {
  Text: "text",
} as const;
/**
 * The type of the content part.
 */
export type InvokeDeploymentRequest2Messages4Type = ClosedEnum<
  typeof InvokeDeploymentRequest2Messages4Type
>;

export const InvokeDeploymentRequestAnnotationsMessages4Type = {
  FilePath: "file_path",
} as const;
export type InvokeDeploymentRequestAnnotationsMessages4Type = ClosedEnum<
  typeof InvokeDeploymentRequestAnnotationsMessages4Type
>;

export type AnnotationsFilePath = {
  fileId: string;
};

export type InvokeDeploymentRequestAnnotations2 = {
  type: InvokeDeploymentRequestAnnotationsMessages4Type;
  text: string;
  filePath: AnnotationsFilePath;
  startIndex: number;
  endIndex: number;
};

export const InvokeDeploymentRequestAnnotationsMessagesType = {
  FileCitation: "file_citation",
} as const;
export type InvokeDeploymentRequestAnnotationsMessagesType = ClosedEnum<
  typeof InvokeDeploymentRequestAnnotationsMessagesType
>;

export type AnnotationsFileCitation = {
  fileId: string;
  quote?: string | undefined;
};

export type InvokeDeploymentRequestAnnotations1 = {
  type: InvokeDeploymentRequestAnnotationsMessagesType;
  text: string;
  fileCitation: AnnotationsFileCitation;
  startIndex: number;
  endIndex: number;
};

export type TwoAnnotations =
  | InvokeDeploymentRequestAnnotations1
  | InvokeDeploymentRequestAnnotations2;

export type TwoTextContentPart = {
  /**
   * The type of the content part.
   */
  type: InvokeDeploymentRequest2Messages4Type;
  /**
   * The text content.
   */
  text: string;
  /**
   * Annotations for the text content.
   */
  annotations?:
    | Array<
      InvokeDeploymentRequestAnnotations1 | InvokeDeploymentRequestAnnotations2
    >
    | undefined;
};

export type InvokeDeploymentRequestContentMessages2 =
  | TwoTextContentPart
  | TwoRefusalContentPart;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type InvokeDeploymentRequestMessagesContent =
  | string
  | Array<TwoTextContentPart | TwoRefusalContentPart>;

/**
 * The role of the messages author, in this case `assistant`.
 */
export const InvokeDeploymentRequestMessages4Role = {
  Assistant: "assistant",
} as const;
/**
 * The role of the messages author, in this case `assistant`.
 */
export type InvokeDeploymentRequestMessages4Role = ClosedEnum<
  typeof InvokeDeploymentRequestMessages4Role
>;

/**
 * Data about a previous audio response from the model.
 */
export type MessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const MessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type MessagesType = ClosedEnum<typeof MessagesType>;

export type MessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type MessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: MessagesType;
  function: MessagesFunction;
};

export type MessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<TwoTextContentPart | TwoRefusalContentPart>
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: InvokeDeploymentRequestMessages4Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: MessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<MessagesToolCalls> | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the messages author, in this case `user`.
 */
export const InvokeDeploymentRequestMessages3Role = {
  User: "user",
} as const;
/**
 * The role of the messages author, in this case `user`.
 */
export type InvokeDeploymentRequestMessages3Role = ClosedEnum<
  typeof InvokeDeploymentRequestMessages3Role
>;

/**
 * The type of the content part. Always `file`.
 */
export const InvokeDeploymentRequest2Messages3Content4Type = {
  File: "file",
} as const;
/**
 * The type of the content part. Always `file`.
 */
export type InvokeDeploymentRequest2Messages3Content4Type = ClosedEnum<
  typeof InvokeDeploymentRequest2Messages3Content4Type
>;

/**
 * File data for the content part. Must contain either file_data or uri, but not both.
 */
export type TwoFile = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Two4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: InvokeDeploymentRequest2Messages3Content4Type;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: TwoFile;
};

export const InvokeDeploymentRequest2Messages3ContentType = {
  InputAudio: "input_audio",
} as const;
export type InvokeDeploymentRequest2Messages3ContentType = ClosedEnum<
  typeof InvokeDeploymentRequest2Messages3ContentType
>;

/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export const TwoFormat = {
  Mp3: "mp3",
  Wav: "wav",
} as const;
/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export type TwoFormat = ClosedEnum<typeof TwoFormat>;

export type TwoInputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports `wav` and `mp3`.
   */
  format: TwoFormat;
};

export type Two3 = {
  type: InvokeDeploymentRequest2Messages3ContentType;
  inputAudio: TwoInputAudio;
};

export const InvokeDeploymentRequest2Messages3Type = {
  ImageUrl: "image_url",
} as const;
export type InvokeDeploymentRequest2Messages3Type = ClosedEnum<
  typeof InvokeDeploymentRequest2Messages3Type
>;

/**
 * Specifies the detail level of the image.
 */
export const TwoDetail = {
  Low: "low",
  High: "high",
  Auto: "auto",
} as const;
/**
 * Specifies the detail level of the image.
 */
export type TwoDetail = ClosedEnum<typeof TwoDetail>;

export type TwoImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded image data.
   */
  url: string;
  /**
   * Specifies the detail level of the image.
   */
  detail?: TwoDetail | undefined;
};

export type InvokeDeploymentRequest22 = {
  type: InvokeDeploymentRequest2Messages3Type;
  imageUrl: TwoImageUrl;
};

export const InvokeDeploymentRequest2MessagesType = {
  Text: "text",
} as const;
export type InvokeDeploymentRequest2MessagesType = ClosedEnum<
  typeof InvokeDeploymentRequest2MessagesType
>;

export type Two1 = {
  type: InvokeDeploymentRequest2MessagesType;
  text: string;
};

export type InvokeDeploymentRequestContent2 =
  | Two1
  | InvokeDeploymentRequest22
  | Two3
  | Two4;

/**
 * The contents of the user message.
 */
export type MessagesContent =
  | string
  | Array<Two1 | InvokeDeploymentRequest22 | Two3 | Two4>;

export type MessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: InvokeDeploymentRequestMessages3Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content: string | Array<Two1 | InvokeDeploymentRequest22 | Two3 | Two4>;
};

/**
 * The role of the messages author, in this case `system`.
 */
export const InvokeDeploymentRequestMessagesRole = {
  System: "system",
} as const;
/**
 * The role of the messages author, in this case `system`.
 */
export type InvokeDeploymentRequestMessagesRole = ClosedEnum<
  typeof InvokeDeploymentRequestMessagesRole
>;

export type MessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: InvokeDeploymentRequestMessagesRole;
  /**
   * The contents of the system message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The role of the messages author, in this case  `developer`.
 */
export const MessagesRole = {
  Developer: "developer",
} as const;
/**
 * The role of the messages author, in this case  `developer`.
 */
export type MessagesRole = ClosedEnum<typeof MessagesRole>;

export type MessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: MessagesRole;
  /**
   * The contents of the developer message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type Messages =
  | MessagesToolMessage
  | MessagesDeveloperMessage
  | MessagesSystemMessage
  | MessagesUserMessage
  | MessagesAssistantMessage;

/**
 * Metadata about the document
 */
export type Metadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: Metadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
  /**
   * A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage.
   */
  mockResponse?: string | undefined;
};

export type Thread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Exists
 */
export type OrExists = {
  exists: boolean;
};

export type OrNin = string | number | boolean;

/**
 * Not in
 */
export type InvokeDeploymentRequestOrNin = {
  nin: Array<string | number | boolean>;
};

export type OrIn = string | number | boolean;

/**
 * In
 */
export type InvokeDeploymentRequestOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type OrLte = {
  lte: number;
};

/**
 * Less than
 */
export type OrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type OrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type OrGt = {
  gt: number;
};

export type OrNe = string | number | boolean;

/**
 * Not equal to
 */
export type InvokeDeploymentRequestOrNe = {
  ne: string | number | boolean;
};

export type OrEq = string | number | boolean;

/**
 * Equal to
 */
export type InvokeDeploymentRequestOrEq = {
  eq: string | number | boolean;
};

export type Or =
  | InvokeDeploymentRequestOrEq
  | InvokeDeploymentRequestOrNe
  | OrGt
  | OrGte
  | OrLt
  | OrLte
  | InvokeDeploymentRequestOrIn
  | InvokeDeploymentRequestOrNin
  | OrExists;

/**
 * Or
 */
export type KnowledgeFilterOr = {
  or: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestOrEq
        | InvokeDeploymentRequestOrNe
        | OrGt
        | OrGte
        | OrLt
        | OrLte
        | InvokeDeploymentRequestOrIn
        | InvokeDeploymentRequestOrNin
        | OrExists;
    }
  >;
};

/**
 * Exists
 */
export type AndExists = {
  exists: boolean;
};

export type AndNin = string | number | boolean;

/**
 * Not in
 */
export type InvokeDeploymentRequestAndNin = {
  nin: Array<string | number | boolean>;
};

export type AndIn = string | number | boolean;

/**
 * In
 */
export type InvokeDeploymentRequestAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type AndLte = {
  lte: number;
};

/**
 * Less than
 */
export type AndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type AndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type AndGt = {
  gt: number;
};

export type AndNe = string | number | boolean;

/**
 * Not equal to
 */
export type InvokeDeploymentRequestAndNe = {
  ne: string | number | boolean;
};

export type AndEq = string | number | boolean;

/**
 * Equal to
 */
export type InvokeDeploymentRequestAndEq = {
  eq: string | number | boolean;
};

export type And =
  | InvokeDeploymentRequestAndEq
  | InvokeDeploymentRequestAndNe
  | AndGt
  | AndGte
  | AndLt
  | AndLte
  | InvokeDeploymentRequestAndIn
  | InvokeDeploymentRequestAndNin
  | AndExists;

/**
 * And
 */
export type KnowledgeFilterAnd = {
  and: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestAndEq
        | InvokeDeploymentRequestAndNe
        | AndGt
        | AndGte
        | AndLt
        | AndLte
        | InvokeDeploymentRequestAndIn
        | InvokeDeploymentRequestAndNin
        | AndExists;
    }
  >;
};

/**
 * Exists
 */
export type Exists = {
  exists: boolean;
};

export type Nin = string | number | boolean;

/**
 * Not in
 */
export type OneNin = {
  nin: Array<string | number | boolean>;
};

export type In = string | number | boolean;

/**
 * In
 */
export type OneIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type Lte = {
  lte: number;
};

/**
 * Less than
 */
export type Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type Gt = {
  gt: number;
};

export type Ne = string | number | boolean;

/**
 * Not equal to
 */
export type OneNe = {
  ne: string | number | boolean;
};

export type Eq = string | number | boolean;

/**
 * Equal to
 */
export type OneEq = {
  eq: string | number | boolean;
};

export type One = OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;

/**
 * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
 */
export type KnowledgeFilter = KnowledgeFilterAnd | KnowledgeFilterOr | {
  [k: string]: OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;
};

/**
 * The deployment request payload
 */
export type InvokeDeploymentRequest = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * If set, partial message content will be sent. Tokens will be sent as data-only `server-sent events` as they become available, with the stream terminated by a `data: [DONE]` message.
   */
  stream?: boolean | undefined;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: any } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your deployment routing configuration
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?:
    | Array<
      | ToolMessage
      | DeveloperMessage
      | SystemMessage
      | UserMessage
      | AssistantMessage
    >
    | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?:
    | Array<
      | MessagesToolMessage
      | MessagesDeveloperMessage
      | MessagesSystemMessage
      | MessagesUserMessage
      | MessagesAssistantMessage
    >
    | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
  thread?: Thread | undefined;
  /**
   * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
   */
  knowledgeFilter?: KnowledgeFilterAnd | KnowledgeFilterOr | {
    [k: string]: OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;
  } | undefined;
};

/** @internal */
export const InvokeDeploymentRequestPrefixMessages5Role$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessages5Role> = z
    .nativeEnum(InvokeDeploymentRequestPrefixMessages5Role);
/** @internal */
export const InvokeDeploymentRequestPrefixMessages5Role$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessages5Role> =
    InvokeDeploymentRequestPrefixMessages5Role$inboundSchema;

/** @internal */
export const InvokeDeploymentRequestPrefixMessagesContent$inboundSchema:
  z.ZodType<
    InvokeDeploymentRequestPrefixMessagesContent,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type InvokeDeploymentRequestPrefixMessagesContent$Outbound =
  | string
  | Array<string>;

/** @internal */
export const InvokeDeploymentRequestPrefixMessagesContent$outboundSchema:
  z.ZodType<
    InvokeDeploymentRequestPrefixMessagesContent$Outbound,
    z.ZodTypeDef,
    InvokeDeploymentRequestPrefixMessagesContent
  > = z.union([z.string(), z.array(z.string())]);

export function invokeDeploymentRequestPrefixMessagesContentToJSON(
  invokeDeploymentRequestPrefixMessagesContent:
    InvokeDeploymentRequestPrefixMessagesContent,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestPrefixMessagesContent$outboundSchema.parse(
      invokeDeploymentRequestPrefixMessagesContent,
    ),
  );
}
export function invokeDeploymentRequestPrefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeDeploymentRequestPrefixMessagesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestPrefixMessagesContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InvokeDeploymentRequestPrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const ToolMessage$inboundSchema: z.ZodType<
  ToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: InvokeDeploymentRequestPrefixMessages5Role$inboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  tool_call_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type ToolMessage$Outbound = {
  role: string;
  content: string | Array<string>;
  tool_call_id: string;
};

/** @internal */
export const ToolMessage$outboundSchema: z.ZodType<
  ToolMessage$Outbound,
  z.ZodTypeDef,
  ToolMessage
> = z.object({
  role: InvokeDeploymentRequestPrefixMessages5Role$outboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  toolCallId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function toolMessageToJSON(toolMessage: ToolMessage): string {
  return JSON.stringify(ToolMessage$outboundSchema.parse(toolMessage));
}
export function toolMessageFromJSON(
  jsonString: string,
): SafeParseResult<ToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolMessage' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2PrefixMessages4ContentType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages4ContentType> = z
    .nativeEnum(InvokeDeploymentRequest2PrefixMessages4ContentType);
/** @internal */
export const InvokeDeploymentRequest2PrefixMessages4ContentType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages4ContentType> =
    InvokeDeploymentRequest2PrefixMessages4ContentType$inboundSchema;

/** @internal */
export const RefusalContentPart$inboundSchema: z.ZodType<
  RefusalContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages4ContentType$inboundSchema,
  refusal: z.string(),
});
/** @internal */
export type RefusalContentPart$Outbound = {
  type: string;
  refusal: string;
};

/** @internal */
export const RefusalContentPart$outboundSchema: z.ZodType<
  RefusalContentPart$Outbound,
  z.ZodTypeDef,
  RefusalContentPart
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages4ContentType$outboundSchema,
  refusal: z.string(),
});

export function refusalContentPartToJSON(
  refusalContentPart: RefusalContentPart,
): string {
  return JSON.stringify(
    RefusalContentPart$outboundSchema.parse(refusalContentPart),
  );
}
export function refusalContentPartFromJSON(
  jsonString: string,
): SafeParseResult<RefusalContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefusalContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefusalContentPart' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2PrefixMessages4Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages4Type> = z
    .nativeEnum(InvokeDeploymentRequest2PrefixMessages4Type);
/** @internal */
export const InvokeDeploymentRequest2PrefixMessages4Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages4Type> =
    InvokeDeploymentRequest2PrefixMessages4Type$inboundSchema;

/** @internal */
export const InvokeDeploymentRequestAnnotationsType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsType> = z.nativeEnum(
    InvokeDeploymentRequestAnnotationsType,
  );
/** @internal */
export const InvokeDeploymentRequestAnnotationsType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsType> =
    InvokeDeploymentRequestAnnotationsType$inboundSchema;

/** @internal */
export const FilePath$inboundSchema: z.ZodType<
  FilePath,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "file_id": "fileId",
  });
});
/** @internal */
export type FilePath$Outbound = {
  file_id: string;
};

/** @internal */
export const FilePath$outboundSchema: z.ZodType<
  FilePath$Outbound,
  z.ZodTypeDef,
  FilePath
> = z.object({
  fileId: z.string(),
}).transform((v) => {
  return remap$(v, {
    fileId: "file_id",
  });
});

export function filePathToJSON(filePath: FilePath): string {
  return JSON.stringify(FilePath$outboundSchema.parse(filePath));
}
export function filePathFromJSON(
  jsonString: string,
): SafeParseResult<FilePath, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilePath$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilePath' from JSON`,
  );
}

/** @internal */
export const Annotations2$inboundSchema: z.ZodType<
  Annotations2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequestAnnotationsType$inboundSchema,
  text: z.string(),
  file_path: z.lazy(() => FilePath$inboundSchema),
  start_index: z.number().int(),
  end_index: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "file_path": "filePath",
    "start_index": "startIndex",
    "end_index": "endIndex",
  });
});
/** @internal */
export type Annotations2$Outbound = {
  type: string;
  text: string;
  file_path: FilePath$Outbound;
  start_index: number;
  end_index: number;
};

/** @internal */
export const Annotations2$outboundSchema: z.ZodType<
  Annotations2$Outbound,
  z.ZodTypeDef,
  Annotations2
> = z.object({
  type: InvokeDeploymentRequestAnnotationsType$outboundSchema,
  text: z.string(),
  filePath: z.lazy(() => FilePath$outboundSchema),
  startIndex: z.number().int(),
  endIndex: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    filePath: "file_path",
    startIndex: "start_index",
    endIndex: "end_index",
  });
});

export function annotations2ToJSON(annotations2: Annotations2): string {
  return JSON.stringify(Annotations2$outboundSchema.parse(annotations2));
}
export function annotations2FromJSON(
  jsonString: string,
): SafeParseResult<Annotations2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations2' from JSON`,
  );
}

/** @internal */
export const AnnotationsType$inboundSchema: z.ZodNativeEnum<
  typeof AnnotationsType
> = z.nativeEnum(AnnotationsType);
/** @internal */
export const AnnotationsType$outboundSchema: z.ZodNativeEnum<
  typeof AnnotationsType
> = AnnotationsType$inboundSchema;

/** @internal */
export const FileCitation$inboundSchema: z.ZodType<
  FileCitation,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_id: z.string(),
  quote: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_id": "fileId",
  });
});
/** @internal */
export type FileCitation$Outbound = {
  file_id: string;
  quote?: string | undefined;
};

/** @internal */
export const FileCitation$outboundSchema: z.ZodType<
  FileCitation$Outbound,
  z.ZodTypeDef,
  FileCitation
> = z.object({
  fileId: z.string(),
  quote: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileId: "file_id",
  });
});

export function fileCitationToJSON(fileCitation: FileCitation): string {
  return JSON.stringify(FileCitation$outboundSchema.parse(fileCitation));
}
export function fileCitationFromJSON(
  jsonString: string,
): SafeParseResult<FileCitation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileCitation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileCitation' from JSON`,
  );
}

/** @internal */
export const Annotations1$inboundSchema: z.ZodType<
  Annotations1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AnnotationsType$inboundSchema,
  text: z.string(),
  file_citation: z.lazy(() => FileCitation$inboundSchema),
  start_index: z.number().int(),
  end_index: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "file_citation": "fileCitation",
    "start_index": "startIndex",
    "end_index": "endIndex",
  });
});
/** @internal */
export type Annotations1$Outbound = {
  type: string;
  text: string;
  file_citation: FileCitation$Outbound;
  start_index: number;
  end_index: number;
};

/** @internal */
export const Annotations1$outboundSchema: z.ZodType<
  Annotations1$Outbound,
  z.ZodTypeDef,
  Annotations1
> = z.object({
  type: AnnotationsType$outboundSchema,
  text: z.string(),
  fileCitation: z.lazy(() => FileCitation$outboundSchema),
  startIndex: z.number().int(),
  endIndex: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    fileCitation: "file_citation",
    startIndex: "start_index",
    endIndex: "end_index",
  });
});

export function annotations1ToJSON(annotations1: Annotations1): string {
  return JSON.stringify(Annotations1$outboundSchema.parse(annotations1));
}
export function annotations1FromJSON(
  jsonString: string,
): SafeParseResult<Annotations1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations1' from JSON`,
  );
}

/** @internal */
export const Annotations$inboundSchema: z.ZodType<
  Annotations,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Annotations1$inboundSchema),
  z.lazy(() => Annotations2$inboundSchema),
]);
/** @internal */
export type Annotations$Outbound =
  | Annotations1$Outbound
  | Annotations2$Outbound;

/** @internal */
export const Annotations$outboundSchema: z.ZodType<
  Annotations$Outbound,
  z.ZodTypeDef,
  Annotations
> = z.union([
  z.lazy(() => Annotations1$outboundSchema),
  z.lazy(() => Annotations2$outboundSchema),
]);

export function annotationsToJSON(annotations: Annotations): string {
  return JSON.stringify(Annotations$outboundSchema.parse(annotations));
}
export function annotationsFromJSON(
  jsonString: string,
): SafeParseResult<Annotations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations' from JSON`,
  );
}

/** @internal */
export const TextContentPart$inboundSchema: z.ZodType<
  TextContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages4Type$inboundSchema,
  text: z.string(),
  annotations: z.array(
    z.union([
      z.lazy(() => Annotations1$inboundSchema),
      z.lazy(() => Annotations2$inboundSchema),
    ]),
  ).optional(),
});
/** @internal */
export type TextContentPart$Outbound = {
  type: string;
  text: string;
  annotations?:
    | Array<Annotations1$Outbound | Annotations2$Outbound>
    | undefined;
};

/** @internal */
export const TextContentPart$outboundSchema: z.ZodType<
  TextContentPart$Outbound,
  z.ZodTypeDef,
  TextContentPart
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages4Type$outboundSchema,
  text: z.string(),
  annotations: z.array(
    z.union([
      z.lazy(() => Annotations1$outboundSchema),
      z.lazy(() => Annotations2$outboundSchema),
    ]),
  ).optional(),
});

export function textContentPartToJSON(
  textContentPart: TextContentPart,
): string {
  return JSON.stringify(TextContentPart$outboundSchema.parse(textContentPart));
}
export function textContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TextContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextContentPart' from JSON`,
  );
}

/** @internal */
export const Content2$inboundSchema: z.ZodType<
  Content2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TextContentPart$inboundSchema),
  z.lazy(() => RefusalContentPart$inboundSchema),
]);
/** @internal */
export type Content2$Outbound =
  | TextContentPart$Outbound
  | RefusalContentPart$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  z.lazy(() => TextContentPart$outboundSchema),
  z.lazy(() => RefusalContentPart$outboundSchema),
]);

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}
export function content2FromJSON(
  jsonString: string,
): SafeParseResult<Content2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content2' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesContent$inboundSchema: z.ZodType<
  PrefixMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TextContentPart$inboundSchema),
    z.lazy(() => RefusalContentPart$inboundSchema),
  ])),
]);
/** @internal */
export type PrefixMessagesContent$Outbound =
  | string
  | Array<TextContentPart$Outbound | RefusalContentPart$Outbound>;

/** @internal */
export const PrefixMessagesContent$outboundSchema: z.ZodType<
  PrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  PrefixMessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TextContentPart$outboundSchema),
    z.lazy(() => RefusalContentPart$outboundSchema),
  ])),
]);

export function prefixMessagesContentToJSON(
  prefixMessagesContent: PrefixMessagesContent,
): string {
  return JSON.stringify(
    PrefixMessagesContent$outboundSchema.parse(prefixMessagesContent),
  );
}
export function prefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestPrefixMessages4Role$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessages4Role> = z
    .nativeEnum(InvokeDeploymentRequestPrefixMessages4Role);
/** @internal */
export const InvokeDeploymentRequestPrefixMessages4Role$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessages4Role> =
    InvokeDeploymentRequestPrefixMessages4Role$inboundSchema;

/** @internal */
export const Audio$inboundSchema: z.ZodType<Audio, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });
/** @internal */
export type Audio$Outbound = {
  id: string;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
});

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}
export function audioFromJSON(
  jsonString: string,
): SafeParseResult<Audio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Audio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Audio' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);
/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/** @internal */
export const FunctionT$inboundSchema: z.ZodType<
  FunctionT,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type FunctionT$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const FunctionT$outboundSchema: z.ZodType<
  FunctionT$Outbound,
  z.ZodTypeDef,
  FunctionT
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function functionToJSON(functionT: FunctionT): string {
  return JSON.stringify(FunctionT$outboundSchema.parse(functionT));
}
export function functionFromJSON(
  jsonString: string,
): SafeParseResult<FunctionT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionT' from JSON`,
  );
}

/** @internal */
export const ToolCalls$inboundSchema: z.ZodType<
  ToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: Type$inboundSchema,
  function: z.lazy(() => FunctionT$inboundSchema),
});
/** @internal */
export type ToolCalls$Outbound = {
  id: string;
  type: string;
  function: FunctionT$Outbound;
};

/** @internal */
export const ToolCalls$outboundSchema: z.ZodType<
  ToolCalls$Outbound,
  z.ZodTypeDef,
  ToolCalls
> = z.object({
  id: z.string(),
  type: Type$outboundSchema,
  function: z.lazy(() => FunctionT$outboundSchema),
});

export function toolCallsToJSON(toolCalls: ToolCalls): string {
  return JSON.stringify(ToolCalls$outboundSchema.parse(toolCalls));
}
export function toolCallsFromJSON(
  jsonString: string,
): SafeParseResult<ToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolCalls' from JSON`,
  );
}

/** @internal */
export const AssistantMessage$inboundSchema: z.ZodType<
  AssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => TextContentPart$inboundSchema),
        z.lazy(() => RefusalContentPart$inboundSchema),
      ])),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: InvokeDeploymentRequestPrefixMessages4Role$inboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => ToolCalls$inboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type AssistantMessage$Outbound = {
  content?:
    | string
    | Array<TextContentPart$Outbound | RefusalContentPart$Outbound>
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: string;
  name?: string | undefined;
  audio?: Audio$Outbound | null | undefined;
  tool_calls?: Array<ToolCalls$Outbound> | undefined;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const AssistantMessage$outboundSchema: z.ZodType<
  AssistantMessage$Outbound,
  z.ZodTypeDef,
  AssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TextContentPart$outboundSchema),
          z.lazy(() => RefusalContentPart$outboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: InvokeDeploymentRequestPrefixMessages4Role$outboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => ToolCalls$outboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function assistantMessageToJSON(
  assistantMessage: AssistantMessage,
): string {
  return JSON.stringify(
    AssistantMessage$outboundSchema.parse(assistantMessage),
  );
}
export function assistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<AssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AssistantMessage' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestPrefixMessagesRole$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessagesRole> = z
    .nativeEnum(InvokeDeploymentRequestPrefixMessagesRole);
/** @internal */
export const InvokeDeploymentRequestPrefixMessagesRole$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessagesRole> =
    InvokeDeploymentRequestPrefixMessagesRole$inboundSchema;

/** @internal */
export const InvokeDeploymentRequest2PrefixMessagesType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessagesType> = z
    .nativeEnum(InvokeDeploymentRequest2PrefixMessagesType);
/** @internal */
export const InvokeDeploymentRequest2PrefixMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessagesType> =
    InvokeDeploymentRequest2PrefixMessagesType$inboundSchema;

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    file_data: z.string().optional(),
    uri: z.string().optional(),
    mimeType: z.string().optional(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });
/** @internal */
export type FileT$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}
export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({
    type: InvokeDeploymentRequest2PrefixMessagesType$inboundSchema,
    file: z.lazy(() => FileT$inboundSchema),
  });
/** @internal */
export type Four$Outbound = {
  type: string;
  file: FileT$Outbound;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    type: InvokeDeploymentRequest2PrefixMessagesType$outboundSchema,
    file: z.lazy(() => FileT$outboundSchema),
  });

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}
export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2Type$inboundSchema: z.ZodNativeEnum<
  typeof InvokeDeploymentRequest2Type
> = z.nativeEnum(InvokeDeploymentRequest2Type);
/** @internal */
export const InvokeDeploymentRequest2Type$outboundSchema: z.ZodNativeEnum<
  typeof InvokeDeploymentRequest2Type
> = InvokeDeploymentRequest2Type$inboundSchema;

/** @internal */
export const Format$inboundSchema: z.ZodNativeEnum<typeof Format> = z
  .nativeEnum(Format);
/** @internal */
export const Format$outboundSchema: z.ZodNativeEnum<typeof Format> =
  Format$inboundSchema;

/** @internal */
export const InputAudio$inboundSchema: z.ZodType<
  InputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: Format$inboundSchema,
});
/** @internal */
export type InputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const InputAudio$outboundSchema: z.ZodType<
  InputAudio$Outbound,
  z.ZodTypeDef,
  InputAudio
> = z.object({
  data: z.string(),
  format: Format$outboundSchema,
});

export function inputAudioToJSON(inputAudio: InputAudio): string {
  return JSON.stringify(InputAudio$outboundSchema.parse(inputAudio));
}
export function inputAudioFromJSON(
  jsonString: string,
): SafeParseResult<InputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAudio' from JSON`,
  );
}

/** @internal */
export const Three$inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z
  .object({
    type: InvokeDeploymentRequest2Type$inboundSchema,
    input_audio: z.lazy(() => InputAudio$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "input_audio": "inputAudio",
    });
  });
/** @internal */
export type Three$Outbound = {
  type: string;
  input_audio: InputAudio$Outbound;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<
  Three$Outbound,
  z.ZodTypeDef,
  Three
> = z.object({
  type: InvokeDeploymentRequest2Type$outboundSchema,
  inputAudio: z.lazy(() => InputAudio$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    inputAudio: "input_audio",
  });
});

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}
export function threeFromJSON(
  jsonString: string,
): SafeParseResult<Three, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Three$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Three' from JSON`,
  );
}

/** @internal */
export const TwoType$inboundSchema: z.ZodNativeEnum<typeof TwoType> = z
  .nativeEnum(TwoType);
/** @internal */
export const TwoType$outboundSchema: z.ZodNativeEnum<typeof TwoType> =
  TwoType$inboundSchema;

/** @internal */
export const Detail$inboundSchema: z.ZodNativeEnum<typeof Detail> = z
  .nativeEnum(Detail);
/** @internal */
export const Detail$outboundSchema: z.ZodNativeEnum<typeof Detail> =
  Detail$inboundSchema;

/** @internal */
export const ImageUrl$inboundSchema: z.ZodType<
  ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: Detail$inboundSchema.optional(),
});
/** @internal */
export type ImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({
  url: z.string(),
  detail: Detail$outboundSchema.optional(),
});

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}
export function imageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageUrl' from JSON`,
  );
}

/** @internal */
export const Two2$inboundSchema: z.ZodType<Two2, z.ZodTypeDef, unknown> = z
  .object({
    type: TwoType$inboundSchema,
    image_url: z.lazy(() => ImageUrl$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "image_url": "imageUrl",
    });
  });
/** @internal */
export type Two2$Outbound = {
  type: string;
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const Two2$outboundSchema: z.ZodType<Two2$Outbound, z.ZodTypeDef, Two2> =
  z.object({
    type: TwoType$outboundSchema,
    imageUrl: z.lazy(() => ImageUrl$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      imageUrl: "image_url",
    });
  });

export function two2ToJSON(two2: Two2): string {
  return JSON.stringify(Two2$outboundSchema.parse(two2));
}
export function two2FromJSON(
  jsonString: string,
): SafeParseResult<Two2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two2' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2PrefixMessages3Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages3Type> = z
    .nativeEnum(InvokeDeploymentRequest2PrefixMessages3Type);
/** @internal */
export const InvokeDeploymentRequest2PrefixMessages3Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessages3Type> =
    InvokeDeploymentRequest2PrefixMessages3Type$inboundSchema;

/** @internal */
export const InvokeDeploymentRequest21$inboundSchema: z.ZodType<
  InvokeDeploymentRequest21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages3Type$inboundSchema,
  text: z.string(),
});
/** @internal */
export type InvokeDeploymentRequest21$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const InvokeDeploymentRequest21$outboundSchema: z.ZodType<
  InvokeDeploymentRequest21$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequest21
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessages3Type$outboundSchema,
  text: z.string(),
});

export function invokeDeploymentRequest21ToJSON(
  invokeDeploymentRequest21: InvokeDeploymentRequest21,
): string {
  return JSON.stringify(
    InvokeDeploymentRequest21$outboundSchema.parse(invokeDeploymentRequest21),
  );
}
export function invokeDeploymentRequest21FromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequest21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequest21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequest21' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => InvokeDeploymentRequest21$inboundSchema),
    z.lazy(() => Two2$inboundSchema),
    z.lazy(() => Three$inboundSchema),
    z.lazy(() => Four$inboundSchema),
  ],
);
/** @internal */
export type Two$Outbound =
  | InvokeDeploymentRequest21$Outbound
  | Two2$Outbound
  | Three$Outbound
  | Four$Outbound;

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .union([
    z.lazy(() => InvokeDeploymentRequest21$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Three$outboundSchema),
    z.lazy(() => Four$outboundSchema),
  ]);

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}
export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Content$inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> =
  z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => InvokeDeploymentRequest21$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
      z.lazy(() => Three$inboundSchema),
      z.lazy(() => Four$inboundSchema),
    ])),
  ]);
/** @internal */
export type Content$Outbound =
  | string
  | Array<
    | InvokeDeploymentRequest21$Outbound
    | Two2$Outbound
    | Three$Outbound
    | Four$Outbound
  >;

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => InvokeDeploymentRequest21$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Three$outboundSchema),
    z.lazy(() => Four$outboundSchema),
  ])),
]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}
export function contentFromJSON(
  jsonString: string,
): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`,
  );
}

/** @internal */
export const UserMessage$inboundSchema: z.ZodType<
  UserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: InvokeDeploymentRequestPrefixMessagesRole$inboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => InvokeDeploymentRequest21$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
      z.lazy(() => Three$inboundSchema),
      z.lazy(() => Four$inboundSchema),
    ])),
  ]),
});
/** @internal */
export type UserMessage$Outbound = {
  role: string;
  name?: string | undefined;
  content:
    | string
    | Array<
      | InvokeDeploymentRequest21$Outbound
      | Two2$Outbound
      | Three$Outbound
      | Four$Outbound
    >;
};

/** @internal */
export const UserMessage$outboundSchema: z.ZodType<
  UserMessage$Outbound,
  z.ZodTypeDef,
  UserMessage
> = z.object({
  role: InvokeDeploymentRequestPrefixMessagesRole$outboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => InvokeDeploymentRequest21$outboundSchema),
      z.lazy(() => Two2$outboundSchema),
      z.lazy(() => Three$outboundSchema),
      z.lazy(() => Four$outboundSchema),
    ])),
  ]),
});

export function userMessageToJSON(userMessage: UserMessage): string {
  return JSON.stringify(UserMessage$outboundSchema.parse(userMessage));
}
export function userMessageFromJSON(
  jsonString: string,
): SafeParseResult<UserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesRole$inboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesRole
> = z.nativeEnum(PrefixMessagesRole);
/** @internal */
export const PrefixMessagesRole$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesRole
> = PrefixMessagesRole$inboundSchema;

/** @internal */
export const SystemMessage$inboundSchema: z.ZodType<
  SystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: PrefixMessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});
/** @internal */
export type SystemMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const SystemMessage$outboundSchema: z.ZodType<
  SystemMessage$Outbound,
  z.ZodTypeDef,
  SystemMessage
> = z.object({
  role: PrefixMessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

export function systemMessageToJSON(systemMessage: SystemMessage): string {
  return JSON.stringify(SystemMessage$outboundSchema.parse(systemMessage));
}
export function systemMessageFromJSON(
  jsonString: string,
): SafeParseResult<SystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SystemMessage' from JSON`,
  );
}

/** @internal */
export const Role$inboundSchema: z.ZodNativeEnum<typeof Role> = z.nativeEnum(
  Role,
);
/** @internal */
export const Role$outboundSchema: z.ZodNativeEnum<typeof Role> =
  Role$inboundSchema;

/** @internal */
export const DeveloperMessage$inboundSchema: z.ZodType<
  DeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: Role$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});
/** @internal */
export type DeveloperMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const DeveloperMessage$outboundSchema: z.ZodType<
  DeveloperMessage$Outbound,
  z.ZodTypeDef,
  DeveloperMessage
> = z.object({
  role: Role$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

export function developerMessageToJSON(
  developerMessage: DeveloperMessage,
): string {
  return JSON.stringify(
    DeveloperMessage$outboundSchema.parse(developerMessage),
  );
}
export function developerMessageFromJSON(
  jsonString: string,
): SafeParseResult<DeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeveloperMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessages$inboundSchema: z.ZodType<
  PrefixMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ToolMessage$inboundSchema),
  z.lazy(() => DeveloperMessage$inboundSchema),
  z.lazy(() => SystemMessage$inboundSchema),
  z.lazy(() => UserMessage$inboundSchema),
  z.lazy(() => AssistantMessage$inboundSchema),
]);
/** @internal */
export type PrefixMessages$Outbound =
  | ToolMessage$Outbound
  | DeveloperMessage$Outbound
  | SystemMessage$Outbound
  | UserMessage$Outbound
  | AssistantMessage$Outbound;

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.union([
  z.lazy(() => ToolMessage$outboundSchema),
  z.lazy(() => DeveloperMessage$outboundSchema),
  z.lazy(() => SystemMessage$outboundSchema),
  z.lazy(() => UserMessage$outboundSchema),
  z.lazy(() => AssistantMessage$outboundSchema),
]);

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}
export function prefixMessagesFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessages' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestMessages5Role$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages5Role> = z.nativeEnum(
    InvokeDeploymentRequestMessages5Role,
  );
/** @internal */
export const InvokeDeploymentRequestMessages5Role$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages5Role> =
    InvokeDeploymentRequestMessages5Role$inboundSchema;

/** @internal */
export const InvokeDeploymentRequestMessages5Content$inboundSchema: z.ZodType<
  InvokeDeploymentRequestMessages5Content,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type InvokeDeploymentRequestMessages5Content$Outbound =
  | string
  | Array<string>;

/** @internal */
export const InvokeDeploymentRequestMessages5Content$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessages5Content$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessages5Content
> = z.union([z.string(), z.array(z.string())]);

export function invokeDeploymentRequestMessages5ContentToJSON(
  invokeDeploymentRequestMessages5Content:
    InvokeDeploymentRequestMessages5Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessages5Content$outboundSchema.parse(
      invokeDeploymentRequestMessages5Content,
    ),
  );
}
export function invokeDeploymentRequestMessages5ContentFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeDeploymentRequestMessages5Content,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestMessages5Content$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InvokeDeploymentRequestMessages5Content' from JSON`,
  );
}

/** @internal */
export const MessagesToolMessage$inboundSchema: z.ZodType<
  MessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: InvokeDeploymentRequestMessages5Role$inboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  tool_call_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type MessagesToolMessage$Outbound = {
  role: string;
  content: string | Array<string>;
  tool_call_id: string;
};

/** @internal */
export const MessagesToolMessage$outboundSchema: z.ZodType<
  MessagesToolMessage$Outbound,
  z.ZodTypeDef,
  MessagesToolMessage
> = z.object({
  role: InvokeDeploymentRequestMessages5Role$outboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  toolCallId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function messagesToolMessageToJSON(
  messagesToolMessage: MessagesToolMessage,
): string {
  return JSON.stringify(
    MessagesToolMessage$outboundSchema.parse(messagesToolMessage),
  );
}
export function messagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2Messages4ContentType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages4ContentType> = z
    .nativeEnum(InvokeDeploymentRequest2Messages4ContentType);
/** @internal */
export const InvokeDeploymentRequest2Messages4ContentType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages4ContentType> =
    InvokeDeploymentRequest2Messages4ContentType$inboundSchema;

/** @internal */
export const TwoRefusalContentPart$inboundSchema: z.ZodType<
  TwoRefusalContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2Messages4ContentType$inboundSchema,
  refusal: z.string(),
});
/** @internal */
export type TwoRefusalContentPart$Outbound = {
  type: string;
  refusal: string;
};

/** @internal */
export const TwoRefusalContentPart$outboundSchema: z.ZodType<
  TwoRefusalContentPart$Outbound,
  z.ZodTypeDef,
  TwoRefusalContentPart
> = z.object({
  type: InvokeDeploymentRequest2Messages4ContentType$outboundSchema,
  refusal: z.string(),
});

export function twoRefusalContentPartToJSON(
  twoRefusalContentPart: TwoRefusalContentPart,
): string {
  return JSON.stringify(
    TwoRefusalContentPart$outboundSchema.parse(twoRefusalContentPart),
  );
}
export function twoRefusalContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TwoRefusalContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoRefusalContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoRefusalContentPart' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2Messages4Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages4Type> = z.nativeEnum(
    InvokeDeploymentRequest2Messages4Type,
  );
/** @internal */
export const InvokeDeploymentRequest2Messages4Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages4Type> =
    InvokeDeploymentRequest2Messages4Type$inboundSchema;

/** @internal */
export const InvokeDeploymentRequestAnnotationsMessages4Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsMessages4Type> = z
    .nativeEnum(InvokeDeploymentRequestAnnotationsMessages4Type);
/** @internal */
export const InvokeDeploymentRequestAnnotationsMessages4Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsMessages4Type> =
    InvokeDeploymentRequestAnnotationsMessages4Type$inboundSchema;

/** @internal */
export const AnnotationsFilePath$inboundSchema: z.ZodType<
  AnnotationsFilePath,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "file_id": "fileId",
  });
});
/** @internal */
export type AnnotationsFilePath$Outbound = {
  file_id: string;
};

/** @internal */
export const AnnotationsFilePath$outboundSchema: z.ZodType<
  AnnotationsFilePath$Outbound,
  z.ZodTypeDef,
  AnnotationsFilePath
> = z.object({
  fileId: z.string(),
}).transform((v) => {
  return remap$(v, {
    fileId: "file_id",
  });
});

export function annotationsFilePathToJSON(
  annotationsFilePath: AnnotationsFilePath,
): string {
  return JSON.stringify(
    AnnotationsFilePath$outboundSchema.parse(annotationsFilePath),
  );
}
export function annotationsFilePathFromJSON(
  jsonString: string,
): SafeParseResult<AnnotationsFilePath, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnnotationsFilePath$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnnotationsFilePath' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAnnotations2$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAnnotations2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequestAnnotationsMessages4Type$inboundSchema,
  text: z.string(),
  file_path: z.lazy(() => AnnotationsFilePath$inboundSchema),
  start_index: z.number().int(),
  end_index: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "file_path": "filePath",
    "start_index": "startIndex",
    "end_index": "endIndex",
  });
});
/** @internal */
export type InvokeDeploymentRequestAnnotations2$Outbound = {
  type: string;
  text: string;
  file_path: AnnotationsFilePath$Outbound;
  start_index: number;
  end_index: number;
};

/** @internal */
export const InvokeDeploymentRequestAnnotations2$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAnnotations2$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAnnotations2
> = z.object({
  type: InvokeDeploymentRequestAnnotationsMessages4Type$outboundSchema,
  text: z.string(),
  filePath: z.lazy(() => AnnotationsFilePath$outboundSchema),
  startIndex: z.number().int(),
  endIndex: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    filePath: "file_path",
    startIndex: "start_index",
    endIndex: "end_index",
  });
});

export function invokeDeploymentRequestAnnotations2ToJSON(
  invokeDeploymentRequestAnnotations2: InvokeDeploymentRequestAnnotations2,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAnnotations2$outboundSchema.parse(
      invokeDeploymentRequestAnnotations2,
    ),
  );
}
export function invokeDeploymentRequestAnnotations2FromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAnnotations2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestAnnotations2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAnnotations2' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAnnotationsMessagesType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsMessagesType> = z
    .nativeEnum(InvokeDeploymentRequestAnnotationsMessagesType);
/** @internal */
export const InvokeDeploymentRequestAnnotationsMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestAnnotationsMessagesType> =
    InvokeDeploymentRequestAnnotationsMessagesType$inboundSchema;

/** @internal */
export const AnnotationsFileCitation$inboundSchema: z.ZodType<
  AnnotationsFileCitation,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_id: z.string(),
  quote: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_id": "fileId",
  });
});
/** @internal */
export type AnnotationsFileCitation$Outbound = {
  file_id: string;
  quote?: string | undefined;
};

/** @internal */
export const AnnotationsFileCitation$outboundSchema: z.ZodType<
  AnnotationsFileCitation$Outbound,
  z.ZodTypeDef,
  AnnotationsFileCitation
> = z.object({
  fileId: z.string(),
  quote: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileId: "file_id",
  });
});

export function annotationsFileCitationToJSON(
  annotationsFileCitation: AnnotationsFileCitation,
): string {
  return JSON.stringify(
    AnnotationsFileCitation$outboundSchema.parse(annotationsFileCitation),
  );
}
export function annotationsFileCitationFromJSON(
  jsonString: string,
): SafeParseResult<AnnotationsFileCitation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AnnotationsFileCitation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AnnotationsFileCitation' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAnnotations1$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAnnotations1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequestAnnotationsMessagesType$inboundSchema,
  text: z.string(),
  file_citation: z.lazy(() => AnnotationsFileCitation$inboundSchema),
  start_index: z.number().int(),
  end_index: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    "file_citation": "fileCitation",
    "start_index": "startIndex",
    "end_index": "endIndex",
  });
});
/** @internal */
export type InvokeDeploymentRequestAnnotations1$Outbound = {
  type: string;
  text: string;
  file_citation: AnnotationsFileCitation$Outbound;
  start_index: number;
  end_index: number;
};

/** @internal */
export const InvokeDeploymentRequestAnnotations1$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAnnotations1$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAnnotations1
> = z.object({
  type: InvokeDeploymentRequestAnnotationsMessagesType$outboundSchema,
  text: z.string(),
  fileCitation: z.lazy(() => AnnotationsFileCitation$outboundSchema),
  startIndex: z.number().int(),
  endIndex: z.number().int(),
}).transform((v) => {
  return remap$(v, {
    fileCitation: "file_citation",
    startIndex: "start_index",
    endIndex: "end_index",
  });
});

export function invokeDeploymentRequestAnnotations1ToJSON(
  invokeDeploymentRequestAnnotations1: InvokeDeploymentRequestAnnotations1,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAnnotations1$outboundSchema.parse(
      invokeDeploymentRequestAnnotations1,
    ),
  );
}
export function invokeDeploymentRequestAnnotations1FromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAnnotations1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestAnnotations1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAnnotations1' from JSON`,
  );
}

/** @internal */
export const TwoAnnotations$inboundSchema: z.ZodType<
  TwoAnnotations,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InvokeDeploymentRequestAnnotations1$inboundSchema),
  z.lazy(() => InvokeDeploymentRequestAnnotations2$inboundSchema),
]);
/** @internal */
export type TwoAnnotations$Outbound =
  | InvokeDeploymentRequestAnnotations1$Outbound
  | InvokeDeploymentRequestAnnotations2$Outbound;

/** @internal */
export const TwoAnnotations$outboundSchema: z.ZodType<
  TwoAnnotations$Outbound,
  z.ZodTypeDef,
  TwoAnnotations
> = z.union([
  z.lazy(() => InvokeDeploymentRequestAnnotations1$outboundSchema),
  z.lazy(() => InvokeDeploymentRequestAnnotations2$outboundSchema),
]);

export function twoAnnotationsToJSON(twoAnnotations: TwoAnnotations): string {
  return JSON.stringify(TwoAnnotations$outboundSchema.parse(twoAnnotations));
}
export function twoAnnotationsFromJSON(
  jsonString: string,
): SafeParseResult<TwoAnnotations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoAnnotations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoAnnotations' from JSON`,
  );
}

/** @internal */
export const TwoTextContentPart$inboundSchema: z.ZodType<
  TwoTextContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2Messages4Type$inboundSchema,
  text: z.string(),
  annotations: z.array(
    z.union([
      z.lazy(() => InvokeDeploymentRequestAnnotations1$inboundSchema),
      z.lazy(() => InvokeDeploymentRequestAnnotations2$inboundSchema),
    ]),
  ).optional(),
});
/** @internal */
export type TwoTextContentPart$Outbound = {
  type: string;
  text: string;
  annotations?:
    | Array<
      | InvokeDeploymentRequestAnnotations1$Outbound
      | InvokeDeploymentRequestAnnotations2$Outbound
    >
    | undefined;
};

/** @internal */
export const TwoTextContentPart$outboundSchema: z.ZodType<
  TwoTextContentPart$Outbound,
  z.ZodTypeDef,
  TwoTextContentPart
> = z.object({
  type: InvokeDeploymentRequest2Messages4Type$outboundSchema,
  text: z.string(),
  annotations: z.array(
    z.union([
      z.lazy(() => InvokeDeploymentRequestAnnotations1$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestAnnotations2$outboundSchema),
    ]),
  ).optional(),
});

export function twoTextContentPartToJSON(
  twoTextContentPart: TwoTextContentPart,
): string {
  return JSON.stringify(
    TwoTextContentPart$outboundSchema.parse(twoTextContentPart),
  );
}
export function twoTextContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TwoTextContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoTextContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoTextContentPart' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestContentMessages2$inboundSchema: z.ZodType<
  InvokeDeploymentRequestContentMessages2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TwoTextContentPart$inboundSchema),
  z.lazy(() => TwoRefusalContentPart$inboundSchema),
]);
/** @internal */
export type InvokeDeploymentRequestContentMessages2$Outbound =
  | TwoTextContentPart$Outbound
  | TwoRefusalContentPart$Outbound;

/** @internal */
export const InvokeDeploymentRequestContentMessages2$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContentMessages2$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContentMessages2
> = z.union([
  z.lazy(() => TwoTextContentPart$outboundSchema),
  z.lazy(() => TwoRefusalContentPart$outboundSchema),
]);

export function invokeDeploymentRequestContentMessages2ToJSON(
  invokeDeploymentRequestContentMessages2:
    InvokeDeploymentRequestContentMessages2,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContentMessages2$outboundSchema.parse(
      invokeDeploymentRequestContentMessages2,
    ),
  );
}
export function invokeDeploymentRequestContentMessages2FromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeDeploymentRequestContentMessages2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestContentMessages2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InvokeDeploymentRequestContentMessages2' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestMessagesContent$inboundSchema: z.ZodType<
  InvokeDeploymentRequestMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TwoTextContentPart$inboundSchema),
    z.lazy(() => TwoRefusalContentPart$inboundSchema),
  ])),
]);
/** @internal */
export type InvokeDeploymentRequestMessagesContent$Outbound =
  | string
  | Array<TwoTextContentPart$Outbound | TwoRefusalContentPart$Outbound>;

/** @internal */
export const InvokeDeploymentRequestMessagesContent$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessagesContent$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TwoTextContentPart$outboundSchema),
    z.lazy(() => TwoRefusalContentPart$outboundSchema),
  ])),
]);

export function invokeDeploymentRequestMessagesContentToJSON(
  invokeDeploymentRequestMessagesContent:
    InvokeDeploymentRequestMessagesContent,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessagesContent$outboundSchema.parse(
      invokeDeploymentRequestMessagesContent,
    ),
  );
}
export function invokeDeploymentRequestMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeDeploymentRequestMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestMessagesContent' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestMessages4Role$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages4Role> = z.nativeEnum(
    InvokeDeploymentRequestMessages4Role,
  );
/** @internal */
export const InvokeDeploymentRequestMessages4Role$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages4Role> =
    InvokeDeploymentRequestMessages4Role$inboundSchema;

/** @internal */
export const MessagesAudio$inboundSchema: z.ZodType<
  MessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});
/** @internal */
export type MessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const MessagesAudio$outboundSchema: z.ZodType<
  MessagesAudio$Outbound,
  z.ZodTypeDef,
  MessagesAudio
> = z.object({
  id: z.string(),
});

export function messagesAudioToJSON(messagesAudio: MessagesAudio): string {
  return JSON.stringify(MessagesAudio$outboundSchema.parse(messagesAudio));
}
export function messagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAudio' from JSON`,
  );
}

/** @internal */
export const MessagesType$inboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  z.nativeEnum(MessagesType);
/** @internal */
export const MessagesType$outboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  MessagesType$inboundSchema;

/** @internal */
export const MessagesFunction$inboundSchema: z.ZodType<
  MessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type MessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const MessagesFunction$outboundSchema: z.ZodType<
  MessagesFunction$Outbound,
  z.ZodTypeDef,
  MessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function messagesFunctionToJSON(
  messagesFunction: MessagesFunction,
): string {
  return JSON.stringify(
    MessagesFunction$outboundSchema.parse(messagesFunction),
  );
}
export function messagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<MessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesFunction' from JSON`,
  );
}

/** @internal */
export const MessagesToolCalls$inboundSchema: z.ZodType<
  MessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: MessagesType$inboundSchema,
  function: z.lazy(() => MessagesFunction$inboundSchema),
});
/** @internal */
export type MessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: MessagesFunction$Outbound;
};

/** @internal */
export const MessagesToolCalls$outboundSchema: z.ZodType<
  MessagesToolCalls$Outbound,
  z.ZodTypeDef,
  MessagesToolCalls
> = z.object({
  id: z.string(),
  type: MessagesType$outboundSchema,
  function: z.lazy(() => MessagesFunction$outboundSchema),
});

export function messagesToolCallsToJSON(
  messagesToolCalls: MessagesToolCalls,
): string {
  return JSON.stringify(
    MessagesToolCalls$outboundSchema.parse(messagesToolCalls),
  );
}
export function messagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const MessagesAssistantMessage$inboundSchema: z.ZodType<
  MessagesAssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TwoTextContentPart$inboundSchema),
          z.lazy(() => TwoRefusalContentPart$inboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: InvokeDeploymentRequestMessages4Role$inboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => MessagesToolCalls$inboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type MessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<TwoTextContentPart$Outbound | TwoRefusalContentPart$Outbound>
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: string;
  name?: string | undefined;
  audio?: MessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<MessagesToolCalls$Outbound> | undefined;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const MessagesAssistantMessage$outboundSchema: z.ZodType<
  MessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  MessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TwoTextContentPart$outboundSchema),
          z.lazy(() => TwoRefusalContentPart$outboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: InvokeDeploymentRequestMessages4Role$outboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => MessagesToolCalls$outboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function messagesAssistantMessageToJSON(
  messagesAssistantMessage: MessagesAssistantMessage,
): string {
  return JSON.stringify(
    MessagesAssistantMessage$outboundSchema.parse(messagesAssistantMessage),
  );
}
export function messagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestMessages3Role$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages3Role> = z.nativeEnum(
    InvokeDeploymentRequestMessages3Role,
  );
/** @internal */
export const InvokeDeploymentRequestMessages3Role$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessages3Role> =
    InvokeDeploymentRequestMessages3Role$inboundSchema;

/** @internal */
export const InvokeDeploymentRequest2Messages3Content4Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3Content4Type> = z
    .nativeEnum(InvokeDeploymentRequest2Messages3Content4Type);
/** @internal */
export const InvokeDeploymentRequest2Messages3Content4Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3Content4Type> =
    InvokeDeploymentRequest2Messages3Content4Type$inboundSchema;

/** @internal */
export const TwoFile$inboundSchema: z.ZodType<TwoFile, z.ZodTypeDef, unknown> =
  z.object({
    file_data: z.string().optional(),
    uri: z.string().optional(),
    mimeType: z.string().optional(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });
/** @internal */
export type TwoFile$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const TwoFile$outboundSchema: z.ZodType<
  TwoFile$Outbound,
  z.ZodTypeDef,
  TwoFile
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function twoFileToJSON(twoFile: TwoFile): string {
  return JSON.stringify(TwoFile$outboundSchema.parse(twoFile));
}
export function twoFileFromJSON(
  jsonString: string,
): SafeParseResult<TwoFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoFile' from JSON`,
  );
}

/** @internal */
export const Two4$inboundSchema: z.ZodType<Two4, z.ZodTypeDef, unknown> = z
  .object({
    type: InvokeDeploymentRequest2Messages3Content4Type$inboundSchema,
    file: z.lazy(() => TwoFile$inboundSchema),
  });
/** @internal */
export type Two4$Outbound = {
  type: string;
  file: TwoFile$Outbound;
};

/** @internal */
export const Two4$outboundSchema: z.ZodType<Two4$Outbound, z.ZodTypeDef, Two4> =
  z.object({
    type: InvokeDeploymentRequest2Messages3Content4Type$outboundSchema,
    file: z.lazy(() => TwoFile$outboundSchema),
  });

export function two4ToJSON(two4: Two4): string {
  return JSON.stringify(Two4$outboundSchema.parse(two4));
}
export function two4FromJSON(
  jsonString: string,
): SafeParseResult<Two4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two4' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2Messages3ContentType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3ContentType> = z
    .nativeEnum(InvokeDeploymentRequest2Messages3ContentType);
/** @internal */
export const InvokeDeploymentRequest2Messages3ContentType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3ContentType> =
    InvokeDeploymentRequest2Messages3ContentType$inboundSchema;

/** @internal */
export const TwoFormat$inboundSchema: z.ZodNativeEnum<typeof TwoFormat> = z
  .nativeEnum(TwoFormat);
/** @internal */
export const TwoFormat$outboundSchema: z.ZodNativeEnum<typeof TwoFormat> =
  TwoFormat$inboundSchema;

/** @internal */
export const TwoInputAudio$inboundSchema: z.ZodType<
  TwoInputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: TwoFormat$inboundSchema,
});
/** @internal */
export type TwoInputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const TwoInputAudio$outboundSchema: z.ZodType<
  TwoInputAudio$Outbound,
  z.ZodTypeDef,
  TwoInputAudio
> = z.object({
  data: z.string(),
  format: TwoFormat$outboundSchema,
});

export function twoInputAudioToJSON(twoInputAudio: TwoInputAudio): string {
  return JSON.stringify(TwoInputAudio$outboundSchema.parse(twoInputAudio));
}
export function twoInputAudioFromJSON(
  jsonString: string,
): SafeParseResult<TwoInputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoInputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoInputAudio' from JSON`,
  );
}

/** @internal */
export const Two3$inboundSchema: z.ZodType<Two3, z.ZodTypeDef, unknown> = z
  .object({
    type: InvokeDeploymentRequest2Messages3ContentType$inboundSchema,
    input_audio: z.lazy(() => TwoInputAudio$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "input_audio": "inputAudio",
    });
  });
/** @internal */
export type Two3$Outbound = {
  type: string;
  input_audio: TwoInputAudio$Outbound;
};

/** @internal */
export const Two3$outboundSchema: z.ZodType<Two3$Outbound, z.ZodTypeDef, Two3> =
  z.object({
    type: InvokeDeploymentRequest2Messages3ContentType$outboundSchema,
    inputAudio: z.lazy(() => TwoInputAudio$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      inputAudio: "input_audio",
    });
  });

export function two3ToJSON(two3: Two3): string {
  return JSON.stringify(Two3$outboundSchema.parse(two3));
}
export function two3FromJSON(
  jsonString: string,
): SafeParseResult<Two3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two3' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2Messages3Type$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3Type> = z.nativeEnum(
    InvokeDeploymentRequest2Messages3Type,
  );
/** @internal */
export const InvokeDeploymentRequest2Messages3Type$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2Messages3Type> =
    InvokeDeploymentRequest2Messages3Type$inboundSchema;

/** @internal */
export const TwoDetail$inboundSchema: z.ZodNativeEnum<typeof TwoDetail> = z
  .nativeEnum(TwoDetail);
/** @internal */
export const TwoDetail$outboundSchema: z.ZodNativeEnum<typeof TwoDetail> =
  TwoDetail$inboundSchema;

/** @internal */
export const TwoImageUrl$inboundSchema: z.ZodType<
  TwoImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: TwoDetail$inboundSchema.optional(),
});
/** @internal */
export type TwoImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const TwoImageUrl$outboundSchema: z.ZodType<
  TwoImageUrl$Outbound,
  z.ZodTypeDef,
  TwoImageUrl
> = z.object({
  url: z.string(),
  detail: TwoDetail$outboundSchema.optional(),
});

export function twoImageUrlToJSON(twoImageUrl: TwoImageUrl): string {
  return JSON.stringify(TwoImageUrl$outboundSchema.parse(twoImageUrl));
}
export function twoImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<TwoImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoImageUrl' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest22$inboundSchema: z.ZodType<
  InvokeDeploymentRequest22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: InvokeDeploymentRequest2Messages3Type$inboundSchema,
  image_url: z.lazy(() => TwoImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});
/** @internal */
export type InvokeDeploymentRequest22$Outbound = {
  type: string;
  image_url: TwoImageUrl$Outbound;
};

/** @internal */
export const InvokeDeploymentRequest22$outboundSchema: z.ZodType<
  InvokeDeploymentRequest22$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequest22
> = z.object({
  type: InvokeDeploymentRequest2Messages3Type$outboundSchema,
  imageUrl: z.lazy(() => TwoImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function invokeDeploymentRequest22ToJSON(
  invokeDeploymentRequest22: InvokeDeploymentRequest22,
): string {
  return JSON.stringify(
    InvokeDeploymentRequest22$outboundSchema.parse(invokeDeploymentRequest22),
  );
}
export function invokeDeploymentRequest22FromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequest22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequest22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequest22' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest2MessagesType$inboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2MessagesType> = z.nativeEnum(
    InvokeDeploymentRequest2MessagesType,
  );
/** @internal */
export const InvokeDeploymentRequest2MessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2MessagesType> =
    InvokeDeploymentRequest2MessagesType$inboundSchema;

/** @internal */
export const Two1$inboundSchema: z.ZodType<Two1, z.ZodTypeDef, unknown> = z
  .object({
    type: InvokeDeploymentRequest2MessagesType$inboundSchema,
    text: z.string(),
  });
/** @internal */
export type Two1$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const Two1$outboundSchema: z.ZodType<Two1$Outbound, z.ZodTypeDef, Two1> =
  z.object({
    type: InvokeDeploymentRequest2MessagesType$outboundSchema,
    text: z.string(),
  });

export function two1ToJSON(two1: Two1): string {
  return JSON.stringify(Two1$outboundSchema.parse(two1));
}
export function two1FromJSON(
  jsonString: string,
): SafeParseResult<Two1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two1' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestContent2$inboundSchema: z.ZodType<
  InvokeDeploymentRequestContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Two1$inboundSchema),
  z.lazy(() => InvokeDeploymentRequest22$inboundSchema),
  z.lazy(() => Two3$inboundSchema),
  z.lazy(() => Two4$inboundSchema),
]);
/** @internal */
export type InvokeDeploymentRequestContent2$Outbound =
  | Two1$Outbound
  | InvokeDeploymentRequest22$Outbound
  | Two3$Outbound
  | Two4$Outbound;

/** @internal */
export const InvokeDeploymentRequestContent2$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContent2$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContent2
> = z.union([
  z.lazy(() => Two1$outboundSchema),
  z.lazy(() => InvokeDeploymentRequest22$outboundSchema),
  z.lazy(() => Two3$outboundSchema),
  z.lazy(() => Two4$outboundSchema),
]);

export function invokeDeploymentRequestContent2ToJSON(
  invokeDeploymentRequestContent2: InvokeDeploymentRequestContent2,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContent2$outboundSchema.parse(
      invokeDeploymentRequestContent2,
    ),
  );
}
export function invokeDeploymentRequestContent2FromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestContent2' from JSON`,
  );
}

/** @internal */
export const MessagesContent$inboundSchema: z.ZodType<
  MessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$inboundSchema),
    z.lazy(() => InvokeDeploymentRequest22$inboundSchema),
    z.lazy(() => Two3$inboundSchema),
    z.lazy(() => Two4$inboundSchema),
  ])),
]);
/** @internal */
export type MessagesContent$Outbound =
  | string
  | Array<
    | Two1$Outbound
    | InvokeDeploymentRequest22$Outbound
    | Two3$Outbound
    | Two4$Outbound
  >;

/** @internal */
export const MessagesContent$outboundSchema: z.ZodType<
  MessagesContent$Outbound,
  z.ZodTypeDef,
  MessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$outboundSchema),
    z.lazy(() => InvokeDeploymentRequest22$outboundSchema),
    z.lazy(() => Two3$outboundSchema),
    z.lazy(() => Two4$outboundSchema),
  ])),
]);

export function messagesContentToJSON(
  messagesContent: MessagesContent,
): string {
  return JSON.stringify(MessagesContent$outboundSchema.parse(messagesContent));
}
export function messagesContentFromJSON(
  jsonString: string,
): SafeParseResult<MessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesContent' from JSON`,
  );
}

/** @internal */
export const MessagesUserMessage$inboundSchema: z.ZodType<
  MessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: InvokeDeploymentRequestMessages3Role$inboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$inboundSchema),
      z.lazy(() => InvokeDeploymentRequest22$inboundSchema),
      z.lazy(() => Two3$inboundSchema),
      z.lazy(() => Two4$inboundSchema),
    ])),
  ]),
});
/** @internal */
export type MessagesUserMessage$Outbound = {
  role: string;
  name?: string | undefined;
  content:
    | string
    | Array<
      | Two1$Outbound
      | InvokeDeploymentRequest22$Outbound
      | Two3$Outbound
      | Two4$Outbound
    >;
};

/** @internal */
export const MessagesUserMessage$outboundSchema: z.ZodType<
  MessagesUserMessage$Outbound,
  z.ZodTypeDef,
  MessagesUserMessage
> = z.object({
  role: InvokeDeploymentRequestMessages3Role$outboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$outboundSchema),
      z.lazy(() => InvokeDeploymentRequest22$outboundSchema),
      z.lazy(() => Two3$outboundSchema),
      z.lazy(() => Two4$outboundSchema),
    ])),
  ]),
});

export function messagesUserMessageToJSON(
  messagesUserMessage: MessagesUserMessage,
): string {
  return JSON.stringify(
    MessagesUserMessage$outboundSchema.parse(messagesUserMessage),
  );
}
export function messagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestMessagesRole$inboundSchema: z.ZodNativeEnum<
  typeof InvokeDeploymentRequestMessagesRole
> = z.nativeEnum(InvokeDeploymentRequestMessagesRole);
/** @internal */
export const InvokeDeploymentRequestMessagesRole$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessagesRole> =
    InvokeDeploymentRequestMessagesRole$inboundSchema;

/** @internal */
export const MessagesSystemMessage$inboundSchema: z.ZodType<
  MessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: InvokeDeploymentRequestMessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});
/** @internal */
export type MessagesSystemMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const MessagesSystemMessage$outboundSchema: z.ZodType<
  MessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  MessagesSystemMessage
> = z.object({
  role: InvokeDeploymentRequestMessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

export function messagesSystemMessageToJSON(
  messagesSystemMessage: MessagesSystemMessage,
): string {
  return JSON.stringify(
    MessagesSystemMessage$outboundSchema.parse(messagesSystemMessage),
  );
}
export function messagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesSystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesSystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const MessagesRole$inboundSchema: z.ZodNativeEnum<typeof MessagesRole> =
  z.nativeEnum(MessagesRole);
/** @internal */
export const MessagesRole$outboundSchema: z.ZodNativeEnum<typeof MessagesRole> =
  MessagesRole$inboundSchema;

/** @internal */
export const MessagesDeveloperMessage$inboundSchema: z.ZodType<
  MessagesDeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: MessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});
/** @internal */
export type MessagesDeveloperMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const MessagesDeveloperMessage$outboundSchema: z.ZodType<
  MessagesDeveloperMessage$Outbound,
  z.ZodTypeDef,
  MessagesDeveloperMessage
> = z.object({
  role: MessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

export function messagesDeveloperMessageToJSON(
  messagesDeveloperMessage: MessagesDeveloperMessage,
): string {
  return JSON.stringify(
    MessagesDeveloperMessage$outboundSchema.parse(messagesDeveloperMessage),
  );
}
export function messagesDeveloperMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesDeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesDeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesDeveloperMessage' from JSON`,
  );
}

/** @internal */
export const Messages$inboundSchema: z.ZodType<
  Messages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => MessagesToolMessage$inboundSchema),
  z.lazy(() => MessagesDeveloperMessage$inboundSchema),
  z.lazy(() => MessagesSystemMessage$inboundSchema),
  z.lazy(() => MessagesUserMessage$inboundSchema),
  z.lazy(() => MessagesAssistantMessage$inboundSchema),
]);
/** @internal */
export type Messages$Outbound =
  | MessagesToolMessage$Outbound
  | MessagesDeveloperMessage$Outbound
  | MessagesSystemMessage$Outbound
  | MessagesUserMessage$Outbound
  | MessagesAssistantMessage$Outbound;

/** @internal */
export const Messages$outboundSchema: z.ZodType<
  Messages$Outbound,
  z.ZodTypeDef,
  Messages
> = z.union([
  z.lazy(() => MessagesToolMessage$outboundSchema),
  z.lazy(() => MessagesDeveloperMessage$outboundSchema),
  z.lazy(() => MessagesSystemMessage$outboundSchema),
  z.lazy(() => MessagesUserMessage$outboundSchema),
  z.lazy(() => MessagesAssistantMessage$outboundSchema),
]);

export function messagesToJSON(messages: Messages): string {
  return JSON.stringify(Messages$outboundSchema.parse(messages));
}
export function messagesFromJSON(
  jsonString: string,
): SafeParseResult<Messages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Messages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Messages' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string().optional(),
  file_type: z.string().optional(),
  page_number: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "file_type": "fileType",
    "page_number": "pageNumber",
  });
});
/** @internal */
export type Metadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}
export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const Documents$inboundSchema: z.ZodType<
  Documents,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$inboundSchema).optional(),
});
/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$outboundSchema).optional(),
});

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}
export function documentsFromJSON(
  jsonString: string,
): SafeParseResult<Documents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Documents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Documents' from JSON`,
  );
}

/** @internal */
export const InvokeOptions$inboundSchema: z.ZodType<
  InvokeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_retrievals: z.boolean().default(false),
  mock_response: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_retrievals": "includeRetrievals",
    "mock_response": "mockResponse",
  });
});
/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
  mock_response?: string | undefined;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
  mockResponse: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
    mockResponse: "mock_response",
  });
});

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}
export function invokeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<InvokeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeOptions' from JSON`,
  );
}

/** @internal */
export const Thread$inboundSchema: z.ZodType<Thread, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    tags: z.array(z.string()).optional(),
  });
/** @internal */
export type Thread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Thread$outboundSchema: z.ZodType<
  Thread$Outbound,
  z.ZodTypeDef,
  Thread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function threadToJSON(thread: Thread): string {
  return JSON.stringify(Thread$outboundSchema.parse(thread));
}
export function threadFromJSON(
  jsonString: string,
): SafeParseResult<Thread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thread' from JSON`,
  );
}

/** @internal */
export const OrExists$inboundSchema: z.ZodType<
  OrExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type OrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const OrExists$outboundSchema: z.ZodType<
  OrExists$Outbound,
  z.ZodTypeDef,
  OrExists
> = z.object({
  exists: z.boolean(),
});

export function orExistsToJSON(orExists: OrExists): string {
  return JSON.stringify(OrExists$outboundSchema.parse(orExists));
}
export function orExistsFromJSON(
  jsonString: string,
): SafeParseResult<OrExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrExists' from JSON`,
  );
}

/** @internal */
export const OrNin$inboundSchema: z.ZodType<OrNin, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OrNin$Outbound = string | number | boolean;

/** @internal */
export const OrNin$outboundSchema: z.ZodType<
  OrNin$Outbound,
  z.ZodTypeDef,
  OrNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function orNinToJSON(orNin: OrNin): string {
  return JSON.stringify(OrNin$outboundSchema.parse(orNin));
}
export function orNinFromJSON(
  jsonString: string,
): SafeParseResult<OrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrNin' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestOrNin$inboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type InvokeDeploymentRequestOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestOrNin$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNin$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestOrNinToJSON(
  invokeDeploymentRequestOrNin: InvokeDeploymentRequestOrNin,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrNin$outboundSchema.parse(
      invokeDeploymentRequestOrNin,
    ),
  );
}
export function invokeDeploymentRequestOrNinFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestOrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestOrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestOrNin' from JSON`,
  );
}

/** @internal */
export const OrIn$inboundSchema: z.ZodType<OrIn, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OrIn$Outbound = string | number | boolean;

/** @internal */
export const OrIn$outboundSchema: z.ZodType<OrIn$Outbound, z.ZodTypeDef, OrIn> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orInToJSON(orIn: OrIn): string {
  return JSON.stringify(OrIn$outboundSchema.parse(orIn));
}
export function orInFromJSON(
  jsonString: string,
): SafeParseResult<OrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrIn' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestOrIn$inboundSchema: z.ZodType<
  InvokeDeploymentRequestOrIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type InvokeDeploymentRequestOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestOrIn$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrIn$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestOrInToJSON(
  invokeDeploymentRequestOrIn: InvokeDeploymentRequestOrIn,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrIn$outboundSchema.parse(
      invokeDeploymentRequestOrIn,
    ),
  );
}
export function invokeDeploymentRequestOrInFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestOrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestOrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestOrIn' from JSON`,
  );
}

/** @internal */
export const OrLte$inboundSchema: z.ZodType<OrLte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type OrLte$Outbound = {
  lte: number;
};

/** @internal */
export const OrLte$outboundSchema: z.ZodType<
  OrLte$Outbound,
  z.ZodTypeDef,
  OrLte
> = z.object({
  lte: z.number(),
});

export function orLteToJSON(orLte: OrLte): string {
  return JSON.stringify(OrLte$outboundSchema.parse(orLte));
}
export function orLteFromJSON(
  jsonString: string,
): SafeParseResult<OrLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrLte' from JSON`,
  );
}

/** @internal */
export const OrLt$inboundSchema: z.ZodType<OrLt, z.ZodTypeDef, unknown> = z
  .object({
    lt: z.number(),
  });
/** @internal */
export type OrLt$Outbound = {
  lt: number;
};

/** @internal */
export const OrLt$outboundSchema: z.ZodType<OrLt$Outbound, z.ZodTypeDef, OrLt> =
  z.object({
    lt: z.number(),
  });

export function orLtToJSON(orLt: OrLt): string {
  return JSON.stringify(OrLt$outboundSchema.parse(orLt));
}
export function orLtFromJSON(
  jsonString: string,
): SafeParseResult<OrLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrLt' from JSON`,
  );
}

/** @internal */
export const OrGte$inboundSchema: z.ZodType<OrGte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type OrGte$Outbound = {
  gte: number;
};

/** @internal */
export const OrGte$outboundSchema: z.ZodType<
  OrGte$Outbound,
  z.ZodTypeDef,
  OrGte
> = z.object({
  gte: z.number(),
});

export function orGteToJSON(orGte: OrGte): string {
  return JSON.stringify(OrGte$outboundSchema.parse(orGte));
}
export function orGteFromJSON(
  jsonString: string,
): SafeParseResult<OrGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrGte' from JSON`,
  );
}

/** @internal */
export const OrGt$inboundSchema: z.ZodType<OrGt, z.ZodTypeDef, unknown> = z
  .object({
    gt: z.number(),
  });
/** @internal */
export type OrGt$Outbound = {
  gt: number;
};

/** @internal */
export const OrGt$outboundSchema: z.ZodType<OrGt$Outbound, z.ZodTypeDef, OrGt> =
  z.object({
    gt: z.number(),
  });

export function orGtToJSON(orGt: OrGt): string {
  return JSON.stringify(OrGt$outboundSchema.parse(orGt));
}
export function orGtFromJSON(
  jsonString: string,
): SafeParseResult<OrGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrGt' from JSON`,
  );
}

/** @internal */
export const OrNe$inboundSchema: z.ZodType<OrNe, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OrNe$Outbound = string | number | boolean;

/** @internal */
export const OrNe$outboundSchema: z.ZodType<OrNe$Outbound, z.ZodTypeDef, OrNe> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orNeToJSON(orNe: OrNe): string {
  return JSON.stringify(OrNe$outboundSchema.parse(orNe));
}
export function orNeFromJSON(
  jsonString: string,
): SafeParseResult<OrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrNe' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestOrNe$inboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type InvokeDeploymentRequestOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestOrNe$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNe$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestOrNeToJSON(
  invokeDeploymentRequestOrNe: InvokeDeploymentRequestOrNe,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrNe$outboundSchema.parse(
      invokeDeploymentRequestOrNe,
    ),
  );
}
export function invokeDeploymentRequestOrNeFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestOrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestOrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestOrNe' from JSON`,
  );
}

/** @internal */
export const OrEq$inboundSchema: z.ZodType<OrEq, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OrEq$Outbound = string | number | boolean;

/** @internal */
export const OrEq$outboundSchema: z.ZodType<OrEq$Outbound, z.ZodTypeDef, OrEq> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orEqToJSON(orEq: OrEq): string {
  return JSON.stringify(OrEq$outboundSchema.parse(orEq));
}
export function orEqFromJSON(
  jsonString: string,
): SafeParseResult<OrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrEq' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestOrEq$inboundSchema: z.ZodType<
  InvokeDeploymentRequestOrEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type InvokeDeploymentRequestOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestOrEq$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrEq$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestOrEqToJSON(
  invokeDeploymentRequestOrEq: InvokeDeploymentRequestOrEq,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrEq$outboundSchema.parse(
      invokeDeploymentRequestOrEq,
    ),
  );
}
export function invokeDeploymentRequestOrEqFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestOrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestOrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestOrEq' from JSON`,
  );
}

/** @internal */
export const Or$inboundSchema: z.ZodType<Or, z.ZodTypeDef, unknown> = z.union([
  z.lazy(() => InvokeDeploymentRequestOrEq$inboundSchema),
  z.lazy(() => InvokeDeploymentRequestOrNe$inboundSchema),
  z.lazy(() => OrGt$inboundSchema),
  z.lazy(() => OrGte$inboundSchema),
  z.lazy(() => OrLt$inboundSchema),
  z.lazy(() => OrLte$inboundSchema),
  z.lazy(() => InvokeDeploymentRequestOrIn$inboundSchema),
  z.lazy(() => InvokeDeploymentRequestOrNin$inboundSchema),
  z.lazy(() => OrExists$inboundSchema),
]);
/** @internal */
export type Or$Outbound =
  | InvokeDeploymentRequestOrEq$Outbound
  | InvokeDeploymentRequestOrNe$Outbound
  | OrGt$Outbound
  | OrGte$Outbound
  | OrLt$Outbound
  | OrLte$Outbound
  | InvokeDeploymentRequestOrIn$Outbound
  | InvokeDeploymentRequestOrNin$Outbound
  | OrExists$Outbound;

/** @internal */
export const Or$outboundSchema: z.ZodType<Or$Outbound, z.ZodTypeDef, Or> = z
  .union([
    z.lazy(() => InvokeDeploymentRequestOrEq$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrNe$outboundSchema),
    z.lazy(() => OrGt$outboundSchema),
    z.lazy(() => OrGte$outboundSchema),
    z.lazy(() => OrLt$outboundSchema),
    z.lazy(() => OrLte$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrIn$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrNin$outboundSchema),
    z.lazy(() => OrExists$outboundSchema),
  ]);

export function orToJSON(or: Or): string {
  return JSON.stringify(Or$outboundSchema.parse(or));
}
export function orFromJSON(
  jsonString: string,
): SafeParseResult<Or, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Or$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Or' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterOr$inboundSchema: z.ZodType<
  KnowledgeFilterOr,
  z.ZodTypeDef,
  unknown
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestOrEq$inboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestOrNe$inboundSchema
      ),
      z.lazy(() => OrGt$inboundSchema),
      z.lazy(() => OrGte$inboundSchema),
      z.lazy(() => OrLt$inboundSchema),
      z.lazy(() => OrLte$inboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrIn$inboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrNin$inboundSchema),
      z.lazy(() => OrExists$inboundSchema),
    ])),
  ),
});
/** @internal */
export type KnowledgeFilterOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestOrEq$Outbound
        | InvokeDeploymentRequestOrNe$Outbound
        | OrGt$Outbound
        | OrGte$Outbound
        | OrLt$Outbound
        | OrLte$Outbound
        | InvokeDeploymentRequestOrIn$Outbound
        | InvokeDeploymentRequestOrNin$Outbound
        | OrExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterOr$outboundSchema: z.ZodType<
  KnowledgeFilterOr$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestOrEq$outboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestOrNe$outboundSchema
      ),
      z.lazy(() => OrGt$outboundSchema),
      z.lazy(() => OrGte$outboundSchema),
      z.lazy(() => OrLt$outboundSchema),
      z.lazy(() => OrLte$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrIn$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrNin$outboundSchema),
      z.lazy(() => OrExists$outboundSchema),
    ])),
  ),
});

export function knowledgeFilterOrToJSON(
  knowledgeFilterOr: KnowledgeFilterOr,
): string {
  return JSON.stringify(
    KnowledgeFilterOr$outboundSchema.parse(knowledgeFilterOr),
  );
}
export function knowledgeFilterOrFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterOr' from JSON`,
  );
}

/** @internal */
export const AndExists$inboundSchema: z.ZodType<
  AndExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type AndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const AndExists$outboundSchema: z.ZodType<
  AndExists$Outbound,
  z.ZodTypeDef,
  AndExists
> = z.object({
  exists: z.boolean(),
});

export function andExistsToJSON(andExists: AndExists): string {
  return JSON.stringify(AndExists$outboundSchema.parse(andExists));
}
export function andExistsFromJSON(
  jsonString: string,
): SafeParseResult<AndExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndExists' from JSON`,
  );
}

/** @internal */
export const AndNin$inboundSchema: z.ZodType<AndNin, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AndNin$Outbound = string | number | boolean;

/** @internal */
export const AndNin$outboundSchema: z.ZodType<
  AndNin$Outbound,
  z.ZodTypeDef,
  AndNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function andNinToJSON(andNin: AndNin): string {
  return JSON.stringify(AndNin$outboundSchema.parse(andNin));
}
export function andNinFromJSON(
  jsonString: string,
): SafeParseResult<AndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndNin' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAndNin$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type InvokeDeploymentRequestAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestAndNin$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNin$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestAndNinToJSON(
  invokeDeploymentRequestAndNin: InvokeDeploymentRequestAndNin,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndNin$outboundSchema.parse(
      invokeDeploymentRequestAndNin,
    ),
  );
}
export function invokeDeploymentRequestAndNinFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestAndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAndNin' from JSON`,
  );
}

/** @internal */
export const AndIn$inboundSchema: z.ZodType<AndIn, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AndIn$Outbound = string | number | boolean;

/** @internal */
export const AndIn$outboundSchema: z.ZodType<
  AndIn$Outbound,
  z.ZodTypeDef,
  AndIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function andInToJSON(andIn: AndIn): string {
  return JSON.stringify(AndIn$outboundSchema.parse(andIn));
}
export function andInFromJSON(
  jsonString: string,
): SafeParseResult<AndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndIn' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAndIn$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAndIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type InvokeDeploymentRequestAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestAndIn$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndIn$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestAndInToJSON(
  invokeDeploymentRequestAndIn: InvokeDeploymentRequestAndIn,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndIn$outboundSchema.parse(
      invokeDeploymentRequestAndIn,
    ),
  );
}
export function invokeDeploymentRequestAndInFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestAndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAndIn' from JSON`,
  );
}

/** @internal */
export const AndLte$inboundSchema: z.ZodType<AndLte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type AndLte$Outbound = {
  lte: number;
};

/** @internal */
export const AndLte$outboundSchema: z.ZodType<
  AndLte$Outbound,
  z.ZodTypeDef,
  AndLte
> = z.object({
  lte: z.number(),
});

export function andLteToJSON(andLte: AndLte): string {
  return JSON.stringify(AndLte$outboundSchema.parse(andLte));
}
export function andLteFromJSON(
  jsonString: string,
): SafeParseResult<AndLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndLte' from JSON`,
  );
}

/** @internal */
export const AndLt$inboundSchema: z.ZodType<AndLt, z.ZodTypeDef, unknown> = z
  .object({
    lt: z.number(),
  });
/** @internal */
export type AndLt$Outbound = {
  lt: number;
};

/** @internal */
export const AndLt$outboundSchema: z.ZodType<
  AndLt$Outbound,
  z.ZodTypeDef,
  AndLt
> = z.object({
  lt: z.number(),
});

export function andLtToJSON(andLt: AndLt): string {
  return JSON.stringify(AndLt$outboundSchema.parse(andLt));
}
export function andLtFromJSON(
  jsonString: string,
): SafeParseResult<AndLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndLt' from JSON`,
  );
}

/** @internal */
export const AndGte$inboundSchema: z.ZodType<AndGte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type AndGte$Outbound = {
  gte: number;
};

/** @internal */
export const AndGte$outboundSchema: z.ZodType<
  AndGte$Outbound,
  z.ZodTypeDef,
  AndGte
> = z.object({
  gte: z.number(),
});

export function andGteToJSON(andGte: AndGte): string {
  return JSON.stringify(AndGte$outboundSchema.parse(andGte));
}
export function andGteFromJSON(
  jsonString: string,
): SafeParseResult<AndGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndGte' from JSON`,
  );
}

/** @internal */
export const AndGt$inboundSchema: z.ZodType<AndGt, z.ZodTypeDef, unknown> = z
  .object({
    gt: z.number(),
  });
/** @internal */
export type AndGt$Outbound = {
  gt: number;
};

/** @internal */
export const AndGt$outboundSchema: z.ZodType<
  AndGt$Outbound,
  z.ZodTypeDef,
  AndGt
> = z.object({
  gt: z.number(),
});

export function andGtToJSON(andGt: AndGt): string {
  return JSON.stringify(AndGt$outboundSchema.parse(andGt));
}
export function andGtFromJSON(
  jsonString: string,
): SafeParseResult<AndGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndGt' from JSON`,
  );
}

/** @internal */
export const AndNe$inboundSchema: z.ZodType<AndNe, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AndNe$Outbound = string | number | boolean;

/** @internal */
export const AndNe$outboundSchema: z.ZodType<
  AndNe$Outbound,
  z.ZodTypeDef,
  AndNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function andNeToJSON(andNe: AndNe): string {
  return JSON.stringify(AndNe$outboundSchema.parse(andNe));
}
export function andNeFromJSON(
  jsonString: string,
): SafeParseResult<AndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndNe' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAndNe$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type InvokeDeploymentRequestAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestAndNe$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNe$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestAndNeToJSON(
  invokeDeploymentRequestAndNe: InvokeDeploymentRequestAndNe,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndNe$outboundSchema.parse(
      invokeDeploymentRequestAndNe,
    ),
  );
}
export function invokeDeploymentRequestAndNeFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestAndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAndNe' from JSON`,
  );
}

/** @internal */
export const AndEq$inboundSchema: z.ZodType<AndEq, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AndEq$Outbound = string | number | boolean;

/** @internal */
export const AndEq$outboundSchema: z.ZodType<
  AndEq$Outbound,
  z.ZodTypeDef,
  AndEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function andEqToJSON(andEq: AndEq): string {
  return JSON.stringify(AndEq$outboundSchema.parse(andEq));
}
export function andEqFromJSON(
  jsonString: string,
): SafeParseResult<AndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndEq' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequestAndEq$inboundSchema: z.ZodType<
  InvokeDeploymentRequestAndEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type InvokeDeploymentRequestAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestAndEq$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndEq$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestAndEqToJSON(
  invokeDeploymentRequestAndEq: InvokeDeploymentRequestAndEq,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndEq$outboundSchema.parse(
      invokeDeploymentRequestAndEq,
    ),
  );
}
export function invokeDeploymentRequestAndEqFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequestAndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequestAndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequestAndEq' from JSON`,
  );
}

/** @internal */
export const And$inboundSchema: z.ZodType<And, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => InvokeDeploymentRequestAndEq$inboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNe$inboundSchema),
    z.lazy(() => AndGt$inboundSchema),
    z.lazy(() => AndGte$inboundSchema),
    z.lazy(() => AndLt$inboundSchema),
    z.lazy(() => AndLte$inboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndIn$inboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNin$inboundSchema),
    z.lazy(() => AndExists$inboundSchema),
  ],
);
/** @internal */
export type And$Outbound =
  | InvokeDeploymentRequestAndEq$Outbound
  | InvokeDeploymentRequestAndNe$Outbound
  | AndGt$Outbound
  | AndGte$Outbound
  | AndLt$Outbound
  | AndLte$Outbound
  | InvokeDeploymentRequestAndIn$Outbound
  | InvokeDeploymentRequestAndNin$Outbound
  | AndExists$Outbound;

/** @internal */
export const And$outboundSchema: z.ZodType<And$Outbound, z.ZodTypeDef, And> = z
  .union([
    z.lazy(() => InvokeDeploymentRequestAndEq$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNe$outboundSchema),
    z.lazy(() => AndGt$outboundSchema),
    z.lazy(() => AndGte$outboundSchema),
    z.lazy(() => AndLt$outboundSchema),
    z.lazy(() => AndLte$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndIn$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNin$outboundSchema),
    z.lazy(() => AndExists$outboundSchema),
  ]);

export function andToJSON(and: And): string {
  return JSON.stringify(And$outboundSchema.parse(and));
}
export function andFromJSON(
  jsonString: string,
): SafeParseResult<And, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => And$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'And' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterAnd$inboundSchema: z.ZodType<
  KnowledgeFilterAnd,
  z.ZodTypeDef,
  unknown
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestAndEq$inboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestAndNe$inboundSchema
      ),
      z.lazy(() => AndGt$inboundSchema),
      z.lazy(() => AndGte$inboundSchema),
      z.lazy(() => AndLt$inboundSchema),
      z.lazy(() => AndLte$inboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndIn$inboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndNin$inboundSchema),
      z.lazy(() => AndExists$inboundSchema),
    ])),
  ),
});
/** @internal */
export type KnowledgeFilterAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestAndEq$Outbound
        | InvokeDeploymentRequestAndNe$Outbound
        | AndGt$Outbound
        | AndGte$Outbound
        | AndLt$Outbound
        | AndLte$Outbound
        | InvokeDeploymentRequestAndIn$Outbound
        | InvokeDeploymentRequestAndNin$Outbound
        | AndExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterAnd$outboundSchema: z.ZodType<
  KnowledgeFilterAnd$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestAndEq$outboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestAndNe$outboundSchema
      ),
      z.lazy(() => AndGt$outboundSchema),
      z.lazy(() => AndGte$outboundSchema),
      z.lazy(() => AndLt$outboundSchema),
      z.lazy(() => AndLte$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndIn$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndNin$outboundSchema),
      z.lazy(() => AndExists$outboundSchema),
    ])),
  ),
});

export function knowledgeFilterAndToJSON(
  knowledgeFilterAnd: KnowledgeFilterAnd,
): string {
  return JSON.stringify(
    KnowledgeFilterAnd$outboundSchema.parse(knowledgeFilterAnd),
  );
}
export function knowledgeFilterAndFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterAnd' from JSON`,
  );
}

/** @internal */
export const Exists$inboundSchema: z.ZodType<Exists, z.ZodTypeDef, unknown> = z
  .object({
    exists: z.boolean(),
  });
/** @internal */
export type Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const Exists$outboundSchema: z.ZodType<
  Exists$Outbound,
  z.ZodTypeDef,
  Exists
> = z.object({
  exists: z.boolean(),
});

export function existsToJSON(exists: Exists): string {
  return JSON.stringify(Exists$outboundSchema.parse(exists));
}
export function existsFromJSON(
  jsonString: string,
): SafeParseResult<Exists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Exists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Exists' from JSON`,
  );
}

/** @internal */
export const Nin$inboundSchema: z.ZodType<Nin, z.ZodTypeDef, unknown> = z.union(
  [z.string(), z.number(), z.boolean()],
);
/** @internal */
export type Nin$Outbound = string | number | boolean;

/** @internal */
export const Nin$outboundSchema: z.ZodType<Nin$Outbound, z.ZodTypeDef, Nin> = z
  .union([z.string(), z.number(), z.boolean()]);

export function ninToJSON(nin: Nin): string {
  return JSON.stringify(Nin$outboundSchema.parse(nin));
}
export function ninFromJSON(
  jsonString: string,
): SafeParseResult<Nin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Nin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Nin' from JSON`,
  );
}

/** @internal */
export const OneNin$inboundSchema: z.ZodType<OneNin, z.ZodTypeDef, unknown> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type OneNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const OneNin$outboundSchema: z.ZodType<
  OneNin$Outbound,
  z.ZodTypeDef,
  OneNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function oneNinToJSON(oneNin: OneNin): string {
  return JSON.stringify(OneNin$outboundSchema.parse(oneNin));
}
export function oneNinFromJSON(
  jsonString: string,
): SafeParseResult<OneNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneNin' from JSON`,
  );
}

/** @internal */
export const In$inboundSchema: z.ZodType<In, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
]);
/** @internal */
export type In$Outbound = string | number | boolean;

/** @internal */
export const In$outboundSchema: z.ZodType<In$Outbound, z.ZodTypeDef, In> = z
  .union([z.string(), z.number(), z.boolean()]);

export function inToJSON(value: In): string {
  return JSON.stringify(In$outboundSchema.parse(value));
}
export function inFromJSON(
  jsonString: string,
): SafeParseResult<In, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => In$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'In' from JSON`,
  );
}

/** @internal */
export const OneIn$inboundSchema: z.ZodType<OneIn, z.ZodTypeDef, unknown> = z
  .object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type OneIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const OneIn$outboundSchema: z.ZodType<
  OneIn$Outbound,
  z.ZodTypeDef,
  OneIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function oneInToJSON(oneIn: OneIn): string {
  return JSON.stringify(OneIn$outboundSchema.parse(oneIn));
}
export function oneInFromJSON(
  jsonString: string,
): SafeParseResult<OneIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneIn' from JSON`,
  );
}

/** @internal */
export const Lte$inboundSchema: z.ZodType<Lte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type Lte$Outbound = {
  lte: number;
};

/** @internal */
export const Lte$outboundSchema: z.ZodType<Lte$Outbound, z.ZodTypeDef, Lte> = z
  .object({
    lte: z.number(),
  });

export function lteToJSON(lte: Lte): string {
  return JSON.stringify(Lte$outboundSchema.parse(lte));
}
export function lteFromJSON(
  jsonString: string,
): SafeParseResult<Lte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lte' from JSON`,
  );
}

/** @internal */
export const Lt$inboundSchema: z.ZodType<Lt, z.ZodTypeDef, unknown> = z.object({
  lt: z.number(),
});
/** @internal */
export type Lt$Outbound = {
  lt: number;
};

/** @internal */
export const Lt$outboundSchema: z.ZodType<Lt$Outbound, z.ZodTypeDef, Lt> = z
  .object({
    lt: z.number(),
  });

export function ltToJSON(lt: Lt): string {
  return JSON.stringify(Lt$outboundSchema.parse(lt));
}
export function ltFromJSON(
  jsonString: string,
): SafeParseResult<Lt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lt' from JSON`,
  );
}

/** @internal */
export const Gte$inboundSchema: z.ZodType<Gte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type Gte$Outbound = {
  gte: number;
};

/** @internal */
export const Gte$outboundSchema: z.ZodType<Gte$Outbound, z.ZodTypeDef, Gte> = z
  .object({
    gte: z.number(),
  });

export function gteToJSON(gte: Gte): string {
  return JSON.stringify(Gte$outboundSchema.parse(gte));
}
export function gteFromJSON(
  jsonString: string,
): SafeParseResult<Gte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gte' from JSON`,
  );
}

/** @internal */
export const Gt$inboundSchema: z.ZodType<Gt, z.ZodTypeDef, unknown> = z.object({
  gt: z.number(),
});
/** @internal */
export type Gt$Outbound = {
  gt: number;
};

/** @internal */
export const Gt$outboundSchema: z.ZodType<Gt$Outbound, z.ZodTypeDef, Gt> = z
  .object({
    gt: z.number(),
  });

export function gtToJSON(gt: Gt): string {
  return JSON.stringify(Gt$outboundSchema.parse(gt));
}
export function gtFromJSON(
  jsonString: string,
): SafeParseResult<Gt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gt' from JSON`,
  );
}

/** @internal */
export const Ne$inboundSchema: z.ZodType<Ne, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
]);
/** @internal */
export type Ne$Outbound = string | number | boolean;

/** @internal */
export const Ne$outboundSchema: z.ZodType<Ne$Outbound, z.ZodTypeDef, Ne> = z
  .union([z.string(), z.number(), z.boolean()]);

export function neToJSON(ne: Ne): string {
  return JSON.stringify(Ne$outboundSchema.parse(ne));
}
export function neFromJSON(
  jsonString: string,
): SafeParseResult<Ne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ne' from JSON`,
  );
}

/** @internal */
export const OneNe$inboundSchema: z.ZodType<OneNe, z.ZodTypeDef, unknown> = z
  .object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type OneNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const OneNe$outboundSchema: z.ZodType<
  OneNe$Outbound,
  z.ZodTypeDef,
  OneNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function oneNeToJSON(oneNe: OneNe): string {
  return JSON.stringify(OneNe$outboundSchema.parse(oneNe));
}
export function oneNeFromJSON(
  jsonString: string,
): SafeParseResult<OneNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneNe' from JSON`,
  );
}

/** @internal */
export const Eq$inboundSchema: z.ZodType<Eq, z.ZodTypeDef, unknown> = z.union([
  z.string(),
  z.number(),
  z.boolean(),
]);
/** @internal */
export type Eq$Outbound = string | number | boolean;

/** @internal */
export const Eq$outboundSchema: z.ZodType<Eq$Outbound, z.ZodTypeDef, Eq> = z
  .union([z.string(), z.number(), z.boolean()]);

export function eqToJSON(eq: Eq): string {
  return JSON.stringify(Eq$outboundSchema.parse(eq));
}
export function eqFromJSON(
  jsonString: string,
): SafeParseResult<Eq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Eq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Eq' from JSON`,
  );
}

/** @internal */
export const OneEq$inboundSchema: z.ZodType<OneEq, z.ZodTypeDef, unknown> = z
  .object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type OneEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const OneEq$outboundSchema: z.ZodType<
  OneEq$Outbound,
  z.ZodTypeDef,
  OneEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function oneEqToJSON(oneEq: OneEq): string {
  return JSON.stringify(OneEq$outboundSchema.parse(oneEq));
}
export function oneEqFromJSON(
  jsonString: string,
): SafeParseResult<OneEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneEq' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => OneEq$inboundSchema),
    z.lazy(() => OneNe$inboundSchema),
    z.lazy(() => Gt$inboundSchema),
    z.lazy(() => Gte$inboundSchema),
    z.lazy(() => Lt$inboundSchema),
    z.lazy(() => Lte$inboundSchema),
    z.lazy(() => OneIn$inboundSchema),
    z.lazy(() => OneNin$inboundSchema),
    z.lazy(() => Exists$inboundSchema),
  ],
);
/** @internal */
export type One$Outbound =
  | OneEq$Outbound
  | OneNe$Outbound
  | Gt$Outbound
  | Gte$Outbound
  | Lt$Outbound
  | Lte$Outbound
  | OneIn$Outbound
  | OneNin$Outbound
  | Exists$Outbound;

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .union([
    z.lazy(() => OneEq$outboundSchema),
    z.lazy(() => OneNe$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => OneIn$outboundSchema),
    z.lazy(() => OneNin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ]);

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}
export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilter$inboundSchema: z.ZodType<
  KnowledgeFilter,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => KnowledgeFilterAnd$inboundSchema),
  z.lazy(() => KnowledgeFilterOr$inboundSchema),
  z.record(z.union([
    z.lazy(() => OneEq$inboundSchema),
    z.lazy(() => OneNe$inboundSchema),
    z.lazy(() => Gt$inboundSchema),
    z.lazy(() => Gte$inboundSchema),
    z.lazy(() => Lt$inboundSchema),
    z.lazy(() => Lte$inboundSchema),
    z.lazy(() => OneIn$inboundSchema),
    z.lazy(() => OneNin$inboundSchema),
    z.lazy(() => Exists$inboundSchema),
  ])),
]);
/** @internal */
export type KnowledgeFilter$Outbound =
  | KnowledgeFilterAnd$Outbound
  | KnowledgeFilterOr$Outbound
  | {
    [k: string]:
      | OneEq$Outbound
      | OneNe$Outbound
      | Gt$Outbound
      | Gte$Outbound
      | Lt$Outbound
      | Lte$Outbound
      | OneIn$Outbound
      | OneNin$Outbound
      | Exists$Outbound;
  };

/** @internal */
export const KnowledgeFilter$outboundSchema: z.ZodType<
  KnowledgeFilter$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter
> = z.union([
  z.lazy(() => KnowledgeFilterAnd$outboundSchema),
  z.lazy(() => KnowledgeFilterOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => OneEq$outboundSchema),
    z.lazy(() => OneNe$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => OneIn$outboundSchema),
    z.lazy(() => OneNin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ])),
]);

export function knowledgeFilterToJSON(
  knowledgeFilter: KnowledgeFilter,
): string {
  return JSON.stringify(KnowledgeFilter$outboundSchema.parse(knowledgeFilter));
}
export function knowledgeFilterFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilter' from JSON`,
  );
}

/** @internal */
export const InvokeDeploymentRequest$inboundSchema: z.ZodType<
  InvokeDeploymentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  stream: z.boolean().default(false),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefix_messages: z.array(
    z.union([
      z.lazy(() => ToolMessage$inboundSchema),
      z.lazy(() => DeveloperMessage$inboundSchema),
      z.lazy(() => SystemMessage$inboundSchema),
      z.lazy(() => UserMessage$inboundSchema),
      z.lazy(() => AssistantMessage$inboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesToolMessage$inboundSchema),
      z.lazy(() => MessagesDeveloperMessage$inboundSchema),
      z.lazy(() => MessagesSystemMessage$inboundSchema),
      z.lazy(() => MessagesUserMessage$inboundSchema),
      z.lazy(() => MessagesAssistantMessage$inboundSchema),
    ]),
  ).optional(),
  file_ids: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extra_params: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$inboundSchema)).optional(),
  invoke_options: z.lazy(() => InvokeOptions$inboundSchema).optional(),
  thread: z.lazy(() => Thread$inboundSchema).optional(),
  knowledge_filter: z.union([
    z.lazy(() => KnowledgeFilterAnd$inboundSchema),
    z.lazy(() => KnowledgeFilterOr$inboundSchema),
    z.record(z.union([
      z.lazy(() => OneEq$inboundSchema),
      z.lazy(() => OneNe$inboundSchema),
      z.lazy(() => Gt$inboundSchema),
      z.lazy(() => Gte$inboundSchema),
      z.lazy(() => Lt$inboundSchema),
      z.lazy(() => Lte$inboundSchema),
      z.lazy(() => OneIn$inboundSchema),
      z.lazy(() => OneNin$inboundSchema),
      z.lazy(() => Exists$inboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "prefix_messages": "prefixMessages",
    "file_ids": "fileIds",
    "extra_params": "extraParams",
    "invoke_options": "invokeOptions",
    "knowledge_filter": "knowledgeFilter",
  });
});
/** @internal */
export type InvokeDeploymentRequest$Outbound = {
  key: string;
  stream: boolean;
  inputs?: { [k: string]: any } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?:
    | Array<
      | ToolMessage$Outbound
      | DeveloperMessage$Outbound
      | SystemMessage$Outbound
      | UserMessage$Outbound
      | AssistantMessage$Outbound
    >
    | undefined;
  messages?:
    | Array<
      | MessagesToolMessage$Outbound
      | MessagesDeveloperMessage$Outbound
      | MessagesSystemMessage$Outbound
      | MessagesUserMessage$Outbound
      | MessagesAssistantMessage$Outbound
    >
    | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
  thread?: Thread$Outbound | undefined;
  knowledge_filter?:
    | KnowledgeFilterAnd$Outbound
    | KnowledgeFilterOr$Outbound
    | {
      [k: string]:
        | OneEq$Outbound
        | OneNe$Outbound
        | Gt$Outbound
        | Gte$Outbound
        | Lt$Outbound
        | Lte$Outbound
        | OneIn$Outbound
        | OneNin$Outbound
        | Exists$Outbound;
    }
    | undefined;
};

/** @internal */
export const InvokeDeploymentRequest$outboundSchema: z.ZodType<
  InvokeDeploymentRequest$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequest
> = z.object({
  key: z.string(),
  stream: z.boolean().default(false),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(
    z.union([
      z.lazy(() => ToolMessage$outboundSchema),
      z.lazy(() => DeveloperMessage$outboundSchema),
      z.lazy(() => SystemMessage$outboundSchema),
      z.lazy(() => UserMessage$outboundSchema),
      z.lazy(() => AssistantMessage$outboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesToolMessage$outboundSchema),
      z.lazy(() => MessagesDeveloperMessage$outboundSchema),
      z.lazy(() => MessagesSystemMessage$outboundSchema),
      z.lazy(() => MessagesUserMessage$outboundSchema),
      z.lazy(() => MessagesAssistantMessage$outboundSchema),
    ]),
  ).optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
  thread: z.lazy(() => Thread$outboundSchema).optional(),
  knowledgeFilter: z.union([
    z.lazy(() => KnowledgeFilterAnd$outboundSchema),
    z.lazy(() => KnowledgeFilterOr$outboundSchema),
    z.record(z.union([
      z.lazy(() => OneEq$outboundSchema),
      z.lazy(() => OneNe$outboundSchema),
      z.lazy(() => Gt$outboundSchema),
      z.lazy(() => Gte$outboundSchema),
      z.lazy(() => Lt$outboundSchema),
      z.lazy(() => Lte$outboundSchema),
      z.lazy(() => OneIn$outboundSchema),
      z.lazy(() => OneNin$outboundSchema),
      z.lazy(() => Exists$outboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
    knowledgeFilter: "knowledge_filter",
  });
});

export function invokeDeploymentRequestToJSON(
  invokeDeploymentRequest: InvokeDeploymentRequest,
): string {
  return JSON.stringify(
    InvokeDeploymentRequest$outboundSchema.parse(invokeDeploymentRequest),
  );
}
export function invokeDeploymentRequestFromJSON(
  jsonString: string,
): SafeParseResult<InvokeDeploymentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeDeploymentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeDeploymentRequest' from JSON`,
  );
}
