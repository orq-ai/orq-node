/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  DataPart,
  DataPart$inboundSchema,
  DataPart$Outbound,
  DataPart$outboundSchema,
} from "./datapart.js";
import {
  FilePart,
  FilePart$inboundSchema,
  FilePart$Outbound,
  FilePart$outboundSchema,
} from "./filepart.js";
import {
  TextPart,
  TextPart$inboundSchema,
  TextPart$Outbound,
  TextPart$outboundSchema,
} from "./textpart.js";
import {
  ToolCallPart,
  ToolCallPart$inboundSchema,
  ToolCallPart$Outbound,
  ToolCallPart$outboundSchema,
} from "./toolcallpart.js";
import {
  ToolResultPart,
  ToolResultPart$inboundSchema,
  ToolResultPart$Outbound,
  ToolResultPart$outboundSchema,
} from "./toolresultpart.js";

/**
 * Extended A2A message role
 */
export const AgentInactiveStreamingEventRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type AgentInactiveStreamingEventRole = ClosedEnum<
  typeof AgentInactiveStreamingEventRole
>;

export type AgentInactiveStreamingEventParts =
  | TextPart
  | DataPart
  | FilePart
  | ToolCallPart
  | ToolResultPart;

/**
 * Full last message in A2A format (for backwards compatibility)
 */
export type LastMessageFull = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: AgentInactiveStreamingEventRole;
  parts: Array<TextPart | DataPart | FilePart | ToolCallPart | ToolResultPart>;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * The reason why the agent execution became inactive
 */
export const AgentInactiveStreamingEventFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
  MaxIterations: "max_iterations",
  MaxTime: "max_time",
} as const;
/**
 * The reason why the agent execution became inactive
 */
export type AgentInactiveStreamingEventFinishReason = ClosedEnum<
  typeof AgentInactiveStreamingEventFinishReason
>;

export const AgentInactiveStreamingEventDataType = {
  Function: "function",
} as const;
export type AgentInactiveStreamingEventDataType = ClosedEnum<
  typeof AgentInactiveStreamingEventDataType
>;

export type AgentInactiveStreamingEventFunction = {
  name?: string | undefined;
  arguments?: string | undefined;
};

export type AgentInactiveStreamingEventPendingToolCalls = {
  id: string;
  type: AgentInactiveStreamingEventDataType;
  function: AgentInactiveStreamingEventFunction;
};

export type AgentInactiveStreamingEventPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type AgentInactiveStreamingEventCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the last agent message
 */
export type AgentInactiveStreamingEventUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | AgentInactiveStreamingEventPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | AgentInactiveStreamingEventCompletionTokensDetails
    | null
    | undefined;
};

export type AgentInactiveStreamingEventData = {
  lastMessage: string;
  /**
   * Full last message in A2A format (for backwards compatibility)
   */
  lastMessageFull?: LastMessageFull | undefined;
  /**
   * The reason why the agent execution became inactive
   */
  finishReason: AgentInactiveStreamingEventFinishReason;
  /**
   * Tool calls that are pending user response (for function_call finish reason)
   */
  pendingToolCalls?:
    | Array<AgentInactiveStreamingEventPendingToolCalls>
    | undefined;
  /**
   * Token usage from the last agent message
   */
  usage?: AgentInactiveStreamingEventUsage | undefined;
  workflowRunId: string;
  /**
   * ID of the response tracking this execution
   */
  responseId?: string | undefined;
};

/**
 * Emitted when the agent completes processing or pauses for input. Contains the final message, finish reason (stop, tool_calls, max_iterations, etc.), and any pending tool calls awaiting user response.
 */
export type AgentInactiveStreamingEvent = {
  type: "event.agents.inactive";
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: AgentInactiveStreamingEventData;
};

/** @internal */
export const AgentInactiveStreamingEventRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentInactiveStreamingEventRole
> = z.nativeEnum(AgentInactiveStreamingEventRole);
/** @internal */
export const AgentInactiveStreamingEventRole$outboundSchema: z.ZodNativeEnum<
  typeof AgentInactiveStreamingEventRole
> = AgentInactiveStreamingEventRole$inboundSchema;

/** @internal */
export const AgentInactiveStreamingEventParts$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  TextPart$inboundSchema,
  DataPart$inboundSchema,
  FilePart$inboundSchema,
  ToolCallPart$inboundSchema,
  ToolResultPart$inboundSchema,
]);
/** @internal */
export type AgentInactiveStreamingEventParts$Outbound =
  | TextPart$Outbound
  | DataPart$Outbound
  | FilePart$Outbound
  | ToolCallPart$Outbound
  | ToolResultPart$Outbound;

/** @internal */
export const AgentInactiveStreamingEventParts$outboundSchema: z.ZodType<
  AgentInactiveStreamingEventParts$Outbound,
  z.ZodTypeDef,
  AgentInactiveStreamingEventParts
> = z.union([
  TextPart$outboundSchema,
  DataPart$outboundSchema,
  FilePart$outboundSchema,
  ToolCallPart$outboundSchema,
  ToolResultPart$outboundSchema,
]);

export function agentInactiveStreamingEventPartsToJSON(
  agentInactiveStreamingEventParts: AgentInactiveStreamingEventParts,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventParts$outboundSchema.parse(
      agentInactiveStreamingEventParts,
    ),
  );
}
export function agentInactiveStreamingEventPartsFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventParts' from JSON`,
  );
}

/** @internal */
export const LastMessageFull$inboundSchema: z.ZodType<
  LastMessageFull,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: AgentInactiveStreamingEventRole$inboundSchema,
  parts: z.array(
    z.union([
      TextPart$inboundSchema,
      DataPart$inboundSchema,
      FilePart$inboundSchema,
      ToolCallPart$inboundSchema,
      ToolResultPart$inboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type LastMessageFull$Outbound = {
  messageId?: string | undefined;
  role: string;
  parts: Array<
    | TextPart$Outbound
    | DataPart$Outbound
    | FilePart$Outbound
    | ToolCallPart$Outbound
    | ToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const LastMessageFull$outboundSchema: z.ZodType<
  LastMessageFull$Outbound,
  z.ZodTypeDef,
  LastMessageFull
> = z.object({
  messageId: z.string().optional(),
  role: AgentInactiveStreamingEventRole$outboundSchema,
  parts: z.array(
    z.union([
      TextPart$outboundSchema,
      DataPart$outboundSchema,
      FilePart$outboundSchema,
      ToolCallPart$outboundSchema,
      ToolResultPart$outboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function lastMessageFullToJSON(
  lastMessageFull: LastMessageFull,
): string {
  return JSON.stringify(LastMessageFull$outboundSchema.parse(lastMessageFull));
}
export function lastMessageFullFromJSON(
  jsonString: string,
): SafeParseResult<LastMessageFull, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastMessageFull$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastMessageFull' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventFinishReason$inboundSchema:
  z.ZodNativeEnum<typeof AgentInactiveStreamingEventFinishReason> = z
    .nativeEnum(AgentInactiveStreamingEventFinishReason);
/** @internal */
export const AgentInactiveStreamingEventFinishReason$outboundSchema:
  z.ZodNativeEnum<typeof AgentInactiveStreamingEventFinishReason> =
    AgentInactiveStreamingEventFinishReason$inboundSchema;

/** @internal */
export const AgentInactiveStreamingEventDataType$inboundSchema: z.ZodNativeEnum<
  typeof AgentInactiveStreamingEventDataType
> = z.nativeEnum(AgentInactiveStreamingEventDataType);
/** @internal */
export const AgentInactiveStreamingEventDataType$outboundSchema:
  z.ZodNativeEnum<typeof AgentInactiveStreamingEventDataType> =
    AgentInactiveStreamingEventDataType$inboundSchema;

/** @internal */
export const AgentInactiveStreamingEventFunction$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type AgentInactiveStreamingEventFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const AgentInactiveStreamingEventFunction$outboundSchema: z.ZodType<
  AgentInactiveStreamingEventFunction$Outbound,
  z.ZodTypeDef,
  AgentInactiveStreamingEventFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function agentInactiveStreamingEventFunctionToJSON(
  agentInactiveStreamingEventFunction: AgentInactiveStreamingEventFunction,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventFunction$outboundSchema.parse(
      agentInactiveStreamingEventFunction,
    ),
  );
}
export function agentInactiveStreamingEventFunctionFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventFunction' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventPendingToolCalls$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPendingToolCalls,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    type: AgentInactiveStreamingEventDataType$inboundSchema,
    function: z.lazy(() => AgentInactiveStreamingEventFunction$inboundSchema),
  });
/** @internal */
export type AgentInactiveStreamingEventPendingToolCalls$Outbound = {
  id: string;
  type: string;
  function: AgentInactiveStreamingEventFunction$Outbound;
};

/** @internal */
export const AgentInactiveStreamingEventPendingToolCalls$outboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPendingToolCalls$Outbound,
    z.ZodTypeDef,
    AgentInactiveStreamingEventPendingToolCalls
  > = z.object({
    id: z.string(),
    type: AgentInactiveStreamingEventDataType$outboundSchema,
    function: z.lazy(() => AgentInactiveStreamingEventFunction$outboundSchema),
  });

export function agentInactiveStreamingEventPendingToolCallsToJSON(
  agentInactiveStreamingEventPendingToolCalls:
    AgentInactiveStreamingEventPendingToolCalls,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventPendingToolCalls$outboundSchema.parse(
      agentInactiveStreamingEventPendingToolCalls,
    ),
  );
}
export function agentInactiveStreamingEventPendingToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventPendingToolCalls,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventPendingToolCalls$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventPendingToolCalls' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventPromptTokensDetails$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPromptTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    cached_tokens: z.nullable(z.number().int()).optional(),
    cache_creation_tokens: z.nullable(z.number().int()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "cache_creation_tokens": "cacheCreationTokens",
      "audio_tokens": "audioTokens",
    });
  });
/** @internal */
export type AgentInactiveStreamingEventPromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  cache_creation_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const AgentInactiveStreamingEventPromptTokensDetails$outboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPromptTokensDetails$Outbound,
    z.ZodTypeDef,
    AgentInactiveStreamingEventPromptTokensDetails
  > = z.object({
    cachedTokens: z.nullable(z.number().int()).optional(),
    cacheCreationTokens: z.nullable(z.number().int()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      cachedTokens: "cached_tokens",
      cacheCreationTokens: "cache_creation_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function agentInactiveStreamingEventPromptTokensDetailsToJSON(
  agentInactiveStreamingEventPromptTokensDetails:
    AgentInactiveStreamingEventPromptTokensDetails,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventPromptTokensDetails$outboundSchema.parse(
      agentInactiveStreamingEventPromptTokensDetails,
    ),
  );
}
export function agentInactiveStreamingEventPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });
/** @internal */
export type AgentInactiveStreamingEventCompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const AgentInactiveStreamingEventCompletionTokensDetails$outboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventCompletionTokensDetails$Outbound,
    z.ZodTypeDef,
    AgentInactiveStreamingEventCompletionTokensDetails
  > = z.object({
    reasoningTokens: z.nullable(z.number()).optional(),
    acceptedPredictionTokens: z.nullable(z.number()).optional(),
    rejectedPredictionTokens: z.nullable(z.number()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      reasoningTokens: "reasoning_tokens",
      acceptedPredictionTokens: "accepted_prediction_tokens",
      rejectedPredictionTokens: "rejected_prediction_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function agentInactiveStreamingEventCompletionTokensDetailsToJSON(
  agentInactiveStreamingEventCompletionTokensDetails:
    AgentInactiveStreamingEventCompletionTokensDetails,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventCompletionTokensDetails$outboundSchema.parse(
      agentInactiveStreamingEventCompletionTokensDetails,
    ),
  );
}
export function agentInactiveStreamingEventCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventUsage$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => AgentInactiveStreamingEventPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() =>
      AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type AgentInactiveStreamingEventUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?:
    | AgentInactiveStreamingEventPromptTokensDetails$Outbound
    | null
    | undefined;
  completion_tokens_details?:
    | AgentInactiveStreamingEventCompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const AgentInactiveStreamingEventUsage$outboundSchema: z.ZodType<
  AgentInactiveStreamingEventUsage$Outbound,
  z.ZodTypeDef,
  AgentInactiveStreamingEventUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => AgentInactiveStreamingEventPromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() =>
      AgentInactiveStreamingEventCompletionTokensDetails$outboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function agentInactiveStreamingEventUsageToJSON(
  agentInactiveStreamingEventUsage: AgentInactiveStreamingEventUsage,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventUsage$outboundSchema.parse(
      agentInactiveStreamingEventUsage,
    ),
  );
}
export function agentInactiveStreamingEventUsageFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventUsage' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventData$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  last_message: z.string(),
  last_message_full: z.lazy(() => LastMessageFull$inboundSchema).optional(),
  finish_reason: AgentInactiveStreamingEventFinishReason$inboundSchema,
  pending_tool_calls: z.array(
    z.lazy(() => AgentInactiveStreamingEventPendingToolCalls$inboundSchema),
  ).optional(),
  usage: z.lazy(() => AgentInactiveStreamingEventUsage$inboundSchema)
    .optional(),
  workflowRunId: z.string(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "last_message": "lastMessage",
    "last_message_full": "lastMessageFull",
    "finish_reason": "finishReason",
    "pending_tool_calls": "pendingToolCalls",
  });
});
/** @internal */
export type AgentInactiveStreamingEventData$Outbound = {
  last_message: string;
  last_message_full?: LastMessageFull$Outbound | undefined;
  finish_reason: string;
  pending_tool_calls?:
    | Array<AgentInactiveStreamingEventPendingToolCalls$Outbound>
    | undefined;
  usage?: AgentInactiveStreamingEventUsage$Outbound | undefined;
  workflowRunId: string;
  responseId?: string | undefined;
};

/** @internal */
export const AgentInactiveStreamingEventData$outboundSchema: z.ZodType<
  AgentInactiveStreamingEventData$Outbound,
  z.ZodTypeDef,
  AgentInactiveStreamingEventData
> = z.object({
  lastMessage: z.string(),
  lastMessageFull: z.lazy(() => LastMessageFull$outboundSchema).optional(),
  finishReason: AgentInactiveStreamingEventFinishReason$outboundSchema,
  pendingToolCalls: z.array(
    z.lazy(() => AgentInactiveStreamingEventPendingToolCalls$outboundSchema),
  ).optional(),
  usage: z.lazy(() => AgentInactiveStreamingEventUsage$outboundSchema)
    .optional(),
  workflowRunId: z.string(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    lastMessage: "last_message",
    lastMessageFull: "last_message_full",
    finishReason: "finish_reason",
    pendingToolCalls: "pending_tool_calls",
  });
});

export function agentInactiveStreamingEventDataToJSON(
  agentInactiveStreamingEventData: AgentInactiveStreamingEventData,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEventData$outboundSchema.parse(
      agentInactiveStreamingEventData,
    ),
  );
}
export function agentInactiveStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventData' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEvent$inboundSchema: z.ZodType<
  AgentInactiveStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("event.agents.inactive"),
  timestamp: z.string(),
  data: z.lazy(() => AgentInactiveStreamingEventData$inboundSchema),
});
/** @internal */
export type AgentInactiveStreamingEvent$Outbound = {
  type: "event.agents.inactive";
  timestamp: string;
  data: AgentInactiveStreamingEventData$Outbound;
};

/** @internal */
export const AgentInactiveStreamingEvent$outboundSchema: z.ZodType<
  AgentInactiveStreamingEvent$Outbound,
  z.ZodTypeDef,
  AgentInactiveStreamingEvent
> = z.object({
  type: z.literal("event.agents.inactive"),
  timestamp: z.string(),
  data: z.lazy(() => AgentInactiveStreamingEventData$outboundSchema),
});

export function agentInactiveStreamingEventToJSON(
  agentInactiveStreamingEvent: AgentInactiveStreamingEvent,
): string {
  return JSON.stringify(
    AgentInactiveStreamingEvent$outboundSchema.parse(
      agentInactiveStreamingEvent,
    ),
  );
}
export function agentInactiveStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEvent' from JSON`,
  );
}
