/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { DataPart, DataPart$inboundSchema } from "./datapart.js";
import { ErrorPart, ErrorPart$inboundSchema } from "./errorpart.js";
import { FilePart, FilePart$inboundSchema } from "./filepart.js";
import { TextPart, TextPart$inboundSchema } from "./textpart.js";
import { ToolCallPart, ToolCallPart$inboundSchema } from "./toolcallpart.js";
import {
  ToolResultPart,
  ToolResultPart$inboundSchema,
} from "./toolresultpart.js";

/**
 * Extended A2A message role
 */
export const AgentInactiveStreamingEventRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type AgentInactiveStreamingEventRole = ClosedEnum<
  typeof AgentInactiveStreamingEventRole
>;

export type AgentInactiveStreamingEventParts =
  | TextPart
  | ErrorPart
  | DataPart
  | FilePart
  | ToolCallPart
  | ToolResultPart;

/**
 * Full last message in A2A format (for backwards compatibility)
 */
export type LastMessageFull = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: AgentInactiveStreamingEventRole;
  parts: Array<
    TextPart | ErrorPart | DataPart | FilePart | ToolCallPart | ToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * The reason why the agent execution became inactive
 */
export const AgentInactiveStreamingEventFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
  MaxIterations: "max_iterations",
  MaxTime: "max_time",
} as const;
/**
 * The reason why the agent execution became inactive
 */
export type AgentInactiveStreamingEventFinishReason = ClosedEnum<
  typeof AgentInactiveStreamingEventFinishReason
>;

export const AgentInactiveStreamingEventDataType = {
  Function: "function",
} as const;
export type AgentInactiveStreamingEventDataType = ClosedEnum<
  typeof AgentInactiveStreamingEventDataType
>;

export type AgentInactiveStreamingEventFunction = {
  name?: string | undefined;
  arguments?: string | undefined;
};

export type AgentInactiveStreamingEventPendingToolCalls = {
  id: string;
  type: AgentInactiveStreamingEventDataType;
  function: AgentInactiveStreamingEventFunction;
};

export type AgentInactiveStreamingEventPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type AgentInactiveStreamingEventCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the last agent message
 */
export type AgentInactiveStreamingEventUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | AgentInactiveStreamingEventPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | AgentInactiveStreamingEventCompletionTokensDetails
    | null
    | undefined;
  timeToFirstToken?: number | undefined;
};

/**
 * Billing information for the agent execution
 */
export type Billing = {
  totalCost: number;
  inputCost: number;
  outputCost: number;
  billable: boolean;
  integrationId: string | null;
};

export type AgentInactiveStreamingEventData = {
  lastMessage: string;
  /**
   * Full last message in A2A format (for backwards compatibility)
   */
  lastMessageFull?: LastMessageFull | undefined;
  /**
   * The reason why the agent execution became inactive
   */
  finishReason: AgentInactiveStreamingEventFinishReason;
  /**
   * Tool calls that are pending user response (for function_call finish reason)
   */
  pendingToolCalls?:
    | Array<AgentInactiveStreamingEventPendingToolCalls>
    | undefined;
  /**
   * Token usage from the last agent message
   */
  usage?: AgentInactiveStreamingEventUsage | undefined;
  /**
   * Billing information for the agent execution
   */
  billing?: Billing | undefined;
  workflowRunId: string;
  /**
   * ID of the response tracking this execution
   */
  responseId?: string | undefined;
};

/**
 * Emitted when the agent completes processing or pauses for input. Contains the final message, finish reason (stop, tool_calls, max_iterations, etc.), and any pending tool calls awaiting user response.
 */
export type AgentInactiveStreamingEvent = {
  type: "event.agents.inactive";
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: AgentInactiveStreamingEventData;
};

/** @internal */
export const AgentInactiveStreamingEventRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentInactiveStreamingEventRole
> = z.nativeEnum(AgentInactiveStreamingEventRole);

/** @internal */
export const AgentInactiveStreamingEventParts$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  TextPart$inboundSchema,
  ErrorPart$inboundSchema,
  DataPart$inboundSchema,
  FilePart$inboundSchema,
  ToolCallPart$inboundSchema,
  ToolResultPart$inboundSchema,
]);

export function agentInactiveStreamingEventPartsFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventParts' from JSON`,
  );
}

/** @internal */
export const LastMessageFull$inboundSchema: z.ZodType<
  LastMessageFull,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: AgentInactiveStreamingEventRole$inboundSchema,
  parts: z.array(
    z.union([
      TextPart$inboundSchema,
      ErrorPart$inboundSchema,
      DataPart$inboundSchema,
      FilePart$inboundSchema,
      ToolCallPart$inboundSchema,
      ToolResultPart$inboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function lastMessageFullFromJSON(
  jsonString: string,
): SafeParseResult<LastMessageFull, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastMessageFull$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastMessageFull' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventFinishReason$inboundSchema:
  z.ZodNativeEnum<typeof AgentInactiveStreamingEventFinishReason> = z
    .nativeEnum(AgentInactiveStreamingEventFinishReason);

/** @internal */
export const AgentInactiveStreamingEventDataType$inboundSchema: z.ZodNativeEnum<
  typeof AgentInactiveStreamingEventDataType
> = z.nativeEnum(AgentInactiveStreamingEventDataType);

/** @internal */
export const AgentInactiveStreamingEventFunction$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function agentInactiveStreamingEventFunctionFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventFunction' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventPendingToolCalls$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPendingToolCalls,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    type: AgentInactiveStreamingEventDataType$inboundSchema,
    function: z.lazy(() => AgentInactiveStreamingEventFunction$inboundSchema),
  });

export function agentInactiveStreamingEventPendingToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventPendingToolCalls,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventPendingToolCalls$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventPendingToolCalls' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventPromptTokensDetails$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventPromptTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    cached_tokens: z.nullable(z.number().int()).optional(),
    cache_creation_tokens: z.nullable(z.number().int()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "cache_creation_tokens": "cacheCreationTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function agentInactiveStreamingEventPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema:
  z.ZodType<
    AgentInactiveStreamingEventCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function agentInactiveStreamingEventCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentInactiveStreamingEventCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentInactiveStreamingEventCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventUsage$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => AgentInactiveStreamingEventPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() =>
      AgentInactiveStreamingEventCompletionTokensDetails$inboundSchema
    ),
  ).optional(),
  time_to_first_token: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
    "time_to_first_token": "timeToFirstToken",
  });
});

export function agentInactiveStreamingEventUsageFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventUsage' from JSON`,
  );
}

/** @internal */
export const Billing$inboundSchema: z.ZodType<Billing, z.ZodTypeDef, unknown> =
  z.object({
    total_cost: z.number(),
    input_cost: z.number(),
    output_cost: z.number(),
    billable: z.boolean(),
    integration_id: z.nullable(z.string()),
  }).transform((v) => {
    return remap$(v, {
      "total_cost": "totalCost",
      "input_cost": "inputCost",
      "output_cost": "outputCost",
      "integration_id": "integrationId",
    });
  });

export function billingFromJSON(
  jsonString: string,
): SafeParseResult<Billing, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Billing$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Billing' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEventData$inboundSchema: z.ZodType<
  AgentInactiveStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  last_message: z.string(),
  last_message_full: z.lazy(() => LastMessageFull$inboundSchema).optional(),
  finish_reason: AgentInactiveStreamingEventFinishReason$inboundSchema,
  pending_tool_calls: z.array(
    z.lazy(() => AgentInactiveStreamingEventPendingToolCalls$inboundSchema),
  ).optional(),
  usage: z.lazy(() => AgentInactiveStreamingEventUsage$inboundSchema)
    .optional(),
  billing: z.lazy(() => Billing$inboundSchema).optional(),
  workflowRunId: z.string(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "last_message": "lastMessage",
    "last_message_full": "lastMessageFull",
    "finish_reason": "finishReason",
    "pending_tool_calls": "pendingToolCalls",
  });
});

export function agentInactiveStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEventData' from JSON`,
  );
}

/** @internal */
export const AgentInactiveStreamingEvent$inboundSchema: z.ZodType<
  AgentInactiveStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("event.agents.inactive"),
  timestamp: z.string(),
  data: z.lazy(() => AgentInactiveStreamingEventData$inboundSchema),
});

export function agentInactiveStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<AgentInactiveStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentInactiveStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentInactiveStreamingEvent' from JSON`,
  );
}
