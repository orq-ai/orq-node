/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const ActionReviewRequestedStreamingEventType = {
  EventAgentsActionReviewRequested: "event.agents.action_review_requested",
} as const;
export type ActionReviewRequestedStreamingEventType = ClosedEnum<
  typeof ActionReviewRequestedStreamingEventType
>;

export type Conditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type Tool = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<Conditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type ActionReviewRequestedStreamingEventData = {
  agentId: string;
  actionId: string;
  requiresApproval: boolean;
  tool: Tool;
  input: { [k: string]: any };
  agentToolCallId: string;
  responseId?: string | undefined;
};

/**
 * Emitted when a tool action requires approval before execution. Contains the tool details, input arguments, and whether approval is mandatory.
 */
export type ActionReviewRequestedStreamingEvent = {
  type: ActionReviewRequestedStreamingEventType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: ActionReviewRequestedStreamingEventData;
};

/** @internal */
export const ActionReviewRequestedStreamingEventType$inboundSchema:
  z.ZodNativeEnum<typeof ActionReviewRequestedStreamingEventType> = z
    .nativeEnum(ActionReviewRequestedStreamingEventType);
/** @internal */
export const ActionReviewRequestedStreamingEventType$outboundSchema:
  z.ZodNativeEnum<typeof ActionReviewRequestedStreamingEventType> =
    ActionReviewRequestedStreamingEventType$inboundSchema;

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type Conditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const Conditions$outboundSchema: z.ZodType<
  Conditions$Outbound,
  z.ZodTypeDef,
  Conditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function conditionsToJSON(conditions: Conditions): string {
  return JSON.stringify(Conditions$outboundSchema.parse(conditions));
}
export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const Tool$inboundSchema: z.ZodType<Tool, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    key: z.string().optional(),
    action_type: z.string(),
    display_name: z.string().optional(),
    description: z.string().optional(),
    requires_approval: z.boolean().default(false),
    tool_id: z.string().optional(),
    conditions: z.array(z.lazy(() => Conditions$inboundSchema)).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "display_name": "displayName",
      "requires_approval": "requiresApproval",
      "tool_id": "toolId",
    });
  });
/** @internal */
export type Tool$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<Conditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const Tool$outboundSchema: z.ZodType<Tool$Outbound, z.ZodTypeDef, Tool> =
  z.object({
    id: z.string(),
    key: z.string().optional(),
    actionType: z.string(),
    displayName: z.string().optional(),
    description: z.string().optional(),
    requiresApproval: z.boolean().default(false),
    toolId: z.string().optional(),
    conditions: z.array(z.lazy(() => Conditions$outboundSchema)).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      actionType: "action_type",
      displayName: "display_name",
      requiresApproval: "requires_approval",
      toolId: "tool_id",
    });
  });

export function toolToJSON(tool: Tool): string {
  return JSON.stringify(Tool$outboundSchema.parse(tool));
}
export function toolFromJSON(
  jsonString: string,
): SafeParseResult<Tool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tool' from JSON`,
  );
}

/** @internal */
export const ActionReviewRequestedStreamingEventData$inboundSchema: z.ZodType<
  ActionReviewRequestedStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_id: z.string(),
  action_id: z.string(),
  requires_approval: z.boolean(),
  tool: z.lazy(() => Tool$inboundSchema),
  input: z.record(z.any()),
  agent_tool_call_id: z.string(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "agent_id": "agentId",
    "action_id": "actionId",
    "requires_approval": "requiresApproval",
    "agent_tool_call_id": "agentToolCallId",
  });
});
/** @internal */
export type ActionReviewRequestedStreamingEventData$Outbound = {
  agent_id: string;
  action_id: string;
  requires_approval: boolean;
  tool: Tool$Outbound;
  input: { [k: string]: any };
  agent_tool_call_id: string;
  responseId?: string | undefined;
};

/** @internal */
export const ActionReviewRequestedStreamingEventData$outboundSchema: z.ZodType<
  ActionReviewRequestedStreamingEventData$Outbound,
  z.ZodTypeDef,
  ActionReviewRequestedStreamingEventData
> = z.object({
  agentId: z.string(),
  actionId: z.string(),
  requiresApproval: z.boolean(),
  tool: z.lazy(() => Tool$outboundSchema),
  input: z.record(z.any()),
  agentToolCallId: z.string(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    agentId: "agent_id",
    actionId: "action_id",
    requiresApproval: "requires_approval",
    agentToolCallId: "agent_tool_call_id",
  });
});

export function actionReviewRequestedStreamingEventDataToJSON(
  actionReviewRequestedStreamingEventData:
    ActionReviewRequestedStreamingEventData,
): string {
  return JSON.stringify(
    ActionReviewRequestedStreamingEventData$outboundSchema.parse(
      actionReviewRequestedStreamingEventData,
    ),
  );
}
export function actionReviewRequestedStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<
  ActionReviewRequestedStreamingEventData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ActionReviewRequestedStreamingEventData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ActionReviewRequestedStreamingEventData' from JSON`,
  );
}

/** @internal */
export const ActionReviewRequestedStreamingEvent$inboundSchema: z.ZodType<
  ActionReviewRequestedStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ActionReviewRequestedStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => ActionReviewRequestedStreamingEventData$inboundSchema),
});
/** @internal */
export type ActionReviewRequestedStreamingEvent$Outbound = {
  type: string;
  timestamp: string;
  data: ActionReviewRequestedStreamingEventData$Outbound;
};

/** @internal */
export const ActionReviewRequestedStreamingEvent$outboundSchema: z.ZodType<
  ActionReviewRequestedStreamingEvent$Outbound,
  z.ZodTypeDef,
  ActionReviewRequestedStreamingEvent
> = z.object({
  type: ActionReviewRequestedStreamingEventType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => ActionReviewRequestedStreamingEventData$outboundSchema),
});

export function actionReviewRequestedStreamingEventToJSON(
  actionReviewRequestedStreamingEvent: ActionReviewRequestedStreamingEvent,
): string {
  return JSON.stringify(
    ActionReviewRequestedStreamingEvent$outboundSchema.parse(
      actionReviewRequestedStreamingEvent,
    ),
  );
}
export function actionReviewRequestedStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<ActionReviewRequestedStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ActionReviewRequestedStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ActionReviewRequestedStreamingEvent' from JSON`,
  );
}
