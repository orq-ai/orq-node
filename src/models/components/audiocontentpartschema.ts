/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export const Format = {
  Mp3: "mp3",
  Wav: "wav",
} as const;
/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export type Format = ClosedEnum<typeof Format>;

export type InputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports `wav` and `mp3`.
   */
  format: Format;
};

/**
 * An audio content part
 */
export type AudioContentPartSchema = {
  type: "input_audio";
  inputAudio: InputAudio;
};

/** @internal */
export const Format$inboundSchema: z.ZodNativeEnum<typeof Format> = z
  .nativeEnum(Format);
/** @internal */
export const Format$outboundSchema: z.ZodNativeEnum<typeof Format> =
  Format$inboundSchema;

/** @internal */
export const InputAudio$inboundSchema: z.ZodType<
  InputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: Format$inboundSchema,
});
/** @internal */
export type InputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const InputAudio$outboundSchema: z.ZodType<
  InputAudio$Outbound,
  z.ZodTypeDef,
  InputAudio
> = z.object({
  data: z.string(),
  format: Format$outboundSchema,
});

export function inputAudioToJSON(inputAudio: InputAudio): string {
  return JSON.stringify(InputAudio$outboundSchema.parse(inputAudio));
}
export function inputAudioFromJSON(
  jsonString: string,
): SafeParseResult<InputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAudio' from JSON`,
  );
}

/** @internal */
export const AudioContentPartSchema$inboundSchema: z.ZodType<
  AudioContentPartSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("input_audio"),
  input_audio: z.lazy(() => InputAudio$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "input_audio": "inputAudio",
  });
});
/** @internal */
export type AudioContentPartSchema$Outbound = {
  type: "input_audio";
  input_audio: InputAudio$Outbound;
};

/** @internal */
export const AudioContentPartSchema$outboundSchema: z.ZodType<
  AudioContentPartSchema$Outbound,
  z.ZodTypeDef,
  AudioContentPartSchema
> = z.object({
  type: z.literal("input_audio"),
  inputAudio: z.lazy(() => InputAudio$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    inputAudio: "input_audio",
  });
});

export function audioContentPartSchemaToJSON(
  audioContentPartSchema: AudioContentPartSchema,
): string {
  return JSON.stringify(
    AudioContentPartSchema$outboundSchema.parse(audioContentPartSchema),
  );
}
export function audioContentPartSchemaFromJSON(
  jsonString: string,
): SafeParseResult<AudioContentPartSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AudioContentPartSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AudioContentPartSchema' from JSON`,
  );
}
