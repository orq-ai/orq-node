/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  DataPart,
  DataPart$inboundSchema,
  DataPart$Outbound,
  DataPart$outboundSchema,
} from "./datapart.js";
import {
  FilePart,
  FilePart$inboundSchema,
  FilePart$Outbound,
  FilePart$outboundSchema,
} from "./filepart.js";
import {
  TextPart,
  TextPart$inboundSchema,
  TextPart$Outbound,
  TextPart$outboundSchema,
} from "./textpart.js";
import {
  ToolCallPart,
  ToolCallPart$inboundSchema,
  ToolCallPart$Outbound,
  ToolCallPart$outboundSchema,
} from "./toolcallpart.js";
import {
  ToolResultPart,
  ToolResultPart$inboundSchema,
  ToolResultPart$Outbound,
  ToolResultPart$outboundSchema,
} from "./toolresultpart.js";

export const AgentThoughtStreamingEventType = {
  EventAgentsThought: "event.agents.thought",
} as const;
export type AgentThoughtStreamingEventType = ClosedEnum<
  typeof AgentThoughtStreamingEventType
>;

export const AgentThoughtStreamingEventRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
export type AgentThoughtStreamingEventRole = ClosedEnum<
  typeof AgentThoughtStreamingEventRole
>;

export type AgentThoughtStreamingEventParts =
  | (ToolCallPart & { kind: "tool_call" })
  | (TextPart & { kind: "text" })
  | (DataPart & { kind: "data" })
  | (FilePart & { kind: "file" })
  | (ToolResultPart & { kind: "tool_result" });

export type MessageDifference = {
  messageId: string;
  role: AgentThoughtStreamingEventRole;
  parts: Array<
    | (ToolCallPart & { kind: "tool_call" })
    | (TextPart & { kind: "text" })
    | (DataPart & { kind: "data" })
    | (FilePart & { kind: "file" })
    | (ToolResultPart & { kind: "tool_result" })
  >;
  metadata?: { [k: string]: any } | undefined;
  agentId: string;
  agentExecutionId: string;
  workspaceId: string;
};

/**
 * The reason the model stopped generating tokens.
 */
export const AgentThoughtStreamingEventFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type AgentThoughtStreamingEventFinishReason = ClosedEnum<
  typeof AgentThoughtStreamingEventFinishReason
>;

export const AgentThoughtStreamingEventDataType = {
  Function: "function",
} as const;
export type AgentThoughtStreamingEventDataType = ClosedEnum<
  typeof AgentThoughtStreamingEventDataType
>;

export type AgentThoughtStreamingEventFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type AgentThoughtStreamingEventToolCalls = {
  id?: string | undefined;
  type?: AgentThoughtStreamingEventDataType | undefined;
  function?: AgentThoughtStreamingEventFunction | undefined;
};

export const AgentThoughtStreamingEventDataRole = {
  Assistant: "assistant",
} as const;
export type AgentThoughtStreamingEventDataRole = ClosedEnum<
  typeof AgentThoughtStreamingEventDataRole
>;

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model.
 */
export type AgentThoughtStreamingEventAudio = {
  id: string;
  expiresAt: number;
  data: string;
  transcript: string;
};

/**
 * A chat completion message generated by the model.
 */
export type AgentThoughtStreamingEventMessage = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?: Array<AgentThoughtStreamingEventToolCalls> | undefined;
  role?: AgentThoughtStreamingEventDataRole | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | null | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | null | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * If the audio output modality is requested, this object contains data about the audio response from the model.
   */
  audio?: AgentThoughtStreamingEventAudio | null | undefined;
};

export type TopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type AgentThoughtStreamingEventContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<TopLogprobs>;
};

export type AgentThoughtStreamingEventTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type Refusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<AgentThoughtStreamingEventTopLogprobs>;
};

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<AgentThoughtStreamingEventContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<Refusal> | null;
};

export type Choice = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: AgentThoughtStreamingEventFinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index?: number | undefined;
  /**
   * A chat completion message generated by the model.
   */
  message: AgentThoughtStreamingEventMessage;
  /**
   * Log probability information for the choice.
   */
  logprobs?: Logprobs | null | undefined;
};

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type Usage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | null | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

export type AgentThoughtStreamingEventData = {
  agentId: string;
  messageDifference: { [k: string]: MessageDifference };
  choice?: Choice | undefined;
  choiceIndex?: number | undefined;
  iteration: number;
  accumulatedExecutionTime: number;
  responseId?: string | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: Usage | undefined;
};

/**
 * Emitted during agent reasoning. Contains the incremental message changes, model choices, iteration count, and token usage for this processing step.
 */
export type AgentThoughtStreamingEvent = {
  type: AgentThoughtStreamingEventType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: AgentThoughtStreamingEventData;
};

/** @internal */
export const AgentThoughtStreamingEventType$inboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventType
> = z.nativeEnum(AgentThoughtStreamingEventType);
/** @internal */
export const AgentThoughtStreamingEventType$outboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventType
> = AgentThoughtStreamingEventType$inboundSchema;

/** @internal */
export const AgentThoughtStreamingEventRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventRole
> = z.nativeEnum(AgentThoughtStreamingEventRole);
/** @internal */
export const AgentThoughtStreamingEventRole$outboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventRole
> = AgentThoughtStreamingEventRole$inboundSchema;

/** @internal */
export const AgentThoughtStreamingEventParts$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  ToolCallPart$inboundSchema.and(
    z.object({ kind: z.literal("tool_call") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
  TextPart$inboundSchema.and(
    z.object({ kind: z.literal("text") }).transform((v) => ({ kind: v.kind })),
  ),
  DataPart$inboundSchema.and(
    z.object({ kind: z.literal("data") }).transform((v) => ({ kind: v.kind })),
  ),
  FilePart$inboundSchema.and(
    z.object({ kind: z.literal("file") }).transform((v) => ({ kind: v.kind })),
  ),
  ToolResultPart$inboundSchema.and(
    z.object({ kind: z.literal("tool_result") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
]);
/** @internal */
export type AgentThoughtStreamingEventParts$Outbound =
  | (ToolCallPart$Outbound & { kind: "tool_call" })
  | (TextPart$Outbound & { kind: "text" })
  | (DataPart$Outbound & { kind: "data" })
  | (FilePart$Outbound & { kind: "file" })
  | (ToolResultPart$Outbound & { kind: "tool_result" });

/** @internal */
export const AgentThoughtStreamingEventParts$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventParts$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventParts
> = z.union([
  ToolCallPart$outboundSchema.and(
    z.object({ kind: z.literal("tool_call") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
  TextPart$outboundSchema.and(
    z.object({ kind: z.literal("text") }).transform((v) => ({ kind: v.kind })),
  ),
  DataPart$outboundSchema.and(
    z.object({ kind: z.literal("data") }).transform((v) => ({ kind: v.kind })),
  ),
  FilePart$outboundSchema.and(
    z.object({ kind: z.literal("file") }).transform((v) => ({ kind: v.kind })),
  ),
  ToolResultPart$outboundSchema.and(
    z.object({ kind: z.literal("tool_result") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
]);

export function agentThoughtStreamingEventPartsToJSON(
  agentThoughtStreamingEventParts: AgentThoughtStreamingEventParts,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventParts$outboundSchema.parse(
      agentThoughtStreamingEventParts,
    ),
  );
}
export function agentThoughtStreamingEventPartsFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEventParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventParts' from JSON`,
  );
}

/** @internal */
export const MessageDifference$inboundSchema: z.ZodType<
  MessageDifference,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string(),
  role: AgentThoughtStreamingEventRole$inboundSchema,
  parts: z.array(
    z.union([
      ToolCallPart$inboundSchema.and(
        z.object({ kind: z.literal("tool_call") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      TextPart$inboundSchema.and(
        z.object({ kind: z.literal("text") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      DataPart$inboundSchema.and(
        z.object({ kind: z.literal("data") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      FilePart$inboundSchema.and(
        z.object({ kind: z.literal("file") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      ToolResultPart$inboundSchema.and(
        z.object({ kind: z.literal("tool_result") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
  agent_id: z.string(),
  agent_execution_id: z.string(),
  workspace_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_id": "agentId",
    "agent_execution_id": "agentExecutionId",
    "workspace_id": "workspaceId",
  });
});
/** @internal */
export type MessageDifference$Outbound = {
  messageId: string;
  role: string;
  parts: Array<
    | (ToolCallPart$Outbound & { kind: "tool_call" })
    | (TextPart$Outbound & { kind: "text" })
    | (DataPart$Outbound & { kind: "data" })
    | (FilePart$Outbound & { kind: "file" })
    | (ToolResultPart$Outbound & { kind: "tool_result" })
  >;
  metadata?: { [k: string]: any } | undefined;
  agent_id: string;
  agent_execution_id: string;
  workspace_id: string;
};

/** @internal */
export const MessageDifference$outboundSchema: z.ZodType<
  MessageDifference$Outbound,
  z.ZodTypeDef,
  MessageDifference
> = z.object({
  messageId: z.string(),
  role: AgentThoughtStreamingEventRole$outboundSchema,
  parts: z.array(
    z.union([
      ToolCallPart$outboundSchema.and(
        z.object({ kind: z.literal("tool_call") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      TextPart$outboundSchema.and(
        z.object({ kind: z.literal("text") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      DataPart$outboundSchema.and(
        z.object({ kind: z.literal("data") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      FilePart$outboundSchema.and(
        z.object({ kind: z.literal("file") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      ToolResultPart$outboundSchema.and(
        z.object({ kind: z.literal("tool_result") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
  agentId: z.string(),
  agentExecutionId: z.string(),
  workspaceId: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentId: "agent_id",
    agentExecutionId: "agent_execution_id",
    workspaceId: "workspace_id",
  });
});

export function messageDifferenceToJSON(
  messageDifference: MessageDifference,
): string {
  return JSON.stringify(
    MessageDifference$outboundSchema.parse(messageDifference),
  );
}
export function messageDifferenceFromJSON(
  jsonString: string,
): SafeParseResult<MessageDifference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageDifference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageDifference' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventFinishReason$inboundSchema:
  z.ZodNativeEnum<typeof AgentThoughtStreamingEventFinishReason> = z.nativeEnum(
    AgentThoughtStreamingEventFinishReason,
  );
/** @internal */
export const AgentThoughtStreamingEventFinishReason$outboundSchema:
  z.ZodNativeEnum<typeof AgentThoughtStreamingEventFinishReason> =
    AgentThoughtStreamingEventFinishReason$inboundSchema;

/** @internal */
export const AgentThoughtStreamingEventDataType$inboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventDataType
> = z.nativeEnum(AgentThoughtStreamingEventDataType);
/** @internal */
export const AgentThoughtStreamingEventDataType$outboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventDataType
> = AgentThoughtStreamingEventDataType$inboundSchema;

/** @internal */
export const AgentThoughtStreamingEventFunction$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type AgentThoughtStreamingEventFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const AgentThoughtStreamingEventFunction$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventFunction$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function agentThoughtStreamingEventFunctionToJSON(
  agentThoughtStreamingEventFunction: AgentThoughtStreamingEventFunction,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventFunction$outboundSchema.parse(
      agentThoughtStreamingEventFunction,
    ),
  );
}
export function agentThoughtStreamingEventFunctionFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentThoughtStreamingEventFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventFunction' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventToolCalls$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type: AgentThoughtStreamingEventDataType$inboundSchema.optional(),
  function: z.lazy(() => AgentThoughtStreamingEventFunction$inboundSchema)
    .optional(),
});
/** @internal */
export type AgentThoughtStreamingEventToolCalls$Outbound = {
  id?: string | undefined;
  type?: string | undefined;
  function?: AgentThoughtStreamingEventFunction$Outbound | undefined;
};

/** @internal */
export const AgentThoughtStreamingEventToolCalls$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventToolCalls$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventToolCalls
> = z.object({
  id: z.string().optional(),
  type: AgentThoughtStreamingEventDataType$outboundSchema.optional(),
  function: z.lazy(() => AgentThoughtStreamingEventFunction$outboundSchema)
    .optional(),
});

export function agentThoughtStreamingEventToolCallsToJSON(
  agentThoughtStreamingEventToolCalls: AgentThoughtStreamingEventToolCalls,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventToolCalls$outboundSchema.parse(
      agentThoughtStreamingEventToolCalls,
    ),
  );
}
export function agentThoughtStreamingEventToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentThoughtStreamingEventToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventToolCalls' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventDataRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventDataRole
> = z.nativeEnum(AgentThoughtStreamingEventDataRole);
/** @internal */
export const AgentThoughtStreamingEventDataRole$outboundSchema: z.ZodNativeEnum<
  typeof AgentThoughtStreamingEventDataRole
> = AgentThoughtStreamingEventDataRole$inboundSchema;

/** @internal */
export const AgentThoughtStreamingEventAudio$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  expires_at: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    "expires_at": "expiresAt",
  });
});
/** @internal */
export type AgentThoughtStreamingEventAudio$Outbound = {
  id: string;
  expires_at: number;
  data: string;
  transcript: string;
};

/** @internal */
export const AgentThoughtStreamingEventAudio$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventAudio$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventAudio
> = z.object({
  id: z.string(),
  expiresAt: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    expiresAt: "expires_at",
  });
});

export function agentThoughtStreamingEventAudioToJSON(
  agentThoughtStreamingEventAudio: AgentThoughtStreamingEventAudio,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventAudio$outboundSchema.parse(
      agentThoughtStreamingEventAudio,
    ),
  );
}
export function agentThoughtStreamingEventAudioFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEventAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventAudio' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventMessage$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  tool_calls: z.array(
    z.lazy(() => AgentThoughtStreamingEventToolCalls$inboundSchema),
  ).optional(),
  role: AgentThoughtStreamingEventDataRole$inboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoning_signature: z.nullable(z.string()).optional(),
  redacted_reasoning: z.string().optional(),
  audio: z.nullable(z.lazy(() => AgentThoughtStreamingEventAudio$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type AgentThoughtStreamingEventMessage$Outbound = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  tool_calls?: Array<AgentThoughtStreamingEventToolCalls$Outbound> | undefined;
  role?: string | undefined;
  reasoning?: string | null | undefined;
  reasoning_signature?: string | null | undefined;
  redacted_reasoning?: string | undefined;
  audio?: AgentThoughtStreamingEventAudio$Outbound | null | undefined;
};

/** @internal */
export const AgentThoughtStreamingEventMessage$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventMessage$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventMessage
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  toolCalls: z.array(
    z.lazy(() => AgentThoughtStreamingEventToolCalls$outboundSchema),
  ).optional(),
  role: AgentThoughtStreamingEventDataRole$outboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoningSignature: z.nullable(z.string()).optional(),
  redactedReasoning: z.string().optional(),
  audio: z.nullable(
    z.lazy(() => AgentThoughtStreamingEventAudio$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function agentThoughtStreamingEventMessageToJSON(
  agentThoughtStreamingEventMessage: AgentThoughtStreamingEventMessage,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventMessage$outboundSchema.parse(
      agentThoughtStreamingEventMessage,
    ),
  );
}
export function agentThoughtStreamingEventMessageFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEventMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventMessage' from JSON`,
  );
}

/** @internal */
export const TopLogprobs$inboundSchema: z.ZodType<
  TopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type TopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const TopLogprobs$outboundSchema: z.ZodType<
  TopLogprobs$Outbound,
  z.ZodTypeDef,
  TopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function topLogprobsToJSON(topLogprobs: TopLogprobs): string {
  return JSON.stringify(TopLogprobs$outboundSchema.parse(topLogprobs));
}
export function topLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<TopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopLogprobs' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventContent$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(z.lazy(() => TopLogprobs$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});
/** @internal */
export type AgentThoughtStreamingEventContent$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<TopLogprobs$Outbound>;
};

/** @internal */
export const AgentThoughtStreamingEventContent$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventContent$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventContent
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(z.lazy(() => TopLogprobs$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function agentThoughtStreamingEventContentToJSON(
  agentThoughtStreamingEventContent: AgentThoughtStreamingEventContent,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventContent$outboundSchema.parse(
      agentThoughtStreamingEventContent,
    ),
  );
}
export function agentThoughtStreamingEventContentFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEventContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventContent' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventTopLogprobs$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventTopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type AgentThoughtStreamingEventTopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const AgentThoughtStreamingEventTopLogprobs$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventTopLogprobs$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventTopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function agentThoughtStreamingEventTopLogprobsToJSON(
  agentThoughtStreamingEventTopLogprobs: AgentThoughtStreamingEventTopLogprobs,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventTopLogprobs$outboundSchema.parse(
      agentThoughtStreamingEventTopLogprobs,
    ),
  );
}
export function agentThoughtStreamingEventTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventTopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentThoughtStreamingEventTopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventTopLogprobs' from JSON`,
  );
}

/** @internal */
export const Refusal$inboundSchema: z.ZodType<Refusal, z.ZodTypeDef, unknown> =
  z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
    top_logprobs: z.array(
      z.lazy(() => AgentThoughtStreamingEventTopLogprobs$inboundSchema),
    ),
  }).transform((v) => {
    return remap$(v, {
      "top_logprobs": "topLogprobs",
    });
  });
/** @internal */
export type Refusal$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<AgentThoughtStreamingEventTopLogprobs$Outbound>;
};

/** @internal */
export const Refusal$outboundSchema: z.ZodType<
  Refusal$Outbound,
  z.ZodTypeDef,
  Refusal
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(
    z.lazy(() => AgentThoughtStreamingEventTopLogprobs$outboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function refusalToJSON(refusal: Refusal): string {
  return JSON.stringify(Refusal$outboundSchema.parse(refusal));
}
export function refusalFromJSON(
  jsonString: string,
): SafeParseResult<Refusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refusal' from JSON`,
  );
}

/** @internal */
export const Logprobs$inboundSchema: z.ZodType<
  Logprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => AgentThoughtStreamingEventContent$inboundSchema)),
  ),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$inboundSchema))),
});
/** @internal */
export type Logprobs$Outbound = {
  content: Array<AgentThoughtStreamingEventContent$Outbound> | null;
  refusal: Array<Refusal$Outbound> | null;
};

/** @internal */
export const Logprobs$outboundSchema: z.ZodType<
  Logprobs$Outbound,
  z.ZodTypeDef,
  Logprobs
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => AgentThoughtStreamingEventContent$outboundSchema)),
  ),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$outboundSchema))),
});

export function logprobsToJSON(logprobs: Logprobs): string {
  return JSON.stringify(Logprobs$outboundSchema.parse(logprobs));
}
export function logprobsFromJSON(
  jsonString: string,
): SafeParseResult<Logprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Logprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Logprobs' from JSON`,
  );
}

/** @internal */
export const Choice$inboundSchema: z.ZodType<Choice, z.ZodTypeDef, unknown> = z
  .object({
    finish_reason: z.nullable(
      AgentThoughtStreamingEventFinishReason$inboundSchema,
    ),
    index: z.number().default(0),
    message: z.lazy(() => AgentThoughtStreamingEventMessage$inboundSchema),
    logprobs: z.nullable(z.lazy(() => Logprobs$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "finish_reason": "finishReason",
    });
  });
/** @internal */
export type Choice$Outbound = {
  finish_reason: string | null;
  index: number;
  message: AgentThoughtStreamingEventMessage$Outbound;
  logprobs?: Logprobs$Outbound | null | undefined;
};

/** @internal */
export const Choice$outboundSchema: z.ZodType<
  Choice$Outbound,
  z.ZodTypeDef,
  Choice
> = z.object({
  finishReason: z.nullable(
    AgentThoughtStreamingEventFinishReason$outboundSchema,
  ),
  index: z.number().default(0),
  message: z.lazy(() => AgentThoughtStreamingEventMessage$outboundSchema),
  logprobs: z.nullable(z.lazy(() => Logprobs$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

export function choiceToJSON(choice: Choice): string {
  return JSON.stringify(Choice$outboundSchema.parse(choice));
}
export function choiceFromJSON(
  jsonString: string,
): SafeParseResult<Choice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Choice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Choice' from JSON`,
  );
}

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type PromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const PromptTokensDetails$outboundSchema: z.ZodType<
  PromptTokensDetails$Outbound,
  z.ZodTypeDef,
  PromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    audioTokens: "audio_tokens",
  });
});

export function promptTokensDetailsToJSON(
  promptTokensDetails: PromptTokensDetails,
): string {
  return JSON.stringify(
    PromptTokensDetails$outboundSchema.parse(promptTokensDetails),
  );
}
export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type CompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CompletionTokensDetails$outboundSchema: z.ZodType<
  CompletionTokensDetails$Outbound,
  z.ZodTypeDef,
  CompletionTokensDetails
> = z.object({
  reasoningTokens: z.nullable(z.number()).optional(),
  acceptedPredictionTokens: z.nullable(z.number()).optional(),
  rejectedPredictionTokens: z.nullable(z.number()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningTokens: "reasoning_tokens",
    acceptedPredictionTokens: "accepted_prediction_tokens",
    rejectedPredictionTokens: "rejected_prediction_tokens",
    audioTokens: "audio_tokens",
  });
});

export function completionTokensDetailsToJSON(
  completionTokensDetails: CompletionTokensDetails,
): string {
  return JSON.stringify(
    CompletionTokensDetails$outboundSchema.parse(completionTokensDetails),
  );
}
export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, z.ZodTypeDef, unknown> = z
  .object({
    completion_tokens: z.number().optional(),
    prompt_tokens: z.number().optional(),
    total_tokens: z.number().optional(),
    prompt_tokens_details: z.nullable(
      z.lazy(() => PromptTokensDetails$inboundSchema),
    ).optional(),
    completion_tokens_details: z.nullable(
      z.lazy(() => CompletionTokensDetails$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "completion_tokens": "completionTokens",
      "prompt_tokens": "promptTokens",
      "total_tokens": "totalTokens",
      "prompt_tokens_details": "promptTokensDetails",
      "completion_tokens_details": "completionTokensDetails",
    });
  });
/** @internal */
export type Usage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?: PromptTokensDetails$Outbound | null | undefined;
  completion_tokens_details?:
    | CompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const Usage$outboundSchema: z.ZodType<
  Usage$Outbound,
  z.ZodTypeDef,
  Usage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => PromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => CompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function usageToJSON(usage: Usage): string {
  return JSON.stringify(Usage$outboundSchema.parse(usage));
}
export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEventData$inboundSchema: z.ZodType<
  AgentThoughtStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_id: z.string(),
  message_difference: z.record(z.lazy(() => MessageDifference$inboundSchema)),
  choice: z.lazy(() => Choice$inboundSchema).optional(),
  choiceIndex: z.number().optional(),
  iteration: z.number(),
  accumulated_execution_time: z.number(),
  responseId: z.string().optional(),
  usage: z.lazy(() => Usage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "agent_id": "agentId",
    "message_difference": "messageDifference",
    "accumulated_execution_time": "accumulatedExecutionTime",
  });
});
/** @internal */
export type AgentThoughtStreamingEventData$Outbound = {
  agent_id: string;
  message_difference: { [k: string]: MessageDifference$Outbound };
  choice?: Choice$Outbound | undefined;
  choiceIndex?: number | undefined;
  iteration: number;
  accumulated_execution_time: number;
  responseId?: string | undefined;
  usage?: Usage$Outbound | undefined;
};

/** @internal */
export const AgentThoughtStreamingEventData$outboundSchema: z.ZodType<
  AgentThoughtStreamingEventData$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEventData
> = z.object({
  agentId: z.string(),
  messageDifference: z.record(z.lazy(() => MessageDifference$outboundSchema)),
  choice: z.lazy(() => Choice$outboundSchema).optional(),
  choiceIndex: z.number().optional(),
  iteration: z.number(),
  accumulatedExecutionTime: z.number(),
  responseId: z.string().optional(),
  usage: z.lazy(() => Usage$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    agentId: "agent_id",
    messageDifference: "message_difference",
    accumulatedExecutionTime: "accumulated_execution_time",
  });
});

export function agentThoughtStreamingEventDataToJSON(
  agentThoughtStreamingEventData: AgentThoughtStreamingEventData,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEventData$outboundSchema.parse(
      agentThoughtStreamingEventData,
    ),
  );
}
export function agentThoughtStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEventData' from JSON`,
  );
}

/** @internal */
export const AgentThoughtStreamingEvent$inboundSchema: z.ZodType<
  AgentThoughtStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AgentThoughtStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => AgentThoughtStreamingEventData$inboundSchema),
});
/** @internal */
export type AgentThoughtStreamingEvent$Outbound = {
  type: string;
  timestamp: string;
  data: AgentThoughtStreamingEventData$Outbound;
};

/** @internal */
export const AgentThoughtStreamingEvent$outboundSchema: z.ZodType<
  AgentThoughtStreamingEvent$Outbound,
  z.ZodTypeDef,
  AgentThoughtStreamingEvent
> = z.object({
  type: AgentThoughtStreamingEventType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => AgentThoughtStreamingEventData$outboundSchema),
});

export function agentThoughtStreamingEventToJSON(
  agentThoughtStreamingEvent: AgentThoughtStreamingEvent,
): string {
  return JSON.stringify(
    AgentThoughtStreamingEvent$outboundSchema.parse(agentThoughtStreamingEvent),
  );
}
export function agentThoughtStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<AgentThoughtStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentThoughtStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentThoughtStreamingEvent' from JSON`,
  );
}
