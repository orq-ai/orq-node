/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  DataPart,
  DataPart$inboundSchema,
  DataPart$Outbound,
  DataPart$outboundSchema,
} from "./datapart.js";
import {
  FilePart,
  FilePart$inboundSchema,
  FilePart$Outbound,
  FilePart$outboundSchema,
} from "./filepart.js";
import {
  TextPart,
  TextPart$inboundSchema,
  TextPart$Outbound,
  TextPart$outboundSchema,
} from "./textpart.js";
import {
  ToolCallPart,
  ToolCallPart$inboundSchema,
  ToolCallPart$Outbound,
  ToolCallPart$outboundSchema,
} from "./toolcallpart.js";
import {
  ToolResultPart,
  ToolResultPart$inboundSchema,
  ToolResultPart$Outbound,
  ToolResultPart$outboundSchema,
} from "./toolresultpart.js";

/**
 * Extended A2A message role
 */
export const AgentStartedStreamingEventRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type AgentStartedStreamingEventRole = ClosedEnum<
  typeof AgentStartedStreamingEventRole
>;

export type AgentStartedStreamingEventParts =
  | TextPart
  | DataPart
  | FilePart
  | ToolCallPart
  | ToolResultPart;

export type InputMessage = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: AgentStartedStreamingEventRole;
  parts: Array<TextPart | DataPart | FilePart | ToolCallPart | ToolResultPart>;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

export type AgentStartedStreamingEventConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type Tools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<AgentStartedStreamingEventConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type ExecuteOn = ClosedEnum<typeof ExecuteOn>;

export type Evaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: ExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const AgentStartedStreamingEventExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type AgentStartedStreamingEventExecuteOn = ClosedEnum<
  typeof AgentStartedStreamingEventExecuteOn
>;

export type Guardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: AgentStartedStreamingEventExecuteOn;
};

export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  tools?: Array<Tools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<Evaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<Guardrails> | undefined;
};

export type AgentStartedStreamingEventData = {
  workflowRunId: string;
  integrationId?: string | undefined;
  inputMessage: InputMessage;
  modelId: string;
  instructions: string;
  systemPrompt: string;
  settings?: Settings | undefined;
  agentManifestId: string;
  agentKey: string;
  variables?: { [k: string]: any } | undefined;
  toolExecutionId?: string | undefined;
  isContinuation?: boolean | undefined;
  stream?: boolean | undefined;
  responseId?: string | undefined;
};

/**
 * Emitted when the agent begins processing. Contains configuration details including the model, instructions, system prompt, and input message.
 */
export type AgentStartedStreamingEvent = {
  type: "event.agents.started";
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: AgentStartedStreamingEventData;
};

/** @internal */
export const AgentStartedStreamingEventRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentStartedStreamingEventRole
> = z.nativeEnum(AgentStartedStreamingEventRole);
/** @internal */
export const AgentStartedStreamingEventRole$outboundSchema: z.ZodNativeEnum<
  typeof AgentStartedStreamingEventRole
> = AgentStartedStreamingEventRole$inboundSchema;

/** @internal */
export const AgentStartedStreamingEventParts$inboundSchema: z.ZodType<
  AgentStartedStreamingEventParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  TextPart$inboundSchema,
  DataPart$inboundSchema,
  FilePart$inboundSchema,
  ToolCallPart$inboundSchema,
  ToolResultPart$inboundSchema,
]);
/** @internal */
export type AgentStartedStreamingEventParts$Outbound =
  | TextPart$Outbound
  | DataPart$Outbound
  | FilePart$Outbound
  | ToolCallPart$Outbound
  | ToolResultPart$Outbound;

/** @internal */
export const AgentStartedStreamingEventParts$outboundSchema: z.ZodType<
  AgentStartedStreamingEventParts$Outbound,
  z.ZodTypeDef,
  AgentStartedStreamingEventParts
> = z.union([
  TextPart$outboundSchema,
  DataPart$outboundSchema,
  FilePart$outboundSchema,
  ToolCallPart$outboundSchema,
  ToolResultPart$outboundSchema,
]);

export function agentStartedStreamingEventPartsToJSON(
  agentStartedStreamingEventParts: AgentStartedStreamingEventParts,
): string {
  return JSON.stringify(
    AgentStartedStreamingEventParts$outboundSchema.parse(
      agentStartedStreamingEventParts,
    ),
  );
}
export function agentStartedStreamingEventPartsFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEventParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventParts' from JSON`,
  );
}

/** @internal */
export const InputMessage$inboundSchema: z.ZodType<
  InputMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: AgentStartedStreamingEventRole$inboundSchema,
  parts: z.array(
    z.union([
      TextPart$inboundSchema,
      DataPart$inboundSchema,
      FilePart$inboundSchema,
      ToolCallPart$inboundSchema,
      ToolResultPart$inboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InputMessage$Outbound = {
  messageId?: string | undefined;
  role: string;
  parts: Array<
    | TextPart$Outbound
    | DataPart$Outbound
    | FilePart$Outbound
    | ToolCallPart$Outbound
    | ToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InputMessage$outboundSchema: z.ZodType<
  InputMessage$Outbound,
  z.ZodTypeDef,
  InputMessage
> = z.object({
  messageId: z.string().optional(),
  role: AgentStartedStreamingEventRole$outboundSchema,
  parts: z.array(
    z.union([
      TextPart$outboundSchema,
      DataPart$outboundSchema,
      FilePart$outboundSchema,
      ToolCallPart$outboundSchema,
      ToolResultPart$outboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function inputMessageToJSON(inputMessage: InputMessage): string {
  return JSON.stringify(InputMessage$outboundSchema.parse(inputMessage));
}
export function inputMessageFromJSON(
  jsonString: string,
): SafeParseResult<InputMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMessage' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);
/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = ToolApprovalRequired$inboundSchema;

/** @internal */
export const AgentStartedStreamingEventConditions$inboundSchema: z.ZodType<
  AgentStartedStreamingEventConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type AgentStartedStreamingEventConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const AgentStartedStreamingEventConditions$outboundSchema: z.ZodType<
  AgentStartedStreamingEventConditions$Outbound,
  z.ZodTypeDef,
  AgentStartedStreamingEventConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function agentStartedStreamingEventConditionsToJSON(
  agentStartedStreamingEventConditions: AgentStartedStreamingEventConditions,
): string {
  return JSON.stringify(
    AgentStartedStreamingEventConditions$outboundSchema.parse(
      agentStartedStreamingEventConditions,
    ),
  );
}
export function agentStartedStreamingEventConditionsFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentStartedStreamingEventConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventConditions' from JSON`,
  );
}

/** @internal */
export const Tools$inboundSchema: z.ZodType<Tools, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    key: z.string().optional(),
    action_type: z.string(),
    display_name: z.string().optional(),
    description: z.string().optional(),
    requires_approval: z.boolean().default(false),
    tool_id: z.string().optional(),
    conditions: z.array(
      z.lazy(() => AgentStartedStreamingEventConditions$inboundSchema),
    ).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "display_name": "displayName",
      "requires_approval": "requiresApproval",
      "tool_id": "toolId",
    });
  });
/** @internal */
export type Tools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<AgentStartedStreamingEventConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const Tools$outboundSchema: z.ZodType<
  Tools$Outbound,
  z.ZodTypeDef,
  Tools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  toolId: z.string().optional(),
  conditions: z.array(
    z.lazy(() => AgentStartedStreamingEventConditions$outboundSchema),
  ).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
    toolId: "tool_id",
  });
});

export function toolsToJSON(tools: Tools): string {
  return JSON.stringify(Tools$outboundSchema.parse(tools));
}
export function toolsFromJSON(
  jsonString: string,
): SafeParseResult<Tools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tools' from JSON`,
  );
}

/** @internal */
export const ExecuteOn$inboundSchema: z.ZodNativeEnum<typeof ExecuteOn> = z
  .nativeEnum(ExecuteOn);
/** @internal */
export const ExecuteOn$outboundSchema: z.ZodNativeEnum<typeof ExecuteOn> =
  ExecuteOn$inboundSchema;

/** @internal */
export const Evaluators$inboundSchema: z.ZodType<
  Evaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type Evaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const Evaluators$outboundSchema: z.ZodType<
  Evaluators$Outbound,
  z.ZodTypeDef,
  Evaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: ExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function evaluatorsToJSON(evaluators: Evaluators): string {
  return JSON.stringify(Evaluators$outboundSchema.parse(evaluators));
}
export function evaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<Evaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Evaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Evaluators' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEventExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof AgentStartedStreamingEventExecuteOn
> = z.nativeEnum(AgentStartedStreamingEventExecuteOn);
/** @internal */
export const AgentStartedStreamingEventExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof AgentStartedStreamingEventExecuteOn> =
    AgentStartedStreamingEventExecuteOn$inboundSchema;

/** @internal */
export const Guardrails$inboundSchema: z.ZodType<
  Guardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: AgentStartedStreamingEventExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type Guardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const Guardrails$outboundSchema: z.ZodType<
  Guardrails$Outbound,
  z.ZodTypeDef,
  Guardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: AgentStartedStreamingEventExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function guardrailsToJSON(guardrails: Guardrails): string {
  return JSON.stringify(Guardrails$outboundSchema.parse(guardrails));
}
export function guardrailsFromJSON(
  jsonString: string,
): SafeParseResult<Guardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Guardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Guardrails' from JSON`,
  );
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => Tools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$inboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type Settings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<Tools$Outbound> | undefined;
  evaluators?: Array<Evaluators$Outbound> | undefined;
  guardrails?: Array<Guardrails$Outbound> | undefined;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => Tools$outboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$outboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}
export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEventData$inboundSchema: z.ZodType<
  AgentStartedStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  workflowRunId: z.string(),
  integration_id: z.string().optional(),
  inputMessage: z.lazy(() => InputMessage$inboundSchema),
  modelId: z.string(),
  instructions: z.string(),
  system_prompt: z.string(),
  settings: z.lazy(() => Settings$inboundSchema).optional(),
  agent_manifest_id: z.string(),
  agent_key: z.string(),
  variables: z.record(z.any()).optional(),
  tool_execution_id: z.string().optional(),
  is_continuation: z.boolean().optional(),
  stream: z.boolean().optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "system_prompt": "systemPrompt",
    "agent_manifest_id": "agentManifestId",
    "agent_key": "agentKey",
    "tool_execution_id": "toolExecutionId",
    "is_continuation": "isContinuation",
  });
});
/** @internal */
export type AgentStartedStreamingEventData$Outbound = {
  workflowRunId: string;
  integration_id?: string | undefined;
  inputMessage: InputMessage$Outbound;
  modelId: string;
  instructions: string;
  system_prompt: string;
  settings?: Settings$Outbound | undefined;
  agent_manifest_id: string;
  agent_key: string;
  variables?: { [k: string]: any } | undefined;
  tool_execution_id?: string | undefined;
  is_continuation?: boolean | undefined;
  stream?: boolean | undefined;
  responseId?: string | undefined;
};

/** @internal */
export const AgentStartedStreamingEventData$outboundSchema: z.ZodType<
  AgentStartedStreamingEventData$Outbound,
  z.ZodTypeDef,
  AgentStartedStreamingEventData
> = z.object({
  workflowRunId: z.string(),
  integrationId: z.string().optional(),
  inputMessage: z.lazy(() => InputMessage$outboundSchema),
  modelId: z.string(),
  instructions: z.string(),
  systemPrompt: z.string(),
  settings: z.lazy(() => Settings$outboundSchema).optional(),
  agentManifestId: z.string(),
  agentKey: z.string(),
  variables: z.record(z.any()).optional(),
  toolExecutionId: z.string().optional(),
  isContinuation: z.boolean().optional(),
  stream: z.boolean().optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    systemPrompt: "system_prompt",
    agentManifestId: "agent_manifest_id",
    agentKey: "agent_key",
    toolExecutionId: "tool_execution_id",
    isContinuation: "is_continuation",
  });
});

export function agentStartedStreamingEventDataToJSON(
  agentStartedStreamingEventData: AgentStartedStreamingEventData,
): string {
  return JSON.stringify(
    AgentStartedStreamingEventData$outboundSchema.parse(
      agentStartedStreamingEventData,
    ),
  );
}
export function agentStartedStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventData' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEvent$inboundSchema: z.ZodType<
  AgentStartedStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("event.agents.started"),
  timestamp: z.string(),
  data: z.lazy(() => AgentStartedStreamingEventData$inboundSchema),
});
/** @internal */
export type AgentStartedStreamingEvent$Outbound = {
  type: "event.agents.started";
  timestamp: string;
  data: AgentStartedStreamingEventData$Outbound;
};

/** @internal */
export const AgentStartedStreamingEvent$outboundSchema: z.ZodType<
  AgentStartedStreamingEvent$Outbound,
  z.ZodTypeDef,
  AgentStartedStreamingEvent
> = z.object({
  type: z.literal("event.agents.started"),
  timestamp: z.string(),
  data: z.lazy(() => AgentStartedStreamingEventData$outboundSchema),
});

export function agentStartedStreamingEventToJSON(
  agentStartedStreamingEvent: AgentStartedStreamingEvent,
): string {
  return JSON.stringify(
    AgentStartedStreamingEvent$outboundSchema.parse(agentStartedStreamingEvent),
  );
}
export function agentStartedStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEvent' from JSON`,
  );
}
