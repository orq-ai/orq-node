/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { DataPart, DataPart$inboundSchema } from "./datapart.js";
import { ErrorPart, ErrorPart$inboundSchema } from "./errorpart.js";
import { FilePart, FilePart$inboundSchema } from "./filepart.js";
import { TextPart, TextPart$inboundSchema } from "./textpart.js";
import { ToolCallPart, ToolCallPart$inboundSchema } from "./toolcallpart.js";
import {
  ToolResultPart,
  ToolResultPart$inboundSchema,
} from "./toolresultpart.js";

/**
 * Extended A2A message role
 */
export const AgentStartedStreamingEventRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type AgentStartedStreamingEventRole = ClosedEnum<
  typeof AgentStartedStreamingEventRole
>;

export type AgentStartedStreamingEventParts =
  | TextPart
  | ErrorPart
  | DataPart
  | FilePart
  | ToolCallPart
  | ToolResultPart;

export type InputMessage = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: AgentStartedStreamingEventRole;
  parts: Array<
    TextPart | ErrorPart | DataPart | FilePart | ToolCallPart | ToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

export type AgentStartedStreamingEventConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type Tools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval: boolean;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<AgentStartedStreamingEventConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout: number;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type ExecuteOn = ClosedEnum<typeof ExecuteOn>;

export type Evaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: ExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const AgentStartedStreamingEventExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type AgentStartedStreamingEventExecuteOn = ClosedEnum<
  typeof AgentStartedStreamingEventExecuteOn
>;

export type Guardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: AgentStartedStreamingEventExecuteOn;
};

export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations: number;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime: number;
  /**
   * Maximum cost in USD for the agent execution. When the accumulated cost exceeds this limit, the agent will stop executing. Set to 0 for unlimited. Only supported in v3 responses
   */
  maxCost: number;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired: ToolApprovalRequired;
  tools?: Array<Tools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<Evaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<Guardrails> | undefined;
};

export type AgentStartedStreamingEventData = {
  workflowRunId: string;
  integrationId?: string | undefined;
  inputMessage: InputMessage;
  modelId: string;
  instructions: string;
  systemPrompt: string;
  settings?: Settings | undefined;
  agentManifestId: string;
  agentKey: string;
  agentDescription?: string | null | undefined;
  variables?: { [k: string]: any } | undefined;
  toolExecutionId?: string | undefined;
  isContinuation?: boolean | undefined;
  stream?: boolean | undefined;
  responseId?: string | undefined;
};

/**
 * Emitted when the agent begins processing. Contains configuration details including the model, instructions, system prompt, and input message.
 */
export type AgentStartedStreamingEvent = {
  type: "event.agents.started";
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: AgentStartedStreamingEventData;
};

/** @internal */
export const AgentStartedStreamingEventRole$inboundSchema: z.ZodNativeEnum<
  typeof AgentStartedStreamingEventRole
> = z.nativeEnum(AgentStartedStreamingEventRole);

/** @internal */
export const AgentStartedStreamingEventParts$inboundSchema: z.ZodType<
  AgentStartedStreamingEventParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  TextPart$inboundSchema,
  ErrorPart$inboundSchema,
  DataPart$inboundSchema,
  FilePart$inboundSchema,
  ToolCallPart$inboundSchema,
  ToolResultPart$inboundSchema,
]);

export function agentStartedStreamingEventPartsFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEventParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventParts' from JSON`,
  );
}

/** @internal */
export const InputMessage$inboundSchema: z.ZodType<
  InputMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: AgentStartedStreamingEventRole$inboundSchema,
  parts: z.array(
    z.union([
      TextPart$inboundSchema,
      ErrorPart$inboundSchema,
      DataPart$inboundSchema,
      FilePart$inboundSchema,
      ToolCallPart$inboundSchema,
      ToolResultPart$inboundSchema,
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function inputMessageFromJSON(
  jsonString: string,
): SafeParseResult<InputMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMessage' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);

/** @internal */
export const AgentStartedStreamingEventConditions$inboundSchema: z.ZodType<
  AgentStartedStreamingEventConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function agentStartedStreamingEventConditionsFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentStartedStreamingEventConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventConditions' from JSON`,
  );
}

/** @internal */
export const Tools$inboundSchema: z.ZodType<Tools, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    key: z.string().optional(),
    action_type: z.string(),
    display_name: z.string().optional(),
    description: z.string().optional(),
    requires_approval: z.boolean().default(false),
    tool_id: z.string().optional(),
    conditions: z.array(
      z.lazy(() => AgentStartedStreamingEventConditions$inboundSchema),
    ).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "display_name": "displayName",
      "requires_approval": "requiresApproval",
      "tool_id": "toolId",
    });
  });

export function toolsFromJSON(
  jsonString: string,
): SafeParseResult<Tools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tools' from JSON`,
  );
}

/** @internal */
export const ExecuteOn$inboundSchema: z.ZodNativeEnum<typeof ExecuteOn> = z
  .nativeEnum(ExecuteOn);

/** @internal */
export const Evaluators$inboundSchema: z.ZodType<
  Evaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function evaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<Evaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Evaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Evaluators' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEventExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof AgentStartedStreamingEventExecuteOn
> = z.nativeEnum(AgentStartedStreamingEventExecuteOn);

/** @internal */
export const Guardrails$inboundSchema: z.ZodType<
  Guardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: AgentStartedStreamingEventExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function guardrailsFromJSON(
  jsonString: string,
): SafeParseResult<Guardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Guardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Guardrails' from JSON`,
  );
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  max_cost: z.number().default(0),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => Tools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$inboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "max_cost": "maxCost",
    "tool_approval_required": "toolApprovalRequired",
  });
});

export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEventData$inboundSchema: z.ZodType<
  AgentStartedStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  workflowRunId: z.string(),
  integration_id: z.string().optional(),
  inputMessage: z.lazy(() => InputMessage$inboundSchema),
  modelId: z.string(),
  instructions: z.string(),
  system_prompt: z.string(),
  settings: z.lazy(() => Settings$inboundSchema).optional(),
  agent_manifest_id: z.string(),
  agent_key: z.string(),
  agent_description: z.nullable(z.string()).optional(),
  variables: z.record(z.any()).optional(),
  tool_execution_id: z.string().optional(),
  is_continuation: z.boolean().optional(),
  stream: z.boolean().optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "system_prompt": "systemPrompt",
    "agent_manifest_id": "agentManifestId",
    "agent_key": "agentKey",
    "agent_description": "agentDescription",
    "tool_execution_id": "toolExecutionId",
    "is_continuation": "isContinuation",
  });
});

export function agentStartedStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEventData' from JSON`,
  );
}

/** @internal */
export const AgentStartedStreamingEvent$inboundSchema: z.ZodType<
  AgentStartedStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("event.agents.started"),
  timestamp: z.string(),
  data: z.lazy(() => AgentStartedStreamingEventData$inboundSchema),
});

export function agentStartedStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<AgentStartedStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentStartedStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentStartedStreamingEvent' from JSON`,
  );
}
