/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const FilePartKind = {
  File: "file",
} as const;
export type FilePartKind = ClosedEnum<typeof FilePartKind>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type FileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type BinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type FileT = BinaryFormat | FileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type FilePart = {
  kind: FilePartKind;
  file: BinaryFormat | FileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const FilePartKind$inboundSchema: z.ZodNativeEnum<typeof FilePartKind> =
  z.nativeEnum(FilePartKind);
/** @internal */
export const FilePartKind$outboundSchema: z.ZodNativeEnum<typeof FilePartKind> =
  FilePartKind$inboundSchema;

/** @internal */
export const FileInURIFormat$inboundSchema: z.ZodType<
  FileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileInURIFormat$outboundSchema: z.ZodType<
  FileInURIFormat$Outbound,
  z.ZodTypeDef,
  FileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileInURIFormatToJSON(
  fileInURIFormat: FileInURIFormat,
): string {
  return JSON.stringify(FileInURIFormat$outboundSchema.parse(fileInURIFormat));
}
export function fileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileInURIFormat' from JSON`,
  );
}

/** @internal */
export const BinaryFormat$inboundSchema: z.ZodType<
  BinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type BinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const BinaryFormat$outboundSchema: z.ZodType<
  BinaryFormat$Outbound,
  z.ZodTypeDef,
  BinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function binaryFormatToJSON(binaryFormat: BinaryFormat): string {
  return JSON.stringify(BinaryFormat$outboundSchema.parse(binaryFormat));
}
export function binaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<BinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BinaryFormat' from JSON`,
  );
}

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => BinaryFormat$inboundSchema),
    z.lazy(() => FileInURIFormat$inboundSchema),
  ]);
/** @internal */
export type FileT$Outbound = BinaryFormat$Outbound | FileInURIFormat$Outbound;

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.union([
  z.lazy(() => BinaryFormat$outboundSchema),
  z.lazy(() => FileInURIFormat$outboundSchema),
]);

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}
export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const FilePart$inboundSchema: z.ZodType<
  FilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: FilePartKind$inboundSchema,
  file: z.union([
    z.lazy(() => BinaryFormat$inboundSchema),
    z.lazy(() => FileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type FilePart$Outbound = {
  kind: string;
  file: BinaryFormat$Outbound | FileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const FilePart$outboundSchema: z.ZodType<
  FilePart$Outbound,
  z.ZodTypeDef,
  FilePart
> = z.object({
  kind: FilePartKind$outboundSchema,
  file: z.union([
    z.lazy(() => BinaryFormat$outboundSchema),
    z.lazy(() => FileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function filePartToJSON(filePart: FilePart): string {
  return JSON.stringify(FilePart$outboundSchema.parse(filePart));
}
export function filePartFromJSON(
  jsonString: string,
): SafeParseResult<FilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilePart' from JSON`,
  );
}
