/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DeploymentInvokeGlobals = {
  environment?: string | undefined;
  contactId?: string | undefined;
};

/**
 * Indicates the type of model used to generate the response
 */
export const DeploymentInvokeObject = {
  Chat: "chat",
  Completion: "completion",
  Image: "image",
} as const;
/**
 * Indicates the type of model used to generate the response
 */
export type DeploymentInvokeObject = ClosedEnum<typeof DeploymentInvokeObject>;

/**
 * The provider used to generate the response
 */
export const Provider = {
  Openai: "openai",
  Groq: "groq",
  Cohere: "cohere",
  Azure: "azure",
  Aws: "aws",
  Google: "google",
  GoogleAi: "google-ai",
  Huggingface: "huggingface",
  Togetherai: "togetherai",
  Perplexity: "perplexity",
  Anthropic: "anthropic",
  Leonardoai: "leonardoai",
  Fal: "fal",
  Nvidia: "nvidia",
  Jina: "jina",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Cerebras: "cerebras",
  Openailike: "openailike",
  Bytedance: "bytedance",
  Mistral: "mistral",
  Deepseek: "deepseek",
  Contextualai: "contextualai",
  Moonshotai: "moonshotai",
  Zai: "zai",
  Slack: "slack",
} as const;
/**
 * The provider used to generate the response
 */
export type Provider = ClosedEnum<typeof Provider>;

/**
 * Metadata of the retrieved chunk from the knowledge base
 */
export type DeploymentInvokeMetadata = {
  /**
   * Name of the file
   */
  fileName: string;
  /**
   * Page number of the chunk
   */
  pageNumber: number | null;
  /**
   * Type of the file
   */
  fileType: string;
  /**
   * Rerank scores are normalized to be in the range [0, 1]. Scores close to 1 indicate a high relevance to the query, and scores closer to 0 indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
   */
  rerankScore?: number | undefined;
  /**
   * Search scores are normalized to be in the range [0, 1]. Search score is calculated based on `[Cosine Similarity](https://en.wikipedia.org/wiki/Cosine_similarity)` algorithm. Scores close to 1 indicate the document is closer to the query, and scores closer to 0 indicate the document is farther from the query.
   */
  searchScore: number;
};

export type Retrievals = {
  /**
   * Content of the retrieved chunk from the knowledge base
   */
  document: string;
  /**
   * Metadata of the retrieved chunk from the knowledge base
   */
  metadata: DeploymentInvokeMetadata;
};

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
};

/**
 * Usage metrics for the response
 */
export type DeploymentInvokeUsage = {
  totalTokens?: number | undefined;
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

/**
 * The role of the prompt message
 */
export const DeploymentInvokeMessageDeploymentsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentInvokeMessageDeploymentsRole = ClosedEnum<
  typeof DeploymentInvokeMessageDeploymentsRole
>;

export type Message3 = {
  type: "image";
  /**
   * The role of the prompt message
   */
  role: DeploymentInvokeMessageDeploymentsRole;
  url: string;
};

/**
 * The role of the prompt message
 */
export const DeploymentInvokeMessageRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentInvokeMessageRole = ClosedEnum<
  typeof DeploymentInvokeMessageRole
>;

export type Message2 = {
  type: "content";
  /**
   * The role of the prompt message
   */
  role: DeploymentInvokeMessageRole;
  content: string | null;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the prompt message
 */
export const MessageRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type MessageRole = ClosedEnum<typeof MessageRole>;

export const DeploymentInvokeMessageDeploymentsResponseType = {
  Function: "function",
} as const;
export type DeploymentInvokeMessageDeploymentsResponseType = ClosedEnum<
  typeof DeploymentInvokeMessageDeploymentsResponseType
>;

export type MessageFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type MessageToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentInvokeMessageDeploymentsResponseType;
  function: MessageFunction;
};

export type Message1 = {
  type: "tool_calls";
  /**
   * The role of the prompt message
   */
  role: MessageRole;
  content?: string | null | undefined;
  toolCalls: Array<MessageToolCalls>;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

export type Message = Message1 | Message2 | Message3;

export type DeploymentInvokeChoices = {
  index: number;
  message: Message1 | Message2 | Message3;
  finishReason?: string | null | undefined;
};

/**
 * Successful operation
 */
export type DeploymentInvokeResponseBody = {
  /**
   * A unique identifier for the response. Can be used to add metrics to the transaction.
   */
  id: string;
  /**
   * A timestamp indicating when the object was created. Usually in a standardized format like ISO 8601
   */
  created: Date;
  /**
   * Indicates the type of model used to generate the response
   */
  object: DeploymentInvokeObject;
  /**
   * The model used to generate the response
   */
  model: string;
  /**
   * The provider used to generate the response
   */
  provider: Provider;
  /**
   * Indicates if the response is the final response
   */
  isFinal: boolean;
  /**
   * Indicates integration id used to generate the response
   */
  integrationId?: string | undefined;
  /**
   * A timestamp indicating when the object was finalized. Usually in a standardized format like ISO 8601
   */
  finalized?: Date | undefined;
  /**
   * Provider backed system fingerprint.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * List of documents retrieved from the knowledge base. This property is only available when the `include_retrievals` flag is set to `true` in the invoke settings. When stream is set to true, the `retrievals` property will be returned in the last streamed chunk where the property `is_final` is set to `true`.
   */
  retrievals?: Array<Retrievals> | undefined;
  /**
   * Response returned by the model provider. This functionality is only supported when streaming is not used. If streaming is used, the `provider_response` property will be set to `null`.
   */
  providerResponse?: any | undefined;
  /**
   * Usage metrics for the response
   */
  usage?: DeploymentInvokeUsage | null | undefined;
  /**
   * A list of choices generated by the model
   */
  choices: Array<DeploymentInvokeChoices>;
};

/** @internal */
export const DeploymentInvokeObject$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeObject
> = z.nativeEnum(DeploymentInvokeObject);

/** @internal */
export const Provider$inboundSchema: z.ZodNativeEnum<typeof Provider> = z
  .nativeEnum(Provider);

/** @internal */
export const DeploymentInvokeMetadata$inboundSchema: z.ZodType<
  DeploymentInvokeMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string(),
  page_number: z.nullable(z.number()),
  file_type: z.string(),
  rerank_score: z.number().optional(),
  search_score: z.number(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "page_number": "pageNumber",
    "file_type": "fileType",
    "rerank_score": "rerankScore",
    "search_score": "searchScore",
  });
});

export function deploymentInvokeMetadataFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeMetadata' from JSON`,
  );
}

/** @internal */
export const Retrievals$inboundSchema: z.ZodType<
  Retrievals,
  z.ZodTypeDef,
  unknown
> = z.object({
  document: z.string(),
  metadata: z.lazy(() => DeploymentInvokeMetadata$inboundSchema),
});

export function retrievalsFromJSON(
  jsonString: string,
): SafeParseResult<Retrievals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Retrievals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Retrievals' from JSON`,
  );
}

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
  });
});

export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
  });
});

export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeUsage$inboundSchema: z.ZodType<
  DeploymentInvokeUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  completion_tokens: z.number().optional(),
  prompt_tokens_details: z.lazy(() => PromptTokensDetails$inboundSchema)
    .optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "total_tokens": "totalTokens",
    "prompt_tokens": "promptTokens",
    "completion_tokens": "completionTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});

export function deploymentInvokeUsageFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeUsage' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeMessageDeploymentsRole$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsRole> = z.nativeEnum(
    DeploymentInvokeMessageDeploymentsRole,
  );

/** @internal */
export const Message3$inboundSchema: z.ZodType<
  Message3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image"),
  role: DeploymentInvokeMessageDeploymentsRole$inboundSchema,
  url: z.string(),
});

export function message3FromJSON(
  jsonString: string,
): SafeParseResult<Message3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message3' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeMessageRole
> = z.nativeEnum(DeploymentInvokeMessageRole);

/** @internal */
export const Message2$inboundSchema: z.ZodType<
  Message2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("content"),
  role: DeploymentInvokeMessageRole$inboundSchema,
  content: z.nullable(z.string()),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});

export function message2FromJSON(
  jsonString: string,
): SafeParseResult<Message2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message2' from JSON`,
  );
}

/** @internal */
export const MessageRole$inboundSchema: z.ZodNativeEnum<typeof MessageRole> = z
  .nativeEnum(MessageRole);

/** @internal */
export const DeploymentInvokeMessageDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsResponseType> = z
    .nativeEnum(DeploymentInvokeMessageDeploymentsResponseType);

/** @internal */
export const MessageFunction$inboundSchema: z.ZodType<
  MessageFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function messageFunctionFromJSON(
  jsonString: string,
): SafeParseResult<MessageFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageFunction' from JSON`,
  );
}

/** @internal */
export const MessageToolCalls$inboundSchema: z.ZodType<
  MessageToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentInvokeMessageDeploymentsResponseType$inboundSchema,
  function: z.lazy(() => MessageFunction$inboundSchema),
});

export function messageToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<MessageToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageToolCalls' from JSON`,
  );
}

/** @internal */
export const Message1$inboundSchema: z.ZodType<
  Message1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("tool_calls"),
  role: MessageRole$inboundSchema,
  content: z.nullable(z.string()).optional(),
  tool_calls: z.array(z.lazy(() => MessageToolCalls$inboundSchema)),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});

export function message1FromJSON(
  jsonString: string,
): SafeParseResult<Message1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message1' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => Message1$inboundSchema),
    z.lazy(() => Message2$inboundSchema),
    z.lazy(() => Message3$inboundSchema),
  ]);

export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeChoices$inboundSchema: z.ZodType<
  DeploymentInvokeChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number(),
  message: z.union([
    z.lazy(() => Message1$inboundSchema),
    z.lazy(() => Message2$inboundSchema),
    z.lazy(() => Message3$inboundSchema),
  ]),
  finish_reason: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});

export function deploymentInvokeChoicesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeChoices' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeResponseBody$inboundSchema: z.ZodType<
  DeploymentInvokeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  object: DeploymentInvokeObject$inboundSchema,
  model: z.string(),
  provider: Provider$inboundSchema,
  is_final: z.boolean(),
  integration_id: z.string().optional(),
  finalized: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  system_fingerprint: z.nullable(z.string()).optional(),
  retrievals: z.array(z.lazy(() => Retrievals$inboundSchema)).optional(),
  provider_response: z.any().optional(),
  usage: z.nullable(z.lazy(() => DeploymentInvokeUsage$inboundSchema))
    .optional(),
  choices: z.array(z.lazy(() => DeploymentInvokeChoices$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "is_final": "isFinal",
    "integration_id": "integrationId",
    "system_fingerprint": "systemFingerprint",
    "provider_response": "providerResponse",
  });
});

export function deploymentInvokeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeResponseBody' from JSON`,
  );
}
