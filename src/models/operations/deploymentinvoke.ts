/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DeploymentInvokeGlobals = {
  environment?: string | undefined;
  contactId?: string | undefined;
};

/**
 * Indicates the type of model used to generate the response
 */
export const DeploymentInvokeObject = {
  Chat: "chat",
  Completion: "completion",
  Image: "image",
} as const;
/**
 * Indicates the type of model used to generate the response
 */
export type DeploymentInvokeObject = ClosedEnum<typeof DeploymentInvokeObject>;

/**
 * The provider used to generate the response
 */
export const DeploymentInvokeProvider = {
  Cohere: "cohere",
  Openai: "openai",
  Anthropic: "anthropic",
  Huggingface: "huggingface",
  Replicate: "replicate",
  Google: "google",
  GoogleAi: "google-ai",
  Azure: "azure",
  Aws: "aws",
  Anyscale: "anyscale",
  Perplexity: "perplexity",
  Groq: "groq",
  Fal: "fal",
  Leonardoai: "leonardoai",
  Nvidia: "nvidia",
  Jina: "jina",
  Togetherai: "togetherai",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Openailike: "openailike",
  Cerebras: "cerebras",
  Bytedance: "bytedance",
  Mistral: "mistral",
} as const;
/**
 * The provider used to generate the response
 */
export type DeploymentInvokeProvider = ClosedEnum<
  typeof DeploymentInvokeProvider
>;

/**
 * Metadata of the retrieved chunk from the knowledge base
 */
export type DeploymentInvokeMetadata = {
  /**
   * Name of the file
   */
  fileName: string;
  /**
   * Page number of the chunk
   */
  pageNumber: number | null;
  /**
   * Type of the file
   */
  fileType: string;
  /**
   * Rerank scores are normalized to be in the range [0, 1]. Scores close to 1 indicate a high relevance to the query, and scores closer to 0 indicate low relevance. It is not accurate to assume a score of 0.9 means the document is 2x more relevant than a document with a score of 0.45
   */
  rerankScore?: number | undefined;
  /**
   * Search scores are normalized to be in the range [0, 1]. Search score is calculated based on `[Cosine Similarity](https://en.wikipedia.org/wiki/Cosine_similarity)` algorithm. Scores close to 1 indicate the document is closer to the query, and scores closer to 0 indicate the document is farther from the query.
   */
  searchScore: number;
};

export type Retrievals = {
  /**
   * Content of the retrieved chunk from the knowledge base
   */
  document: string;
  /**
   * Metadata of the retrieved chunk from the knowledge base
   */
  metadata: DeploymentInvokeMetadata;
};

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
};

/**
 * Usage metrics for the response
 */
export type DeploymentInvokeUsage = {
  totalTokens?: number | undefined;
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

/**
 * The role of the prompt message
 */
export const DeploymentInvokeMessageDeploymentsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentInvokeMessageDeploymentsRole = ClosedEnum<
  typeof DeploymentInvokeMessageDeploymentsRole
>;

export type Message3 = {
  type: "image";
  /**
   * The role of the prompt message
   */
  role: DeploymentInvokeMessageDeploymentsRole;
  url: string;
};

/**
 * The role of the prompt message
 */
export const DeploymentInvokeMessageRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentInvokeMessageRole = ClosedEnum<
  typeof DeploymentInvokeMessageRole
>;

export type Message2 = {
  type: "content";
  /**
   * The role of the prompt message
   */
  role: DeploymentInvokeMessageRole;
  content: string | null;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the prompt message
 */
export const MessageRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type MessageRole = ClosedEnum<typeof MessageRole>;

export const DeploymentInvokeMessageDeploymentsResponseType = {
  Function: "function",
} as const;
export type DeploymentInvokeMessageDeploymentsResponseType = ClosedEnum<
  typeof DeploymentInvokeMessageDeploymentsResponseType
>;

export type MessageFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type MessageToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentInvokeMessageDeploymentsResponseType;
  function: MessageFunction;
};

export type Message1 = {
  type: "tool_calls";
  /**
   * The role of the prompt message
   */
  role: MessageRole;
  content?: string | null | undefined;
  toolCalls: Array<MessageToolCalls>;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

export type Message = Message1 | Message2 | Message3;

export type DeploymentInvokeChoices = {
  index: number;
  message: Message1 | Message2 | Message3;
  finishReason?: string | null | undefined;
};

/**
 * Successful operation
 */
export type DeploymentInvokeResponseBody = {
  /**
   * A unique identifier for the response. Can be used to add metrics to the transaction.
   */
  id: string;
  /**
   * A timestamp indicating when the object was created. Usually in a standardized format like ISO 8601
   */
  created: Date;
  /**
   * Indicates the type of model used to generate the response
   */
  object: DeploymentInvokeObject;
  /**
   * The model used to generate the response
   */
  model: string;
  /**
   * The provider used to generate the response
   */
  provider: DeploymentInvokeProvider;
  /**
   * Indicates if the response is the final response
   */
  isFinal: boolean;
  /**
   * Indicates integration id used to generate the response
   */
  integrationId?: string | undefined;
  /**
   * A timestamp indicating when the object was finalized. Usually in a standardized format like ISO 8601
   */
  finalized?: Date | undefined;
  /**
   * Provider backed system fingerprint.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * List of documents retrieved from the knowledge base. This property is only available when the `include_retrievals` flag is set to `true` in the invoke settings. When stream is set to true, the `retrievals` property will be returned in the last streamed chunk where the property `is_final` is set to `true`.
   */
  retrievals?: Array<Retrievals> | undefined;
  /**
   * Response returned by the model provider. This functionality is only supported when streaming is not used. If streaming is used, the `provider_response` property will be set to `null`.
   */
  providerResponse?: any | undefined;
  /**
   * Usage metrics for the response
   */
  usage?: DeploymentInvokeUsage | null | undefined;
  /**
   * A list of choices generated by the model
   */
  choices: Array<DeploymentInvokeChoices>;
};

/** @internal */
export const DeploymentInvokeGlobals$inboundSchema: z.ZodType<
  DeploymentInvokeGlobals,
  z.ZodTypeDef,
  unknown
> = z.object({
  environment: z.string().optional(),
  contactId: z.string().optional(),
});
/** @internal */
export type DeploymentInvokeGlobals$Outbound = {
  environment?: string | undefined;
  contactId?: string | undefined;
};

/** @internal */
export const DeploymentInvokeGlobals$outboundSchema: z.ZodType<
  DeploymentInvokeGlobals$Outbound,
  z.ZodTypeDef,
  DeploymentInvokeGlobals
> = z.object({
  environment: z.string().optional(),
  contactId: z.string().optional(),
});

export function deploymentInvokeGlobalsToJSON(
  deploymentInvokeGlobals: DeploymentInvokeGlobals,
): string {
  return JSON.stringify(
    DeploymentInvokeGlobals$outboundSchema.parse(deploymentInvokeGlobals),
  );
}
export function deploymentInvokeGlobalsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeGlobals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeGlobals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeGlobals' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeObject$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeObject
> = z.nativeEnum(DeploymentInvokeObject);
/** @internal */
export const DeploymentInvokeObject$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeObject
> = DeploymentInvokeObject$inboundSchema;

/** @internal */
export const DeploymentInvokeProvider$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeProvider
> = z.nativeEnum(DeploymentInvokeProvider);
/** @internal */
export const DeploymentInvokeProvider$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeProvider
> = DeploymentInvokeProvider$inboundSchema;

/** @internal */
export const DeploymentInvokeMetadata$inboundSchema: z.ZodType<
  DeploymentInvokeMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string(),
  page_number: z.nullable(z.number()),
  file_type: z.string(),
  rerank_score: z.number().optional(),
  search_score: z.number(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "page_number": "pageNumber",
    "file_type": "fileType",
    "rerank_score": "rerankScore",
    "search_score": "searchScore",
  });
});
/** @internal */
export type DeploymentInvokeMetadata$Outbound = {
  file_name: string;
  page_number: number | null;
  file_type: string;
  rerank_score?: number | undefined;
  search_score: number;
};

/** @internal */
export const DeploymentInvokeMetadata$outboundSchema: z.ZodType<
  DeploymentInvokeMetadata$Outbound,
  z.ZodTypeDef,
  DeploymentInvokeMetadata
> = z.object({
  fileName: z.string(),
  pageNumber: z.nullable(z.number()),
  fileType: z.string(),
  rerankScore: z.number().optional(),
  searchScore: z.number(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    pageNumber: "page_number",
    fileType: "file_type",
    rerankScore: "rerank_score",
    searchScore: "search_score",
  });
});

export function deploymentInvokeMetadataToJSON(
  deploymentInvokeMetadata: DeploymentInvokeMetadata,
): string {
  return JSON.stringify(
    DeploymentInvokeMetadata$outboundSchema.parse(deploymentInvokeMetadata),
  );
}
export function deploymentInvokeMetadataFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeMetadata' from JSON`,
  );
}

/** @internal */
export const Retrievals$inboundSchema: z.ZodType<
  Retrievals,
  z.ZodTypeDef,
  unknown
> = z.object({
  document: z.string(),
  metadata: z.lazy(() => DeploymentInvokeMetadata$inboundSchema),
});
/** @internal */
export type Retrievals$Outbound = {
  document: string;
  metadata: DeploymentInvokeMetadata$Outbound;
};

/** @internal */
export const Retrievals$outboundSchema: z.ZodType<
  Retrievals$Outbound,
  z.ZodTypeDef,
  Retrievals
> = z.object({
  document: z.string(),
  metadata: z.lazy(() => DeploymentInvokeMetadata$outboundSchema),
});

export function retrievalsToJSON(retrievals: Retrievals): string {
  return JSON.stringify(Retrievals$outboundSchema.parse(retrievals));
}
export function retrievalsFromJSON(
  jsonString: string,
): SafeParseResult<Retrievals, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Retrievals$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Retrievals' from JSON`,
  );
}

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
  });
});
/** @internal */
export type PromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
};

/** @internal */
export const PromptTokensDetails$outboundSchema: z.ZodType<
  PromptTokensDetails$Outbound,
  z.ZodTypeDef,
  PromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
  });
});

export function promptTokensDetailsToJSON(
  promptTokensDetails: PromptTokensDetails,
): string {
  return JSON.stringify(
    PromptTokensDetails$outboundSchema.parse(promptTokensDetails),
  );
}
export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
  });
});
/** @internal */
export type CompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
};

/** @internal */
export const CompletionTokensDetails$outboundSchema: z.ZodType<
  CompletionTokensDetails$Outbound,
  z.ZodTypeDef,
  CompletionTokensDetails
> = z.object({
  reasoningTokens: z.nullable(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningTokens: "reasoning_tokens",
  });
});

export function completionTokensDetailsToJSON(
  completionTokensDetails: CompletionTokensDetails,
): string {
  return JSON.stringify(
    CompletionTokensDetails$outboundSchema.parse(completionTokensDetails),
  );
}
export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeUsage$inboundSchema: z.ZodType<
  DeploymentInvokeUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  completion_tokens: z.number().optional(),
  prompt_tokens_details: z.lazy(() => PromptTokensDetails$inboundSchema)
    .optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "total_tokens": "totalTokens",
    "prompt_tokens": "promptTokens",
    "completion_tokens": "completionTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type DeploymentInvokeUsage$Outbound = {
  total_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  completion_tokens?: number | undefined;
  prompt_tokens_details?: PromptTokensDetails$Outbound | undefined;
  completion_tokens_details?:
    | CompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const DeploymentInvokeUsage$outboundSchema: z.ZodType<
  DeploymentInvokeUsage$Outbound,
  z.ZodTypeDef,
  DeploymentInvokeUsage
> = z.object({
  totalTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  completionTokens: z.number().optional(),
  promptTokensDetails: z.lazy(() => PromptTokensDetails$outboundSchema)
    .optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => CompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    totalTokens: "total_tokens",
    promptTokens: "prompt_tokens",
    completionTokens: "completion_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function deploymentInvokeUsageToJSON(
  deploymentInvokeUsage: DeploymentInvokeUsage,
): string {
  return JSON.stringify(
    DeploymentInvokeUsage$outboundSchema.parse(deploymentInvokeUsage),
  );
}
export function deploymentInvokeUsageFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeUsage' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeMessageDeploymentsRole$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsRole> = z.nativeEnum(
    DeploymentInvokeMessageDeploymentsRole,
  );
/** @internal */
export const DeploymentInvokeMessageDeploymentsRole$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsRole> =
    DeploymentInvokeMessageDeploymentsRole$inboundSchema;

/** @internal */
export const Message3$inboundSchema: z.ZodType<
  Message3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image"),
  role: DeploymentInvokeMessageDeploymentsRole$inboundSchema,
  url: z.string(),
});
/** @internal */
export type Message3$Outbound = {
  type: "image";
  role: string;
  url: string;
};

/** @internal */
export const Message3$outboundSchema: z.ZodType<
  Message3$Outbound,
  z.ZodTypeDef,
  Message3
> = z.object({
  type: z.literal("image"),
  role: DeploymentInvokeMessageDeploymentsRole$outboundSchema,
  url: z.string(),
});

export function message3ToJSON(message3: Message3): string {
  return JSON.stringify(Message3$outboundSchema.parse(message3));
}
export function message3FromJSON(
  jsonString: string,
): SafeParseResult<Message3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message3' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeMessageRole
> = z.nativeEnum(DeploymentInvokeMessageRole);
/** @internal */
export const DeploymentInvokeMessageRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentInvokeMessageRole
> = DeploymentInvokeMessageRole$inboundSchema;

/** @internal */
export const Message2$inboundSchema: z.ZodType<
  Message2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("content"),
  role: DeploymentInvokeMessageRole$inboundSchema,
  content: z.nullable(z.string()),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type Message2$Outbound = {
  type: "content";
  role: string;
  content: string | null;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const Message2$outboundSchema: z.ZodType<
  Message2$Outbound,
  z.ZodTypeDef,
  Message2
> = z.object({
  type: z.literal("content"),
  role: DeploymentInvokeMessageRole$outboundSchema,
  content: z.nullable(z.string()),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function message2ToJSON(message2: Message2): string {
  return JSON.stringify(Message2$outboundSchema.parse(message2));
}
export function message2FromJSON(
  jsonString: string,
): SafeParseResult<Message2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message2' from JSON`,
  );
}

/** @internal */
export const MessageRole$inboundSchema: z.ZodNativeEnum<typeof MessageRole> = z
  .nativeEnum(MessageRole);
/** @internal */
export const MessageRole$outboundSchema: z.ZodNativeEnum<typeof MessageRole> =
  MessageRole$inboundSchema;

/** @internal */
export const DeploymentInvokeMessageDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsResponseType> = z
    .nativeEnum(DeploymentInvokeMessageDeploymentsResponseType);
/** @internal */
export const DeploymentInvokeMessageDeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentInvokeMessageDeploymentsResponseType> =
    DeploymentInvokeMessageDeploymentsResponseType$inboundSchema;

/** @internal */
export const MessageFunction$inboundSchema: z.ZodType<
  MessageFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});
/** @internal */
export type MessageFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const MessageFunction$outboundSchema: z.ZodType<
  MessageFunction$Outbound,
  z.ZodTypeDef,
  MessageFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function messageFunctionToJSON(
  messageFunction: MessageFunction,
): string {
  return JSON.stringify(MessageFunction$outboundSchema.parse(messageFunction));
}
export function messageFunctionFromJSON(
  jsonString: string,
): SafeParseResult<MessageFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageFunction' from JSON`,
  );
}

/** @internal */
export const MessageToolCalls$inboundSchema: z.ZodType<
  MessageToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentInvokeMessageDeploymentsResponseType$inboundSchema,
  function: z.lazy(() => MessageFunction$inboundSchema),
});
/** @internal */
export type MessageToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: MessageFunction$Outbound;
};

/** @internal */
export const MessageToolCalls$outboundSchema: z.ZodType<
  MessageToolCalls$Outbound,
  z.ZodTypeDef,
  MessageToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentInvokeMessageDeploymentsResponseType$outboundSchema,
  function: z.lazy(() => MessageFunction$outboundSchema),
});

export function messageToolCallsToJSON(
  messageToolCalls: MessageToolCalls,
): string {
  return JSON.stringify(
    MessageToolCalls$outboundSchema.parse(messageToolCalls),
  );
}
export function messageToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<MessageToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageToolCalls' from JSON`,
  );
}

/** @internal */
export const Message1$inboundSchema: z.ZodType<
  Message1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("tool_calls"),
  role: MessageRole$inboundSchema,
  content: z.nullable(z.string()).optional(),
  tool_calls: z.array(z.lazy(() => MessageToolCalls$inboundSchema)),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type Message1$Outbound = {
  type: "tool_calls";
  role: string;
  content?: string | null | undefined;
  tool_calls: Array<MessageToolCalls$Outbound>;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const Message1$outboundSchema: z.ZodType<
  Message1$Outbound,
  z.ZodTypeDef,
  Message1
> = z.object({
  type: z.literal("tool_calls"),
  role: MessageRole$outboundSchema,
  content: z.nullable(z.string()).optional(),
  toolCalls: z.array(z.lazy(() => MessageToolCalls$outboundSchema)),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function message1ToJSON(message1: Message1): string {
  return JSON.stringify(Message1$outboundSchema.parse(message1));
}
export function message1FromJSON(
  jsonString: string,
): SafeParseResult<Message1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message1' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => Message1$inboundSchema),
    z.lazy(() => Message2$inboundSchema),
    z.lazy(() => Message3$inboundSchema),
  ]);
/** @internal */
export type Message$Outbound =
  | Message1$Outbound
  | Message2$Outbound
  | Message3$Outbound;

/** @internal */
export const Message$outboundSchema: z.ZodType<
  Message$Outbound,
  z.ZodTypeDef,
  Message
> = z.union([
  z.lazy(() => Message1$outboundSchema),
  z.lazy(() => Message2$outboundSchema),
  z.lazy(() => Message3$outboundSchema),
]);

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}
export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeChoices$inboundSchema: z.ZodType<
  DeploymentInvokeChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number(),
  message: z.union([
    z.lazy(() => Message1$inboundSchema),
    z.lazy(() => Message2$inboundSchema),
    z.lazy(() => Message3$inboundSchema),
  ]),
  finish_reason: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});
/** @internal */
export type DeploymentInvokeChoices$Outbound = {
  index: number;
  message: Message1$Outbound | Message2$Outbound | Message3$Outbound;
  finish_reason?: string | null | undefined;
};

/** @internal */
export const DeploymentInvokeChoices$outboundSchema: z.ZodType<
  DeploymentInvokeChoices$Outbound,
  z.ZodTypeDef,
  DeploymentInvokeChoices
> = z.object({
  index: z.number(),
  message: z.union([
    z.lazy(() => Message1$outboundSchema),
    z.lazy(() => Message2$outboundSchema),
    z.lazy(() => Message3$outboundSchema),
  ]),
  finishReason: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

export function deploymentInvokeChoicesToJSON(
  deploymentInvokeChoices: DeploymentInvokeChoices,
): string {
  return JSON.stringify(
    DeploymentInvokeChoices$outboundSchema.parse(deploymentInvokeChoices),
  );
}
export function deploymentInvokeChoicesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeChoices' from JSON`,
  );
}

/** @internal */
export const DeploymentInvokeResponseBody$inboundSchema: z.ZodType<
  DeploymentInvokeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  created: z.string().datetime({ offset: true }).transform(v => new Date(v)),
  object: DeploymentInvokeObject$inboundSchema,
  model: z.string(),
  provider: DeploymentInvokeProvider$inboundSchema,
  is_final: z.boolean(),
  integration_id: z.string().optional(),
  finalized: z.string().datetime({ offset: true }).transform(v => new Date(v))
    .optional(),
  system_fingerprint: z.nullable(z.string()).optional(),
  retrievals: z.array(z.lazy(() => Retrievals$inboundSchema)).optional(),
  provider_response: z.any().optional(),
  usage: z.nullable(z.lazy(() => DeploymentInvokeUsage$inboundSchema))
    .optional(),
  choices: z.array(z.lazy(() => DeploymentInvokeChoices$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "is_final": "isFinal",
    "integration_id": "integrationId",
    "system_fingerprint": "systemFingerprint",
    "provider_response": "providerResponse",
  });
});
/** @internal */
export type DeploymentInvokeResponseBody$Outbound = {
  id: string;
  created: string;
  object: string;
  model: string;
  provider: string;
  is_final: boolean;
  integration_id?: string | undefined;
  finalized?: string | undefined;
  system_fingerprint?: string | null | undefined;
  retrievals?: Array<Retrievals$Outbound> | undefined;
  provider_response?: any | undefined;
  usage?: DeploymentInvokeUsage$Outbound | null | undefined;
  choices: Array<DeploymentInvokeChoices$Outbound>;
};

/** @internal */
export const DeploymentInvokeResponseBody$outboundSchema: z.ZodType<
  DeploymentInvokeResponseBody$Outbound,
  z.ZodTypeDef,
  DeploymentInvokeResponseBody
> = z.object({
  id: z.string(),
  created: z.date().transform(v => v.toISOString()),
  object: DeploymentInvokeObject$outboundSchema,
  model: z.string(),
  provider: DeploymentInvokeProvider$outboundSchema,
  isFinal: z.boolean(),
  integrationId: z.string().optional(),
  finalized: z.date().transform(v => v.toISOString()).optional(),
  systemFingerprint: z.nullable(z.string()).optional(),
  retrievals: z.array(z.lazy(() => Retrievals$outboundSchema)).optional(),
  providerResponse: z.any().optional(),
  usage: z.nullable(z.lazy(() => DeploymentInvokeUsage$outboundSchema))
    .optional(),
  choices: z.array(z.lazy(() => DeploymentInvokeChoices$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    isFinal: "is_final",
    integrationId: "integration_id",
    systemFingerprint: "system_fingerprint",
    providerResponse: "provider_response",
  });
});

export function deploymentInvokeResponseBodyToJSON(
  deploymentInvokeResponseBody: DeploymentInvokeResponseBody,
): string {
  return JSON.stringify(
    DeploymentInvokeResponseBody$outboundSchema.parse(
      deploymentInvokeResponseBody,
    ),
  );
}
export function deploymentInvokeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentInvokeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentInvokeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentInvokeResponseBody' from JSON`,
  );
}
