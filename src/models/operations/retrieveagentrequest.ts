/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RetrieveAgentRequestRequest = {
  /**
   * The unique key of the agent to retrieve
   */
  agentKey: string;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveAgentRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveAgentRequestStatus = ClosedEnum<
  typeof RetrieveAgentRequestStatus
>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const RetrieveAgentRequestToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type RetrieveAgentRequestToolApprovalRequired = ClosedEnum<
  typeof RetrieveAgentRequestToolApprovalRequired
>;

export type RetrieveAgentRequestConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type RetrieveAgentRequestTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<RetrieveAgentRequestConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RetrieveAgentRequestExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RetrieveAgentRequestExecuteOn = ClosedEnum<
  typeof RetrieveAgentRequestExecuteOn
>;

export type RetrieveAgentRequestEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RetrieveAgentRequestExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RetrieveAgentRequestAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RetrieveAgentRequestAgentsExecuteOn = ClosedEnum<
  typeof RetrieveAgentRequestAgentsExecuteOn
>;

export type RetrieveAgentRequestGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RetrieveAgentRequestAgentsExecuteOn;
};

export type RetrieveAgentRequestSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: RetrieveAgentRequestToolApprovalRequired | undefined;
  tools?: Array<RetrieveAgentRequestTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<RetrieveAgentRequestEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<RetrieveAgentRequestGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RetrieveAgentRequestVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RetrieveAgentRequestVoice = ClosedEnum<
  typeof RetrieveAgentRequestVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RetrieveAgentRequestFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RetrieveAgentRequestFormat = ClosedEnum<
  typeof RetrieveAgentRequestFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RetrieveAgentRequestAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RetrieveAgentRequestVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RetrieveAgentRequestFormat;
};

export type RetrieveAgentRequestResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RetrieveAgentRequestResponseFormatAgentsJSONSchema = {
  type: "json_schema";
  jsonSchema: RetrieveAgentRequestResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RetrieveAgentRequestResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RetrieveAgentRequestResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type RetrieveAgentRequestResponseFormat =
  | RetrieveAgentRequestResponseFormatText
  | RetrieveAgentRequestResponseFormatJSONObject
  | RetrieveAgentRequestResponseFormatAgentsJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RetrieveAgentRequestStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RetrieveAgentRequestStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const RetrieveAgentRequestType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type RetrieveAgentRequestType = ClosedEnum<
  typeof RetrieveAgentRequestType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const RetrieveAgentRequestThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type RetrieveAgentRequestThinkingLevel = ClosedEnum<
  typeof RetrieveAgentRequestThinkingLevel
>;

export type RetrieveAgentRequestThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: RetrieveAgentRequestType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: RetrieveAgentRequestThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RetrieveAgentRequestToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RetrieveAgentRequestToolChoiceType = ClosedEnum<
  typeof RetrieveAgentRequestToolChoiceType
>;

export type RetrieveAgentRequestToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type RetrieveAgentRequestToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RetrieveAgentRequestToolChoiceType | undefined;
  function: RetrieveAgentRequestToolChoiceFunction;
};

export const RetrieveAgentRequestToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RetrieveAgentRequestToolChoice1 = ClosedEnum<
  typeof RetrieveAgentRequestToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RetrieveAgentRequestToolChoice =
  | RetrieveAgentRequestToolChoice2
  | RetrieveAgentRequestToolChoice1;

export const RetrieveAgentRequestModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RetrieveAgentRequestModalities = ClosedEnum<
  typeof RetrieveAgentRequestModalities
>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type RetrieveAgentRequestParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: RetrieveAgentRequestAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RetrieveAgentRequestResponseFormatText
    | RetrieveAgentRequestResponseFormatJSONObject
    | RetrieveAgentRequestResponseFormatAgentsJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: RetrieveAgentRequestStreamOptions | null | undefined;
  thinking?: RetrieveAgentRequestThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | RetrieveAgentRequestToolChoice2
    | RetrieveAgentRequestToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<RetrieveAgentRequestModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type RetrieveAgentRequestRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RetrieveAgentRequestFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RetrieveAgentRequestFallbackModelConfigurationVoice = ClosedEnum<
  typeof RetrieveAgentRequestFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RetrieveAgentRequestFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RetrieveAgentRequestFallbackModelConfigurationFormat = ClosedEnum<
  typeof RetrieveAgentRequestFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RetrieveAgentRequestFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RetrieveAgentRequestFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RetrieveAgentRequestFallbackModelConfigurationFormat;
};

export type RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema = {
  type: "json_schema";
  jsonSchema: RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RetrieveAgentRequestResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RetrieveAgentRequestResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type RetrieveAgentRequestFallbackModelConfigurationResponseFormat =
  | RetrieveAgentRequestResponseFormatAgentsText
  | RetrieveAgentRequestResponseFormatAgentsJSONObject
  | RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RetrieveAgentRequestFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RetrieveAgentRequestFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const RetrieveAgentRequestFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type RetrieveAgentRequestFallbackModelConfigurationType = ClosedEnum<
  typeof RetrieveAgentRequestFallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const RetrieveAgentRequestFallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type RetrieveAgentRequestFallbackModelConfigurationThinkingLevel =
  ClosedEnum<
    typeof RetrieveAgentRequestFallbackModelConfigurationThinkingLevel
  >;

export type RetrieveAgentRequestFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: RetrieveAgentRequestFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?:
    | RetrieveAgentRequestFallbackModelConfigurationThinkingLevel
    | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RetrieveAgentRequestToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RetrieveAgentRequestToolChoiceAgentsType = ClosedEnum<
  typeof RetrieveAgentRequestToolChoiceAgentsType
>;

export type RetrieveAgentRequestToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type RetrieveAgentRequestToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RetrieveAgentRequestToolChoiceAgentsType | undefined;
  function: RetrieveAgentRequestToolChoiceAgentsFunction;
};

export const RetrieveAgentRequestToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RetrieveAgentRequestToolChoiceAgents1 = ClosedEnum<
  typeof RetrieveAgentRequestToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RetrieveAgentRequestFallbackModelConfigurationToolChoice =
  | RetrieveAgentRequestToolChoiceAgents2
  | RetrieveAgentRequestToolChoiceAgents1;

export const RetrieveAgentRequestFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RetrieveAgentRequestFallbackModelConfigurationModalities =
  ClosedEnum<typeof RetrieveAgentRequestFallbackModelConfigurationModalities>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type RetrieveAgentRequestFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?:
    | RetrieveAgentRequestFallbackModelConfigurationAudio
    | null
    | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RetrieveAgentRequestResponseFormatAgentsText
    | RetrieveAgentRequestResponseFormatAgentsJSONObject
    | RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | RetrieveAgentRequestFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: RetrieveAgentRequestFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | RetrieveAgentRequestToolChoiceAgents2
    | RetrieveAgentRequestToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<RetrieveAgentRequestFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type RetrieveAgentRequestFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?:
    | RetrieveAgentRequestFallbackModelConfigurationParameters
    | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type RetrieveAgentRequestFallbackModelConfiguration =
  | RetrieveAgentRequestFallbackModelConfiguration2
  | string;

export type RetrieveAgentRequestModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: RetrieveAgentRequestParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: RetrieveAgentRequestRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<RetrieveAgentRequestFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type RetrieveAgentRequestTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type RetrieveAgentRequestMetrics = {
  totalCost?: number | undefined;
};

export type RetrieveAgentRequestKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

/**
 * Agent successfully retrieved. Returns the complete agent manifest with all configuration details, including models, tools, knowledge bases, and execution settings.
 */
export type RetrieveAgentRequestResponseBody = {
  id: string;
  key: string;
  displayName: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveAgentRequestStatus;
  settings?: RetrieveAgentRequestSettings | undefined;
  model: RetrieveAgentRequestModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<RetrieveAgentRequestTeamOfAgents>;
  metrics?: RetrieveAgentRequestMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<RetrieveAgentRequestKnowledgeBases> | undefined;
};

/** @internal */
export const RetrieveAgentRequestRequest$inboundSchema: z.ZodType<
  RetrieveAgentRequestRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
  });
});
/** @internal */
export type RetrieveAgentRequestRequest$Outbound = {
  agent_key: string;
};

/** @internal */
export const RetrieveAgentRequestRequest$outboundSchema: z.ZodType<
  RetrieveAgentRequestRequest$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestRequest
> = z.object({
  agentKey: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
  });
});

export function retrieveAgentRequestRequestToJSON(
  retrieveAgentRequestRequest: RetrieveAgentRequestRequest,
): string {
  return JSON.stringify(
    RetrieveAgentRequestRequest$outboundSchema.parse(
      retrieveAgentRequestRequest,
    ),
  );
}
export function retrieveAgentRequestRequestFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestRequest' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestStatus$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestStatus
> = z.nativeEnum(RetrieveAgentRequestStatus);
/** @internal */
export const RetrieveAgentRequestStatus$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestStatus
> = RetrieveAgentRequestStatus$inboundSchema;

/** @internal */
export const RetrieveAgentRequestToolApprovalRequired$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolApprovalRequired> = z
    .nativeEnum(RetrieveAgentRequestToolApprovalRequired);
/** @internal */
export const RetrieveAgentRequestToolApprovalRequired$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolApprovalRequired> =
    RetrieveAgentRequestToolApprovalRequired$inboundSchema;

/** @internal */
export const RetrieveAgentRequestConditions$inboundSchema: z.ZodType<
  RetrieveAgentRequestConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type RetrieveAgentRequestConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const RetrieveAgentRequestConditions$outboundSchema: z.ZodType<
  RetrieveAgentRequestConditions$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function retrieveAgentRequestConditionsToJSON(
  retrieveAgentRequestConditions: RetrieveAgentRequestConditions,
): string {
  return JSON.stringify(
    RetrieveAgentRequestConditions$outboundSchema.parse(
      retrieveAgentRequestConditions,
    ),
  );
}
export function retrieveAgentRequestConditionsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestConditions' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestTools$inboundSchema: z.ZodType<
  RetrieveAgentRequestTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(
    z.lazy(() => RetrieveAgentRequestConditions$inboundSchema),
  ).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});
/** @internal */
export type RetrieveAgentRequestTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<RetrieveAgentRequestConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const RetrieveAgentRequestTools$outboundSchema: z.ZodType<
  RetrieveAgentRequestTools$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  toolId: z.string().optional(),
  conditions: z.array(
    z.lazy(() => RetrieveAgentRequestConditions$outboundSchema),
  ).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
    toolId: "tool_id",
  });
});

export function retrieveAgentRequestToolsToJSON(
  retrieveAgentRequestTools: RetrieveAgentRequestTools,
): string {
  return JSON.stringify(
    RetrieveAgentRequestTools$outboundSchema.parse(retrieveAgentRequestTools),
  );
}
export function retrieveAgentRequestToolsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestTools' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestExecuteOn
> = z.nativeEnum(RetrieveAgentRequestExecuteOn);
/** @internal */
export const RetrieveAgentRequestExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestExecuteOn
> = RetrieveAgentRequestExecuteOn$inboundSchema;

/** @internal */
export const RetrieveAgentRequestEvaluators$inboundSchema: z.ZodType<
  RetrieveAgentRequestEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: RetrieveAgentRequestExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type RetrieveAgentRequestEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RetrieveAgentRequestEvaluators$outboundSchema: z.ZodType<
  RetrieveAgentRequestEvaluators$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RetrieveAgentRequestExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function retrieveAgentRequestEvaluatorsToJSON(
  retrieveAgentRequestEvaluators: RetrieveAgentRequestEvaluators,
): string {
  return JSON.stringify(
    RetrieveAgentRequestEvaluators$outboundSchema.parse(
      retrieveAgentRequestEvaluators,
    ),
  );
}
export function retrieveAgentRequestEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestEvaluators' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestAgentsExecuteOn
> = z.nativeEnum(RetrieveAgentRequestAgentsExecuteOn);
/** @internal */
export const RetrieveAgentRequestAgentsExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestAgentsExecuteOn> =
    RetrieveAgentRequestAgentsExecuteOn$inboundSchema;

/** @internal */
export const RetrieveAgentRequestGuardrails$inboundSchema: z.ZodType<
  RetrieveAgentRequestGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: RetrieveAgentRequestAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type RetrieveAgentRequestGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RetrieveAgentRequestGuardrails$outboundSchema: z.ZodType<
  RetrieveAgentRequestGuardrails$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RetrieveAgentRequestAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function retrieveAgentRequestGuardrailsToJSON(
  retrieveAgentRequestGuardrails: RetrieveAgentRequestGuardrails,
): string {
  return JSON.stringify(
    RetrieveAgentRequestGuardrails$outboundSchema.parse(
      retrieveAgentRequestGuardrails,
    ),
  );
}
export function retrieveAgentRequestGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestGuardrails' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestSettings$inboundSchema: z.ZodType<
  RetrieveAgentRequestSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: RetrieveAgentRequestToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => RetrieveAgentRequestTools$inboundSchema))
    .optional(),
  evaluators: z.array(
    z.lazy(() => RetrieveAgentRequestEvaluators$inboundSchema),
  ).optional(),
  guardrails: z.array(
    z.lazy(() => RetrieveAgentRequestGuardrails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type RetrieveAgentRequestSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<RetrieveAgentRequestTools$Outbound> | undefined;
  evaluators?: Array<RetrieveAgentRequestEvaluators$Outbound> | undefined;
  guardrails?: Array<RetrieveAgentRequestGuardrails$Outbound> | undefined;
};

/** @internal */
export const RetrieveAgentRequestSettings$outboundSchema: z.ZodType<
  RetrieveAgentRequestSettings$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: RetrieveAgentRequestToolApprovalRequired$outboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => RetrieveAgentRequestTools$outboundSchema))
    .optional(),
  evaluators: z.array(
    z.lazy(() => RetrieveAgentRequestEvaluators$outboundSchema),
  ).optional(),
  guardrails: z.array(
    z.lazy(() => RetrieveAgentRequestGuardrails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function retrieveAgentRequestSettingsToJSON(
  retrieveAgentRequestSettings: RetrieveAgentRequestSettings,
): string {
  return JSON.stringify(
    RetrieveAgentRequestSettings$outboundSchema.parse(
      retrieveAgentRequestSettings,
    ),
  );
}
export function retrieveAgentRequestSettingsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestSettings' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestVoice$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestVoice
> = z.nativeEnum(RetrieveAgentRequestVoice);
/** @internal */
export const RetrieveAgentRequestVoice$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestVoice
> = RetrieveAgentRequestVoice$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFormat$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestFormat
> = z.nativeEnum(RetrieveAgentRequestFormat);
/** @internal */
export const RetrieveAgentRequestFormat$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestFormat
> = RetrieveAgentRequestFormat$inboundSchema;

/** @internal */
export const RetrieveAgentRequestAudio$inboundSchema: z.ZodType<
  RetrieveAgentRequestAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: RetrieveAgentRequestVoice$inboundSchema,
  format: RetrieveAgentRequestFormat$inboundSchema,
});
/** @internal */
export type RetrieveAgentRequestAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RetrieveAgentRequestAudio$outboundSchema: z.ZodType<
  RetrieveAgentRequestAudio$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestAudio
> = z.object({
  voice: RetrieveAgentRequestVoice$outboundSchema,
  format: RetrieveAgentRequestFormat$outboundSchema,
});

export function retrieveAgentRequestAudioToJSON(
  retrieveAgentRequestAudio: RetrieveAgentRequestAudio,
): string {
  return JSON.stringify(
    RetrieveAgentRequestAudio$outboundSchema.parse(retrieveAgentRequestAudio),
  );
}
export function retrieveAgentRequestAudioFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestAudio' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatJsonSchema$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const RetrieveAgentRequestResponseFormatJsonSchema$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatJsonSchema$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function retrieveAgentRequestResponseFormatJsonSchemaToJSON(
  retrieveAgentRequestResponseFormatJsonSchema:
    RetrieveAgentRequestResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatJsonSchema$outboundSchema.parse(
      retrieveAgentRequestResponseFormatJsonSchema,
    ),
  );
}
export function retrieveAgentRequestResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsJSONSchema$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      RetrieveAgentRequestResponseFormatJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatAgentsJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: RetrieveAgentRequestResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsJSONSchema$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsJSONSchema$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatAgentsJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      RetrieveAgentRequestResponseFormatJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function retrieveAgentRequestResponseFormatAgentsJSONSchemaToJSON(
  retrieveAgentRequestResponseFormatAgentsJSONSchema:
    RetrieveAgentRequestResponseFormatAgentsJSONSchema,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatAgentsJSONSchema$outboundSchema.parse(
      retrieveAgentRequestResponseFormatAgentsJSONSchema,
    ),
  );
}
export function retrieveAgentRequestResponseFormatAgentsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatAgentsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatAgentsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestResponseFormatAgentsJSONSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatJSONObject$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const RetrieveAgentRequestResponseFormatJSONObject$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatJSONObject$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function retrieveAgentRequestResponseFormatJSONObjectToJSON(
  retrieveAgentRequestResponseFormatJSONObject:
    RetrieveAgentRequestResponseFormatJSONObject,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatJSONObject$outboundSchema.parse(
      retrieveAgentRequestResponseFormatJSONObject,
    ),
  );
}
export function retrieveAgentRequestResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatText$inboundSchema: z.ZodType<
  RetrieveAgentRequestResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type RetrieveAgentRequestResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const RetrieveAgentRequestResponseFormatText$outboundSchema: z.ZodType<
  RetrieveAgentRequestResponseFormatText$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function retrieveAgentRequestResponseFormatTextToJSON(
  retrieveAgentRequestResponseFormatText:
    RetrieveAgentRequestResponseFormatText,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatText$outboundSchema.parse(
      retrieveAgentRequestResponseFormatText,
    ),
  );
}
export function retrieveAgentRequestResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestResponseFormatText' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormat$inboundSchema: z.ZodType<
  RetrieveAgentRequestResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RetrieveAgentRequestResponseFormatText$inboundSchema),
  z.lazy(() => RetrieveAgentRequestResponseFormatJSONObject$inboundSchema),
  z.lazy(() =>
    RetrieveAgentRequestResponseFormatAgentsJSONSchema$inboundSchema
  ),
]);
/** @internal */
export type RetrieveAgentRequestResponseFormat$Outbound =
  | RetrieveAgentRequestResponseFormatText$Outbound
  | RetrieveAgentRequestResponseFormatJSONObject$Outbound
  | RetrieveAgentRequestResponseFormatAgentsJSONSchema$Outbound;

/** @internal */
export const RetrieveAgentRequestResponseFormat$outboundSchema: z.ZodType<
  RetrieveAgentRequestResponseFormat$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestResponseFormat
> = z.union([
  z.lazy(() => RetrieveAgentRequestResponseFormatText$outboundSchema),
  z.lazy(() => RetrieveAgentRequestResponseFormatJSONObject$outboundSchema),
  z.lazy(() =>
    RetrieveAgentRequestResponseFormatAgentsJSONSchema$outboundSchema
  ),
]);

export function retrieveAgentRequestResponseFormatToJSON(
  retrieveAgentRequestResponseFormat: RetrieveAgentRequestResponseFormat,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormat$outboundSchema.parse(
      retrieveAgentRequestResponseFormat,
    ),
  );
}
export function retrieveAgentRequestResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestResponseFormat' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestStop$inboundSchema: z.ZodType<
  RetrieveAgentRequestStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type RetrieveAgentRequestStop$Outbound = string | Array<string>;

/** @internal */
export const RetrieveAgentRequestStop$outboundSchema: z.ZodType<
  RetrieveAgentRequestStop$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestStop
> = z.union([z.string(), z.array(z.string())]);

export function retrieveAgentRequestStopToJSON(
  retrieveAgentRequestStop: RetrieveAgentRequestStop,
): string {
  return JSON.stringify(
    RetrieveAgentRequestStop$outboundSchema.parse(retrieveAgentRequestStop),
  );
}
export function retrieveAgentRequestStopFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestStop' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestStreamOptions$inboundSchema: z.ZodType<
  RetrieveAgentRequestStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type RetrieveAgentRequestStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const RetrieveAgentRequestStreamOptions$outboundSchema: z.ZodType<
  RetrieveAgentRequestStreamOptions$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function retrieveAgentRequestStreamOptionsToJSON(
  retrieveAgentRequestStreamOptions: RetrieveAgentRequestStreamOptions,
): string {
  return JSON.stringify(
    RetrieveAgentRequestStreamOptions$outboundSchema.parse(
      retrieveAgentRequestStreamOptions,
    ),
  );
}
export function retrieveAgentRequestStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestStreamOptions' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestType$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestType
> = z.nativeEnum(RetrieveAgentRequestType);
/** @internal */
export const RetrieveAgentRequestType$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestType
> = RetrieveAgentRequestType$inboundSchema;

/** @internal */
export const RetrieveAgentRequestThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestThinkingLevel
> = z.nativeEnum(RetrieveAgentRequestThinkingLevel);
/** @internal */
export const RetrieveAgentRequestThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestThinkingLevel
> = RetrieveAgentRequestThinkingLevel$inboundSchema;

/** @internal */
export const RetrieveAgentRequestThinking$inboundSchema: z.ZodType<
  RetrieveAgentRequestThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetrieveAgentRequestType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: RetrieveAgentRequestThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type RetrieveAgentRequestThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const RetrieveAgentRequestThinking$outboundSchema: z.ZodType<
  RetrieveAgentRequestThinking$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestThinking
> = z.object({
  type: RetrieveAgentRequestType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: RetrieveAgentRequestThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function retrieveAgentRequestThinkingToJSON(
  retrieveAgentRequestThinking: RetrieveAgentRequestThinking,
): string {
  return JSON.stringify(
    RetrieveAgentRequestThinking$outboundSchema.parse(
      retrieveAgentRequestThinking,
    ),
  );
}
export function retrieveAgentRequestThinkingFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestThinking' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestToolChoiceType
> = z.nativeEnum(RetrieveAgentRequestToolChoiceType);
/** @internal */
export const RetrieveAgentRequestToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestToolChoiceType
> = RetrieveAgentRequestToolChoiceType$inboundSchema;

/** @internal */
export const RetrieveAgentRequestToolChoiceFunction$inboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type RetrieveAgentRequestToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const RetrieveAgentRequestToolChoiceFunction$outboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function retrieveAgentRequestToolChoiceFunctionToJSON(
  retrieveAgentRequestToolChoiceFunction:
    RetrieveAgentRequestToolChoiceFunction,
): string {
  return JSON.stringify(
    RetrieveAgentRequestToolChoiceFunction$outboundSchema.parse(
      retrieveAgentRequestToolChoiceFunction,
    ),
  );
}
export function retrieveAgentRequestToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoice2$inboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetrieveAgentRequestToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => RetrieveAgentRequestToolChoiceFunction$inboundSchema),
});
/** @internal */
export type RetrieveAgentRequestToolChoice2$Outbound = {
  type?: string | undefined;
  function: RetrieveAgentRequestToolChoiceFunction$Outbound;
};

/** @internal */
export const RetrieveAgentRequestToolChoice2$outboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoice2$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestToolChoice2
> = z.object({
  type: RetrieveAgentRequestToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => RetrieveAgentRequestToolChoiceFunction$outboundSchema),
});

export function retrieveAgentRequestToolChoice2ToJSON(
  retrieveAgentRequestToolChoice2: RetrieveAgentRequestToolChoice2,
): string {
  return JSON.stringify(
    RetrieveAgentRequestToolChoice2$outboundSchema.parse(
      retrieveAgentRequestToolChoice2,
    ),
  );
}
export function retrieveAgentRequestToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestToolChoice2' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestToolChoice1
> = z.nativeEnum(RetrieveAgentRequestToolChoice1);
/** @internal */
export const RetrieveAgentRequestToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestToolChoice1
> = RetrieveAgentRequestToolChoice1$inboundSchema;

/** @internal */
export const RetrieveAgentRequestToolChoice$inboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RetrieveAgentRequestToolChoice2$inboundSchema),
  RetrieveAgentRequestToolChoice1$inboundSchema,
]);
/** @internal */
export type RetrieveAgentRequestToolChoice$Outbound =
  | RetrieveAgentRequestToolChoice2$Outbound
  | string;

/** @internal */
export const RetrieveAgentRequestToolChoice$outboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoice$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestToolChoice
> = z.union([
  z.lazy(() => RetrieveAgentRequestToolChoice2$outboundSchema),
  RetrieveAgentRequestToolChoice1$outboundSchema,
]);

export function retrieveAgentRequestToolChoiceToJSON(
  retrieveAgentRequestToolChoice: RetrieveAgentRequestToolChoice,
): string {
  return JSON.stringify(
    RetrieveAgentRequestToolChoice$outboundSchema.parse(
      retrieveAgentRequestToolChoice,
    ),
  );
}
export function retrieveAgentRequestToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestToolChoice' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestModalities$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestModalities
> = z.nativeEnum(RetrieveAgentRequestModalities);
/** @internal */
export const RetrieveAgentRequestModalities$outboundSchema: z.ZodNativeEnum<
  typeof RetrieveAgentRequestModalities
> = RetrieveAgentRequestModalities$inboundSchema;

/** @internal */
export const RetrieveAgentRequestParameters$inboundSchema: z.ZodType<
  RetrieveAgentRequestParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => RetrieveAgentRequestAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => RetrieveAgentRequestResponseFormatText$inboundSchema),
    z.lazy(() => RetrieveAgentRequestResponseFormatJSONObject$inboundSchema),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsJSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => RetrieveAgentRequestStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => RetrieveAgentRequestThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => RetrieveAgentRequestToolChoice2$inboundSchema),
    RetrieveAgentRequestToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(RetrieveAgentRequestModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type RetrieveAgentRequestParameters$Outbound = {
  audio?: RetrieveAgentRequestAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | RetrieveAgentRequestResponseFormatText$Outbound
    | RetrieveAgentRequestResponseFormatJSONObject$Outbound
    | RetrieveAgentRequestResponseFormatAgentsJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | RetrieveAgentRequestStreamOptions$Outbound
    | null
    | undefined;
  thinking?: RetrieveAgentRequestThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: RetrieveAgentRequestToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const RetrieveAgentRequestParameters$outboundSchema: z.ZodType<
  RetrieveAgentRequestParameters$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestParameters
> = z.object({
  audio: z.nullable(z.lazy(() => RetrieveAgentRequestAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => RetrieveAgentRequestResponseFormatText$outboundSchema),
    z.lazy(() => RetrieveAgentRequestResponseFormatJSONObject$outboundSchema),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsJSONSchema$outboundSchema
    ),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => RetrieveAgentRequestStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => RetrieveAgentRequestThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => RetrieveAgentRequestToolChoice2$outboundSchema),
    RetrieveAgentRequestToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(RetrieveAgentRequestModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function retrieveAgentRequestParametersToJSON(
  retrieveAgentRequestParameters: RetrieveAgentRequestParameters,
): string {
  return JSON.stringify(
    RetrieveAgentRequestParameters$outboundSchema.parse(
      retrieveAgentRequestParameters,
    ),
  );
}
export function retrieveAgentRequestParametersFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestParameters' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestRetry$inboundSchema: z.ZodType<
  RetrieveAgentRequestRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type RetrieveAgentRequestRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RetrieveAgentRequestRetry$outboundSchema: z.ZodType<
  RetrieveAgentRequestRetry$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function retrieveAgentRequestRetryToJSON(
  retrieveAgentRequestRetry: RetrieveAgentRequestRetry,
): string {
  return JSON.stringify(
    RetrieveAgentRequestRetry$outboundSchema.parse(retrieveAgentRequestRetry),
  );
}
export function retrieveAgentRequestRetryFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestRetry' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationVoice> =
    z.nativeEnum(RetrieveAgentRequestFallbackModelConfigurationVoice);
/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationVoice> =
    RetrieveAgentRequestFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationFormat> =
    z.nativeEnum(RetrieveAgentRequestFallbackModelConfigurationFormat);
/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationFormat> =
    RetrieveAgentRequestFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: RetrieveAgentRequestFallbackModelConfigurationVoice$inboundSchema,
    format: RetrieveAgentRequestFallbackModelConfigurationFormat$inboundSchema,
  });
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationAudio
  > = z.object({
    voice: RetrieveAgentRequestFallbackModelConfigurationVoice$outboundSchema,
    format: RetrieveAgentRequestFallbackModelConfigurationFormat$outboundSchema,
  });

export function retrieveAgentRequestFallbackModelConfigurationAudioToJSON(
  retrieveAgentRequestFallbackModelConfigurationAudio:
    RetrieveAgentRequestFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationAudio$outboundSchema.parse(
      retrieveAgentRequestFallbackModelConfigurationAudio,
    ),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function retrieveAgentRequestResponseFormatAgentsResponseJsonSchemaToJSON(
  retrieveAgentRequestResponseFormatAgentsResponseJsonSchema:
    RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema
      .parse(retrieveAgentRequestResponseFormatAgentsResponseJsonSchema),
  );
}
export function retrieveAgentRequestResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$Outbound =
  {
    type: "json_schema";
    json_schema:
      RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound;
  };

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function retrieveAgentRequestResponseFormatAgentsResponse200JSONSchemaToJSON(
  retrieveAgentRequestResponseFormatAgentsResponse200JSONSchema:
    RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$outboundSchema
      .parse(retrieveAgentRequestResponseFormatAgentsResponse200JSONSchema),
  );
}
export function retrieveAgentRequestResponseFormatAgentsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function retrieveAgentRequestResponseFormatAgentsJSONObjectToJSON(
  retrieveAgentRequestResponseFormatAgentsJSONObject:
    RetrieveAgentRequestResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatAgentsJSONObject$outboundSchema.parse(
      retrieveAgentRequestResponseFormatAgentsJSONObject,
    ),
  );
}
export function retrieveAgentRequestResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsText$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsText,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("text"),
  });
/** @internal */
export type RetrieveAgentRequestResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const RetrieveAgentRequestResponseFormatAgentsText$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestResponseFormatAgentsText$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestResponseFormatAgentsText
  > = z.object({
    type: z.literal("text"),
  });

export function retrieveAgentRequestResponseFormatAgentsTextToJSON(
  retrieveAgentRequestResponseFormatAgentsText:
    RetrieveAgentRequestResponseFormatAgentsText,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseFormatAgentsText$outboundSchema.parse(
      retrieveAgentRequestResponseFormatAgentsText,
    ),
  );
}
export function retrieveAgentRequestResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestResponseFormatAgentsText,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestResponseFormatAgentsText$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => RetrieveAgentRequestResponseFormatAgentsText$inboundSchema),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsJSONObject$inboundSchema
    ),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$inboundSchema
    ),
  ]);
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationResponseFormat$Outbound =
  | RetrieveAgentRequestResponseFormatAgentsText$Outbound
  | RetrieveAgentRequestResponseFormatAgentsJSONObject$Outbound
  | RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$Outbound;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => RetrieveAgentRequestResponseFormatAgentsText$outboundSchema),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsJSONObject$outboundSchema
    ),
    z.lazy(() =>
      RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$outboundSchema
    ),
  ]);

export function retrieveAgentRequestFallbackModelConfigurationResponseFormatToJSON(
  retrieveAgentRequestFallbackModelConfigurationResponseFormat:
    RetrieveAgentRequestFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationResponseFormat$outboundSchema
      .parse(retrieveAgentRequestFallbackModelConfigurationResponseFormat),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function retrieveAgentRequestFallbackModelConfigurationStopToJSON(
  retrieveAgentRequestFallbackModelConfigurationStop:
    RetrieveAgentRequestFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationStop$outboundSchema.parse(
      retrieveAgentRequestFallbackModelConfigurationStop,
    ),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationStreamOptions$Outbound =
  {
    include_usage?: boolean | undefined;
  };

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function retrieveAgentRequestFallbackModelConfigurationStreamOptionsToJSON(
  retrieveAgentRequestFallbackModelConfigurationStreamOptions:
    RetrieveAgentRequestFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema
      .parse(retrieveAgentRequestFallbackModelConfigurationStreamOptions),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationType> = z
    .nativeEnum(RetrieveAgentRequestFallbackModelConfigurationType);
/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestFallbackModelConfigurationType> =
    RetrieveAgentRequestFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveAgentRequestFallbackModelConfigurationThinkingLevel
  > = z.nativeEnum(RetrieveAgentRequestFallbackModelConfigurationThinkingLevel);
/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveAgentRequestFallbackModelConfigurationThinkingLevel
  > = RetrieveAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: RetrieveAgentRequestFallbackModelConfigurationType$inboundSchema,
    budget_tokens: z.number(),
    thinking_level:
      RetrieveAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      "budget_tokens": "budgetTokens",
      "thinking_level": "thinkingLevel",
    });
  });
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationThinking
  > = z.object({
    type: RetrieveAgentRequestFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
    thinkingLevel:
      RetrieveAgentRequestFallbackModelConfigurationThinkingLevel$outboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
      thinkingLevel: "thinking_level",
    });
  });

export function retrieveAgentRequestFallbackModelConfigurationThinkingToJSON(
  retrieveAgentRequestFallbackModelConfigurationThinking:
    RetrieveAgentRequestFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationThinking$outboundSchema.parse(
      retrieveAgentRequestFallbackModelConfigurationThinking,
    ),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationThinking$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoiceAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolChoiceAgentsType> = z
    .nativeEnum(RetrieveAgentRequestToolChoiceAgentsType);
/** @internal */
export const RetrieveAgentRequestToolChoiceAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolChoiceAgentsType> =
    RetrieveAgentRequestToolChoiceAgentsType$inboundSchema;

/** @internal */
export const RetrieveAgentRequestToolChoiceAgentsFunction$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestToolChoiceAgentsFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });
/** @internal */
export type RetrieveAgentRequestToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const RetrieveAgentRequestToolChoiceAgentsFunction$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestToolChoiceAgentsFunction$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestToolChoiceAgentsFunction
  > = z.object({
    name: z.string(),
  });

export function retrieveAgentRequestToolChoiceAgentsFunctionToJSON(
  retrieveAgentRequestToolChoiceAgentsFunction:
    RetrieveAgentRequestToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    RetrieveAgentRequestToolChoiceAgentsFunction$outboundSchema.parse(
      retrieveAgentRequestToolChoiceAgentsFunction,
    ),
  );
}
export function retrieveAgentRequestToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestToolChoiceAgentsFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestToolChoiceAgentsFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoiceAgents2$inboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RetrieveAgentRequestToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() =>
    RetrieveAgentRequestToolChoiceAgentsFunction$inboundSchema
  ),
});
/** @internal */
export type RetrieveAgentRequestToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: RetrieveAgentRequestToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const RetrieveAgentRequestToolChoiceAgents2$outboundSchema: z.ZodType<
  RetrieveAgentRequestToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestToolChoiceAgents2
> = z.object({
  type: RetrieveAgentRequestToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() =>
    RetrieveAgentRequestToolChoiceAgentsFunction$outboundSchema
  ),
});

export function retrieveAgentRequestToolChoiceAgents2ToJSON(
  retrieveAgentRequestToolChoiceAgents2: RetrieveAgentRequestToolChoiceAgents2,
): string {
  return JSON.stringify(
    RetrieveAgentRequestToolChoiceAgents2$outboundSchema.parse(
      retrieveAgentRequestToolChoiceAgents2,
    ),
  );
}
export function retrieveAgentRequestToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestToolChoiceAgents1$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolChoiceAgents1> = z.nativeEnum(
    RetrieveAgentRequestToolChoiceAgents1,
  );
/** @internal */
export const RetrieveAgentRequestToolChoiceAgents1$outboundSchema:
  z.ZodNativeEnum<typeof RetrieveAgentRequestToolChoiceAgents1> =
    RetrieveAgentRequestToolChoiceAgents1$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => RetrieveAgentRequestToolChoiceAgents2$inboundSchema),
    RetrieveAgentRequestToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationToolChoice$Outbound =
  | RetrieveAgentRequestToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => RetrieveAgentRequestToolChoiceAgents2$outboundSchema),
    RetrieveAgentRequestToolChoiceAgents1$outboundSchema,
  ]);

export function retrieveAgentRequestFallbackModelConfigurationToolChoiceToJSON(
  retrieveAgentRequestFallbackModelConfigurationToolChoice:
    RetrieveAgentRequestFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationToolChoice$outboundSchema
      .parse(retrieveAgentRequestFallbackModelConfigurationToolChoice),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationToolChoice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveAgentRequestFallbackModelConfigurationModalities
  > = z.nativeEnum(RetrieveAgentRequestFallbackModelConfigurationModalities);
/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveAgentRequestFallbackModelConfigurationModalities
  > = RetrieveAgentRequestFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfigurationAudio$inboundSchema
      ),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => RetrieveAgentRequestResponseFormatAgentsText$inboundSchema),
      z.lazy(() =>
        RetrieveAgentRequestResponseFormatAgentsJSONObject$inboundSchema
      ),
      z.lazy(() =>
        RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      RetrieveAgentRequestFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => RetrieveAgentRequestToolChoiceAgents2$inboundSchema),
      RetrieveAgentRequestToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        RetrieveAgentRequestFallbackModelConfigurationModalities$inboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type RetrieveAgentRequestFallbackModelConfigurationParameters$Outbound =
  {
    audio?:
      | RetrieveAgentRequestFallbackModelConfigurationAudio$Outbound
      | null
      | undefined;
    frequency_penalty?: number | null | undefined;
    max_tokens?: number | null | undefined;
    max_completion_tokens?: number | null | undefined;
    logprobs?: boolean | null | undefined;
    top_logprobs?: number | null | undefined;
    n?: number | null | undefined;
    presence_penalty?: number | null | undefined;
    response_format?:
      | RetrieveAgentRequestResponseFormatAgentsText$Outbound
      | RetrieveAgentRequestResponseFormatAgentsJSONObject$Outbound
      | RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$Outbound
      | undefined;
    reasoning_effort?: string | undefined;
    verbosity?: string | undefined;
    seed?: number | null | undefined;
    stop?: string | Array<string> | null | undefined;
    stream_options?:
      | RetrieveAgentRequestFallbackModelConfigurationStreamOptions$Outbound
      | null
      | undefined;
    thinking?:
      | RetrieveAgentRequestFallbackModelConfigurationThinking$Outbound
      | undefined;
    temperature?: number | null | undefined;
    top_p?: number | null | undefined;
    top_k?: number | null | undefined;
    tool_choice?:
      | RetrieveAgentRequestToolChoiceAgents2$Outbound
      | string
      | undefined;
    parallel_tool_calls?: boolean | undefined;
    modalities?: Array<string> | null | undefined;
  };

/** @internal */
export const RetrieveAgentRequestFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => RetrieveAgentRequestResponseFormatAgentsText$outboundSchema),
      z.lazy(() =>
        RetrieveAgentRequestResponseFormatAgentsJSONObject$outboundSchema
      ),
      z.lazy(() =>
        RetrieveAgentRequestResponseFormatAgentsResponse200JSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      RetrieveAgentRequestFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => RetrieveAgentRequestToolChoiceAgents2$outboundSchema),
      RetrieveAgentRequestToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        RetrieveAgentRequestFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function retrieveAgentRequestFallbackModelConfigurationParametersToJSON(
  retrieveAgentRequestFallbackModelConfigurationParameters:
    RetrieveAgentRequestFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfigurationParameters$outboundSchema
      .parse(retrieveAgentRequestFallbackModelConfigurationParameters),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfigurationParameters$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfiguration2$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfiguration2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      RetrieveAgentRequestFallbackModelConfigurationParameters$inboundSchema
    ).optional(),
  });
/** @internal */
export type RetrieveAgentRequestFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | RetrieveAgentRequestFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const RetrieveAgentRequestFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      RetrieveAgentRequestFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
  });

export function retrieveAgentRequestFallbackModelConfiguration2ToJSON(
  retrieveAgentRequestFallbackModelConfiguration2:
    RetrieveAgentRequestFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfiguration2$outboundSchema.parse(
      retrieveAgentRequestFallbackModelConfiguration2,
    ),
  );
}
export function retrieveAgentRequestFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestFallbackModelConfiguration$inboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfiguration,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => RetrieveAgentRequestFallbackModelConfiguration2$inboundSchema),
    z.string(),
  ]);
/** @internal */
export type RetrieveAgentRequestFallbackModelConfiguration$Outbound =
  | RetrieveAgentRequestFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const RetrieveAgentRequestFallbackModelConfiguration$outboundSchema:
  z.ZodType<
    RetrieveAgentRequestFallbackModelConfiguration$Outbound,
    z.ZodTypeDef,
    RetrieveAgentRequestFallbackModelConfiguration
  > = z.union([
    z.lazy(() =>
      RetrieveAgentRequestFallbackModelConfiguration2$outboundSchema
    ),
    z.string(),
  ]);

export function retrieveAgentRequestFallbackModelConfigurationToJSON(
  retrieveAgentRequestFallbackModelConfiguration:
    RetrieveAgentRequestFallbackModelConfiguration,
): string {
  return JSON.stringify(
    RetrieveAgentRequestFallbackModelConfiguration$outboundSchema.parse(
      retrieveAgentRequestFallbackModelConfiguration,
    ),
  );
}
export function retrieveAgentRequestFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveAgentRequestFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveAgentRequestFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestModel$inboundSchema: z.ZodType<
  RetrieveAgentRequestModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => RetrieveAgentRequestParameters$inboundSchema)
    .optional(),
  retry: z.lazy(() => RetrieveAgentRequestRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfiguration2$inboundSchema
      ),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type RetrieveAgentRequestModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: RetrieveAgentRequestParameters$Outbound | undefined;
  retry?: RetrieveAgentRequestRetry$Outbound | undefined;
  fallback_models?:
    | Array<RetrieveAgentRequestFallbackModelConfiguration2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const RetrieveAgentRequestModel$outboundSchema: z.ZodType<
  RetrieveAgentRequestModel$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => RetrieveAgentRequestParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => RetrieveAgentRequestRetry$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() =>
        RetrieveAgentRequestFallbackModelConfiguration2$outboundSchema
      ),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function retrieveAgentRequestModelToJSON(
  retrieveAgentRequestModel: RetrieveAgentRequestModel,
): string {
  return JSON.stringify(
    RetrieveAgentRequestModel$outboundSchema.parse(retrieveAgentRequestModel),
  );
}
export function retrieveAgentRequestModelFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestModel' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestTeamOfAgents$inboundSchema: z.ZodType<
  RetrieveAgentRequestTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type RetrieveAgentRequestTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const RetrieveAgentRequestTeamOfAgents$outboundSchema: z.ZodType<
  RetrieveAgentRequestTeamOfAgents$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function retrieveAgentRequestTeamOfAgentsToJSON(
  retrieveAgentRequestTeamOfAgents: RetrieveAgentRequestTeamOfAgents,
): string {
  return JSON.stringify(
    RetrieveAgentRequestTeamOfAgents$outboundSchema.parse(
      retrieveAgentRequestTeamOfAgents,
    ),
  );
}
export function retrieveAgentRequestTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestMetrics$inboundSchema: z.ZodType<
  RetrieveAgentRequestMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type RetrieveAgentRequestMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const RetrieveAgentRequestMetrics$outboundSchema: z.ZodType<
  RetrieveAgentRequestMetrics$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function retrieveAgentRequestMetricsToJSON(
  retrieveAgentRequestMetrics: RetrieveAgentRequestMetrics,
): string {
  return JSON.stringify(
    RetrieveAgentRequestMetrics$outboundSchema.parse(
      retrieveAgentRequestMetrics,
    ),
  );
}
export function retrieveAgentRequestMetricsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestMetrics' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestKnowledgeBases$inboundSchema: z.ZodType<
  RetrieveAgentRequestKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type RetrieveAgentRequestKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const RetrieveAgentRequestKnowledgeBases$outboundSchema: z.ZodType<
  RetrieveAgentRequestKnowledgeBases$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function retrieveAgentRequestKnowledgeBasesToJSON(
  retrieveAgentRequestKnowledgeBases: RetrieveAgentRequestKnowledgeBases,
): string {
  return JSON.stringify(
    RetrieveAgentRequestKnowledgeBases$outboundSchema.parse(
      retrieveAgentRequestKnowledgeBases,
    ),
  );
}
export function retrieveAgentRequestKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveAgentRequestKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentRequestResponseBody$inboundSchema: z.ZodType<
  RetrieveAgentRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: RetrieveAgentRequestStatus$inboundSchema,
  settings: z.lazy(() => RetrieveAgentRequestSettings$inboundSchema).optional(),
  model: z.lazy(() => RetrieveAgentRequestModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => RetrieveAgentRequestTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => RetrieveAgentRequestMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => RetrieveAgentRequestKnowledgeBases$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});
/** @internal */
export type RetrieveAgentRequestResponseBody$Outbound = {
  _id: string;
  key: string;
  display_name: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: RetrieveAgentRequestSettings$Outbound | undefined;
  model: RetrieveAgentRequestModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<RetrieveAgentRequestTeamOfAgents$Outbound>;
  metrics?: RetrieveAgentRequestMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?:
    | Array<RetrieveAgentRequestKnowledgeBases$Outbound>
    | undefined;
};

/** @internal */
export const RetrieveAgentRequestResponseBody$outboundSchema: z.ZodType<
  RetrieveAgentRequestResponseBody$Outbound,
  z.ZodTypeDef,
  RetrieveAgentRequestResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  displayName: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: RetrieveAgentRequestStatus$outboundSchema,
  settings: z.lazy(() => RetrieveAgentRequestSettings$outboundSchema)
    .optional(),
  model: z.lazy(() => RetrieveAgentRequestModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(
    z.lazy(() => RetrieveAgentRequestTeamOfAgents$outboundSchema),
  ),
  metrics: z.lazy(() => RetrieveAgentRequestMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => RetrieveAgentRequestKnowledgeBases$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
  });
});

export function retrieveAgentRequestResponseBodyToJSON(
  retrieveAgentRequestResponseBody: RetrieveAgentRequestResponseBody,
): string {
  return JSON.stringify(
    RetrieveAgentRequestResponseBody$outboundSchema.parse(
      retrieveAgentRequestResponseBody,
    ),
  );
}
export function retrieveAgentRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentRequestResponseBody' from JSON`,
  );
}
