/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import * as components from "../components/index.js";

/**
 * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
 */
export const CreateSpeechResponseFormat = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
/**
 * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
 */
export type CreateSpeechResponseFormat = ClosedEnum<
  typeof CreateSpeechResponseFormat
>;

/**
 * Retry configuration for the request
 */
export type CreateSpeechRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateSpeechFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateSpeechContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type CreateSpeechThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

export const CreateSpeechLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateSpeechLoadBalancerType = ClosedEnum<
  typeof CreateSpeechLoadBalancerType
>;

export type CreateSpeechLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateSpeechLoadBalancer1 = {
  type: CreateSpeechLoadBalancerType;
  models: Array<CreateSpeechLoadBalancerModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateSpeechLoadBalancer = CreateSpeechLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateSpeechTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateSpeechOrq = {
  /**
   * Retry configuration for the request
   */
  retry?: CreateSpeechRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateSpeechFallbacks> | undefined;
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateSpeechContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateSpeechThread | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: CreateSpeechLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateSpeechTimeout | undefined;
};

/**
 * input
 */
export type CreateSpeechRequestBody = {
  /**
   * The text to generate audio for. The maximum length is 4096 characters
   */
  input: string;
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * The voice to use.
   *
   * @remarks
   *
   *  Available voices for OpenAI
   *
   *  `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`
   *
   *  Available voices for ElevenLabs
   *
   *  `aria`, `roger`, `sarah`, `laura`, `charlie`, `george`, `callum`, `river`, `liam`, `charlotte`, `alice`, `matilda`, `will`, `jessica`, `eric`, `chris`, `brian`, `daniel`, `lily`, `bill`
   */
  voice: string;
  /**
   * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
   */
  responseFormat?: CreateSpeechResponseFormat | undefined;
  /**
   * The speed of the generated audio.
   */
  speed?: number | undefined;
  orq?: CreateSpeechOrq | undefined;
};

/** @internal */
export const CreateSpeechResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateSpeechResponseFormat
> = z.nativeEnum(CreateSpeechResponseFormat);

/** @internal */
export type CreateSpeechRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateSpeechRetry$outboundSchema: z.ZodType<
  CreateSpeechRetry$Outbound,
  z.ZodTypeDef,
  CreateSpeechRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createSpeechRetryToJSON(
  createSpeechRetry: CreateSpeechRetry,
): string {
  return JSON.stringify(
    CreateSpeechRetry$outboundSchema.parse(createSpeechRetry),
  );
}

/** @internal */
export type CreateSpeechFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateSpeechFallbacks$outboundSchema: z.ZodType<
  CreateSpeechFallbacks$Outbound,
  z.ZodTypeDef,
  CreateSpeechFallbacks
> = z.object({
  model: z.string(),
});

export function createSpeechFallbacksToJSON(
  createSpeechFallbacks: CreateSpeechFallbacks,
): string {
  return JSON.stringify(
    CreateSpeechFallbacks$outboundSchema.parse(createSpeechFallbacks),
  );
}

/** @internal */
export type CreateSpeechContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateSpeechContact$outboundSchema: z.ZodType<
  CreateSpeechContact$Outbound,
  z.ZodTypeDef,
  CreateSpeechContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createSpeechContactToJSON(
  createSpeechContact: CreateSpeechContact,
): string {
  return JSON.stringify(
    CreateSpeechContact$outboundSchema.parse(createSpeechContact),
  );
}

/** @internal */
export type CreateSpeechThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateSpeechThread$outboundSchema: z.ZodType<
  CreateSpeechThread$Outbound,
  z.ZodTypeDef,
  CreateSpeechThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createSpeechThreadToJSON(
  createSpeechThread: CreateSpeechThread,
): string {
  return JSON.stringify(
    CreateSpeechThread$outboundSchema.parse(createSpeechThread),
  );
}

/** @internal */
export const CreateSpeechLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateSpeechLoadBalancerType
> = z.nativeEnum(CreateSpeechLoadBalancerType);

/** @internal */
export type CreateSpeechLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateSpeechLoadBalancerModels$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createSpeechLoadBalancerModelsToJSON(
  createSpeechLoadBalancerModels: CreateSpeechLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancerModels$outboundSchema.parse(
      createSpeechLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateSpeechLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateSpeechLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateSpeechLoadBalancer1$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancer1
> = z.object({
  type: CreateSpeechLoadBalancerType$outboundSchema,
  models: z.array(z.lazy(() => CreateSpeechLoadBalancerModels$outboundSchema)),
});

export function createSpeechLoadBalancer1ToJSON(
  createSpeechLoadBalancer1: CreateSpeechLoadBalancer1,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancer1$outboundSchema.parse(createSpeechLoadBalancer1),
  );
}

/** @internal */
export type CreateSpeechLoadBalancer$Outbound =
  CreateSpeechLoadBalancer1$Outbound;

/** @internal */
export const CreateSpeechLoadBalancer$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancer
> = z.lazy(() => CreateSpeechLoadBalancer1$outboundSchema);

export function createSpeechLoadBalancerToJSON(
  createSpeechLoadBalancer: CreateSpeechLoadBalancer,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancer$outboundSchema.parse(createSpeechLoadBalancer),
  );
}

/** @internal */
export type CreateSpeechTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateSpeechTimeout$outboundSchema: z.ZodType<
  CreateSpeechTimeout$Outbound,
  z.ZodTypeDef,
  CreateSpeechTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createSpeechTimeoutToJSON(
  createSpeechTimeout: CreateSpeechTimeout,
): string {
  return JSON.stringify(
    CreateSpeechTimeout$outboundSchema.parse(createSpeechTimeout),
  );
}

/** @internal */
export type CreateSpeechOrq$Outbound = {
  retry?: CreateSpeechRetry$Outbound | undefined;
  fallbacks?: Array<CreateSpeechFallbacks$Outbound> | undefined;
  name?: string | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateSpeechContact$Outbound | undefined;
  thread?: CreateSpeechThread$Outbound | undefined;
  load_balancer?: CreateSpeechLoadBalancer1$Outbound | undefined;
  timeout?: CreateSpeechTimeout$Outbound | undefined;
};

/** @internal */
export const CreateSpeechOrq$outboundSchema: z.ZodType<
  CreateSpeechOrq$Outbound,
  z.ZodTypeDef,
  CreateSpeechOrq
> = z.object({
  retry: z.lazy(() => CreateSpeechRetry$outboundSchema).optional(),
  fallbacks: z.array(z.lazy(() => CreateSpeechFallbacks$outboundSchema))
    .optional(),
  name: z.string().optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateSpeechContact$outboundSchema).optional(),
  thread: z.lazy(() => CreateSpeechThread$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateSpeechLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateSpeechTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createSpeechOrqToJSON(
  createSpeechOrq: CreateSpeechOrq,
): string {
  return JSON.stringify(CreateSpeechOrq$outboundSchema.parse(createSpeechOrq));
}

/** @internal */
export type CreateSpeechRequestBody$Outbound = {
  input: string;
  model: string;
  voice: string;
  response_format: string;
  speed: number;
  orq?: CreateSpeechOrq$Outbound | undefined;
};

/** @internal */
export const CreateSpeechRequestBody$outboundSchema: z.ZodType<
  CreateSpeechRequestBody$Outbound,
  z.ZodTypeDef,
  CreateSpeechRequestBody
> = z.object({
  input: z.string(),
  model: z.string(),
  voice: z.string(),
  responseFormat: CreateSpeechResponseFormat$outboundSchema.default("mp3"),
  speed: z.number().default(1),
  orq: z.lazy(() => CreateSpeechOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    responseFormat: "response_format",
  });
});

export function createSpeechRequestBodyToJSON(
  createSpeechRequestBody: CreateSpeechRequestBody,
): string {
  return JSON.stringify(
    CreateSpeechRequestBody$outboundSchema.parse(createSpeechRequestBody),
  );
}
