/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAgentRequest = {
  /**
   * The unique key of the agent to retrieve
   */
  agentKey: string;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAgentStatus = ClosedEnum<typeof GetAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const GetAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type GetAgentToolApprovalRequired = ClosedEnum<
  typeof GetAgentToolApprovalRequired
>;

export type GetAgentConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type GetAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<GetAgentConditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type GetAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: GetAgentToolApprovalRequired | undefined;
  tools?: Array<GetAgentTools> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const GetAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type GetAgentVoice = ClosedEnum<typeof GetAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const GetAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type GetAgentFormat = ClosedEnum<typeof GetAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type GetAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: GetAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: GetAgentFormat;
};

export const GetAgentResponseFormatAgentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type GetAgentResponseFormatAgentsResponseType = ClosedEnum<
  typeof GetAgentResponseFormatAgentsResponseType
>;

export type GetAgentResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type GetAgentResponseFormat3 = {
  type: GetAgentResponseFormatAgentsResponseType;
  jsonSchema: GetAgentResponseFormatJsonSchema;
};

export const GetAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type GetAgentResponseFormatAgentsType = ClosedEnum<
  typeof GetAgentResponseFormatAgentsType
>;

export type GetAgentResponseFormat2 = {
  type: GetAgentResponseFormatAgentsType;
};

export const GetAgentResponseFormatType = {
  Text: "text",
} as const;
export type GetAgentResponseFormatType = ClosedEnum<
  typeof GetAgentResponseFormatType
>;

export type GetAgentResponseFormat1 = {
  type: GetAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type GetAgentResponseFormat =
  | GetAgentResponseFormat3
  | GetAgentResponseFormat1
  | GetAgentResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type GetAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type GetAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const GetAgentType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type GetAgentType = ClosedEnum<typeof GetAgentType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const GetAgentThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type GetAgentThinkingLevel = ClosedEnum<typeof GetAgentThinkingLevel>;

export type GetAgentThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: GetAgentType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: GetAgentThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const GetAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type GetAgentToolChoiceType = ClosedEnum<typeof GetAgentToolChoiceType>;

export type GetAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type GetAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: GetAgentToolChoiceType | undefined;
  function: GetAgentToolChoiceFunction;
};

export const GetAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type GetAgentToolChoice1 = ClosedEnum<typeof GetAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type GetAgentToolChoice = GetAgentToolChoice2 | GetAgentToolChoice1;

export const GetAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type GetAgentModalities = ClosedEnum<typeof GetAgentModalities>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type GetAgentWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
 */
export type GetAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: GetAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | GetAgentResponseFormat3
    | GetAgentResponseFormat1
    | GetAgentResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: GetAgentStreamOptions | null | undefined;
  thinking?: GetAgentThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: GetAgentToolChoice2 | GetAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<GetAgentModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: GetAgentWebSearchOptions | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const GetAgentFallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type GetAgentFallbackModelsVoice = ClosedEnum<
  typeof GetAgentFallbackModelsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const GetAgentFallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type GetAgentFallbackModelsFormat = ClosedEnum<
  typeof GetAgentFallbackModelsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type GetAgentFallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: GetAgentFallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: GetAgentFallbackModelsFormat;
};

export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  >;

export type GetAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type GetAgentResponseFormatAgents3 = {
  type: GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType;
  jsonSchema: GetAgentResponseFormatAgentsJsonSchema;
};

export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType = {
  JsonObject: "json_object",
} as const;
export type GetAgentResponseFormatAgentsResponse200ApplicationJSONType =
  ClosedEnum<typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType>;

export type GetAgentResponseFormatAgents2 = {
  type: GetAgentResponseFormatAgentsResponse200ApplicationJSONType;
};

export const GetAgentResponseFormatAgentsResponse200Type = {
  Text: "text",
} as const;
export type GetAgentResponseFormatAgentsResponse200Type = ClosedEnum<
  typeof GetAgentResponseFormatAgentsResponse200Type
>;

export type GetAgentResponseFormatAgents1 = {
  type: GetAgentResponseFormatAgentsResponse200Type;
};

/**
 * An object specifying the format that the model must output
 */
export type GetAgentFallbackModelsResponseFormat =
  | GetAgentResponseFormatAgents3
  | GetAgentResponseFormatAgents1
  | GetAgentResponseFormatAgents2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type GetAgentFallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type GetAgentFallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const GetAgentFallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type GetAgentFallbackModelsType = ClosedEnum<
  typeof GetAgentFallbackModelsType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const GetAgentFallbackModelsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type GetAgentFallbackModelsThinkingLevel = ClosedEnum<
  typeof GetAgentFallbackModelsThinkingLevel
>;

export type GetAgentFallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: GetAgentFallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: GetAgentFallbackModelsThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const GetAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type GetAgentToolChoiceAgentsType = ClosedEnum<
  typeof GetAgentToolChoiceAgentsType
>;

export type GetAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type GetAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: GetAgentToolChoiceAgentsType | undefined;
  function: GetAgentToolChoiceAgentsFunction;
};

export const GetAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type GetAgentToolChoiceAgents1 = ClosedEnum<
  typeof GetAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type GetAgentFallbackModelsToolChoice =
  | GetAgentToolChoiceAgents2
  | GetAgentToolChoiceAgents1;

export const GetAgentFallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type GetAgentFallbackModelsModalities = ClosedEnum<
  typeof GetAgentFallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type GetAgentFallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type GetAgentFallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: GetAgentFallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | GetAgentResponseFormatAgents3
    | GetAgentResponseFormatAgents1
    | GetAgentResponseFormatAgents2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: GetAgentFallbackModelsStreamOptions | null | undefined;
  thinking?: GetAgentFallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | GetAgentToolChoiceAgents2
    | GetAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<GetAgentFallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: GetAgentFallbackModelsWebSearchOptions | undefined;
};

export type GetAgentFallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: GetAgentFallbackModelsParameters | undefined;
};

export type GetAgentFallbackModels = GetAgentFallbackModels2 | string;

export type GetAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
   */
  parameters?: GetAgentParameters | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?: Array<GetAgentFallbackModels2 | string> | null | undefined;
};

export type GetAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type GetAgentMetrics = {
  totalCost?: number | undefined;
};

export type GetAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const GetAgentHiddenPanels = {
  Model: "model",
  Tools: "tools",
  KnowledgeBases: "knowledge_bases",
  Variables: "variables",
  RuntimeConstraints: "runtime_constraints",
} as const;
export type GetAgentHiddenPanels = ClosedEnum<typeof GetAgentHiddenPanels>;

/**
 * Agent retrieved successfully
 */
export type GetAgentResponseBody = {
  id: string;
  key: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAgentStatus;
  settings?: GetAgentSettings | undefined;
  model: GetAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<GetAgentTeamOfAgents>;
  metrics?: GetAgentMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<GetAgentKnowledgeBases> | undefined;
  /**
   * List of hidden collapsed panels in configuration. Duplicates are not allowed.
   */
  hiddenPanels?: Array<GetAgentHiddenPanels> | undefined;
};

/** @internal */
export const GetAgentRequest$inboundSchema: z.ZodType<
  GetAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
  });
});
/** @internal */
export type GetAgentRequest$Outbound = {
  agent_key: string;
};

/** @internal */
export const GetAgentRequest$outboundSchema: z.ZodType<
  GetAgentRequest$Outbound,
  z.ZodTypeDef,
  GetAgentRequest
> = z.object({
  agentKey: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
  });
});

export function getAgentRequestToJSON(
  getAgentRequest: GetAgentRequest,
): string {
  return JSON.stringify(GetAgentRequest$outboundSchema.parse(getAgentRequest));
}
export function getAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentRequest' from JSON`,
  );
}

/** @internal */
export const GetAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentStatus
> = z.nativeEnum(GetAgentStatus);
/** @internal */
export const GetAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentStatus
> = GetAgentStatus$inboundSchema;

/** @internal */
export const GetAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolApprovalRequired
> = z.nativeEnum(GetAgentToolApprovalRequired);
/** @internal */
export const GetAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolApprovalRequired
> = GetAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const GetAgentConditions$inboundSchema: z.ZodType<
  GetAgentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type GetAgentConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const GetAgentConditions$outboundSchema: z.ZodType<
  GetAgentConditions$Outbound,
  z.ZodTypeDef,
  GetAgentConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function getAgentConditionsToJSON(
  getAgentConditions: GetAgentConditions,
): string {
  return JSON.stringify(
    GetAgentConditions$outboundSchema.parse(getAgentConditions),
  );
}
export function getAgentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentConditions' from JSON`,
  );
}

/** @internal */
export const GetAgentTools$inboundSchema: z.ZodType<
  GetAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => GetAgentConditions$inboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type GetAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<GetAgentConditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const GetAgentTools$outboundSchema: z.ZodType<
  GetAgentTools$Outbound,
  z.ZodTypeDef,
  GetAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => GetAgentConditions$outboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function getAgentToolsToJSON(getAgentTools: GetAgentTools): string {
  return JSON.stringify(GetAgentTools$outboundSchema.parse(getAgentTools));
}
export function getAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentTools' from JSON`,
  );
}

/** @internal */
export const GetAgentSettings$inboundSchema: z.ZodType<
  GetAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: GetAgentToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => GetAgentTools$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type GetAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<GetAgentTools$Outbound> | undefined;
};

/** @internal */
export const GetAgentSettings$outboundSchema: z.ZodType<
  GetAgentSettings$Outbound,
  z.ZodTypeDef,
  GetAgentSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: GetAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => GetAgentTools$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function getAgentSettingsToJSON(
  getAgentSettings: GetAgentSettings,
): string {
  return JSON.stringify(
    GetAgentSettings$outboundSchema.parse(getAgentSettings),
  );
}
export function getAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentSettings' from JSON`,
  );
}

/** @internal */
export const GetAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentVoice
> = z.nativeEnum(GetAgentVoice);
/** @internal */
export const GetAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentVoice
> = GetAgentVoice$inboundSchema;

/** @internal */
export const GetAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFormat
> = z.nativeEnum(GetAgentFormat);
/** @internal */
export const GetAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFormat
> = GetAgentFormat$inboundSchema;

/** @internal */
export const GetAgentAudio$inboundSchema: z.ZodType<
  GetAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: GetAgentVoice$inboundSchema,
  format: GetAgentFormat$inboundSchema,
});
/** @internal */
export type GetAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const GetAgentAudio$outboundSchema: z.ZodType<
  GetAgentAudio$Outbound,
  z.ZodTypeDef,
  GetAgentAudio
> = z.object({
  voice: GetAgentVoice$outboundSchema,
  format: GetAgentFormat$outboundSchema,
});

export function getAgentAudioToJSON(getAgentAudio: GetAgentAudio): string {
  return JSON.stringify(GetAgentAudio$outboundSchema.parse(getAgentAudio));
}
export function getAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentAudio' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponseType> = z
    .nativeEnum(GetAgentResponseFormatAgentsResponseType);
/** @internal */
export const GetAgentResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponseType> =
    GetAgentResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatJsonSchema$inboundSchema: z.ZodType<
  GetAgentResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type GetAgentResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const GetAgentResponseFormatJsonSchema$outboundSchema: z.ZodType<
  GetAgentResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function getAgentResponseFormatJsonSchemaToJSON(
  getAgentResponseFormatJsonSchema: GetAgentResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatJsonSchema$outboundSchema.parse(
      getAgentResponseFormatJsonSchema,
    ),
  );
}
export function getAgentResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormat3$inboundSchema: z.ZodType<
  GetAgentResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsResponseType$inboundSchema,
  json_schema: z.lazy(() => GetAgentResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type GetAgentResponseFormat3$Outbound = {
  type: string;
  json_schema: GetAgentResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const GetAgentResponseFormat3$outboundSchema: z.ZodType<
  GetAgentResponseFormat3$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormat3
> = z.object({
  type: GetAgentResponseFormatAgentsResponseType$outboundSchema,
  jsonSchema: z.lazy(() => GetAgentResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function getAgentResponseFormat3ToJSON(
  getAgentResponseFormat3: GetAgentResponseFormat3,
): string {
  return JSON.stringify(
    GetAgentResponseFormat3$outboundSchema.parse(getAgentResponseFormat3),
  );
}
export function getAgentResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormat3' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatAgentsType
> = z.nativeEnum(GetAgentResponseFormatAgentsType);
/** @internal */
export const GetAgentResponseFormatAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatAgentsType
> = GetAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const GetAgentResponseFormat2$inboundSchema: z.ZodType<
  GetAgentResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormat2$outboundSchema: z.ZodType<
  GetAgentResponseFormat2$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormat2
> = z.object({
  type: GetAgentResponseFormatAgentsType$outboundSchema,
});

export function getAgentResponseFormat2ToJSON(
  getAgentResponseFormat2: GetAgentResponseFormat2,
): string {
  return JSON.stringify(
    GetAgentResponseFormat2$outboundSchema.parse(getAgentResponseFormat2),
  );
}
export function getAgentResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormat2' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatType
> = z.nativeEnum(GetAgentResponseFormatType);
/** @internal */
export const GetAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatType
> = GetAgentResponseFormatType$inboundSchema;

/** @internal */
export const GetAgentResponseFormat1$inboundSchema: z.ZodType<
  GetAgentResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormat1$outboundSchema: z.ZodType<
  GetAgentResponseFormat1$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormat1
> = z.object({
  type: GetAgentResponseFormatType$outboundSchema,
});

export function getAgentResponseFormat1ToJSON(
  getAgentResponseFormat1: GetAgentResponseFormat1,
): string {
  return JSON.stringify(
    GetAgentResponseFormat1$outboundSchema.parse(getAgentResponseFormat1),
  );
}
export function getAgentResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormat1' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormat$inboundSchema: z.ZodType<
  GetAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentResponseFormat3$inboundSchema),
  z.lazy(() => GetAgentResponseFormat1$inboundSchema),
  z.lazy(() => GetAgentResponseFormat2$inboundSchema),
]);
/** @internal */
export type GetAgentResponseFormat$Outbound =
  | GetAgentResponseFormat3$Outbound
  | GetAgentResponseFormat1$Outbound
  | GetAgentResponseFormat2$Outbound;

/** @internal */
export const GetAgentResponseFormat$outboundSchema: z.ZodType<
  GetAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormat
> = z.union([
  z.lazy(() => GetAgentResponseFormat3$outboundSchema),
  z.lazy(() => GetAgentResponseFormat1$outboundSchema),
  z.lazy(() => GetAgentResponseFormat2$outboundSchema),
]);

export function getAgentResponseFormatToJSON(
  getAgentResponseFormat: GetAgentResponseFormat,
): string {
  return JSON.stringify(
    GetAgentResponseFormat$outboundSchema.parse(getAgentResponseFormat),
  );
}
export function getAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAgentStop$inboundSchema: z.ZodType<
  GetAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type GetAgentStop$Outbound = string | Array<string>;

/** @internal */
export const GetAgentStop$outboundSchema: z.ZodType<
  GetAgentStop$Outbound,
  z.ZodTypeDef,
  GetAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function getAgentStopToJSON(getAgentStop: GetAgentStop): string {
  return JSON.stringify(GetAgentStop$outboundSchema.parse(getAgentStop));
}
export function getAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentStop' from JSON`,
  );
}

/** @internal */
export const GetAgentStreamOptions$inboundSchema: z.ZodType<
  GetAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type GetAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const GetAgentStreamOptions$outboundSchema: z.ZodType<
  GetAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  GetAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function getAgentStreamOptionsToJSON(
  getAgentStreamOptions: GetAgentStreamOptions,
): string {
  return JSON.stringify(
    GetAgentStreamOptions$outboundSchema.parse(getAgentStreamOptions),
  );
}
export function getAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentType$inboundSchema: z.ZodNativeEnum<typeof GetAgentType> =
  z.nativeEnum(GetAgentType);
/** @internal */
export const GetAgentType$outboundSchema: z.ZodNativeEnum<typeof GetAgentType> =
  GetAgentType$inboundSchema;

/** @internal */
export const GetAgentThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentThinkingLevel
> = z.nativeEnum(GetAgentThinkingLevel);
/** @internal */
export const GetAgentThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentThinkingLevel
> = GetAgentThinkingLevel$inboundSchema;

/** @internal */
export const GetAgentThinking$inboundSchema: z.ZodType<
  GetAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: GetAgentThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type GetAgentThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const GetAgentThinking$outboundSchema: z.ZodType<
  GetAgentThinking$Outbound,
  z.ZodTypeDef,
  GetAgentThinking
> = z.object({
  type: GetAgentType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: GetAgentThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function getAgentThinkingToJSON(
  getAgentThinking: GetAgentThinking,
): string {
  return JSON.stringify(
    GetAgentThinking$outboundSchema.parse(getAgentThinking),
  );
}
export function getAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentThinking' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceType
> = z.nativeEnum(GetAgentToolChoiceType);
/** @internal */
export const GetAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceType
> = GetAgentToolChoiceType$inboundSchema;

/** @internal */
export const GetAgentToolChoiceFunction$inboundSchema: z.ZodType<
  GetAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type GetAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const GetAgentToolChoiceFunction$outboundSchema: z.ZodType<
  GetAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function getAgentToolChoiceFunctionToJSON(
  getAgentToolChoiceFunction: GetAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    GetAgentToolChoiceFunction$outboundSchema.parse(getAgentToolChoiceFunction),
  );
}
export function getAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoice2$inboundSchema: z.ZodType<
  GetAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type GetAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: GetAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const GetAgentToolChoice2$outboundSchema: z.ZodType<
  GetAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoice2
> = z.object({
  type: GetAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceFunction$outboundSchema),
});

export function getAgentToolChoice2ToJSON(
  getAgentToolChoice2: GetAgentToolChoice2,
): string {
  return JSON.stringify(
    GetAgentToolChoice2$outboundSchema.parse(getAgentToolChoice2),
  );
}
export function getAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoice1
> = z.nativeEnum(GetAgentToolChoice1);
/** @internal */
export const GetAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoice1
> = GetAgentToolChoice1$inboundSchema;

/** @internal */
export const GetAgentToolChoice$inboundSchema: z.ZodType<
  GetAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentToolChoice2$inboundSchema),
  GetAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type GetAgentToolChoice$Outbound = GetAgentToolChoice2$Outbound | string;

/** @internal */
export const GetAgentToolChoice$outboundSchema: z.ZodType<
  GetAgentToolChoice$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoice
> = z.union([
  z.lazy(() => GetAgentToolChoice2$outboundSchema),
  GetAgentToolChoice1$outboundSchema,
]);

export function getAgentToolChoiceToJSON(
  getAgentToolChoice: GetAgentToolChoice,
): string {
  return JSON.stringify(
    GetAgentToolChoice$outboundSchema.parse(getAgentToolChoice),
  );
}
export function getAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const GetAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentModalities
> = z.nativeEnum(GetAgentModalities);
/** @internal */
export const GetAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentModalities
> = GetAgentModalities$inboundSchema;

/** @internal */
export const GetAgentWebSearchOptions$inboundSchema: z.ZodType<
  GetAgentWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type GetAgentWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const GetAgentWebSearchOptions$outboundSchema: z.ZodType<
  GetAgentWebSearchOptions$Outbound,
  z.ZodTypeDef,
  GetAgentWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function getAgentWebSearchOptionsToJSON(
  getAgentWebSearchOptions: GetAgentWebSearchOptions,
): string {
  return JSON.stringify(
    GetAgentWebSearchOptions$outboundSchema.parse(getAgentWebSearchOptions),
  );
}
export function getAgentWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentParameters$inboundSchema: z.ZodType<
  GetAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => GetAgentResponseFormat3$inboundSchema),
    z.lazy(() => GetAgentResponseFormat1$inboundSchema),
    z.lazy(() => GetAgentResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(z.lazy(() => GetAgentStreamOptions$inboundSchema))
    .optional(),
  thinking: z.lazy(() => GetAgentThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => GetAgentToolChoice2$inboundSchema),
    GetAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(GetAgentModalities$inboundSchema)).optional(),
  web_search_options: z.lazy(() => GetAgentWebSearchOptions$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type GetAgentParameters$Outbound = {
  audio?: GetAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | GetAgentResponseFormat3$Outbound
    | GetAgentResponseFormat1$Outbound
    | GetAgentResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: GetAgentStreamOptions$Outbound | null | undefined;
  thinking?: GetAgentThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: GetAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: GetAgentWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const GetAgentParameters$outboundSchema: z.ZodType<
  GetAgentParameters$Outbound,
  z.ZodTypeDef,
  GetAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => GetAgentResponseFormat3$outboundSchema),
    z.lazy(() => GetAgentResponseFormat1$outboundSchema),
    z.lazy(() => GetAgentResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => GetAgentStreamOptions$outboundSchema))
    .optional(),
  thinking: z.lazy(() => GetAgentThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => GetAgentToolChoice2$outboundSchema),
    GetAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(GetAgentModalities$outboundSchema)).optional(),
  webSearchOptions: z.lazy(() => GetAgentWebSearchOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function getAgentParametersToJSON(
  getAgentParameters: GetAgentParameters,
): string {
  return JSON.stringify(
    GetAgentParameters$outboundSchema.parse(getAgentParameters),
  );
}
export function getAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentParameters' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsVoice
> = z.nativeEnum(GetAgentFallbackModelsVoice);
/** @internal */
export const GetAgentFallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsVoice
> = GetAgentFallbackModelsVoice$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsFormat
> = z.nativeEnum(GetAgentFallbackModelsFormat);
/** @internal */
export const GetAgentFallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsFormat
> = GetAgentFallbackModelsFormat$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsAudio$inboundSchema: z.ZodType<
  GetAgentFallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: GetAgentFallbackModelsVoice$inboundSchema,
  format: GetAgentFallbackModelsFormat$inboundSchema,
});
/** @internal */
export type GetAgentFallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const GetAgentFallbackModelsAudio$outboundSchema: z.ZodType<
  GetAgentFallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsAudio
> = z.object({
  voice: GetAgentFallbackModelsVoice$outboundSchema,
  format: GetAgentFallbackModelsFormat$outboundSchema,
});

export function getAgentFallbackModelsAudioToJSON(
  getAgentFallbackModelsAudio: GetAgentFallbackModelsAudio,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsAudio$outboundSchema.parse(
      getAgentFallbackModelsAudio,
    ),
  );
}
export function getAgentFallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > =
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type GetAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const GetAgentResponseFormatAgentsJsonSchema$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJsonSchema$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgentsJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function getAgentResponseFormatAgentsJsonSchemaToJSON(
  getAgentResponseFormatAgentsJsonSchema:
    GetAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      getAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function getAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgentsJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgents3$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgents3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  json_schema: z.lazy(() =>
    GetAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type GetAgentResponseFormatAgents3$Outbound = {
  type: string;
  json_schema: GetAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const GetAgentResponseFormatAgents3$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgents3$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgents3
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  jsonSchema: z.lazy(() =>
    GetAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function getAgentResponseFormatAgents3ToJSON(
  getAgentResponseFormatAgents3: GetAgentResponseFormatAgents3,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgents3$outboundSchema.parse(
      getAgentResponseFormatAgents3,
    ),
  );
}
export function getAgentResponseFormatAgents3FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgents3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatAgents3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgents3' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType
  > = z.nativeEnum(GetAgentResponseFormatAgentsResponse200ApplicationJSONType);
/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType
  > = GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgents2$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatAgents2$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatAgents2$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgents2$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgents2
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema,
});

export function getAgentResponseFormatAgents2ToJSON(
  getAgentResponseFormatAgents2: GetAgentResponseFormatAgents2,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgents2$outboundSchema.parse(
      getAgentResponseFormatAgents2,
    ),
  );
}
export function getAgentResponseFormatAgents2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgents2' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponse200Type> = z
    .nativeEnum(GetAgentResponseFormatAgentsResponse200Type);
/** @internal */
export const GetAgentResponseFormatAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponse200Type> =
    GetAgentResponseFormatAgentsResponse200Type$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgents1$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsResponse200Type$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatAgents1$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatAgents1$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgents1$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgents1
> = z.object({
  type: GetAgentResponseFormatAgentsResponse200Type$outboundSchema,
});

export function getAgentResponseFormatAgents1ToJSON(
  getAgentResponseFormatAgents1: GetAgentResponseFormatAgents1,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgents1$outboundSchema.parse(
      getAgentResponseFormatAgents1,
    ),
  );
}
export function getAgentResponseFormatAgents1FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgents1' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsResponseFormat$inboundSchema: z.ZodType<
  GetAgentFallbackModelsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentResponseFormatAgents3$inboundSchema),
  z.lazy(() => GetAgentResponseFormatAgents1$inboundSchema),
  z.lazy(() => GetAgentResponseFormatAgents2$inboundSchema),
]);
/** @internal */
export type GetAgentFallbackModelsResponseFormat$Outbound =
  | GetAgentResponseFormatAgents3$Outbound
  | GetAgentResponseFormatAgents1$Outbound
  | GetAgentResponseFormatAgents2$Outbound;

/** @internal */
export const GetAgentFallbackModelsResponseFormat$outboundSchema: z.ZodType<
  GetAgentFallbackModelsResponseFormat$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsResponseFormat
> = z.union([
  z.lazy(() => GetAgentResponseFormatAgents3$outboundSchema),
  z.lazy(() => GetAgentResponseFormatAgents1$outboundSchema),
  z.lazy(() => GetAgentResponseFormatAgents2$outboundSchema),
]);

export function getAgentFallbackModelsResponseFormatToJSON(
  getAgentFallbackModelsResponseFormat: GetAgentFallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsResponseFormat$outboundSchema.parse(
      getAgentFallbackModelsResponseFormat,
    ),
  );
}
export function getAgentFallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsStop$inboundSchema: z.ZodType<
  GetAgentFallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type GetAgentFallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const GetAgentFallbackModelsStop$outboundSchema: z.ZodType<
  GetAgentFallbackModelsStop$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function getAgentFallbackModelsStopToJSON(
  getAgentFallbackModelsStop: GetAgentFallbackModelsStop,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsStop$outboundSchema.parse(getAgentFallbackModelsStop),
  );
}
export function getAgentFallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsStreamOptions$inboundSchema: z.ZodType<
  GetAgentFallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type GetAgentFallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const GetAgentFallbackModelsStreamOptions$outboundSchema: z.ZodType<
  GetAgentFallbackModelsStreamOptions$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function getAgentFallbackModelsStreamOptionsToJSON(
  getAgentFallbackModelsStreamOptions: GetAgentFallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsStreamOptions$outboundSchema.parse(
      getAgentFallbackModelsStreamOptions,
    ),
  );
}
export function getAgentFallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsType
> = z.nativeEnum(GetAgentFallbackModelsType);
/** @internal */
export const GetAgentFallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsType
> = GetAgentFallbackModelsType$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsThinkingLevel
> = z.nativeEnum(GetAgentFallbackModelsThinkingLevel);
/** @internal */
export const GetAgentFallbackModelsThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelsThinkingLevel> =
    GetAgentFallbackModelsThinkingLevel$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsThinking$inboundSchema: z.ZodType<
  GetAgentFallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentFallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: GetAgentFallbackModelsThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type GetAgentFallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const GetAgentFallbackModelsThinking$outboundSchema: z.ZodType<
  GetAgentFallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsThinking
> = z.object({
  type: GetAgentFallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: GetAgentFallbackModelsThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function getAgentFallbackModelsThinkingToJSON(
  getAgentFallbackModelsThinking: GetAgentFallbackModelsThinking,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsThinking$outboundSchema.parse(
      getAgentFallbackModelsThinking,
    ),
  );
}
export function getAgentFallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgentsType
> = z.nativeEnum(GetAgentToolChoiceAgentsType);
/** @internal */
export const GetAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgentsType
> = GetAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const GetAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  GetAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type GetAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const GetAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  GetAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function getAgentToolChoiceAgentsFunctionToJSON(
  getAgentToolChoiceAgentsFunction: GetAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    GetAgentToolChoiceAgentsFunction$outboundSchema.parse(
      getAgentToolChoiceAgentsFunction,
    ),
  );
}
export function getAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  GetAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type GetAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: GetAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const GetAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  GetAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceAgents2
> = z.object({
  type: GetAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceAgentsFunction$outboundSchema),
});

export function getAgentToolChoiceAgents2ToJSON(
  getAgentToolChoiceAgents2: GetAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    GetAgentToolChoiceAgents2$outboundSchema.parse(getAgentToolChoiceAgents2),
  );
}
export function getAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgents1
> = z.nativeEnum(GetAgentToolChoiceAgents1);
/** @internal */
export const GetAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgents1
> = GetAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsToolChoice$inboundSchema: z.ZodType<
  GetAgentFallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentToolChoiceAgents2$inboundSchema),
  GetAgentToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type GetAgentFallbackModelsToolChoice$Outbound =
  | GetAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const GetAgentFallbackModelsToolChoice$outboundSchema: z.ZodType<
  GetAgentFallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsToolChoice
> = z.union([
  z.lazy(() => GetAgentToolChoiceAgents2$outboundSchema),
  GetAgentToolChoiceAgents1$outboundSchema,
]);

export function getAgentFallbackModelsToolChoiceToJSON(
  getAgentFallbackModelsToolChoice: GetAgentFallbackModelsToolChoice,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsToolChoice$outboundSchema.parse(
      getAgentFallbackModelsToolChoice,
    ),
  );
}
export function getAgentFallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsModalities$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsModalities
> = z.nativeEnum(GetAgentFallbackModelsModalities);
/** @internal */
export const GetAgentFallbackModelsModalities$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFallbackModelsModalities
> = GetAgentFallbackModelsModalities$inboundSchema;

/** @internal */
export const GetAgentFallbackModelsWebSearchOptions$inboundSchema: z.ZodType<
  GetAgentFallbackModelsWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type GetAgentFallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const GetAgentFallbackModelsWebSearchOptions$outboundSchema: z.ZodType<
  GetAgentFallbackModelsWebSearchOptions$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function getAgentFallbackModelsWebSearchOptionsToJSON(
  getAgentFallbackModelsWebSearchOptions:
    GetAgentFallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsWebSearchOptions$outboundSchema.parse(
      getAgentFallbackModelsWebSearchOptions,
    ),
  );
}
export function getAgentFallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelsWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelsParameters$inboundSchema: z.ZodType<
  GetAgentFallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentFallbackModelsAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => GetAgentResponseFormatAgents3$inboundSchema),
    z.lazy(() => GetAgentResponseFormatAgents1$inboundSchema),
    z.lazy(() => GetAgentResponseFormatAgents2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => GetAgentFallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => GetAgentFallbackModelsThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => GetAgentToolChoiceAgents2$inboundSchema),
    GetAgentToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(GetAgentFallbackModelsModalities$inboundSchema),
  ).optional(),
  web_search_options: z.lazy(() =>
    GetAgentFallbackModelsWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type GetAgentFallbackModelsParameters$Outbound = {
  audio?: GetAgentFallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | GetAgentResponseFormatAgents3$Outbound
    | GetAgentResponseFormatAgents1$Outbound
    | GetAgentResponseFormatAgents2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | GetAgentFallbackModelsStreamOptions$Outbound
    | null
    | undefined;
  thinking?: GetAgentFallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: GetAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?:
    | GetAgentFallbackModelsWebSearchOptions$Outbound
    | undefined;
};

/** @internal */
export const GetAgentFallbackModelsParameters$outboundSchema: z.ZodType<
  GetAgentFallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelsParameters
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentFallbackModelsAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => GetAgentResponseFormatAgents3$outboundSchema),
    z.lazy(() => GetAgentResponseFormatAgents1$outboundSchema),
    z.lazy(() => GetAgentResponseFormatAgents2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => GetAgentFallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => GetAgentFallbackModelsThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => GetAgentToolChoiceAgents2$outboundSchema),
    GetAgentToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(GetAgentFallbackModelsModalities$outboundSchema),
  ).optional(),
  webSearchOptions: z.lazy(() =>
    GetAgentFallbackModelsWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function getAgentFallbackModelsParametersToJSON(
  getAgentFallbackModelsParameters: GetAgentFallbackModelsParameters,
): string {
  return JSON.stringify(
    GetAgentFallbackModelsParameters$outboundSchema.parse(
      getAgentFallbackModelsParameters,
    ),
  );
}
export function getAgentFallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModels2$inboundSchema: z.ZodType<
  GetAgentFallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentFallbackModelsParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type GetAgentFallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: GetAgentFallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const GetAgentFallbackModels2$outboundSchema: z.ZodType<
  GetAgentFallbackModels2$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentFallbackModelsParameters$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function getAgentFallbackModels2ToJSON(
  getAgentFallbackModels2: GetAgentFallbackModels2,
): string {
  return JSON.stringify(
    GetAgentFallbackModels2$outboundSchema.parse(getAgentFallbackModels2),
  );
}
export function getAgentFallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModels2' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModels$inboundSchema: z.ZodType<
  GetAgentFallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => GetAgentFallbackModels2$inboundSchema), z.string()]);
/** @internal */
export type GetAgentFallbackModels$Outbound =
  | GetAgentFallbackModels2$Outbound
  | string;

/** @internal */
export const GetAgentFallbackModels$outboundSchema: z.ZodType<
  GetAgentFallbackModels$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModels
> = z.union([z.lazy(() => GetAgentFallbackModels2$outboundSchema), z.string()]);

export function getAgentFallbackModelsToJSON(
  getAgentFallbackModels: GetAgentFallbackModels,
): string {
  return JSON.stringify(
    GetAgentFallbackModels$outboundSchema.parse(getAgentFallbackModels),
  );
}
export function getAgentFallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentFallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModels' from JSON`,
  );
}

/** @internal */
export const GetAgentModel$inboundSchema: z.ZodType<
  GetAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentParameters$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => GetAgentFallbackModels2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type GetAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: GetAgentParameters$Outbound | undefined;
  fallback_models?:
    | Array<GetAgentFallbackModels2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const GetAgentModel$outboundSchema: z.ZodType<
  GetAgentModel$Outbound,
  z.ZodTypeDef,
  GetAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentParameters$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => GetAgentFallbackModels2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function getAgentModelToJSON(getAgentModel: GetAgentModel): string {
  return JSON.stringify(GetAgentModel$outboundSchema.parse(getAgentModel));
}
export function getAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentModel' from JSON`,
  );
}

/** @internal */
export const GetAgentTeamOfAgents$inboundSchema: z.ZodType<
  GetAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type GetAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const GetAgentTeamOfAgents$outboundSchema: z.ZodType<
  GetAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  GetAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function getAgentTeamOfAgentsToJSON(
  getAgentTeamOfAgents: GetAgentTeamOfAgents,
): string {
  return JSON.stringify(
    GetAgentTeamOfAgents$outboundSchema.parse(getAgentTeamOfAgents),
  );
}
export function getAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const GetAgentMetrics$inboundSchema: z.ZodType<
  GetAgentMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type GetAgentMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const GetAgentMetrics$outboundSchema: z.ZodType<
  GetAgentMetrics$Outbound,
  z.ZodTypeDef,
  GetAgentMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function getAgentMetricsToJSON(
  getAgentMetrics: GetAgentMetrics,
): string {
  return JSON.stringify(GetAgentMetrics$outboundSchema.parse(getAgentMetrics));
}
export function getAgentMetricsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentMetrics' from JSON`,
  );
}

/** @internal */
export const GetAgentKnowledgeBases$inboundSchema: z.ZodType<
  GetAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type GetAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const GetAgentKnowledgeBases$outboundSchema: z.ZodType<
  GetAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  GetAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function getAgentKnowledgeBasesToJSON(
  getAgentKnowledgeBases: GetAgentKnowledgeBases,
): string {
  return JSON.stringify(
    GetAgentKnowledgeBases$outboundSchema.parse(getAgentKnowledgeBases),
  );
}
export function getAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const GetAgentHiddenPanels$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentHiddenPanels
> = z.nativeEnum(GetAgentHiddenPanels);
/** @internal */
export const GetAgentHiddenPanels$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentHiddenPanels
> = GetAgentHiddenPanels$inboundSchema;

/** @internal */
export const GetAgentResponseBody$inboundSchema: z.ZodType<
  GetAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: GetAgentStatus$inboundSchema,
  settings: z.lazy(() => GetAgentSettings$inboundSchema).optional(),
  model: z.lazy(() => GetAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => GetAgentTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => GetAgentMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(z.lazy(() => GetAgentKnowledgeBases$inboundSchema))
    .optional(),
  hidden_panels: z.array(GetAgentHiddenPanels$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
    "hidden_panels": "hiddenPanels",
  });
});
/** @internal */
export type GetAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: GetAgentSettings$Outbound | undefined;
  model: GetAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<GetAgentTeamOfAgents$Outbound>;
  metrics?: GetAgentMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<GetAgentKnowledgeBases$Outbound> | undefined;
  hidden_panels?: Array<string> | undefined;
};

/** @internal */
export const GetAgentResponseBody$outboundSchema: z.ZodType<
  GetAgentResponseBody$Outbound,
  z.ZodTypeDef,
  GetAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: GetAgentStatus$outboundSchema,
  settings: z.lazy(() => GetAgentSettings$outboundSchema).optional(),
  model: z.lazy(() => GetAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(z.lazy(() => GetAgentTeamOfAgents$outboundSchema)),
  metrics: z.lazy(() => GetAgentMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(z.lazy(() => GetAgentKnowledgeBases$outboundSchema))
    .optional(),
  hiddenPanels: z.array(GetAgentHiddenPanels$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
    hiddenPanels: "hidden_panels",
  });
});

export function getAgentResponseBodyToJSON(
  getAgentResponseBody: GetAgentResponseBody,
): string {
  return JSON.stringify(
    GetAgentResponseBody$outboundSchema.parse(getAgentResponseBody),
  );
}
export function getAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseBody' from JSON`,
  );
}
