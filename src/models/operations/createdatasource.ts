/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Provides advanced settings for customizing chunking behavior, enabling fine-grained control to better meet specific data processing needs.
 */
export type ChunkingConfiguration2 = {
  type: "advanced";
  /**
   * Defines the absolute maximum character length per chunk. Text elements exceeding this size will be automatically split into multiple chunks.
   */
  chunkMaxCharacters?: number | undefined;
  /**
   * Specifies the number of characters to overlap between consecutive chunks. This overlap helps maintain semantic continuity when splitting large text elements.
   */
  chunkOverlap?: number | undefined;
};

/**
 * Optimized chunking strategy focusing on speed and avoiding duplication of content chunks.
 */
export type ChunkingConfiguration1 = {
  type: "default";
};

/**
 * The chunking configuration settings for the datasource. Defaults to the system's standard chunking configuration if not specified.
 */
export type ChunkingConfiguration =
  | ChunkingConfiguration1
  | ChunkingConfiguration2;

/**
 * The cleanup options applied to the datasource content. All options are enabled by default to ensure enhanced security and optimal chunk quality. Defaults to system-standard cleanup options if not specified.
 */
export type ChunkingCleanupOptions = {
  /**
   * Removes email addresses from the provided text.
   */
  deleteEmails?: boolean | undefined;
  /**
   * Removes credit card numbers from the provided text.
   */
  deleteCreditCards?: boolean | undefined;
  /**
   * Removes phone numbers from the provided text.
   */
  deletePhoneNumbers?: boolean | undefined;
  /**
   * Removes bullet points formatting from the text.
   */
  cleanBulletPoints?: boolean | undefined;
  /**
   * Removes numbered list formatting from the text.
   */
  cleanNumberedList?: boolean | undefined;
  /**
   * Normalizes or removes unnecessary unicode characters from the text.
   */
  cleanUnicode?: boolean | undefined;
  /**
   * Normalizes or removes various dash characters to standardize the text.
   */
  cleanDashes?: boolean | undefined;
  /**
   * Trims and normalizes excessive whitespace throughout the text.
   */
  cleanWhitespaces?: boolean | undefined;
};

/**
 * Configuration options specifying how the datasource file is chunked. Required if `file_id` is specified. Defaults to standard chunking options if omitted.
 */
export type ChunkingOptions = {
  /**
   * The chunking configuration settings for the datasource. Defaults to the system's standard chunking configuration if not specified.
   */
  chunkingConfiguration?:
    | ChunkingConfiguration1
    | ChunkingConfiguration2
    | undefined;
  /**
   * The cleanup options applied to the datasource content. All options are enabled by default to ensure enhanced security and optimal chunk quality. Defaults to system-standard cleanup options if not specified.
   */
  chunkingCleanupOptions?: ChunkingCleanupOptions | undefined;
};

export type CreateDatasourceRequestBody = {
  /**
   * The display name for the datasource visible in the UI. If omitted, the display name is derived from the uploaded file. When both `display_name` and `file_id` are provided, the provided `display_name` is prioritized.
   */
  displayName?: string | undefined;
  /**
   * The unique identifier of the file used for datasource creation. If provided, the file is immediately queued for chunking.
   */
  fileId?: string | undefined;
  /**
   * Configuration options specifying how the datasource file is chunked. Required if `file_id` is specified. Defaults to standard chunking options if omitted.
   */
  chunkingOptions?: ChunkingOptions | undefined;
};

export type CreateDatasourceRequest = {
  /**
   * The unique identifier of the knowledge base
   */
  knowledgeId: string;
  requestBody: CreateDatasourceRequestBody;
};

export const CreateDatasourceStatus = {
  Pending: "pending",
  Processing: "processing",
  Completed: "completed",
  Failed: "failed",
  Queued: "queued",
} as const;
export type CreateDatasourceStatus = ClosedEnum<typeof CreateDatasourceStatus>;

/**
 * Datasource successfully created
 */
export type CreateDatasourceResponseBody = {
  /**
   * The unique identifier of the data source
   */
  id: string;
  /**
   * The display name of the datasource. Normally the name of the uploaded file
   */
  displayName: string;
  /**
   * The description of the knowledge base
   */
  description?: string | undefined;
  status: CreateDatasourceStatus;
  /**
   * The unique identifier of the file used to create the datasource.
   */
  fileId?: string | null | undefined;
  /**
   * The date and time the datasource was created
   */
  created: string;
  /**
   * The date and time the datasource was updated
   */
  updated: string;
  /**
   * The user ID of the creator of the knowledge base
   */
  createdById?: string | null | undefined;
  /**
   * The user ID of the last user who updated the knowledge base
   */
  updateById?: string | null | undefined;
  /**
   * The unique identifier of the knowledge base
   */
  knowledgeId: string;
  /**
   * The number of chunks in the datasource
   */
  chunksCount: number;
};

/** @internal */
export type ChunkingConfiguration2$Outbound = {
  type: "advanced";
  chunk_max_characters: number;
  chunk_overlap: number;
};

/** @internal */
export const ChunkingConfiguration2$outboundSchema: z.ZodType<
  ChunkingConfiguration2$Outbound,
  z.ZodTypeDef,
  ChunkingConfiguration2
> = z.object({
  type: z.literal("advanced"),
  chunkMaxCharacters: z.number().default(500),
  chunkOverlap: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    chunkMaxCharacters: "chunk_max_characters",
    chunkOverlap: "chunk_overlap",
  });
});

export function chunkingConfiguration2ToJSON(
  chunkingConfiguration2: ChunkingConfiguration2,
): string {
  return JSON.stringify(
    ChunkingConfiguration2$outboundSchema.parse(chunkingConfiguration2),
  );
}

/** @internal */
export type ChunkingConfiguration1$Outbound = {
  type: "default";
};

/** @internal */
export const ChunkingConfiguration1$outboundSchema: z.ZodType<
  ChunkingConfiguration1$Outbound,
  z.ZodTypeDef,
  ChunkingConfiguration1
> = z.object({
  type: z.literal("default"),
});

export function chunkingConfiguration1ToJSON(
  chunkingConfiguration1: ChunkingConfiguration1,
): string {
  return JSON.stringify(
    ChunkingConfiguration1$outboundSchema.parse(chunkingConfiguration1),
  );
}

/** @internal */
export type ChunkingConfiguration$Outbound =
  | ChunkingConfiguration1$Outbound
  | ChunkingConfiguration2$Outbound;

/** @internal */
export const ChunkingConfiguration$outboundSchema: z.ZodType<
  ChunkingConfiguration$Outbound,
  z.ZodTypeDef,
  ChunkingConfiguration
> = z.union([
  z.lazy(() => ChunkingConfiguration1$outboundSchema),
  z.lazy(() => ChunkingConfiguration2$outboundSchema),
]);

export function chunkingConfigurationToJSON(
  chunkingConfiguration: ChunkingConfiguration,
): string {
  return JSON.stringify(
    ChunkingConfiguration$outboundSchema.parse(chunkingConfiguration),
  );
}

/** @internal */
export type ChunkingCleanupOptions$Outbound = {
  delete_emails?: boolean | undefined;
  delete_credit_cards?: boolean | undefined;
  delete_phone_numbers?: boolean | undefined;
  clean_bullet_points?: boolean | undefined;
  clean_numbered_list?: boolean | undefined;
  clean_unicode?: boolean | undefined;
  clean_dashes?: boolean | undefined;
  clean_whitespaces?: boolean | undefined;
};

/** @internal */
export const ChunkingCleanupOptions$outboundSchema: z.ZodType<
  ChunkingCleanupOptions$Outbound,
  z.ZodTypeDef,
  ChunkingCleanupOptions
> = z.object({
  deleteEmails: z.boolean().optional(),
  deleteCreditCards: z.boolean().optional(),
  deletePhoneNumbers: z.boolean().optional(),
  cleanBulletPoints: z.boolean().optional(),
  cleanNumberedList: z.boolean().optional(),
  cleanUnicode: z.boolean().optional(),
  cleanDashes: z.boolean().optional(),
  cleanWhitespaces: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    deleteEmails: "delete_emails",
    deleteCreditCards: "delete_credit_cards",
    deletePhoneNumbers: "delete_phone_numbers",
    cleanBulletPoints: "clean_bullet_points",
    cleanNumberedList: "clean_numbered_list",
    cleanUnicode: "clean_unicode",
    cleanDashes: "clean_dashes",
    cleanWhitespaces: "clean_whitespaces",
  });
});

export function chunkingCleanupOptionsToJSON(
  chunkingCleanupOptions: ChunkingCleanupOptions,
): string {
  return JSON.stringify(
    ChunkingCleanupOptions$outboundSchema.parse(chunkingCleanupOptions),
  );
}

/** @internal */
export type ChunkingOptions$Outbound = {
  chunking_configuration?:
    | ChunkingConfiguration1$Outbound
    | ChunkingConfiguration2$Outbound
    | undefined;
  chunking_cleanup_options?: ChunkingCleanupOptions$Outbound | undefined;
};

/** @internal */
export const ChunkingOptions$outboundSchema: z.ZodType<
  ChunkingOptions$Outbound,
  z.ZodTypeDef,
  ChunkingOptions
> = z.object({
  chunkingConfiguration: z.union([
    z.lazy(() => ChunkingConfiguration1$outboundSchema),
    z.lazy(() => ChunkingConfiguration2$outboundSchema),
  ]).optional(),
  chunkingCleanupOptions: z.lazy(() => ChunkingCleanupOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    chunkingConfiguration: "chunking_configuration",
    chunkingCleanupOptions: "chunking_cleanup_options",
  });
});

export function chunkingOptionsToJSON(
  chunkingOptions: ChunkingOptions,
): string {
  return JSON.stringify(ChunkingOptions$outboundSchema.parse(chunkingOptions));
}

/** @internal */
export type CreateDatasourceRequestBody$Outbound = {
  display_name?: string | undefined;
  file_id?: string | undefined;
  chunking_options?: ChunkingOptions$Outbound | undefined;
};

/** @internal */
export const CreateDatasourceRequestBody$outboundSchema: z.ZodType<
  CreateDatasourceRequestBody$Outbound,
  z.ZodTypeDef,
  CreateDatasourceRequestBody
> = z.object({
  displayName: z.string().optional(),
  fileId: z.string().optional(),
  chunkingOptions: z.lazy(() => ChunkingOptions$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    fileId: "file_id",
    chunkingOptions: "chunking_options",
  });
});

export function createDatasourceRequestBodyToJSON(
  createDatasourceRequestBody: CreateDatasourceRequestBody,
): string {
  return JSON.stringify(
    CreateDatasourceRequestBody$outboundSchema.parse(
      createDatasourceRequestBody,
    ),
  );
}

/** @internal */
export type CreateDatasourceRequest$Outbound = {
  knowledge_id: string;
  RequestBody: CreateDatasourceRequestBody$Outbound;
};

/** @internal */
export const CreateDatasourceRequest$outboundSchema: z.ZodType<
  CreateDatasourceRequest$Outbound,
  z.ZodTypeDef,
  CreateDatasourceRequest
> = z.object({
  knowledgeId: z.string(),
  requestBody: z.lazy(() => CreateDatasourceRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    requestBody: "RequestBody",
  });
});

export function createDatasourceRequestToJSON(
  createDatasourceRequest: CreateDatasourceRequest,
): string {
  return JSON.stringify(
    CreateDatasourceRequest$outboundSchema.parse(createDatasourceRequest),
  );
}

/** @internal */
export const CreateDatasourceStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateDatasourceStatus
> = z.nativeEnum(CreateDatasourceStatus);

/** @internal */
export const CreateDatasourceResponseBody$inboundSchema: z.ZodType<
  CreateDatasourceResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KGHB3KVMF3K8ACVSBG71VGGJ"),
  display_name: z.string(),
  description: z.string().optional(),
  status: CreateDatasourceStatus$inboundSchema,
  file_id: z.nullable(z.string()).optional(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  update_by_id: z.nullable(z.string()).optional(),
  knowledge_id: z.string(),
  chunks_count: z.number(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "file_id": "fileId",
    "created_by_id": "createdById",
    "update_by_id": "updateById",
    "knowledge_id": "knowledgeId",
    "chunks_count": "chunksCount",
  });
});

export function createDatasourceResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateDatasourceResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateDatasourceResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateDatasourceResponseBody' from JSON`,
  );
}
