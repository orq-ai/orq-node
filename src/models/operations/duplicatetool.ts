/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DuplicateToolRequest = {
  /**
   * The key of the tool to duplicate
   */
  key: string;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type DuplicateToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  >;

export const DuplicateToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type DuplicateToolResponseBodyLanguage = ClosedEnum<
  typeof DuplicateToolResponseBodyLanguage
>;

export type DuplicateToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: DuplicateToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type DuplicateToolResponseBody5 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?:
    | DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
    | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: DuplicateToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponse200Status
>;

export const DuplicateToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type DuplicateToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponse200Type
>;

export type DuplicateToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  >;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type DuplicateToolResponseBodyInputSchema = {
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const DuplicateToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DuplicateToolResponseBodyConnectionType = ClosedEnum<
  typeof DuplicateToolResponseBodyConnectionType
>;

export type DuplicateToolResponseBodyMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: DuplicateToolResponseBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: DuplicateToolResponseBodyInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DuplicateToolResponseBodyConnectionType;
};

export type DuplicateToolResponseBody4 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponse200Type;
  mcp: DuplicateToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponseStatus
>;

export const DuplicateToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type DuplicateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const DuplicateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type DuplicateToolResponseBodyMethod = ClosedEnum<
  typeof DuplicateToolResponseBodyMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DuplicateToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: DuplicateToolResponseBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  >;

/**
 * The default value of the argument.
 */
export type DuplicateToolResponseBodyDefaultValue = string | number | boolean;

export type DuplicateToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type DuplicateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DuplicateToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DuplicateToolResponseBodyArguments } | undefined;
};

export type DuplicateToolResponseBody3 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponseType;
  http: DuplicateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsStatus
>;

export const DuplicateToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type DuplicateToolResponseBodyToolsType = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsType
>;

export type DuplicateToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type DuplicateToolResponseBody2 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsType;
  jsonSchema: DuplicateToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyStatus
>;

export const DuplicateToolResponseBodyType = {
  Function: "function",
} as const;
export type DuplicateToolResponseBodyType = ClosedEnum<
  typeof DuplicateToolResponseBodyType
>;

export type DuplicateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type DuplicateToolResponseBody1 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyType;
  function: DuplicateToolResponseBodyFunction;
};

/**
 * Successfully duplicated the tool.
 */
export type DuplicateToolResponseBody =
  | DuplicateToolResponseBody1
  | DuplicateToolResponseBody2
  | DuplicateToolResponseBody3
  | DuplicateToolResponseBody4
  | DuplicateToolResponseBody5;

/** @internal */
export const DuplicateToolRequest$inboundSchema: z.ZodType<
  DuplicateToolRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
});

/** @internal */
export type DuplicateToolRequest$Outbound = {
  key: string;
};

/** @internal */
export const DuplicateToolRequest$outboundSchema: z.ZodType<
  DuplicateToolRequest$Outbound,
  z.ZodTypeDef,
  DuplicateToolRequest
> = z.object({
  key: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolRequest$ {
  /** @deprecated use `DuplicateToolRequest$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolRequest$inboundSchema;
  /** @deprecated use `DuplicateToolRequest$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolRequest$outboundSchema;
  /** @deprecated use `DuplicateToolRequest$Outbound` instead. */
  export type Outbound = DuplicateToolRequest$Outbound;
}

export function duplicateToolRequestToJSON(
  duplicateToolRequest: DuplicateToolRequest,
): string {
  return JSON.stringify(
    DuplicateToolRequest$outboundSchema.parse(duplicateToolRequest),
  );
}

export function duplicateToolRequestFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolRequest' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus,
  );

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType,
  );

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyLanguage
> = z.nativeEnum(DuplicateToolResponseBodyLanguage);

/** @internal */
export const DuplicateToolResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyLanguage
> = DuplicateToolResponseBodyLanguage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyLanguage$ {
  /** @deprecated use `DuplicateToolResponseBodyLanguage$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyLanguage$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyLanguage$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyLanguage$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DuplicateToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});

/** @internal */
export type DuplicateToolResponseBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const DuplicateToolResponseBodyCodeTool$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DuplicateToolResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyCodeTool$ {
  /** @deprecated use `DuplicateToolResponseBodyCodeTool$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyCodeTool$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyCodeTool$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyCodeTool$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyCodeTool$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyCodeTool$Outbound;
}

export function duplicateToolResponseBodyCodeToolToJSON(
  duplicateToolResponseBodyCodeTool: DuplicateToolResponseBodyCodeTool,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyCodeTool$outboundSchema.parse(
      duplicateToolResponseBodyCodeTool,
    ),
  );
}

export function duplicateToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody5$inboundSchema: z.ZodType<
  DuplicateToolResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K7KDRXSNBRT1HA1BV643Q412"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => DuplicateToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

/** @internal */
export type DuplicateToolResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: DuplicateToolResponseBodyCodeTool$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody5$outboundSchema: z.ZodType<
  DuplicateToolResponseBody5$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody5
> = z.object({
  id: z.string().default("01K7KDRXSNBRT1HA1BV643Q412"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema
      .default("live"),
  versionHash: z.string().optional(),
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => DuplicateToolResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody5$ {
  /** @deprecated use `DuplicateToolResponseBody5$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody5$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody5$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody5$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody5$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody5$Outbound;
}

export function duplicateToolResponseBody5ToJSON(
  duplicateToolResponseBody5: DuplicateToolResponseBody5,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody5$outboundSchema.parse(duplicateToolResponseBody5),
  );
}

export function duplicateToolResponseBody5FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody5' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponse200Status);

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Status> =
    DuplicateToolResponseBodyToolsResponse200Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200Status$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200Status$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200Status$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200Status$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200Status$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponse200Type);

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Type> =
    DuplicateToolResponseBodyToolsResponse200Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200Type$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200Type$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200Type$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200Type$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200Type$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/** @internal */
export type DuplicateToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DuplicateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyHeaders$ {
  /** @deprecated use `DuplicateToolResponseBodyHeaders$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyHeaders$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyHeaders$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyHeaders$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyHeaders$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyHeaders$Outbound;
}

export function duplicateToolResponseBodyHeadersToJSON(
  duplicateToolResponseBodyHeaders: DuplicateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyHeaders$outboundSchema.parse(
      duplicateToolResponseBodyHeaders,
    ),
  );
}

export function duplicateToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type,
  );

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyInputSchema$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/** @internal */
export type DuplicateToolResponseBodyInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyInputSchema$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyInputSchema$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyInputSchema
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyInputSchema$ {
  /** @deprecated use `DuplicateToolResponseBodyInputSchema$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyInputSchema$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyInputSchema$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyInputSchema$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyInputSchema$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyInputSchema$Outbound;
}

export function duplicateToolResponseBodyInputSchemaToJSON(
  duplicateToolResponseBodyInputSchema: DuplicateToolResponseBodyInputSchema,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyInputSchema$outboundSchema.parse(
      duplicateToolResponseBodyInputSchema,
    ),
  );
}

export function duplicateToolResponseBodyInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyInputSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyConnectionType> = z
    .nativeEnum(DuplicateToolResponseBodyConnectionType);

/** @internal */
export const DuplicateToolResponseBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyConnectionType> =
    DuplicateToolResponseBodyConnectionType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyConnectionType$ {
  /** @deprecated use `DuplicateToolResponseBodyConnectionType$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyConnectionType$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyConnectionType$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyConnectionType$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyMcp$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_id: z.string(),
  tool_name: z.string(),
  server_url: z.string(),
  headers: z.record(
    z.lazy(() => DuplicateToolResponseBodyHeaders$inboundSchema),
  ).optional(),
  input_schema: z.lazy(() =>
    DuplicateToolResponseBodyInputSchema$inboundSchema
  ),
  connection_type: DuplicateToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_id": "serverId",
    "tool_name": "toolName",
    "server_url": "serverUrl",
    "input_schema": "inputSchema",
    "connection_type": "connectionType",
  });
});

/** @internal */
export type DuplicateToolResponseBodyMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?:
    | { [k: string]: DuplicateToolResponseBodyHeaders$Outbound }
    | undefined;
  input_schema: DuplicateToolResponseBodyInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const DuplicateToolResponseBodyMcp$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(
    z.lazy(() => DuplicateToolResponseBodyHeaders$outboundSchema),
  ).optional(),
  inputSchema: z.lazy(() =>
    DuplicateToolResponseBodyInputSchema$outboundSchema
  ),
  connectionType: DuplicateToolResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyMcp$ {
  /** @deprecated use `DuplicateToolResponseBodyMcp$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyMcp$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyMcp$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyMcp$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyMcp$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyMcp$Outbound;
}

export function duplicateToolResponseBodyMcpToJSON(
  duplicateToolResponseBodyMcp: DuplicateToolResponseBodyMcp,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyMcp$outboundSchema.parse(
      duplicateToolResponseBodyMcp,
    ),
  );
}

export function duplicateToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody4$inboundSchema: z.ZodType<
  DuplicateToolResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K7KDRXSM2NPZHMPMGB225NX7"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => DuplicateToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type DuplicateToolResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: DuplicateToolResponseBodyMcp$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody4$outboundSchema: z.ZodType<
  DuplicateToolResponseBody4$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody4
> = z.object({
  id: z.string().default("01K7KDRXSM2NPZHMPMGB225NX7"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponse200Status$outboundSchema
    .default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => DuplicateToolResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody4$ {
  /** @deprecated use `DuplicateToolResponseBody4$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody4$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody4$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody4$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody4$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody4$Outbound;
}

export function duplicateToolResponseBody4ToJSON(
  duplicateToolResponseBody4: DuplicateToolResponseBody4,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody4$outboundSchema.parse(duplicateToolResponseBody4),
  );
}

export function duplicateToolResponseBody4FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody4' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponseStatus);

/** @internal */
export const DuplicateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseStatus> =
    DuplicateToolResponseBodyToolsResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponseStatus$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponseStatus$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponseStatus$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponseStatus$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponseStatus$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseType> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponseType);

/** @internal */
export const DuplicateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseType> =
    DuplicateToolResponseBodyToolsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponseType$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponseType$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponseType$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponseType$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponseType$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyMethod
> = z.nativeEnum(DuplicateToolResponseBodyMethod);

/** @internal */
export const DuplicateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyMethod
> = DuplicateToolResponseBodyMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyMethod$ {
  /** @deprecated use `DuplicateToolResponseBodyMethod$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyMethod$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyMethod$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyMethod$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: DuplicateToolResponseBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type DuplicateToolResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyBlueprint$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: DuplicateToolResponseBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyBlueprint$ {
  /** @deprecated use `DuplicateToolResponseBodyBlueprint$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyBlueprint$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyBlueprint$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyBlueprint$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyBlueprint$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyBlueprint$Outbound;
}

export function duplicateToolResponseBodyBlueprintToJSON(
  duplicateToolResponseBodyBlueprint: DuplicateToolResponseBodyBlueprint,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyBlueprint$outboundSchema.parse(
      duplicateToolResponseBodyBlueprint,
    ),
  );
}

export function duplicateToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type,
  );

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DuplicateToolResponseBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const DuplicateToolResponseBodyDefaultValue$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyDefaultValue$ {
  /** @deprecated use `DuplicateToolResponseBodyDefaultValue$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyDefaultValue$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyDefaultValue$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyDefaultValue$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyDefaultValue$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyDefaultValue$Outbound;
}

export function duplicateToolResponseBodyDefaultValueToJSON(
  duplicateToolResponseBodyDefaultValue: DuplicateToolResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyDefaultValue$outboundSchema.parse(
      duplicateToolResponseBodyDefaultValue,
    ),
  );
}

export function duplicateToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyArguments$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type DuplicateToolResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyArguments$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyArguments
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyArguments$ {
  /** @deprecated use `DuplicateToolResponseBodyArguments$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyArguments$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyArguments$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyArguments$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyArguments$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyArguments$Outbound;
}

export function duplicateToolResponseBodyArgumentsToJSON(
  duplicateToolResponseBodyArguments: DuplicateToolResponseBodyArguments,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyArguments$outboundSchema.parse(
      duplicateToolResponseBodyArguments,
    ),
  );
}

export function duplicateToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyHttp$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DuplicateToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => DuplicateToolResponseBodyArguments$inboundSchema),
  ).optional(),
});

/** @internal */
export type DuplicateToolResponseBodyHttp$Outbound = {
  blueprint: DuplicateToolResponseBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: DuplicateToolResponseBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyHttp$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => DuplicateToolResponseBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => DuplicateToolResponseBodyArguments$outboundSchema),
  ).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyHttp$ {
  /** @deprecated use `DuplicateToolResponseBodyHttp$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyHttp$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyHttp$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyHttp$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyHttp$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyHttp$Outbound;
}

export function duplicateToolResponseBodyHttpToJSON(
  duplicateToolResponseBodyHttp: DuplicateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyHttp$outboundSchema.parse(
      duplicateToolResponseBodyHttp,
    ),
  );
}

export function duplicateToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody3$inboundSchema: z.ZodType<
  DuplicateToolResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K7KDRXSMFZE4SRN3C6TXZ0JD"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => DuplicateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type DuplicateToolResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: DuplicateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody3$outboundSchema: z.ZodType<
  DuplicateToolResponseBody3$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody3
> = z.object({
  id: z.string().default("01K7KDRXSMFZE4SRN3C6TXZ0JD"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => DuplicateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody3$ {
  /** @deprecated use `DuplicateToolResponseBody3$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody3$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody3$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody3$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody3$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody3$Outbound;
}

export function duplicateToolResponseBody3ToJSON(
  duplicateToolResponseBody3: DuplicateToolResponseBody3,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody3$outboundSchema.parse(duplicateToolResponseBody3),
  );
}

export function duplicateToolResponseBody3FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody3' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsStatus$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsStatus> = z.nativeEnum(
    DuplicateToolResponseBodyToolsStatus,
  );

/** @internal */
export const DuplicateToolResponseBodyToolsStatus$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsStatus> =
    DuplicateToolResponseBodyToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsStatus$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsStatus$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyToolsStatus$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsStatus$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsStatus$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyToolsType
> = z.nativeEnum(DuplicateToolResponseBodyToolsType);

/** @internal */
export const DuplicateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyToolsType
> = DuplicateToolResponseBodyToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyToolsType$ {
  /** @deprecated use `DuplicateToolResponseBodyToolsType$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyToolsType$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyToolsType$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyToolsType$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type DuplicateToolResponseBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const DuplicateToolResponseBodyJsonSchema$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyJsonSchema$ {
  /** @deprecated use `DuplicateToolResponseBodyJsonSchema$inboundSchema` instead. */
  export const inboundSchema =
    DuplicateToolResponseBodyJsonSchema$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyJsonSchema$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyJsonSchema$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyJsonSchema$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyJsonSchema$Outbound;
}

export function duplicateToolResponseBodyJsonSchemaToJSON(
  duplicateToolResponseBodyJsonSchema: DuplicateToolResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyJsonSchema$outboundSchema.parse(
      duplicateToolResponseBodyJsonSchema,
    ),
  );
}

export function duplicateToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody2$inboundSchema: z.ZodType<
  DuplicateToolResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K7KDRXSM4H29QEA2KN2K40ZP"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => DuplicateToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type DuplicateToolResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: DuplicateToolResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody2$outboundSchema: z.ZodType<
  DuplicateToolResponseBody2$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody2
> = z.object({
  id: z.string().default("01K7KDRXSM4H29QEA2KN2K40ZP"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => DuplicateToolResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody2$ {
  /** @deprecated use `DuplicateToolResponseBody2$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody2$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody2$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody2$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody2$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody2$Outbound;
}

export function duplicateToolResponseBody2ToJSON(
  duplicateToolResponseBody2: DuplicateToolResponseBody2,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody2$outboundSchema.parse(duplicateToolResponseBody2),
  );
}

export function duplicateToolResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody2' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyStatus
> = z.nativeEnum(DuplicateToolResponseBodyStatus);

/** @internal */
export const DuplicateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyStatus
> = DuplicateToolResponseBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyStatus$ {
  /** @deprecated use `DuplicateToolResponseBodyStatus$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyStatus$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyStatus$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyStatus$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyType
> = z.nativeEnum(DuplicateToolResponseBodyType);

/** @internal */
export const DuplicateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyType
> = DuplicateToolResponseBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyType$ {
  /** @deprecated use `DuplicateToolResponseBodyType$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyType$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyType$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBodyType$outboundSchema;
}

/** @internal */
export const DuplicateToolResponseBodyFunction$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type DuplicateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyFunction$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBodyFunction$ {
  /** @deprecated use `DuplicateToolResponseBodyFunction$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBodyFunction$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyFunction$outboundSchema` instead. */
  export const outboundSchema =
    DuplicateToolResponseBodyFunction$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBodyFunction$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBodyFunction$Outbound;
}

export function duplicateToolResponseBodyFunctionToJSON(
  duplicateToolResponseBodyFunction: DuplicateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyFunction$outboundSchema.parse(
      duplicateToolResponseBodyFunction,
    ),
  );
}

export function duplicateToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody1$inboundSchema: z.ZodType<
  DuplicateToolResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K7KDRXSKJ5KAFQ2M65WT2YEQ"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyType$inboundSchema,
  function: z.lazy(() => DuplicateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type DuplicateToolResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: DuplicateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody1$outboundSchema: z.ZodType<
  DuplicateToolResponseBody1$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody1
> = z.object({
  id: z.string().default("01K7KDRXSKJ5KAFQ2M65WT2YEQ"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyType$outboundSchema,
  function: z.lazy(() => DuplicateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody1$ {
  /** @deprecated use `DuplicateToolResponseBody1$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody1$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody1$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody1$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody1$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody1$Outbound;
}

export function duplicateToolResponseBody1ToJSON(
  duplicateToolResponseBody1: DuplicateToolResponseBody1,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody1$outboundSchema.parse(duplicateToolResponseBody1),
  );
}

export function duplicateToolResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody1' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody$inboundSchema: z.ZodType<
  DuplicateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DuplicateToolResponseBody1$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody2$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody3$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody4$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody5$inboundSchema),
]);

/** @internal */
export type DuplicateToolResponseBody$Outbound =
  | DuplicateToolResponseBody1$Outbound
  | DuplicateToolResponseBody2$Outbound
  | DuplicateToolResponseBody3$Outbound
  | DuplicateToolResponseBody4$Outbound
  | DuplicateToolResponseBody5$Outbound;

/** @internal */
export const DuplicateToolResponseBody$outboundSchema: z.ZodType<
  DuplicateToolResponseBody$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody
> = z.union([
  z.lazy(() => DuplicateToolResponseBody1$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody2$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody3$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody4$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody5$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DuplicateToolResponseBody$ {
  /** @deprecated use `DuplicateToolResponseBody$inboundSchema` instead. */
  export const inboundSchema = DuplicateToolResponseBody$inboundSchema;
  /** @deprecated use `DuplicateToolResponseBody$outboundSchema` instead. */
  export const outboundSchema = DuplicateToolResponseBody$outboundSchema;
  /** @deprecated use `DuplicateToolResponseBody$Outbound` instead. */
  export type Outbound = DuplicateToolResponseBody$Outbound;
}

export function duplicateToolResponseBodyToJSON(
  duplicateToolResponseBody: DuplicateToolResponseBody,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody$outboundSchema.parse(duplicateToolResponseBody),
  );
}

export function duplicateToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody' from JSON`,
  );
}
