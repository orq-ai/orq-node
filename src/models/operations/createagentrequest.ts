/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const Voice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type Voice = ClosedEnum<typeof Voice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const Format = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type Format = ClosedEnum<typeof Format>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: Voice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: Format;
};

export type ResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type JSONSchema = {
  type: "json_schema";
  jsonSchema: ResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type JSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type Text = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ResponseFormat = Text | JSONObject | JSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type Stop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ModelConfigurationType = ClosedEnum<typeof ModelConfigurationType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const ThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type ThinkingLevel = ClosedEnum<typeof ThinkingLevel>;

export type Thinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: ThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ToolChoiceType = ClosedEnum<typeof ToolChoiceType>;

export type ToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type ToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ToolChoiceType | undefined;
  function: ToolChoiceFunction;
};

export const ToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ToolChoice1 = ClosedEnum<typeof ToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ToolChoice = ToolChoice2 | ToolChoice1;

export const Modalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type Modalities = ClosedEnum<typeof Modalities>;

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type ParametersT = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?: Text | JSONObject | JSONSchema | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamOptions | null | undefined;
  thinking?: Thinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ToolChoice2 | ToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<Modalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type Retry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type ModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: ParametersT | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: Retry | undefined;
};

/**
 * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
 */
export type ModelConfiguration = ModelConfiguration2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const FallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type FallbackModelConfigurationVoice = ClosedEnum<
  typeof FallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const FallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type FallbackModelConfigurationFormat = ClosedEnum<
  typeof FallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type FallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: FallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: FallbackModelConfigurationFormat;
};

export type CreateAgentRequestResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: CreateAgentRequestResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type FallbackModelConfigurationResponseFormat =
  | ResponseFormatText
  | ResponseFormatJSONObject
  | CreateAgentRequestResponseFormatJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type FallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type FallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const FallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type FallbackModelConfigurationType = ClosedEnum<
  typeof FallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const FallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type FallbackModelConfigurationThinkingLevel = ClosedEnum<
  typeof FallbackModelConfigurationThinkingLevel
>;

export type FallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: FallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: FallbackModelConfigurationThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceType
>;

export type CreateAgentRequestToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceType | undefined;
  function: CreateAgentRequestToolChoiceFunction;
};

export const CreateAgentRequestToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoice1 = ClosedEnum<
  typeof CreateAgentRequestToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type FallbackModelConfigurationToolChoice =
  | CreateAgentRequestToolChoice2
  | CreateAgentRequestToolChoice1;

export const FallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type FallbackModelConfigurationModalities = ClosedEnum<
  typeof FallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type FallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: FallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ResponseFormatText
    | ResponseFormatJSONObject
    | CreateAgentRequestResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: FallbackModelConfigurationStreamOptions | null | undefined;
  thinking?: FallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoice2
    | CreateAgentRequestToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<FallbackModelConfigurationModalities> | null | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type FallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: FallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type FallbackModelConfiguration = FallbackModelConfiguration2 | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

/**
 * Executes tools from Model Context Protocol (MCP) servers. Specify the parent MCP tool using "key" or "id", and the specific nested tool using "tool_id".
 */
export type MCPTool = {
  /**
   * MCP tool type
   */
  type: "mcp";
  /**
   * The key of the parent MCP tool
   */
  key?: string | undefined;
  /**
   * The ID of the parent MCP tool
   */
  id?: string | undefined;
  /**
   * The ID of the specific nested tool within the MCP server
   */
  toolId: string;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type FunctionTool = {
  /**
   * Function tool type
   */
  type: "function";
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type CodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type: "code";
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type HTTPTool = {
  /**
   * HTTP tool type
   */
  type: "http";
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Returns the current date and time
 */
export type CurrentDateTool = {
  type: "current_date";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries knowledge bases for information
 */
export type QueryKnowledgeBaseTool = {
  type: "query_knowledge_base";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available knowledge bases
 */
export type RetrieveKnowledgeBasesTool = {
  type: "retrieve_knowledge_bases";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Deletes documents from memory stores
 */
export type DeleteMemoryDocumentTool = {
  type: "delete_memory_document";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available memory stores
 */
export type RetrieveMemoryStoresTool = {
  type: "retrieve_memory_stores";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Writes information to agent memory stores
 */
export type WriteMemoryStoreTool = {
  type: "write_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries agent memory stores for context
 */
export type QueryMemoryStoreTool = {
  type: "query_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Retrieves available agents in the system
 */
export type RetrieveAgentsTool = {
  type: "retrieve_agents";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Delegates tasks to specialized sub-agents
 */
export type CallSubAgentTool = {
  type: "call_sub_agent";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Scrapes and extracts content from web pages
 */
export type WebScraperTool = {
  type: "web_scraper";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Performs Google searches to retrieve web content
 */
export type GoogleSearchTool = {
  type: "google_search";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function, MCP) must reference pre-created tools by key or id.
 */
export type AgentToolInputCRUD =
  | GoogleSearchTool
  | WebScraperTool
  | CallSubAgentTool
  | RetrieveAgentsTool
  | QueryMemoryStoreTool
  | WriteMemoryStoreTool
  | RetrieveMemoryStoresTool
  | DeleteMemoryDocumentTool
  | RetrieveKnowledgeBasesTool
  | QueryKnowledgeBaseTool
  | CurrentDateTool
  | HTTPTool
  | CodeExecutionTool
  | FunctionTool
  | MCPTool;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type ExecuteOn = ClosedEnum<typeof ExecuteOn>;

export type Evaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: ExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestExecuteOn = ClosedEnum<
  typeof CreateAgentRequestExecuteOn
>;

export type Guardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestExecuteOn;
};

/**
 * Configuration settings for the agent's behavior
 */
export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | GoogleSearchTool
      | WebScraperTool
      | CallSubAgentTool
      | RetrieveAgentsTool
      | QueryMemoryStoreTool
      | WriteMemoryStoreTool
      | RetrieveMemoryStoresTool
      | DeleteMemoryDocumentTool
      | RetrieveKnowledgeBasesTool
      | QueryKnowledgeBaseTool
      | CurrentDateTool
      | HTTPTool
      | CodeExecutionTool
      | FunctionTool
      | MCPTool
    >
    | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<Evaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<Guardrails> | undefined;
};

export type KnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type TeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type CreateAgentRequestRequestBody = {
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  /**
   * agent display name within the workspace
   */
  displayName?: string | undefined;
  /**
   * The role or function of the agent
   */
  role: string;
  /**
   * A brief description of what the agent does
   */
  description: string;
  /**
   * Detailed instructions that guide the agent's behavior
   */
  instructions: string;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * The path where the agent will be stored in the project structure. The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * @remarks
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
   */
  model: ModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?: Array<FallbackModelConfiguration2 | string> | undefined;
  /**
   * Configuration settings for the agent's behavior
   */
  settings: Settings;
  /**
   * Optional array of memory store identifiers for the agent to access. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Optional array of knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<KnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<TeamOfAgents> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateAgentRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateAgentRequestStatus = ClosedEnum<
  typeof CreateAgentRequestStatus
>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const CreateAgentRequestToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type CreateAgentRequestToolApprovalRequired = ClosedEnum<
  typeof CreateAgentRequestToolApprovalRequired
>;

export type Conditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type CreateAgentRequestTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<Conditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestAgentsExecuteOn = ClosedEnum<
  typeof CreateAgentRequestAgentsExecuteOn
>;

export type CreateAgentRequestEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestAgentsExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestAgentsResponseExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestAgentsResponseExecuteOn = ClosedEnum<
  typeof CreateAgentRequestAgentsResponseExecuteOn
>;

export type CreateAgentRequestGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestAgentsResponseExecuteOn;
};

export type CreateAgentRequestSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: CreateAgentRequestToolApprovalRequired | undefined;
  tools?: Array<CreateAgentRequestTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<CreateAgentRequestEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<CreateAgentRequestGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentRequestVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentRequestVoice = ClosedEnum<
  typeof CreateAgentRequestVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentRequestFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentRequestFormat = ClosedEnum<
  typeof CreateAgentRequestFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentRequestAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentRequestVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentRequestFormat;
};

export type CreateAgentRequestResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatAgentsResponse201JSONSchema = {
  type: "json_schema";
  jsonSchema: CreateAgentRequestResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentRequestResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentRequestResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentRequestResponseFormat =
  | CreateAgentRequestResponseFormatText
  | CreateAgentRequestResponseFormatJSONObject
  | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentRequestStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentRequestStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentRequestType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentRequestType = ClosedEnum<typeof CreateAgentRequestType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const CreateAgentRequestThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type CreateAgentRequestThinkingLevel = ClosedEnum<
  typeof CreateAgentRequestThinkingLevel
>;

export type CreateAgentRequestThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentRequestType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: CreateAgentRequestThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceAgentsType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsType
>;

export type CreateAgentRequestToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceAgentsType | undefined;
  function: CreateAgentRequestToolChoiceAgentsFunction;
};

export const CreateAgentRequestToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoiceAgents1 = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentRequestToolChoice =
  | CreateAgentRequestToolChoiceAgents2
  | CreateAgentRequestToolChoiceAgents1;

export const CreateAgentRequestModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentRequestModalities = ClosedEnum<
  typeof CreateAgentRequestModalities
>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type CreateAgentRequestParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentRequestAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentRequestResponseFormatText
    | CreateAgentRequestResponseFormatJSONObject
    | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateAgentRequestStreamOptions | null | undefined;
  thinking?: CreateAgentRequestThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoiceAgents2
    | CreateAgentRequestToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateAgentRequestModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type CreateAgentRequestRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentRequestFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentRequestFallbackModelConfigurationVoice = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentRequestFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentRequestFallbackModelConfigurationFormat = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentRequestFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentRequestFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentRequestFallbackModelConfigurationFormat;
};

export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict?: boolean | undefined;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema =
  {
    type: "json_schema";
    jsonSchema:
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema;
  };

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentRequestResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentRequestResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentRequestFallbackModelConfigurationResponseFormat =
  | CreateAgentRequestResponseFormatAgentsText
  | CreateAgentRequestResponseFormatAgentsJSONObject
  | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentRequestFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentRequestFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentRequestFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentRequestFallbackModelConfigurationType = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const CreateAgentRequestFallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type CreateAgentRequestFallbackModelConfigurationThinkingLevel =
  ClosedEnum<typeof CreateAgentRequestFallbackModelConfigurationThinkingLevel>;

export type CreateAgentRequestFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentRequestFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?:
    | CreateAgentRequestFallbackModelConfigurationThinkingLevel
    | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceAgentsResponseType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsResponseType
>;

export type CreateAgentRequestToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceAgentsResponseType | undefined;
  function: CreateAgentRequestToolChoiceAgentsResponseFunction;
};

export const CreateAgentRequestToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoiceAgentsResponse1 = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentRequestFallbackModelConfigurationToolChoice =
  | CreateAgentRequestToolChoiceAgentsResponse2
  | CreateAgentRequestToolChoiceAgentsResponse1;

export const CreateAgentRequestFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentRequestFallbackModelConfigurationModalities = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type CreateAgentRequestFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentRequestFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentRequestResponseFormatAgentsText
    | CreateAgentRequestResponseFormatAgentsJSONObject
    | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | CreateAgentRequestFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: CreateAgentRequestFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoiceAgentsResponse2
    | CreateAgentRequestToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<CreateAgentRequestFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type CreateAgentRequestFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?:
    | CreateAgentRequestFallbackModelConfigurationParameters
    | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type CreateAgentRequestFallbackModelConfiguration =
  | CreateAgentRequestFallbackModelConfiguration2
  | string;

export type Model = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: CreateAgentRequestParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: CreateAgentRequestRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<CreateAgentRequestFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type CreateAgentRequestTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type Metrics = {
  totalCost?: number | undefined;
};

export type CreateAgentRequestKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

/**
 * Agent successfully created and ready for use. Returns the complete agent manifest including the generated ID, configuration, and all settings.
 */
export type CreateAgentRequestResponseBody = {
  id: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  displayName: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateAgentRequestStatus;
  settings?: CreateAgentRequestSettings | undefined;
  model: Model;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<CreateAgentRequestTeamOfAgents>;
  metrics?: Metrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<CreateAgentRequestKnowledgeBases> | undefined;
};

/** @internal */
export const Voice$inboundSchema: z.ZodNativeEnum<typeof Voice> = z.nativeEnum(
  Voice,
);
/** @internal */
export const Voice$outboundSchema: z.ZodNativeEnum<typeof Voice> =
  Voice$inboundSchema;

/** @internal */
export const Format$inboundSchema: z.ZodNativeEnum<typeof Format> = z
  .nativeEnum(Format);
/** @internal */
export const Format$outboundSchema: z.ZodNativeEnum<typeof Format> =
  Format$inboundSchema;

/** @internal */
export const ModelConfigurationAudio$inboundSchema: z.ZodType<
  ModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: Voice$inboundSchema,
  format: Format$inboundSchema,
});
/** @internal */
export type ModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ModelConfigurationAudio$outboundSchema: z.ZodType<
  ModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  ModelConfigurationAudio
> = z.object({
  voice: Voice$outboundSchema,
  format: Format$outboundSchema,
});

export function modelConfigurationAudioToJSON(
  modelConfigurationAudio: ModelConfigurationAudio,
): string {
  return JSON.stringify(
    ModelConfigurationAudio$outboundSchema.parse(modelConfigurationAudio),
  );
}
export function modelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const ResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});
/** @internal */
export type ResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const ResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});

export function responseFormatJsonSchemaToJSON(
  responseFormatJsonSchema: ResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ResponseFormatJsonSchema$outboundSchema.parse(responseFormatJsonSchema),
  );
}
export function responseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const JSONSchema$inboundSchema: z.ZodType<
  JSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => ResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type JSONSchema$Outbound = {
  type: "json_schema";
  json_schema: ResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const JSONSchema$outboundSchema: z.ZodType<
  JSONSchema$Outbound,
  z.ZodTypeDef,
  JSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => ResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function jsonSchemaToJSON(jsonSchema: JSONSchema): string {
  return JSON.stringify(JSONSchema$outboundSchema.parse(jsonSchema));
}
export function jsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<JSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONSchema' from JSON`,
  );
}

/** @internal */
export const JSONObject$inboundSchema: z.ZodType<
  JSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type JSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const JSONObject$outboundSchema: z.ZodType<
  JSONObject$Outbound,
  z.ZodTypeDef,
  JSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function jsonObjectToJSON(jsonObject: JSONObject): string {
  return JSON.stringify(JSONObject$outboundSchema.parse(jsonObject));
}
export function jsonObjectFromJSON(
  jsonString: string,
): SafeParseResult<JSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONObject' from JSON`,
  );
}

/** @internal */
export const Text$inboundSchema: z.ZodType<Text, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("text"),
  });
/** @internal */
export type Text$Outbound = {
  type: "text";
};

/** @internal */
export const Text$outboundSchema: z.ZodType<Text$Outbound, z.ZodTypeDef, Text> =
  z.object({
    type: z.literal("text"),
  });

export function textToJSON(text: Text): string {
  return JSON.stringify(Text$outboundSchema.parse(text));
}
export function textFromJSON(
  jsonString: string,
): SafeParseResult<Text, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Text$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Text' from JSON`,
  );
}

/** @internal */
export const ResponseFormat$inboundSchema: z.ZodType<
  ResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Text$inboundSchema),
  z.lazy(() => JSONObject$inboundSchema),
  z.lazy(() => JSONSchema$inboundSchema),
]);
/** @internal */
export type ResponseFormat$Outbound =
  | Text$Outbound
  | JSONObject$Outbound
  | JSONSchema$Outbound;

/** @internal */
export const ResponseFormat$outboundSchema: z.ZodType<
  ResponseFormat$Outbound,
  z.ZodTypeDef,
  ResponseFormat
> = z.union([
  z.lazy(() => Text$outboundSchema),
  z.lazy(() => JSONObject$outboundSchema),
  z.lazy(() => JSONSchema$outboundSchema),
]);

export function responseFormatToJSON(responseFormat: ResponseFormat): string {
  return JSON.stringify(ResponseFormat$outboundSchema.parse(responseFormat));
}
export function responseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat' from JSON`,
  );
}

/** @internal */
export const Stop$inboundSchema: z.ZodType<Stop, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);
/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}
export function stopFromJSON(
  jsonString: string,
): SafeParseResult<Stop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stop' from JSON`,
  );
}

/** @internal */
export const StreamOptions$inboundSchema: z.ZodType<
  StreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type StreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamOptions$outboundSchema: z.ZodType<
  StreamOptions$Outbound,
  z.ZodTypeDef,
  StreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamOptionsToJSON(streamOptions: StreamOptions): string {
  return JSON.stringify(StreamOptions$outboundSchema.parse(streamOptions));
}
export function streamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamOptions' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationType
> = z.nativeEnum(ModelConfigurationType);
/** @internal */
export const ModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationType
> = ModelConfigurationType$inboundSchema;

/** @internal */
export const ThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof ThinkingLevel
> = z.nativeEnum(ThinkingLevel);
/** @internal */
export const ThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof ThinkingLevel
> = ThinkingLevel$inboundSchema;

/** @internal */
export const Thinking$inboundSchema: z.ZodType<
  Thinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: ThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type Thinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const Thinking$outboundSchema: z.ZodType<
  Thinking$Outbound,
  z.ZodTypeDef,
  Thinking
> = z.object({
  type: ModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: ThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function thinkingToJSON(thinking: Thinking): string {
  return JSON.stringify(Thinking$outboundSchema.parse(thinking));
}
export function thinkingFromJSON(
  jsonString: string,
): SafeParseResult<Thinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thinking' from JSON`,
  );
}

/** @internal */
export const ToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = z.nativeEnum(ToolChoiceType);
/** @internal */
export const ToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = ToolChoiceType$inboundSchema;

/** @internal */
export const ToolChoiceFunction$inboundSchema: z.ZodType<
  ToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type ToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const ToolChoiceFunction$outboundSchema: z.ZodType<
  ToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function toolChoiceFunctionToJSON(
  toolChoiceFunction: ToolChoiceFunction,
): string {
  return JSON.stringify(
    ToolChoiceFunction$outboundSchema.parse(toolChoiceFunction),
  );
}
export function toolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ToolChoice2$inboundSchema: z.ZodType<
  ToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$inboundSchema),
});
/** @internal */
export type ToolChoice2$Outbound = {
  type?: string | undefined;
  function: ToolChoiceFunction$Outbound;
};

/** @internal */
export const ToolChoice2$outboundSchema: z.ZodType<
  ToolChoice2$Outbound,
  z.ZodTypeDef,
  ToolChoice2
> = z.object({
  type: ToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$outboundSchema),
});

export function toolChoice2ToJSON(toolChoice2: ToolChoice2): string {
  return JSON.stringify(ToolChoice2$outboundSchema.parse(toolChoice2));
}
export function toolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice2' from JSON`,
  );
}

/** @internal */
export const ToolChoice1$inboundSchema: z.ZodNativeEnum<typeof ToolChoice1> = z
  .nativeEnum(ToolChoice1);
/** @internal */
export const ToolChoice1$outboundSchema: z.ZodNativeEnum<typeof ToolChoice1> =
  ToolChoice1$inboundSchema;

/** @internal */
export const ToolChoice$inboundSchema: z.ZodType<
  ToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ToolChoice2$inboundSchema),
  ToolChoice1$inboundSchema,
]);
/** @internal */
export type ToolChoice$Outbound = ToolChoice2$Outbound | string;

/** @internal */
export const ToolChoice$outboundSchema: z.ZodType<
  ToolChoice$Outbound,
  z.ZodTypeDef,
  ToolChoice
> = z.union([
  z.lazy(() => ToolChoice2$outboundSchema),
  ToolChoice1$outboundSchema,
]);

export function toolChoiceToJSON(toolChoice: ToolChoice): string {
  return JSON.stringify(ToolChoice$outboundSchema.parse(toolChoice));
}
export function toolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice' from JSON`,
  );
}

/** @internal */
export const Modalities$inboundSchema: z.ZodNativeEnum<typeof Modalities> = z
  .nativeEnum(Modalities);
/** @internal */
export const Modalities$outboundSchema: z.ZodNativeEnum<typeof Modalities> =
  Modalities$inboundSchema;

/** @internal */
export const ParametersT$inboundSchema: z.ZodType<
  ParametersT,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ModelConfigurationAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => Text$inboundSchema),
    z.lazy(() => JSONObject$inboundSchema),
    z.lazy(() => JSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(z.lazy(() => StreamOptions$inboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ToolChoice2$inboundSchema),
    ToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type ParametersT$Outbound = {
  audio?: ModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | Text$Outbound
    | JSONObject$Outbound
    | JSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: StreamOptions$Outbound | null | undefined;
  thinking?: Thinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const ParametersT$outboundSchema: z.ZodType<
  ParametersT$Outbound,
  z.ZodTypeDef,
  ParametersT
> = z.object({
  audio: z.nullable(z.lazy(() => ModelConfigurationAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => Text$outboundSchema),
    z.lazy(() => JSONObject$outboundSchema),
    z.lazy(() => JSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => StreamOptions$outboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ToolChoice2$outboundSchema),
    ToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function parametersToJSON(parametersT: ParametersT): string {
  return JSON.stringify(ParametersT$outboundSchema.parse(parametersT));
}
export function parametersFromJSON(
  jsonString: string,
): SafeParseResult<ParametersT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParametersT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParametersT' from JSON`,
  );
}

/** @internal */
export const Retry$inboundSchema: z.ZodType<Retry, z.ZodTypeDef, unknown> = z
  .object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });
/** @internal */
export type Retry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const Retry$outboundSchema: z.ZodType<
  Retry$Outbound,
  z.ZodTypeDef,
  Retry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function retryToJSON(retry: Retry): string {
  return JSON.stringify(Retry$outboundSchema.parse(retry));
}
export function retryFromJSON(
  jsonString: string,
): SafeParseResult<Retry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Retry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Retry' from JSON`,
  );
}

/** @internal */
export const ModelConfiguration2$inboundSchema: z.ZodType<
  ModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ParametersT$inboundSchema).optional(),
  retry: z.lazy(() => Retry$inboundSchema).optional(),
});
/** @internal */
export type ModelConfiguration2$Outbound = {
  id: string;
  parameters?: ParametersT$Outbound | undefined;
  retry?: Retry$Outbound | undefined;
};

/** @internal */
export const ModelConfiguration2$outboundSchema: z.ZodType<
  ModelConfiguration2$Outbound,
  z.ZodTypeDef,
  ModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ParametersT$outboundSchema).optional(),
  retry: z.lazy(() => Retry$outboundSchema).optional(),
});

export function modelConfiguration2ToJSON(
  modelConfiguration2: ModelConfiguration2,
): string {
  return JSON.stringify(
    ModelConfiguration2$outboundSchema.parse(modelConfiguration2),
  );
}
export function modelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<ModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const ModelConfiguration$inboundSchema: z.ZodType<
  ModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => ModelConfiguration2$inboundSchema), z.string()]);
/** @internal */
export type ModelConfiguration$Outbound = ModelConfiguration2$Outbound | string;

/** @internal */
export const ModelConfiguration$outboundSchema: z.ZodType<
  ModelConfiguration$Outbound,
  z.ZodTypeDef,
  ModelConfiguration
> = z.union([z.lazy(() => ModelConfiguration2$outboundSchema), z.string()]);

export function modelConfigurationToJSON(
  modelConfiguration: ModelConfiguration,
): string {
  return JSON.stringify(
    ModelConfiguration$outboundSchema.parse(modelConfiguration),
  );
}
export function modelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfiguration' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationVoice$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationVoice
> = z.nativeEnum(FallbackModelConfigurationVoice);
/** @internal */
export const FallbackModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationVoice
> = FallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const FallbackModelConfigurationFormat$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationFormat
> = z.nativeEnum(FallbackModelConfigurationFormat);
/** @internal */
export const FallbackModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationFormat
> = FallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const FallbackModelConfigurationAudio$inboundSchema: z.ZodType<
  FallbackModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: FallbackModelConfigurationVoice$inboundSchema,
  format: FallbackModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type FallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const FallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  FallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationAudio
> = z.object({
  voice: FallbackModelConfigurationVoice$outboundSchema,
  format: FallbackModelConfigurationFormat$outboundSchema,
});

export function fallbackModelConfigurationAudioToJSON(
  fallbackModelConfigurationAudio: FallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    FallbackModelConfigurationAudio$outboundSchema.parse(
      fallbackModelConfigurationAudio,
    ),
  );
}
export function fallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJsonSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsJsonSchemaToJSON(
  createAgentRequestResponseFormatAgentsJsonSchema:
    CreateAgentRequestResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema.parse(
      createAgentRequestResponseFormatAgentsJsonSchema,
    ),
  );
}
export function createAgentRequestResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatJSONSchema$inboundSchema:
  z.ZodType<CreateAgentRequestResponseFormatJSONSchema, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("json_schema"),
      json_schema: z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsJsonSchema$inboundSchema
      ),
    }).transform((v) => {
      return remap$(v, {
        "json_schema": "jsonSchema",
      });
    });
/** @internal */
export type CreateAgentRequestResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentRequestResponseFormatJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentRequestResponseFormatJSONSchemaToJSON(
  createAgentRequestResponseFormatJSONSchema:
    CreateAgentRequestResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatJSONSchema$outboundSchema.parse(
      createAgentRequestResponseFormatJSONSchema,
    ),
  );
}
export function createAgentRequestResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormatJSONObject$inboundSchema: z.ZodType<
  ResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type ResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const ResponseFormatJSONObject$outboundSchema: z.ZodType<
  ResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  ResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function responseFormatJSONObjectToJSON(
  responseFormatJSONObject: ResponseFormatJSONObject,
): string {
  return JSON.stringify(
    ResponseFormatJSONObject$outboundSchema.parse(responseFormatJSONObject),
  );
}
export function responseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const ResponseFormatText$inboundSchema: z.ZodType<
  ResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type ResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const ResponseFormatText$outboundSchema: z.ZodType<
  ResponseFormatText$Outbound,
  z.ZodTypeDef,
  ResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function responseFormatTextToJSON(
  responseFormatText: ResponseFormatText,
): string {
  return JSON.stringify(
    ResponseFormatText$outboundSchema.parse(responseFormatText),
  );
}
export function responseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatText' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationResponseFormat$inboundSchema: z.ZodType<
  FallbackModelConfigurationResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseFormatText$inboundSchema),
  z.lazy(() => ResponseFormatJSONObject$inboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$inboundSchema),
]);
/** @internal */
export type FallbackModelConfigurationResponseFormat$Outbound =
  | ResponseFormatText$Outbound
  | ResponseFormatJSONObject$Outbound
  | CreateAgentRequestResponseFormatJSONSchema$Outbound;

/** @internal */
export const FallbackModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  FallbackModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => ResponseFormatText$outboundSchema),
  z.lazy(() => ResponseFormatJSONObject$outboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$outboundSchema),
]);

export function fallbackModelConfigurationResponseFormatToJSON(
  fallbackModelConfigurationResponseFormat:
    FallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    FallbackModelConfigurationResponseFormat$outboundSchema.parse(
      fallbackModelConfigurationResponseFormat,
    ),
  );
}
export function fallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  FallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationStop$inboundSchema: z.ZodType<
  FallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type FallbackModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const FallbackModelConfigurationStop$outboundSchema: z.ZodType<
  FallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function fallbackModelConfigurationStopToJSON(
  fallbackModelConfigurationStop: FallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStop$outboundSchema.parse(
      fallbackModelConfigurationStop,
    ),
  );
}
export function fallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationStreamOptions$inboundSchema: z.ZodType<
  FallbackModelConfigurationStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type FallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const FallbackModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  FallbackModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function fallbackModelConfigurationStreamOptionsToJSON(
  fallbackModelConfigurationStreamOptions:
    FallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStreamOptions$outboundSchema.parse(
      fallbackModelConfigurationStreamOptions,
    ),
  );
}
export function fallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  FallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationType
> = z.nativeEnum(FallbackModelConfigurationType);
/** @internal */
export const FallbackModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationType
> = FallbackModelConfigurationType$inboundSchema;

/** @internal */
export const FallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationThinkingLevel> = z
    .nativeEnum(FallbackModelConfigurationThinkingLevel);
/** @internal */
export const FallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationThinkingLevel> =
    FallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const FallbackModelConfigurationThinking$inboundSchema: z.ZodType<
  FallbackModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FallbackModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: FallbackModelConfigurationThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type FallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const FallbackModelConfigurationThinking$outboundSchema: z.ZodType<
  FallbackModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationThinking
> = z.object({
  type: FallbackModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: FallbackModelConfigurationThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function fallbackModelConfigurationThinkingToJSON(
  fallbackModelConfigurationThinking: FallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    FallbackModelConfigurationThinking$outboundSchema.parse(
      fallbackModelConfigurationThinking,
    ),
  );
}
export function fallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoiceType
> = z.nativeEnum(CreateAgentRequestToolChoiceType);
/** @internal */
export const CreateAgentRequestToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoiceType
> = CreateAgentRequestToolChoiceType$inboundSchema;

/** @internal */
export const CreateAgentRequestToolChoiceFunction$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type CreateAgentRequestToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateAgentRequestToolChoiceFunction$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function createAgentRequestToolChoiceFunctionToJSON(
  createAgentRequestToolChoiceFunction: CreateAgentRequestToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceFunction$outboundSchema.parse(
      createAgentRequestToolChoiceFunction,
    ),
  );
}
export function createAgentRequestToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoice2$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentRequestToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => CreateAgentRequestToolChoiceFunction$inboundSchema),
});
/** @internal */
export type CreateAgentRequestToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateAgentRequestToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateAgentRequestToolChoice2$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoice2
> = z.object({
  type: CreateAgentRequestToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentRequestToolChoiceFunction$outboundSchema),
});

export function createAgentRequestToolChoice2ToJSON(
  createAgentRequestToolChoice2: CreateAgentRequestToolChoice2,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoice2$outboundSchema.parse(
      createAgentRequestToolChoice2,
    ),
  );
}
export function createAgentRequestToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoice2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoice1
> = z.nativeEnum(CreateAgentRequestToolChoice1);
/** @internal */
export const CreateAgentRequestToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoice1
> = CreateAgentRequestToolChoice1$inboundSchema;

/** @internal */
export const FallbackModelConfigurationToolChoice$inboundSchema: z.ZodType<
  FallbackModelConfigurationToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoice2$inboundSchema),
  CreateAgentRequestToolChoice1$inboundSchema,
]);
/** @internal */
export type FallbackModelConfigurationToolChoice$Outbound =
  | CreateAgentRequestToolChoice2$Outbound
  | string;

/** @internal */
export const FallbackModelConfigurationToolChoice$outboundSchema: z.ZodType<
  FallbackModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationToolChoice
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoice2$outboundSchema),
  CreateAgentRequestToolChoice1$outboundSchema,
]);

export function fallbackModelConfigurationToolChoiceToJSON(
  fallbackModelConfigurationToolChoice: FallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    FallbackModelConfigurationToolChoice$outboundSchema.parse(
      fallbackModelConfigurationToolChoice,
    ),
  );
}
export function fallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationModalities> = z.nativeEnum(
    FallbackModelConfigurationModalities,
  );
/** @internal */
export const FallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationModalities> =
    FallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const FallbackModelConfigurationParameters$inboundSchema: z.ZodType<
  FallbackModelConfigurationParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => FallbackModelConfigurationAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ResponseFormatText$inboundSchema),
    z.lazy(() => ResponseFormatJSONObject$inboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => FallbackModelConfigurationStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelConfigurationThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentRequestToolChoice2$inboundSchema),
    CreateAgentRequestToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(FallbackModelConfigurationModalities$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type FallbackModelConfigurationParameters$Outbound = {
  audio?: FallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ResponseFormatText$Outbound
    | ResponseFormatJSONObject$Outbound
    | CreateAgentRequestResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | FallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: FallbackModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentRequestToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const FallbackModelConfigurationParameters$outboundSchema: z.ZodType<
  FallbackModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => FallbackModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ResponseFormatText$outboundSchema),
    z.lazy(() => ResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => FallbackModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelConfigurationThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentRequestToolChoice2$outboundSchema),
    CreateAgentRequestToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(FallbackModelConfigurationModalities$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function fallbackModelConfigurationParametersToJSON(
  fallbackModelConfigurationParameters: FallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    FallbackModelConfigurationParameters$outboundSchema.parse(
      fallbackModelConfigurationParameters,
    ),
  );
}
export function fallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfiguration2$inboundSchema: z.ZodType<
  FallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => FallbackModelConfigurationParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type FallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?: FallbackModelConfigurationParameters$Outbound | undefined;
};

/** @internal */
export const FallbackModelConfiguration2$outboundSchema: z.ZodType<
  FallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => FallbackModelConfigurationParameters$outboundSchema)
    .optional(),
});

export function fallbackModelConfiguration2ToJSON(
  fallbackModelConfiguration2: FallbackModelConfiguration2,
): string {
  return JSON.stringify(
    FallbackModelConfiguration2$outboundSchema.parse(
      fallbackModelConfiguration2,
    ),
  );
}
export function fallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfiguration$inboundSchema: z.ZodType<
  FallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type FallbackModelConfiguration$Outbound =
  | FallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const FallbackModelConfiguration$outboundSchema: z.ZodType<
  FallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration
> = z.union([
  z.lazy(() => FallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function fallbackModelConfigurationToJSON(
  fallbackModelConfiguration: FallbackModelConfiguration,
): string {
  return JSON.stringify(
    FallbackModelConfiguration$outboundSchema.parse(fallbackModelConfiguration),
  );
}
export function fallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);
/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = ToolApprovalRequired$inboundSchema;

/** @internal */
export const MCPTool$inboundSchema: z.ZodType<MCPTool, z.ZodTypeDef, unknown> =
  z.object({
    type: z.literal("mcp"),
    key: z.string().optional(),
    id: z.string().optional(),
    tool_id: z.string(),
    requires_approval: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      "tool_id": "toolId",
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type MCPTool$Outbound = {
  type: "mcp";
  key?: string | undefined;
  id?: string | undefined;
  tool_id: string;
  requires_approval: boolean;
};

/** @internal */
export const MCPTool$outboundSchema: z.ZodType<
  MCPTool$Outbound,
  z.ZodTypeDef,
  MCPTool
> = z.object({
  type: z.literal("mcp"),
  key: z.string().optional(),
  id: z.string().optional(),
  toolId: z.string(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requiresApproval: "requires_approval",
  });
});

export function mcpToolToJSON(mcpTool: MCPTool): string {
  return JSON.stringify(MCPTool$outboundSchema.parse(mcpTool));
}
export function mcpToolFromJSON(
  jsonString: string,
): SafeParseResult<MCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MCPTool' from JSON`,
  );
}

/** @internal */
export const FunctionTool$inboundSchema: z.ZodType<
  FunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type FunctionTool$Outbound = {
  type: "function";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const FunctionTool$outboundSchema: z.ZodType<
  FunctionTool$Outbound,
  z.ZodTypeDef,
  FunctionTool
> = z.object({
  type: z.literal("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function functionToolToJSON(functionTool: FunctionTool): string {
  return JSON.stringify(FunctionTool$outboundSchema.parse(functionTool));
}
export function functionToolFromJSON(
  jsonString: string,
): SafeParseResult<FunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionTool' from JSON`,
  );
}

/** @internal */
export const CodeExecutionTool$inboundSchema: z.ZodType<
  CodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CodeExecutionTool$Outbound = {
  type: "code";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const CodeExecutionTool$outboundSchema: z.ZodType<
  CodeExecutionTool$Outbound,
  z.ZodTypeDef,
  CodeExecutionTool
> = z.object({
  type: z.literal("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function codeExecutionToolToJSON(
  codeExecutionTool: CodeExecutionTool,
): string {
  return JSON.stringify(
    CodeExecutionTool$outboundSchema.parse(codeExecutionTool),
  );
}
export function codeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<CodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const HTTPTool$inboundSchema: z.ZodType<
  HTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type HTTPTool$Outbound = {
  type: "http";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const HTTPTool$outboundSchema: z.ZodType<
  HTTPTool$Outbound,
  z.ZodTypeDef,
  HTTPTool
> = z.object({
  type: z.literal("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function httpToolToJSON(httpTool: HTTPTool): string {
  return JSON.stringify(HTTPTool$outboundSchema.parse(httpTool));
}
export function httpToolFromJSON(
  jsonString: string,
): SafeParseResult<HTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HTTPTool' from JSON`,
  );
}

/** @internal */
export const CurrentDateTool$inboundSchema: z.ZodType<
  CurrentDateTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("current_date"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CurrentDateTool$Outbound = {
  type: "current_date";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CurrentDateTool$outboundSchema: z.ZodType<
  CurrentDateTool$Outbound,
  z.ZodTypeDef,
  CurrentDateTool
> = z.object({
  type: z.literal("current_date"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function currentDateToolToJSON(
  currentDateTool: CurrentDateTool,
): string {
  return JSON.stringify(CurrentDateTool$outboundSchema.parse(currentDateTool));
}
export function currentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<CurrentDateTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CurrentDateTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CurrentDateTool' from JSON`,
  );
}

/** @internal */
export const QueryKnowledgeBaseTool$inboundSchema: z.ZodType<
  QueryKnowledgeBaseTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("query_knowledge_base"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryKnowledgeBaseTool$Outbound = {
  type: "query_knowledge_base";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  QueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  QueryKnowledgeBaseTool
> = z.object({
  type: z.literal("query_knowledge_base"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryKnowledgeBaseToolToJSON(
  queryKnowledgeBaseTool: QueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    QueryKnowledgeBaseTool$outboundSchema.parse(queryKnowledgeBaseTool),
  );
}
export function queryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryKnowledgeBaseTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryKnowledgeBaseTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const RetrieveKnowledgeBasesTool$inboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("retrieve_knowledge_bases"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveKnowledgeBasesTool$Outbound = {
  type: "retrieve_knowledge_bases";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveKnowledgeBasesTool$outboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool$Outbound,
  z.ZodTypeDef,
  RetrieveKnowledgeBasesTool
> = z.object({
  type: z.literal("retrieve_knowledge_bases"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveKnowledgeBasesToolToJSON(
  retrieveKnowledgeBasesTool: RetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    RetrieveKnowledgeBasesTool$outboundSchema.parse(retrieveKnowledgeBasesTool),
  );
}
export function retrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveKnowledgeBasesTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveKnowledgeBasesTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const DeleteMemoryDocumentTool$inboundSchema: z.ZodType<
  DeleteMemoryDocumentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("delete_memory_document"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type DeleteMemoryDocumentTool$Outbound = {
  type: "delete_memory_document";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const DeleteMemoryDocumentTool$outboundSchema: z.ZodType<
  DeleteMemoryDocumentTool$Outbound,
  z.ZodTypeDef,
  DeleteMemoryDocumentTool
> = z.object({
  type: z.literal("delete_memory_document"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function deleteMemoryDocumentToolToJSON(
  deleteMemoryDocumentTool: DeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    DeleteMemoryDocumentTool$outboundSchema.parse(deleteMemoryDocumentTool),
  );
}
export function deleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<DeleteMemoryDocumentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteMemoryDocumentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const RetrieveMemoryStoresTool$inboundSchema: z.ZodType<
  RetrieveMemoryStoresTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("retrieve_memory_stores"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveMemoryStoresTool$Outbound = {
  type: "retrieve_memory_stores";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveMemoryStoresTool$outboundSchema: z.ZodType<
  RetrieveMemoryStoresTool$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoresTool
> = z.object({
  type: z.literal("retrieve_memory_stores"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveMemoryStoresToolToJSON(
  retrieveMemoryStoresTool: RetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    RetrieveMemoryStoresTool$outboundSchema.parse(retrieveMemoryStoresTool),
  );
}
export function retrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoresTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryStoresTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const WriteMemoryStoreTool$inboundSchema: z.ZodType<
  WriteMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("write_memory_store"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WriteMemoryStoreTool$Outbound = {
  type: "write_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WriteMemoryStoreTool$outboundSchema: z.ZodType<
  WriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  WriteMemoryStoreTool
> = z.object({
  type: z.literal("write_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function writeMemoryStoreToolToJSON(
  writeMemoryStoreTool: WriteMemoryStoreTool,
): string {
  return JSON.stringify(
    WriteMemoryStoreTool$outboundSchema.parse(writeMemoryStoreTool),
  );
}
export function writeMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<WriteMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WriteMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const QueryMemoryStoreTool$inboundSchema: z.ZodType<
  QueryMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("query_memory_store"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryMemoryStoreTool$Outbound = {
  type: "query_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryMemoryStoreTool$outboundSchema: z.ZodType<
  QueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  QueryMemoryStoreTool
> = z.object({
  type: z.literal("query_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryMemoryStoreToolToJSON(
  queryMemoryStoreTool: QueryMemoryStoreTool,
): string {
  return JSON.stringify(
    QueryMemoryStoreTool$outboundSchema.parse(queryMemoryStoreTool),
  );
}
export function queryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const RetrieveAgentsTool$inboundSchema: z.ZodType<
  RetrieveAgentsTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("retrieve_agents"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveAgentsTool$Outbound = {
  type: "retrieve_agents";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveAgentsTool$outboundSchema: z.ZodType<
  RetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  RetrieveAgentsTool
> = z.object({
  type: z.literal("retrieve_agents"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveAgentsToolToJSON(
  retrieveAgentsTool: RetrieveAgentsTool,
): string {
  return JSON.stringify(
    RetrieveAgentsTool$outboundSchema.parse(retrieveAgentsTool),
  );
}
export function retrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentsTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentsTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const CallSubAgentTool$inboundSchema: z.ZodType<
  CallSubAgentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("call_sub_agent"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CallSubAgentTool$Outbound = {
  type: "call_sub_agent";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CallSubAgentTool$outboundSchema: z.ZodType<
  CallSubAgentTool$Outbound,
  z.ZodTypeDef,
  CallSubAgentTool
> = z.object({
  type: z.literal("call_sub_agent"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function callSubAgentToolToJSON(
  callSubAgentTool: CallSubAgentTool,
): string {
  return JSON.stringify(
    CallSubAgentTool$outboundSchema.parse(callSubAgentTool),
  );
}
export function callSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<CallSubAgentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CallSubAgentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const WebScraperTool$inboundSchema: z.ZodType<
  WebScraperTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("web_scraper"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WebScraperTool$Outbound = {
  type: "web_scraper";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WebScraperTool$outboundSchema: z.ZodType<
  WebScraperTool$Outbound,
  z.ZodTypeDef,
  WebScraperTool
> = z.object({
  type: z.literal("web_scraper"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function webScraperToolToJSON(webScraperTool: WebScraperTool): string {
  return JSON.stringify(WebScraperTool$outboundSchema.parse(webScraperTool));
}
export function webScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<WebScraperTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebScraperTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebScraperTool' from JSON`,
  );
}

/** @internal */
export const GoogleSearchTool$inboundSchema: z.ZodType<
  GoogleSearchTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("google_search"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type GoogleSearchTool$Outbound = {
  type: "google_search";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const GoogleSearchTool$outboundSchema: z.ZodType<
  GoogleSearchTool$Outbound,
  z.ZodTypeDef,
  GoogleSearchTool
> = z.object({
  type: z.literal("google_search"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function googleSearchToolToJSON(
  googleSearchTool: GoogleSearchTool,
): string {
  return JSON.stringify(
    GoogleSearchTool$outboundSchema.parse(googleSearchTool),
  );
}
export function googleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<GoogleSearchTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GoogleSearchTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUD$inboundSchema: z.ZodType<
  AgentToolInputCRUD,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GoogleSearchTool$inboundSchema),
  z.lazy(() => WebScraperTool$inboundSchema),
  z.lazy(() => CallSubAgentTool$inboundSchema),
  z.lazy(() => RetrieveAgentsTool$inboundSchema),
  z.lazy(() => QueryMemoryStoreTool$inboundSchema),
  z.lazy(() => WriteMemoryStoreTool$inboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
  z.lazy(() => CurrentDateTool$inboundSchema),
  z.lazy(() => HTTPTool$inboundSchema),
  z.lazy(() => CodeExecutionTool$inboundSchema),
  z.lazy(() => FunctionTool$inboundSchema),
  z.lazy(() => MCPTool$inboundSchema),
]);
/** @internal */
export type AgentToolInputCRUD$Outbound =
  | GoogleSearchTool$Outbound
  | WebScraperTool$Outbound
  | CallSubAgentTool$Outbound
  | RetrieveAgentsTool$Outbound
  | QueryMemoryStoreTool$Outbound
  | WriteMemoryStoreTool$Outbound
  | RetrieveMemoryStoresTool$Outbound
  | DeleteMemoryDocumentTool$Outbound
  | RetrieveKnowledgeBasesTool$Outbound
  | QueryKnowledgeBaseTool$Outbound
  | CurrentDateTool$Outbound
  | HTTPTool$Outbound
  | CodeExecutionTool$Outbound
  | FunctionTool$Outbound
  | MCPTool$Outbound;

/** @internal */
export const AgentToolInputCRUD$outboundSchema: z.ZodType<
  AgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUD
> = z.union([
  z.lazy(() => GoogleSearchTool$outboundSchema),
  z.lazy(() => WebScraperTool$outboundSchema),
  z.lazy(() => CallSubAgentTool$outboundSchema),
  z.lazy(() => RetrieveAgentsTool$outboundSchema),
  z.lazy(() => QueryMemoryStoreTool$outboundSchema),
  z.lazy(() => WriteMemoryStoreTool$outboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => CurrentDateTool$outboundSchema),
  z.lazy(() => HTTPTool$outboundSchema),
  z.lazy(() => CodeExecutionTool$outboundSchema),
  z.lazy(() => FunctionTool$outboundSchema),
  z.lazy(() => MCPTool$outboundSchema),
]);

export function agentToolInputCRUDToJSON(
  agentToolInputCRUD: AgentToolInputCRUD,
): string {
  return JSON.stringify(
    AgentToolInputCRUD$outboundSchema.parse(agentToolInputCRUD),
  );
}
export function agentToolInputCRUDFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUD, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUD$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUD' from JSON`,
  );
}

/** @internal */
export const ExecuteOn$inboundSchema: z.ZodNativeEnum<typeof ExecuteOn> = z
  .nativeEnum(ExecuteOn);
/** @internal */
export const ExecuteOn$outboundSchema: z.ZodNativeEnum<typeof ExecuteOn> =
  ExecuteOn$inboundSchema;

/** @internal */
export const Evaluators$inboundSchema: z.ZodType<
  Evaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type Evaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const Evaluators$outboundSchema: z.ZodType<
  Evaluators$Outbound,
  z.ZodTypeDef,
  Evaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: ExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function evaluatorsToJSON(evaluators: Evaluators): string {
  return JSON.stringify(Evaluators$outboundSchema.parse(evaluators));
}
export function evaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<Evaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Evaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Evaluators' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestExecuteOn
> = z.nativeEnum(CreateAgentRequestExecuteOn);
/** @internal */
export const CreateAgentRequestExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestExecuteOn
> = CreateAgentRequestExecuteOn$inboundSchema;

/** @internal */
export const Guardrails$inboundSchema: z.ZodType<
  Guardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: CreateAgentRequestExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type Guardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const Guardrails$outboundSchema: z.ZodType<
  Guardrails$Outbound,
  z.ZodTypeDef,
  Guardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: CreateAgentRequestExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function guardrailsToJSON(guardrails: Guardrails): string {
  return JSON.stringify(Guardrails$outboundSchema.parse(guardrails));
}
export function guardrailsFromJSON(
  jsonString: string,
): SafeParseResult<Guardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Guardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Guardrails' from JSON`,
  );
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$inboundSchema),
      z.lazy(() => WebScraperTool$inboundSchema),
      z.lazy(() => CallSubAgentTool$inboundSchema),
      z.lazy(() => RetrieveAgentsTool$inboundSchema),
      z.lazy(() => QueryMemoryStoreTool$inboundSchema),
      z.lazy(() => WriteMemoryStoreTool$inboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
      z.lazy(() => CurrentDateTool$inboundSchema),
      z.lazy(() => HTTPTool$inboundSchema),
      z.lazy(() => CodeExecutionTool$inboundSchema),
      z.lazy(() => FunctionTool$inboundSchema),
      z.lazy(() => MCPTool$inboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$inboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type Settings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | GoogleSearchTool$Outbound
      | WebScraperTool$Outbound
      | CallSubAgentTool$Outbound
      | RetrieveAgentsTool$Outbound
      | QueryMemoryStoreTool$Outbound
      | WriteMemoryStoreTool$Outbound
      | RetrieveMemoryStoresTool$Outbound
      | DeleteMemoryDocumentTool$Outbound
      | RetrieveKnowledgeBasesTool$Outbound
      | QueryKnowledgeBaseTool$Outbound
      | CurrentDateTool$Outbound
      | HTTPTool$Outbound
      | CodeExecutionTool$Outbound
      | FunctionTool$Outbound
      | MCPTool$Outbound
    >
    | undefined;
  evaluators?: Array<Evaluators$Outbound> | undefined;
  guardrails?: Array<Guardrails$Outbound> | undefined;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$outboundSchema),
      z.lazy(() => WebScraperTool$outboundSchema),
      z.lazy(() => CallSubAgentTool$outboundSchema),
      z.lazy(() => RetrieveAgentsTool$outboundSchema),
      z.lazy(() => QueryMemoryStoreTool$outboundSchema),
      z.lazy(() => WriteMemoryStoreTool$outboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => CurrentDateTool$outboundSchema),
      z.lazy(() => HTTPTool$outboundSchema),
      z.lazy(() => CodeExecutionTool$outboundSchema),
      z.lazy(() => FunctionTool$outboundSchema),
      z.lazy(() => MCPTool$outboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$outboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}
export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const KnowledgeBases$inboundSchema: z.ZodType<
  KnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type KnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const KnowledgeBases$outboundSchema: z.ZodType<
  KnowledgeBases$Outbound,
  z.ZodTypeDef,
  KnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function knowledgeBasesToJSON(knowledgeBases: KnowledgeBases): string {
  return JSON.stringify(KnowledgeBases$outboundSchema.parse(knowledgeBases));
}
export function knowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeBases' from JSON`,
  );
}

/** @internal */
export const TeamOfAgents$inboundSchema: z.ZodType<
  TeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type TeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const TeamOfAgents$outboundSchema: z.ZodType<
  TeamOfAgents$Outbound,
  z.ZodTypeDef,
  TeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function teamOfAgentsToJSON(teamOfAgents: TeamOfAgents): string {
  return JSON.stringify(TeamOfAgents$outboundSchema.parse(teamOfAgents));
}
export function teamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<TeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamOfAgents' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestRequestBody$inboundSchema: z.ZodType<
  CreateAgentRequestRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  display_name: z.string().optional(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  system_prompt: z.string().optional(),
  path: z.string(),
  model: z.union([z.lazy(() => ModelConfiguration2$inboundSchema), z.string()]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => FallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => Settings$inboundSchema),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(z.lazy(() => KnowledgeBases$inboundSchema))
    .optional(),
  team_of_agents: z.array(z.lazy(() => TeamOfAgents$inboundSchema)).optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "system_prompt": "systemPrompt",
    "fallback_models": "fallbackModels",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});
/** @internal */
export type CreateAgentRequestRequestBody$Outbound = {
  key: string;
  display_name?: string | undefined;
  role: string;
  description: string;
  instructions: string;
  system_prompt?: string | undefined;
  path: string;
  model: ModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<FallbackModelConfiguration2$Outbound | string>
    | undefined;
  settings: Settings$Outbound;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<KnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<TeamOfAgents$Outbound> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateAgentRequestRequestBody$outboundSchema: z.ZodType<
  CreateAgentRequestRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestRequestBody
> = z.object({
  key: z.string(),
  displayName: z.string().optional(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  systemPrompt: z.string().optional(),
  path: z.string(),
  model: z.union([
    z.lazy(() => ModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => FallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => Settings$outboundSchema),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => KnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => TeamOfAgents$outboundSchema)).optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function createAgentRequestRequestBodyToJSON(
  createAgentRequestRequestBody: CreateAgentRequestRequestBody,
): string {
  return JSON.stringify(
    CreateAgentRequestRequestBody$outboundSchema.parse(
      createAgentRequestRequestBody,
    ),
  );
}
export function createAgentRequestRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestStatus
> = z.nativeEnum(CreateAgentRequestStatus);
/** @internal */
export const CreateAgentRequestStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestStatus
> = CreateAgentRequestStatus$inboundSchema;

/** @internal */
export const CreateAgentRequestToolApprovalRequired$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolApprovalRequired> = z.nativeEnum(
    CreateAgentRequestToolApprovalRequired,
  );
/** @internal */
export const CreateAgentRequestToolApprovalRequired$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolApprovalRequired> =
    CreateAgentRequestToolApprovalRequired$inboundSchema;

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type Conditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const Conditions$outboundSchema: z.ZodType<
  Conditions$Outbound,
  z.ZodTypeDef,
  Conditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function conditionsToJSON(conditions: Conditions): string {
  return JSON.stringify(Conditions$outboundSchema.parse(conditions));
}
export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestTools$inboundSchema: z.ZodType<
  CreateAgentRequestTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => Conditions$inboundSchema)).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});
/** @internal */
export type CreateAgentRequestTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<Conditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const CreateAgentRequestTools$outboundSchema: z.ZodType<
  CreateAgentRequestTools$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  toolId: z.string().optional(),
  conditions: z.array(z.lazy(() => Conditions$outboundSchema)).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
    toolId: "tool_id",
  });
});

export function createAgentRequestToolsToJSON(
  createAgentRequestTools: CreateAgentRequestTools,
): string {
  return JSON.stringify(
    CreateAgentRequestTools$outboundSchema.parse(createAgentRequestTools),
  );
}
export function createAgentRequestToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestTools' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestAgentsExecuteOn
> = z.nativeEnum(CreateAgentRequestAgentsExecuteOn);
/** @internal */
export const CreateAgentRequestAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestAgentsExecuteOn
> = CreateAgentRequestAgentsExecuteOn$inboundSchema;

/** @internal */
export const CreateAgentRequestEvaluators$inboundSchema: z.ZodType<
  CreateAgentRequestEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: CreateAgentRequestAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type CreateAgentRequestEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const CreateAgentRequestEvaluators$outboundSchema: z.ZodType<
  CreateAgentRequestEvaluators$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: CreateAgentRequestAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function createAgentRequestEvaluatorsToJSON(
  createAgentRequestEvaluators: CreateAgentRequestEvaluators,
): string {
  return JSON.stringify(
    CreateAgentRequestEvaluators$outboundSchema.parse(
      createAgentRequestEvaluators,
    ),
  );
}
export function createAgentRequestEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestEvaluators' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsResponseExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentsResponseExecuteOn> = z
    .nativeEnum(CreateAgentRequestAgentsResponseExecuteOn);
/** @internal */
export const CreateAgentRequestAgentsResponseExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentsResponseExecuteOn> =
    CreateAgentRequestAgentsResponseExecuteOn$inboundSchema;

/** @internal */
export const CreateAgentRequestGuardrails$inboundSchema: z.ZodType<
  CreateAgentRequestGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: CreateAgentRequestAgentsResponseExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type CreateAgentRequestGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const CreateAgentRequestGuardrails$outboundSchema: z.ZodType<
  CreateAgentRequestGuardrails$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: CreateAgentRequestAgentsResponseExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function createAgentRequestGuardrailsToJSON(
  createAgentRequestGuardrails: CreateAgentRequestGuardrails,
): string {
  return JSON.stringify(
    CreateAgentRequestGuardrails$outboundSchema.parse(
      createAgentRequestGuardrails,
    ),
  );
}
export function createAgentRequestGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestGuardrails' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestSettings$inboundSchema: z.ZodType<
  CreateAgentRequestSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: CreateAgentRequestToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => CreateAgentRequestTools$inboundSchema))
    .optional(),
  evaluators: z.array(z.lazy(() => CreateAgentRequestEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => CreateAgentRequestGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type CreateAgentRequestSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<CreateAgentRequestTools$Outbound> | undefined;
  evaluators?: Array<CreateAgentRequestEvaluators$Outbound> | undefined;
  guardrails?: Array<CreateAgentRequestGuardrails$Outbound> | undefined;
};

/** @internal */
export const CreateAgentRequestSettings$outboundSchema: z.ZodType<
  CreateAgentRequestSettings$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: CreateAgentRequestToolApprovalRequired$outboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => CreateAgentRequestTools$outboundSchema))
    .optional(),
  evaluators: z.array(z.lazy(() => CreateAgentRequestEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => CreateAgentRequestGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function createAgentRequestSettingsToJSON(
  createAgentRequestSettings: CreateAgentRequestSettings,
): string {
  return JSON.stringify(
    CreateAgentRequestSettings$outboundSchema.parse(createAgentRequestSettings),
  );
}
export function createAgentRequestSettingsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestSettings' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestVoice
> = z.nativeEnum(CreateAgentRequestVoice);
/** @internal */
export const CreateAgentRequestVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestVoice
> = CreateAgentRequestVoice$inboundSchema;

/** @internal */
export const CreateAgentRequestFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestFormat
> = z.nativeEnum(CreateAgentRequestFormat);
/** @internal */
export const CreateAgentRequestFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestFormat
> = CreateAgentRequestFormat$inboundSchema;

/** @internal */
export const CreateAgentRequestAudio$inboundSchema: z.ZodType<
  CreateAgentRequestAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateAgentRequestVoice$inboundSchema,
  format: CreateAgentRequestFormat$inboundSchema,
});
/** @internal */
export type CreateAgentRequestAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentRequestAudio$outboundSchema: z.ZodType<
  CreateAgentRequestAudio$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestAudio
> = z.object({
  voice: CreateAgentRequestVoice$outboundSchema,
  format: CreateAgentRequestFormat$outboundSchema,
});

export function createAgentRequestAudioToJSON(
  createAgentRequestAudio: CreateAgentRequestAudio,
): string {
  return JSON.stringify(
    CreateAgentRequestAudio$outboundSchema.parse(createAgentRequestAudio),
  );
}
export function createAgentRequestAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsResponseJsonSchemaToJSON(
  createAgentRequestResponseFormatAgentsResponseJsonSchema:
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema
      .parse(createAgentRequestResponseFormatAgentsResponseJsonSchema),
  );
}
export function createAgentRequestResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$Outbound =
  {
    type: "json_schema";
    json_schema:
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$Outbound;
  };

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentRequestResponseFormatAgentsResponse201JSONSchemaToJSON(
  createAgentRequestResponseFormatAgentsResponse201JSONSchema:
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$outboundSchema
      .parse(createAgentRequestResponseFormatAgentsResponse201JSONSchema),
  );
}
export function createAgentRequestResponseFormatAgentsResponse201JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201JSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatJSONObject$inboundSchema:
  z.ZodType<CreateAgentRequestResponseFormatJSONObject, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("json_object"),
    });
/** @internal */
export type CreateAgentRequestResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CreateAgentRequestResponseFormatJSONObject$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatJSONObject$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function createAgentRequestResponseFormatJSONObjectToJSON(
  createAgentRequestResponseFormatJSONObject:
    CreateAgentRequestResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatJSONObject$outboundSchema.parse(
      createAgentRequestResponseFormatJSONObject,
    ),
  );
}
export function createAgentRequestResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatText$inboundSchema: z.ZodType<
  CreateAgentRequestResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type CreateAgentRequestResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const CreateAgentRequestResponseFormatText$outboundSchema: z.ZodType<
  CreateAgentRequestResponseFormatText$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function createAgentRequestResponseFormatTextToJSON(
  createAgentRequestResponseFormatText: CreateAgentRequestResponseFormatText,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatText$outboundSchema.parse(
      createAgentRequestResponseFormatText,
    ),
  );
}
export function createAgentRequestResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatText' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormat$inboundSchema: z.ZodType<
  CreateAgentRequestResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentRequestResponseFormatText$inboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONObject$inboundSchema),
  z.lazy(() =>
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
  ),
]);
/** @internal */
export type CreateAgentRequestResponseFormat$Outbound =
  | CreateAgentRequestResponseFormatText$Outbound
  | CreateAgentRequestResponseFormatJSONObject$Outbound
  | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$Outbound;

/** @internal */
export const CreateAgentRequestResponseFormat$outboundSchema: z.ZodType<
  CreateAgentRequestResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestResponseFormat
> = z.union([
  z.lazy(() => CreateAgentRequestResponseFormatText$outboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONObject$outboundSchema),
  z.lazy(() =>
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$outboundSchema
  ),
]);

export function createAgentRequestResponseFormatToJSON(
  createAgentRequestResponseFormat: CreateAgentRequestResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormat$outboundSchema.parse(
      createAgentRequestResponseFormat,
    ),
  );
}
export function createAgentRequestResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestStop$inboundSchema: z.ZodType<
  CreateAgentRequestStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentRequestStop$Outbound = string | Array<string>;

/** @internal */
export const CreateAgentRequestStop$outboundSchema: z.ZodType<
  CreateAgentRequestStop$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestStop
> = z.union([z.string(), z.array(z.string())]);

export function createAgentRequestStopToJSON(
  createAgentRequestStop: CreateAgentRequestStop,
): string {
  return JSON.stringify(
    CreateAgentRequestStop$outboundSchema.parse(createAgentRequestStop),
  );
}
export function createAgentRequestStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestStreamOptions$inboundSchema: z.ZodType<
  CreateAgentRequestStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type CreateAgentRequestStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateAgentRequestStreamOptions$outboundSchema: z.ZodType<
  CreateAgentRequestStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createAgentRequestStreamOptionsToJSON(
  createAgentRequestStreamOptions: CreateAgentRequestStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentRequestStreamOptions$outboundSchema.parse(
      createAgentRequestStreamOptions,
    ),
  );
}
export function createAgentRequestStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestType
> = z.nativeEnum(CreateAgentRequestType);
/** @internal */
export const CreateAgentRequestType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestType
> = CreateAgentRequestType$inboundSchema;

/** @internal */
export const CreateAgentRequestThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestThinkingLevel
> = z.nativeEnum(CreateAgentRequestThinkingLevel);
/** @internal */
export const CreateAgentRequestThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestThinkingLevel
> = CreateAgentRequestThinkingLevel$inboundSchema;

/** @internal */
export const CreateAgentRequestThinking$inboundSchema: z.ZodType<
  CreateAgentRequestThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentRequestType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: CreateAgentRequestThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type CreateAgentRequestThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const CreateAgentRequestThinking$outboundSchema: z.ZodType<
  CreateAgentRequestThinking$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestThinking
> = z.object({
  type: CreateAgentRequestType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: CreateAgentRequestThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function createAgentRequestThinkingToJSON(
  createAgentRequestThinking: CreateAgentRequestThinking,
): string {
  return JSON.stringify(
    CreateAgentRequestThinking$outboundSchema.parse(createAgentRequestThinking),
  );
}
export function createAgentRequestThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsType> = z.nativeEnum(
    CreateAgentRequestToolChoiceAgentsType,
  );
/** @internal */
export const CreateAgentRequestToolChoiceAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsType> =
    CreateAgentRequestToolChoiceAgentsType$inboundSchema;

/** @internal */
export const CreateAgentRequestToolChoiceAgentsFunction$inboundSchema:
  z.ZodType<CreateAgentRequestToolChoiceAgentsFunction, z.ZodTypeDef, unknown> =
    z.object({
      name: z.string(),
    });
/** @internal */
export type CreateAgentRequestToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateAgentRequestToolChoiceAgentsFunction$outboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsFunction$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestToolChoiceAgentsFunction
  > = z.object({
    name: z.string(),
  });

export function createAgentRequestToolChoiceAgentsFunctionToJSON(
  createAgentRequestToolChoiceAgentsFunction:
    CreateAgentRequestToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceAgentsFunction$outboundSchema.parse(
      createAgentRequestToolChoiceAgentsFunction,
    ),
  );
}
export function createAgentRequestToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgents2$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentRequestToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentRequestToolChoiceAgentsFunction$inboundSchema
  ),
});
/** @internal */
export type CreateAgentRequestToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: CreateAgentRequestToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const CreateAgentRequestToolChoiceAgents2$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoiceAgents2
> = z.object({
  type: CreateAgentRequestToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentRequestToolChoiceAgentsFunction$outboundSchema
  ),
});

export function createAgentRequestToolChoiceAgents2ToJSON(
  createAgentRequestToolChoiceAgents2: CreateAgentRequestToolChoiceAgents2,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceAgents2$outboundSchema.parse(
      createAgentRequestToolChoiceAgents2,
    ),
  );
}
export function createAgentRequestToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoiceAgents1
> = z.nativeEnum(CreateAgentRequestToolChoiceAgents1);
/** @internal */
export const CreateAgentRequestToolChoiceAgents1$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgents1> =
    CreateAgentRequestToolChoiceAgents1$inboundSchema;

/** @internal */
export const CreateAgentRequestToolChoice$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoiceAgents2$inboundSchema),
  CreateAgentRequestToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type CreateAgentRequestToolChoice$Outbound =
  | CreateAgentRequestToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const CreateAgentRequestToolChoice$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoice$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoice
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoiceAgents2$outboundSchema),
  CreateAgentRequestToolChoiceAgents1$outboundSchema,
]);

export function createAgentRequestToolChoiceToJSON(
  createAgentRequestToolChoice: CreateAgentRequestToolChoice,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoice$outboundSchema.parse(
      createAgentRequestToolChoice,
    ),
  );
}
export function createAgentRequestToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestModalities
> = z.nativeEnum(CreateAgentRequestModalities);
/** @internal */
export const CreateAgentRequestModalities$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestModalities
> = CreateAgentRequestModalities$inboundSchema;

/** @internal */
export const CreateAgentRequestParameters$inboundSchema: z.ZodType<
  CreateAgentRequestParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentRequestAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentRequestResponseFormatText$inboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONObject$inboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateAgentRequestStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentRequestThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgents2$inboundSchema),
    CreateAgentRequestToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentRequestModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type CreateAgentRequestParameters$Outbound = {
  audio?: CreateAgentRequestAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentRequestResponseFormatText$Outbound
    | CreateAgentRequestResponseFormatJSONObject$Outbound
    | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: CreateAgentRequestStreamOptions$Outbound | null | undefined;
  thinking?: CreateAgentRequestThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | CreateAgentRequestToolChoiceAgents2$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const CreateAgentRequestParameters$outboundSchema: z.ZodType<
  CreateAgentRequestParameters$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestParameters
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentRequestAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateAgentRequestResponseFormatText$outboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONObject$outboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$outboundSchema
    ),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateAgentRequestStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentRequestThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgents2$outboundSchema),
    CreateAgentRequestToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentRequestModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function createAgentRequestParametersToJSON(
  createAgentRequestParameters: CreateAgentRequestParameters,
): string {
  return JSON.stringify(
    CreateAgentRequestParameters$outboundSchema.parse(
      createAgentRequestParameters,
    ),
  );
}
export function createAgentRequestParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestRetry$inboundSchema: z.ZodType<
  CreateAgentRequestRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type CreateAgentRequestRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateAgentRequestRetry$outboundSchema: z.ZodType<
  CreateAgentRequestRetry$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createAgentRequestRetryToJSON(
  createAgentRequestRetry: CreateAgentRequestRetry,
): string {
  return JSON.stringify(
    CreateAgentRequestRetry$outboundSchema.parse(createAgentRequestRetry),
  );
}
export function createAgentRequestRetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestRetry' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationVoice> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationVoice);
/** @internal */
export const CreateAgentRequestFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationVoice> =
    CreateAgentRequestFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationFormat> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationFormat);
/** @internal */
export const CreateAgentRequestFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationFormat> =
    CreateAgentRequestFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: CreateAgentRequestFallbackModelConfigurationVoice$inboundSchema,
    format: CreateAgentRequestFallbackModelConfigurationFormat$inboundSchema,
  });
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationAudio
  > = z.object({
    voice: CreateAgentRequestFallbackModelConfigurationVoice$outboundSchema,
    format: CreateAgentRequestFallbackModelConfigurationFormat$outboundSchema,
  });

export function createAgentRequestFallbackModelConfigurationAudioToJSON(
  createAgentRequestFallbackModelConfigurationAudio:
    CreateAgentRequestFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationAudio$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationAudio,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchemaToJSON(
  createAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema:
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema
      .parse(
        createAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
      ),
  );
}
export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound =
  {
    type: "json_schema";
    json_schema:
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound;
  };

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchemaToJSON(
  createAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema:
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
      .parse(
        createAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
      ),
  );
}
export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function createAgentRequestResponseFormatAgentsJSONObjectToJSON(
  createAgentRequestResponseFormatAgentsJSONObject:
    CreateAgentRequestResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsJSONObject$outboundSchema.parse(
      createAgentRequestResponseFormatAgentsJSONObject,
    ),
  );
}
export function createAgentRequestResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsText$inboundSchema:
  z.ZodType<CreateAgentRequestResponseFormatAgentsText, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("text"),
    });
/** @internal */
export type CreateAgentRequestResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const CreateAgentRequestResponseFormatAgentsText$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsText$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsText
  > = z.object({
    type: z.literal("text"),
  });

export function createAgentRequestResponseFormatAgentsTextToJSON(
  createAgentRequestResponseFormatAgentsText:
    CreateAgentRequestResponseFormatAgentsText,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsText$outboundSchema.parse(
      createAgentRequestResponseFormatAgentsText,
    ),
  );
}
export function createAgentRequestResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsText,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsText$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestResponseFormatAgentsText$inboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema
    ),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
    ),
  ]);
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationResponseFormat$Outbound =
  | CreateAgentRequestResponseFormatAgentsText$Outbound
  | CreateAgentRequestResponseFormatAgentsJSONObject$Outbound
  | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => CreateAgentRequestResponseFormatAgentsText$outboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsJSONObject$outboundSchema
    ),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
    ),
  ]);

export function createAgentRequestFallbackModelConfigurationResponseFormatToJSON(
  createAgentRequestFallbackModelConfigurationResponseFormat:
    CreateAgentRequestFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationResponseFormat$outboundSchema
      .parse(createAgentRequestFallbackModelConfigurationResponseFormat),
  );
}
export function createAgentRequestFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function createAgentRequestFallbackModelConfigurationStopToJSON(
  createAgentRequestFallbackModelConfigurationStop:
    CreateAgentRequestFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationStop$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationStop,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationStreamOptions$Outbound =
  {
    include_usage?: boolean | undefined;
  };

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function createAgentRequestFallbackModelConfigurationStreamOptionsToJSON(
  createAgentRequestFallbackModelConfigurationStreamOptions:
    CreateAgentRequestFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema
      .parse(createAgentRequestFallbackModelConfigurationStreamOptions),
  );
}
export function createAgentRequestFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationType> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationType);
/** @internal */
export const CreateAgentRequestFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationType> =
    CreateAgentRequestFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationThinkingLevel
  > = z.nativeEnum(CreateAgentRequestFallbackModelConfigurationThinkingLevel);
/** @internal */
export const CreateAgentRequestFallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationThinkingLevel
  > = CreateAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateAgentRequestFallbackModelConfigurationType$inboundSchema,
    budget_tokens: z.number(),
    thinking_level:
      CreateAgentRequestFallbackModelConfigurationThinkingLevel$inboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      "budget_tokens": "budgetTokens",
      "thinking_level": "thinkingLevel",
    });
  });
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationThinking
  > = z.object({
    type: CreateAgentRequestFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
    thinkingLevel:
      CreateAgentRequestFallbackModelConfigurationThinkingLevel$outboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
      thinkingLevel: "thinking_level",
    });
  });

export function createAgentRequestFallbackModelConfigurationThinkingToJSON(
  createAgentRequestFallbackModelConfigurationThinking:
    CreateAgentRequestFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationThinking$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationThinking,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponseType> = z
    .nativeEnum(CreateAgentRequestToolChoiceAgentsResponseType);
/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponseType> =
    CreateAgentRequestToolChoiceAgentsResponseType$inboundSchema;

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });
/** @internal */
export type CreateAgentRequestToolChoiceAgentsResponseFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseFunction$outboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponseFunction$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestToolChoiceAgentsResponseFunction
  > = z.object({
    name: z.string(),
  });

export function createAgentRequestToolChoiceAgentsResponseFunctionToJSON(
  createAgentRequestToolChoiceAgentsResponseFunction:
    CreateAgentRequestToolChoiceAgentsResponseFunction,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceAgentsResponseFunction$outboundSchema.parse(
      createAgentRequestToolChoiceAgentsResponseFunction,
    ),
  );
}
export function createAgentRequestToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponse2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateAgentRequestToolChoiceAgentsResponseType$inboundSchema
      .optional(),
    function: z.lazy(() =>
      CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema
    ),
  });
/** @internal */
export type CreateAgentRequestToolChoiceAgentsResponse2$Outbound = {
  type?: string | undefined;
  function: CreateAgentRequestToolChoiceAgentsResponseFunction$Outbound;
};

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse2$outboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponse2$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestToolChoiceAgentsResponse2
  > = z.object({
    type: CreateAgentRequestToolChoiceAgentsResponseType$outboundSchema
      .optional(),
    function: z.lazy(() =>
      CreateAgentRequestToolChoiceAgentsResponseFunction$outboundSchema
    ),
  });

export function createAgentRequestToolChoiceAgentsResponse2ToJSON(
  createAgentRequestToolChoiceAgentsResponse2:
    CreateAgentRequestToolChoiceAgentsResponse2,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceAgentsResponse2$outboundSchema.parse(
      createAgentRequestToolChoiceAgentsResponse2,
    ),
  );
}
export function createAgentRequestToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponse1> = z
    .nativeEnum(CreateAgentRequestToolChoiceAgentsResponse1);
/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse1$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponse1> =
    CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema),
    CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema,
  ]);
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationToolChoice$Outbound =
  | CreateAgentRequestToolChoiceAgentsResponse2$Outbound
  | string;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$outboundSchema),
    CreateAgentRequestToolChoiceAgentsResponse1$outboundSchema,
  ]);

export function createAgentRequestFallbackModelConfigurationToolChoiceToJSON(
  createAgentRequestFallbackModelConfigurationToolChoice:
    CreateAgentRequestFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationToolChoice$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationToolChoice,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationToolChoice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationModalities
  > = z.nativeEnum(CreateAgentRequestFallbackModelConfigurationModalities);
/** @internal */
export const CreateAgentRequestFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationModalities
  > = CreateAgentRequestFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema
      ),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => CreateAgentRequestResponseFormatAgentsText$inboundSchema),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema
      ),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema),
      CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        CreateAgentRequestFallbackModelConfigurationModalities$inboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type CreateAgentRequestFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | CreateAgentRequestFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentRequestResponseFormatAgentsText$Outbound
    | CreateAgentRequestResponseFormatAgentsJSONObject$Outbound
    | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | CreateAgentRequestFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | CreateAgentRequestFallbackModelConfigurationThinking$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | CreateAgentRequestToolChoiceAgentsResponse2$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => CreateAgentRequestResponseFormatAgentsText$outboundSchema),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsJSONObject$outboundSchema
      ),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$outboundSchema),
      CreateAgentRequestToolChoiceAgentsResponse1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        CreateAgentRequestFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function createAgentRequestFallbackModelConfigurationParametersToJSON(
  createAgentRequestFallbackModelConfigurationParameters:
    CreateAgentRequestFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationParameters$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationParameters,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration2$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema
    ).optional(),
  });
/** @internal */
export type CreateAgentRequestFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | CreateAgentRequestFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
  });

export function createAgentRequestFallbackModelConfiguration2ToJSON(
  createAgentRequestFallbackModelConfiguration2:
    CreateAgentRequestFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfiguration2$outboundSchema.parse(
      createAgentRequestFallbackModelConfiguration2,
    ),
  );
}
export function createAgentRequestFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestFallbackModelConfiguration2$inboundSchema),
    z.string(),
  ]);
/** @internal */
export type CreateAgentRequestFallbackModelConfiguration$Outbound =
  | CreateAgentRequestFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfiguration
  > = z.union([
    z.lazy(() => CreateAgentRequestFallbackModelConfiguration2$outboundSchema),
    z.string(),
  ]);

export function createAgentRequestFallbackModelConfigurationToJSON(
  createAgentRequestFallbackModelConfiguration:
    CreateAgentRequestFallbackModelConfiguration,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfiguration$outboundSchema.parse(
      createAgentRequestFallbackModelConfiguration,
    ),
  );
}
export function createAgentRequestFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const Model$inboundSchema: z.ZodType<Model, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    integration_id: z.nullable(z.string()).optional(),
    parameters: z.lazy(() => CreateAgentRequestParameters$inboundSchema)
      .optional(),
    retry: z.lazy(() => CreateAgentRequestRetry$inboundSchema).optional(),
    fallback_models: z.nullable(
      z.array(z.union([
        z.lazy(() =>
          CreateAgentRequestFallbackModelConfiguration2$inboundSchema
        ),
        z.string(),
      ])),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "integration_id": "integrationId",
      "fallback_models": "fallbackModels",
    });
  });
/** @internal */
export type Model$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: CreateAgentRequestParameters$Outbound | undefined;
  retry?: CreateAgentRequestRetry$Outbound | undefined;
  fallback_models?:
    | Array<CreateAgentRequestFallbackModelConfiguration2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const Model$outboundSchema: z.ZodType<
  Model$Outbound,
  z.ZodTypeDef,
  Model
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentRequestParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => CreateAgentRequestRetry$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfiguration2$outboundSchema
      ),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function modelToJSON(model: Model): string {
  return JSON.stringify(Model$outboundSchema.parse(model));
}
export function modelFromJSON(
  jsonString: string,
): SafeParseResult<Model, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestTeamOfAgents$inboundSchema: z.ZodType<
  CreateAgentRequestTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type CreateAgentRequestTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const CreateAgentRequestTeamOfAgents$outboundSchema: z.ZodType<
  CreateAgentRequestTeamOfAgents$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function createAgentRequestTeamOfAgentsToJSON(
  createAgentRequestTeamOfAgents: CreateAgentRequestTeamOfAgents,
): string {
  return JSON.stringify(
    CreateAgentRequestTeamOfAgents$outboundSchema.parse(
      createAgentRequestTeamOfAgents,
    ),
  );
}
export function createAgentRequestTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const Metrics$inboundSchema: z.ZodType<Metrics, z.ZodTypeDef, unknown> =
  z.object({
    total_cost: z.number().default(0),
  }).transform((v) => {
    return remap$(v, {
      "total_cost": "totalCost",
    });
  });
/** @internal */
export type Metrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const Metrics$outboundSchema: z.ZodType<
  Metrics$Outbound,
  z.ZodTypeDef,
  Metrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function metricsToJSON(metrics: Metrics): string {
  return JSON.stringify(Metrics$outboundSchema.parse(metrics));
}
export function metricsFromJSON(
  jsonString: string,
): SafeParseResult<Metrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metrics' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestKnowledgeBases$inboundSchema: z.ZodType<
  CreateAgentRequestKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type CreateAgentRequestKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const CreateAgentRequestKnowledgeBases$outboundSchema: z.ZodType<
  CreateAgentRequestKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function createAgentRequestKnowledgeBasesToJSON(
  createAgentRequestKnowledgeBases: CreateAgentRequestKnowledgeBases,
): string {
  return JSON.stringify(
    CreateAgentRequestKnowledgeBases$outboundSchema.parse(
      createAgentRequestKnowledgeBases,
    ),
  );
}
export function createAgentRequestKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseBody$inboundSchema: z.ZodType<
  CreateAgentRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentRequestStatus$inboundSchema,
  settings: z.lazy(() => CreateAgentRequestSettings$inboundSchema).optional(),
  model: z.lazy(() => Model$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => CreateAgentRequestTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => Metrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => CreateAgentRequestKnowledgeBases$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});
/** @internal */
export type CreateAgentRequestResponseBody$Outbound = {
  _id: string;
  key: string;
  display_name: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: CreateAgentRequestSettings$Outbound | undefined;
  model: Model$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<CreateAgentRequestTeamOfAgents$Outbound>;
  metrics?: Metrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?:
    | Array<CreateAgentRequestKnowledgeBases$Outbound>
    | undefined;
};

/** @internal */
export const CreateAgentRequestResponseBody$outboundSchema: z.ZodType<
  CreateAgentRequestResponseBody$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  displayName: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentRequestStatus$outboundSchema,
  settings: z.lazy(() => CreateAgentRequestSettings$outboundSchema).optional(),
  model: z.lazy(() => Model$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(
    z.lazy(() => CreateAgentRequestTeamOfAgents$outboundSchema),
  ),
  metrics: z.lazy(() => Metrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => CreateAgentRequestKnowledgeBases$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
  });
});

export function createAgentRequestResponseBodyToJSON(
  createAgentRequestResponseBody: CreateAgentRequestResponseBody,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseBody$outboundSchema.parse(
      createAgentRequestResponseBody,
    ),
  );
}
export function createAgentRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseBody' from JSON`,
  );
}
