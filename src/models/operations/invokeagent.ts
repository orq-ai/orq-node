/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const InvokeAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type InvokeAgentRoleToolMessage = ClosedEnum<
  typeof InvokeAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const InvokeAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type InvokeAgentRoleUserMessage = ClosedEnum<
  typeof InvokeAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type InvokeAgentRole =
  | InvokeAgentRoleUserMessage
  | InvokeAgentRoleToolMessage;

export const InvokeAgentPublicMessagePartAgentsRequestKind = {
  ToolResult: "tool_result",
} as const;
export type InvokeAgentPublicMessagePartAgentsRequestKind = ClosedEnum<
  typeof InvokeAgentPublicMessagePartAgentsRequestKind
>;

/**
 * Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request.
 */
export type PublicMessagePartToolResultPart = {
  kind: InvokeAgentPublicMessagePartAgentsRequestKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPublicMessagePartAgentsKind = {
  File: "file",
} as const;
export type InvokeAgentPublicMessagePartAgentsKind = ClosedEnum<
  typeof InvokeAgentPublicMessagePartAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type FileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type FileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type InvokeAgentPublicMessagePartFile =
  | FileBinaryFormat
  | FileFileInURIFormat;

/**
 * File attachment part. Use this to send files (images, documents, etc.) to the agent for processing.
 */
export type PublicMessagePartFilePart = {
  kind: InvokeAgentPublicMessagePartAgentsKind;
  file: FileBinaryFormat | FileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPublicMessagePartKind = {
  Text: "text",
} as const;
export type InvokeAgentPublicMessagePartKind = ClosedEnum<
  typeof InvokeAgentPublicMessagePartKind
>;

/**
 * Text content part. Use this to send text messages to the agent.
 */
export type PublicMessagePartTextPart = {
  kind: InvokeAgentPublicMessagePartKind;
  text: string;
};

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type InvokeAgentPublicMessagePart =
  | PublicMessagePartTextPart
  | PublicMessagePartFilePart
  | PublicMessagePartToolResultPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type InvokeAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: InvokeAgentRoleUserMessage | InvokeAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | PublicMessagePartTextPart
    | PublicMessagePartFilePart
    | PublicMessagePartToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type InvokeAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type InvokeAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type InvokeAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type InvokeAgentRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: InvokeAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: InvokeAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: InvokeAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: InvokeAgentMemory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

export type InvokeAgentRequest = {
  /**
   * The key or ID of the agent to invoke
   */
  key: string;
  requestBody?: InvokeAgentRequestBody | undefined;
};

/**
 * A2A entity type identifier
 */
export const InvokeAgentKind = {
  Task: "task",
} as const;
/**
 * A2A entity type identifier
 */
export type InvokeAgentKind = ClosedEnum<typeof InvokeAgentKind>;

/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export const TaskState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  AuthRequired: "auth-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
} as const;
/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export type TaskState = ClosedEnum<typeof TaskState>;

export const InvokeAgentAgentsKind = {
  Message: "message",
} as const;
export type InvokeAgentAgentsKind = ClosedEnum<typeof InvokeAgentAgentsKind>;

/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export const ExtendedMessageRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export type ExtendedMessageRole = ClosedEnum<typeof ExtendedMessageRole>;

export const InvokeAgentPartsAgentsResponse200Kind = {
  ToolResult: "tool_result",
} as const;
export type InvokeAgentPartsAgentsResponse200Kind = ClosedEnum<
  typeof InvokeAgentPartsAgentsResponse200Kind
>;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type PartsToolResultPart = {
  kind: InvokeAgentPartsAgentsResponse200Kind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsAgentsResponseKind = {
  ToolCall: "tool_call",
} as const;
export type InvokeAgentPartsAgentsResponseKind = ClosedEnum<
  typeof InvokeAgentPartsAgentsResponseKind
>;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type ToolCallPart = {
  kind: InvokeAgentPartsAgentsResponseKind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsAgentsKind = {
  File: "file",
} as const;
export type InvokeAgentPartsAgentsKind = ClosedEnum<
  typeof InvokeAgentPartsAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type InvokeAgentFileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type InvokeAgentFileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type PartsFile =
  | InvokeAgentFileBinaryFormat
  | InvokeAgentFileFileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type PartsFilePart = {
  kind: InvokeAgentPartsAgentsKind;
  file: InvokeAgentFileBinaryFormat | InvokeAgentFileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsKind = {
  Data: "data",
} as const;
export type InvokeAgentPartsKind = ClosedEnum<typeof InvokeAgentPartsKind>;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type DataPart = {
  kind: InvokeAgentPartsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const PartsKind = {
  Text: "text",
} as const;
export type PartsKind = ClosedEnum<typeof PartsKind>;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type PartsTextPart = {
  kind: PartsKind;
  text: string;
};

export type Parts =
  | ToolCallPart
  | PartsTextPart
  | DataPart
  | PartsFilePart
  | PartsToolResultPart;

/**
 * Optional A2A message providing additional context about the current status
 */
export type TaskStatusMessage = {
  kind: InvokeAgentAgentsKind;
  messageId: string;
  /**
   * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
   */
  role: ExtendedMessageRole;
  parts: Array<
    | ToolCallPart
    | PartsTextPart
    | DataPart
    | PartsFilePart
    | PartsToolResultPart
  >;
};

/**
 * Current task status information
 */
export type TaskStatus = {
  /**
   * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
   */
  state: TaskState;
  /**
   * ISO 8601 timestamp of when the status was updated
   */
  timestamp?: string | undefined;
  /**
   * Optional A2A message providing additional context about the current status
   */
  message?: TaskStatusMessage | undefined;
};

/**
 * Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution.
 */
export type InvokeAgentA2ATaskResponse = {
  /**
   * The unique ID of the created agent execution task
   */
  id: string;
  /**
   * The correlation ID for this execution (used for tracking)
   */
  contextId: string;
  /**
   * A2A entity type identifier
   */
  kind: InvokeAgentKind;
  /**
   * Current task status information
   */
  status: TaskStatus;
  /**
   * Task metadata containing workspace_id and trace_id for feedback and tracking
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleToolMessage
> = z.nativeEnum(InvokeAgentRoleToolMessage);
/** @internal */
export const InvokeAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleToolMessage
> = InvokeAgentRoleToolMessage$inboundSchema;

/** @internal */
export const InvokeAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleUserMessage
> = z.nativeEnum(InvokeAgentRoleUserMessage);
/** @internal */
export const InvokeAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleUserMessage
> = InvokeAgentRoleUserMessage$inboundSchema;

/** @internal */
export const InvokeAgentRole$inboundSchema: z.ZodType<
  InvokeAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  InvokeAgentRoleUserMessage$inboundSchema,
  InvokeAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type InvokeAgentRole$Outbound = string | string;

/** @internal */
export const InvokeAgentRole$outboundSchema: z.ZodType<
  InvokeAgentRole$Outbound,
  z.ZodTypeDef,
  InvokeAgentRole
> = z.union([
  InvokeAgentRoleUserMessage$outboundSchema,
  InvokeAgentRoleToolMessage$outboundSchema,
]);

export function invokeAgentRoleToJSON(
  invokeAgentRole: InvokeAgentRole,
): string {
  return JSON.stringify(InvokeAgentRole$outboundSchema.parse(invokeAgentRole));
}
export function invokeAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRole' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePartAgentsRequestKind$inboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPublicMessagePartAgentsRequestKind> = z
    .nativeEnum(InvokeAgentPublicMessagePartAgentsRequestKind);
/** @internal */
export const InvokeAgentPublicMessagePartAgentsRequestKind$outboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPublicMessagePartAgentsRequestKind> =
    InvokeAgentPublicMessagePartAgentsRequestKind$inboundSchema;

/** @internal */
export const PublicMessagePartToolResultPart$inboundSchema: z.ZodType<
  PublicMessagePartToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPublicMessagePartAgentsRequestKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type PublicMessagePartToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PublicMessagePartToolResultPart$outboundSchema: z.ZodType<
  PublicMessagePartToolResultPart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartToolResultPart
> = z.object({
  kind: InvokeAgentPublicMessagePartAgentsRequestKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function publicMessagePartToolResultPartToJSON(
  publicMessagePartToolResultPart: PublicMessagePartToolResultPart,
): string {
  return JSON.stringify(
    PublicMessagePartToolResultPart$outboundSchema.parse(
      publicMessagePartToolResultPart,
    ),
  );
}
export function publicMessagePartToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartToolResultPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePartAgentsKind$inboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPublicMessagePartAgentsKind> = z.nativeEnum(
    InvokeAgentPublicMessagePartAgentsKind,
  );
/** @internal */
export const InvokeAgentPublicMessagePartAgentsKind$outboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPublicMessagePartAgentsKind> =
    InvokeAgentPublicMessagePartAgentsKind$inboundSchema;

/** @internal */
export const FileFileInURIFormat$inboundSchema: z.ZodType<
  FileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileFileInURIFormat$outboundSchema: z.ZodType<
  FileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  FileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileFileInURIFormatToJSON(
  fileFileInURIFormat: FileFileInURIFormat,
): string {
  return JSON.stringify(
    FileFileInURIFormat$outboundSchema.parse(fileFileInURIFormat),
  );
}
export function fileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const FileBinaryFormat$inboundSchema: z.ZodType<
  FileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileBinaryFormat$outboundSchema: z.ZodType<
  FileBinaryFormat$Outbound,
  z.ZodTypeDef,
  FileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileBinaryFormatToJSON(
  fileBinaryFormat: FileBinaryFormat,
): string {
  return JSON.stringify(
    FileBinaryFormat$outboundSchema.parse(fileBinaryFormat),
  );
}
export function fileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePartFile$inboundSchema: z.ZodType<
  InvokeAgentPublicMessagePartFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FileBinaryFormat$inboundSchema),
  z.lazy(() => FileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type InvokeAgentPublicMessagePartFile$Outbound =
  | FileBinaryFormat$Outbound
  | FileFileInURIFormat$Outbound;

/** @internal */
export const InvokeAgentPublicMessagePartFile$outboundSchema: z.ZodType<
  InvokeAgentPublicMessagePartFile$Outbound,
  z.ZodTypeDef,
  InvokeAgentPublicMessagePartFile
> = z.union([
  z.lazy(() => FileBinaryFormat$outboundSchema),
  z.lazy(() => FileFileInURIFormat$outboundSchema),
]);

export function invokeAgentPublicMessagePartFileToJSON(
  invokeAgentPublicMessagePartFile: InvokeAgentPublicMessagePartFile,
): string {
  return JSON.stringify(
    InvokeAgentPublicMessagePartFile$outboundSchema.parse(
      invokeAgentPublicMessagePartFile,
    ),
  );
}
export function invokeAgentPublicMessagePartFileFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPublicMessagePartFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPublicMessagePartFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPublicMessagePartFile' from JSON`,
  );
}

/** @internal */
export const PublicMessagePartFilePart$inboundSchema: z.ZodType<
  PublicMessagePartFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPublicMessagePartAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => FileBinaryFormat$inboundSchema),
    z.lazy(() => FileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type PublicMessagePartFilePart$Outbound = {
  kind: string;
  file: FileBinaryFormat$Outbound | FileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PublicMessagePartFilePart$outboundSchema: z.ZodType<
  PublicMessagePartFilePart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartFilePart
> = z.object({
  kind: InvokeAgentPublicMessagePartAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => FileBinaryFormat$outboundSchema),
    z.lazy(() => FileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function publicMessagePartFilePartToJSON(
  publicMessagePartFilePart: PublicMessagePartFilePart,
): string {
  return JSON.stringify(
    PublicMessagePartFilePart$outboundSchema.parse(publicMessagePartFilePart),
  );
}
export function publicMessagePartFilePartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartFilePart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPublicMessagePartKind
> = z.nativeEnum(InvokeAgentPublicMessagePartKind);
/** @internal */
export const InvokeAgentPublicMessagePartKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPublicMessagePartKind
> = InvokeAgentPublicMessagePartKind$inboundSchema;

/** @internal */
export const PublicMessagePartTextPart$inboundSchema: z.ZodType<
  PublicMessagePartTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPublicMessagePartKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type PublicMessagePartTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const PublicMessagePartTextPart$outboundSchema: z.ZodType<
  PublicMessagePartTextPart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartTextPart
> = z.object({
  kind: InvokeAgentPublicMessagePartKind$outboundSchema,
  text: z.string(),
});

export function publicMessagePartTextPartToJSON(
  publicMessagePartTextPart: PublicMessagePartTextPart,
): string {
  return JSON.stringify(
    PublicMessagePartTextPart$outboundSchema.parse(publicMessagePartTextPart),
  );
}
export function publicMessagePartTextPartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartTextPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePart$inboundSchema: z.ZodType<
  InvokeAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => PublicMessagePartTextPart$inboundSchema),
  z.lazy(() => PublicMessagePartFilePart$inboundSchema),
  z.lazy(() => PublicMessagePartToolResultPart$inboundSchema),
]);
/** @internal */
export type InvokeAgentPublicMessagePart$Outbound =
  | PublicMessagePartTextPart$Outbound
  | PublicMessagePartFilePart$Outbound
  | PublicMessagePartToolResultPart$Outbound;

/** @internal */
export const InvokeAgentPublicMessagePart$outboundSchema: z.ZodType<
  InvokeAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPublicMessagePart
> = z.union([
  z.lazy(() => PublicMessagePartTextPart$outboundSchema),
  z.lazy(() => PublicMessagePartFilePart$outboundSchema),
  z.lazy(() => PublicMessagePartToolResultPart$outboundSchema),
]);

export function invokeAgentPublicMessagePartToJSON(
  invokeAgentPublicMessagePart: InvokeAgentPublicMessagePart,
): string {
  return JSON.stringify(
    InvokeAgentPublicMessagePart$outboundSchema.parse(
      invokeAgentPublicMessagePart,
    ),
  );
}
export function invokeAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentA2AMessage$inboundSchema: z.ZodType<
  InvokeAgentA2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    InvokeAgentRoleUserMessage$inboundSchema,
    InvokeAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => PublicMessagePartTextPart$inboundSchema),
      z.lazy(() => PublicMessagePartFilePart$inboundSchema),
      z.lazy(() => PublicMessagePartToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type InvokeAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | PublicMessagePartTextPart$Outbound
    | PublicMessagePartFilePart$Outbound
    | PublicMessagePartToolResultPart$Outbound
  >;
};

/** @internal */
export const InvokeAgentA2AMessage$outboundSchema: z.ZodType<
  InvokeAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  InvokeAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    InvokeAgentRoleUserMessage$outboundSchema,
    InvokeAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => PublicMessagePartTextPart$outboundSchema),
      z.lazy(() => PublicMessagePartFilePart$outboundSchema),
      z.lazy(() => PublicMessagePartToolResultPart$outboundSchema),
    ]),
  ),
});

export function invokeAgentA2AMessageToJSON(
  invokeAgentA2AMessage: InvokeAgentA2AMessage,
): string {
  return JSON.stringify(
    InvokeAgentA2AMessage$outboundSchema.parse(invokeAgentA2AMessage),
  );
}
export function invokeAgentA2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentA2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentA2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentA2AMessage' from JSON`,
  );
}

/** @internal */
export const InvokeAgentContact$inboundSchema: z.ZodType<
  InvokeAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type InvokeAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentContact$outboundSchema: z.ZodType<
  InvokeAgentContact$Outbound,
  z.ZodTypeDef,
  InvokeAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function invokeAgentContactToJSON(
  invokeAgentContact: InvokeAgentContact,
): string {
  return JSON.stringify(
    InvokeAgentContact$outboundSchema.parse(invokeAgentContact),
  );
}
export function invokeAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentContact' from JSON`,
  );
}

/** @internal */
export const InvokeAgentThread$inboundSchema: z.ZodType<
  InvokeAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type InvokeAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentThread$outboundSchema: z.ZodType<
  InvokeAgentThread$Outbound,
  z.ZodTypeDef,
  InvokeAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function invokeAgentThreadToJSON(
  invokeAgentThread: InvokeAgentThread,
): string {
  return JSON.stringify(
    InvokeAgentThread$outboundSchema.parse(invokeAgentThread),
  );
}
export function invokeAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentThread' from JSON`,
  );
}

/** @internal */
export const InvokeAgentMemory$inboundSchema: z.ZodType<
  InvokeAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type InvokeAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const InvokeAgentMemory$outboundSchema: z.ZodType<
  InvokeAgentMemory$Outbound,
  z.ZodTypeDef,
  InvokeAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function invokeAgentMemoryToJSON(
  invokeAgentMemory: InvokeAgentMemory,
): string {
  return JSON.stringify(
    InvokeAgentMemory$outboundSchema.parse(invokeAgentMemory),
  );
}
export function invokeAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentMemory' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequestBody$inboundSchema: z.ZodType<
  InvokeAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => InvokeAgentA2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => InvokeAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => InvokeAgentMemory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type InvokeAgentRequestBody$Outbound = {
  task_id?: string | undefined;
  message: InvokeAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: InvokeAgentContact$Outbound | undefined;
  thread?: InvokeAgentThread$Outbound | undefined;
  memory?: InvokeAgentMemory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentRequestBody$outboundSchema: z.ZodType<
  InvokeAgentRequestBody$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => InvokeAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => InvokeAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => InvokeAgentMemory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function invokeAgentRequestBodyToJSON(
  invokeAgentRequestBody: InvokeAgentRequestBody,
): string {
  return JSON.stringify(
    InvokeAgentRequestBody$outboundSchema.parse(invokeAgentRequestBody),
  );
}
export function invokeAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequest$inboundSchema: z.ZodType<
  InvokeAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  RequestBody: z.lazy(() => InvokeAgentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type InvokeAgentRequest$Outbound = {
  key: string;
  RequestBody?: InvokeAgentRequestBody$Outbound | undefined;
};

/** @internal */
export const InvokeAgentRequest$outboundSchema: z.ZodType<
  InvokeAgentRequest$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequest
> = z.object({
  key: z.string(),
  requestBody: z.lazy(() => InvokeAgentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function invokeAgentRequestToJSON(
  invokeAgentRequest: InvokeAgentRequest,
): string {
  return JSON.stringify(
    InvokeAgentRequest$outboundSchema.parse(invokeAgentRequest),
  );
}
export function invokeAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequest' from JSON`,
  );
}

/** @internal */
export const InvokeAgentKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = z.nativeEnum(InvokeAgentKind);
/** @internal */
export const InvokeAgentKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = InvokeAgentKind$inboundSchema;

/** @internal */
export const TaskState$inboundSchema: z.ZodNativeEnum<typeof TaskState> = z
  .nativeEnum(TaskState);
/** @internal */
export const TaskState$outboundSchema: z.ZodNativeEnum<typeof TaskState> =
  TaskState$inboundSchema;

/** @internal */
export const InvokeAgentAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentAgentsKind
> = z.nativeEnum(InvokeAgentAgentsKind);
/** @internal */
export const InvokeAgentAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentAgentsKind
> = InvokeAgentAgentsKind$inboundSchema;

/** @internal */
export const ExtendedMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof ExtendedMessageRole
> = z.nativeEnum(ExtendedMessageRole);
/** @internal */
export const ExtendedMessageRole$outboundSchema: z.ZodNativeEnum<
  typeof ExtendedMessageRole
> = ExtendedMessageRole$inboundSchema;

/** @internal */
export const InvokeAgentPartsAgentsResponse200Kind$inboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200Kind> = z.nativeEnum(
    InvokeAgentPartsAgentsResponse200Kind,
  );
/** @internal */
export const InvokeAgentPartsAgentsResponse200Kind$outboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200Kind> =
    InvokeAgentPartsAgentsResponse200Kind$inboundSchema;

/** @internal */
export const PartsToolResultPart$inboundSchema: z.ZodType<
  PartsToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200Kind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type PartsToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PartsToolResultPart$outboundSchema: z.ZodType<
  PartsToolResultPart$Outbound,
  z.ZodTypeDef,
  PartsToolResultPart
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200Kind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function partsToolResultPartToJSON(
  partsToolResultPart: PartsToolResultPart,
): string {
  return JSON.stringify(
    PartsToolResultPart$outboundSchema.parse(partsToolResultPart),
  );
}
export function partsToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<PartsToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartsToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartsToolResultPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsAgentsResponseKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsResponseKind
> = z.nativeEnum(InvokeAgentPartsAgentsResponseKind);
/** @internal */
export const InvokeAgentPartsAgentsResponseKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsResponseKind
> = InvokeAgentPartsAgentsResponseKind$inboundSchema;

/** @internal */
export const ToolCallPart$inboundSchema: z.ZodType<
  ToolCallPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsResponseKind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type ToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const ToolCallPart$outboundSchema: z.ZodType<
  ToolCallPart$Outbound,
  z.ZodTypeDef,
  ToolCallPart
> = z.object({
  kind: InvokeAgentPartsAgentsResponseKind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

export function toolCallPartToJSON(toolCallPart: ToolCallPart): string {
  return JSON.stringify(ToolCallPart$outboundSchema.parse(toolCallPart));
}
export function toolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<ToolCallPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolCallPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolCallPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsKind
> = z.nativeEnum(InvokeAgentPartsAgentsKind);
/** @internal */
export const InvokeAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsKind
> = InvokeAgentPartsAgentsKind$inboundSchema;

/** @internal */
export const InvokeAgentFileFileInURIFormat$inboundSchema: z.ZodType<
  InvokeAgentFileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type InvokeAgentFileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const InvokeAgentFileFileInURIFormat$outboundSchema: z.ZodType<
  InvokeAgentFileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  InvokeAgentFileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function invokeAgentFileFileInURIFormatToJSON(
  invokeAgentFileFileInURIFormat: InvokeAgentFileFileInURIFormat,
): string {
  return JSON.stringify(
    InvokeAgentFileFileInURIFormat$outboundSchema.parse(
      invokeAgentFileFileInURIFormat,
    ),
  );
}
export function invokeAgentFileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentFileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentFileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentFileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const InvokeAgentFileBinaryFormat$inboundSchema: z.ZodType<
  InvokeAgentFileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type InvokeAgentFileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const InvokeAgentFileBinaryFormat$outboundSchema: z.ZodType<
  InvokeAgentFileBinaryFormat$Outbound,
  z.ZodTypeDef,
  InvokeAgentFileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function invokeAgentFileBinaryFormatToJSON(
  invokeAgentFileBinaryFormat: InvokeAgentFileBinaryFormat,
): string {
  return JSON.stringify(
    InvokeAgentFileBinaryFormat$outboundSchema.parse(
      invokeAgentFileBinaryFormat,
    ),
  );
}
export function invokeAgentFileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentFileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentFileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentFileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const PartsFile$inboundSchema: z.ZodType<
  PartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InvokeAgentFileBinaryFormat$inboundSchema),
  z.lazy(() => InvokeAgentFileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type PartsFile$Outbound =
  | InvokeAgentFileBinaryFormat$Outbound
  | InvokeAgentFileFileInURIFormat$Outbound;

/** @internal */
export const PartsFile$outboundSchema: z.ZodType<
  PartsFile$Outbound,
  z.ZodTypeDef,
  PartsFile
> = z.union([
  z.lazy(() => InvokeAgentFileBinaryFormat$outboundSchema),
  z.lazy(() => InvokeAgentFileFileInURIFormat$outboundSchema),
]);

export function partsFileToJSON(partsFile: PartsFile): string {
  return JSON.stringify(PartsFile$outboundSchema.parse(partsFile));
}
export function partsFileFromJSON(
  jsonString: string,
): SafeParseResult<PartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartsFile' from JSON`,
  );
}

/** @internal */
export const PartsFilePart$inboundSchema: z.ZodType<
  PartsFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => InvokeAgentFileBinaryFormat$inboundSchema),
    z.lazy(() => InvokeAgentFileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type PartsFilePart$Outbound = {
  kind: string;
  file:
    | InvokeAgentFileBinaryFormat$Outbound
    | InvokeAgentFileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PartsFilePart$outboundSchema: z.ZodType<
  PartsFilePart$Outbound,
  z.ZodTypeDef,
  PartsFilePart
> = z.object({
  kind: InvokeAgentPartsAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => InvokeAgentFileBinaryFormat$outboundSchema),
    z.lazy(() => InvokeAgentFileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function partsFilePartToJSON(partsFilePart: PartsFilePart): string {
  return JSON.stringify(PartsFilePart$outboundSchema.parse(partsFilePart));
}
export function partsFilePartFromJSON(
  jsonString: string,
): SafeParseResult<PartsFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartsFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartsFilePart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsKind
> = z.nativeEnum(InvokeAgentPartsKind);
/** @internal */
export const InvokeAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsKind
> = InvokeAgentPartsKind$inboundSchema;

/** @internal */
export const DataPart$inboundSchema: z.ZodType<
  DataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type DataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataPart$outboundSchema: z.ZodType<
  DataPart$Outbound,
  z.ZodTypeDef,
  DataPart
> = z.object({
  kind: InvokeAgentPartsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

export function dataPartToJSON(dataPart: DataPart): string {
  return JSON.stringify(DataPart$outboundSchema.parse(dataPart));
}
export function dataPartFromJSON(
  jsonString: string,
): SafeParseResult<DataPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataPart' from JSON`,
  );
}

/** @internal */
export const PartsKind$inboundSchema: z.ZodNativeEnum<typeof PartsKind> = z
  .nativeEnum(PartsKind);
/** @internal */
export const PartsKind$outboundSchema: z.ZodNativeEnum<typeof PartsKind> =
  PartsKind$inboundSchema;

/** @internal */
export const PartsTextPart$inboundSchema: z.ZodType<
  PartsTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: PartsKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type PartsTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const PartsTextPart$outboundSchema: z.ZodType<
  PartsTextPart$Outbound,
  z.ZodTypeDef,
  PartsTextPart
> = z.object({
  kind: PartsKind$outboundSchema,
  text: z.string(),
});

export function partsTextPartToJSON(partsTextPart: PartsTextPart): string {
  return JSON.stringify(PartsTextPart$outboundSchema.parse(partsTextPart));
}
export function partsTextPartFromJSON(
  jsonString: string,
): SafeParseResult<PartsTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartsTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartsTextPart' from JSON`,
  );
}

/** @internal */
export const Parts$inboundSchema: z.ZodType<Parts, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => ToolCallPart$inboundSchema),
    z.lazy(() => PartsTextPart$inboundSchema),
    z.lazy(() => DataPart$inboundSchema),
    z.lazy(() => PartsFilePart$inboundSchema),
    z.lazy(() => PartsToolResultPart$inboundSchema),
  ]);
/** @internal */
export type Parts$Outbound =
  | ToolCallPart$Outbound
  | PartsTextPart$Outbound
  | DataPart$Outbound
  | PartsFilePart$Outbound
  | PartsToolResultPart$Outbound;

/** @internal */
export const Parts$outboundSchema: z.ZodType<
  Parts$Outbound,
  z.ZodTypeDef,
  Parts
> = z.union([
  z.lazy(() => ToolCallPart$outboundSchema),
  z.lazy(() => PartsTextPart$outboundSchema),
  z.lazy(() => DataPart$outboundSchema),
  z.lazy(() => PartsFilePart$outboundSchema),
  z.lazy(() => PartsToolResultPart$outboundSchema),
]);

export function partsToJSON(parts: Parts): string {
  return JSON.stringify(Parts$outboundSchema.parse(parts));
}
export function partsFromJSON(
  jsonString: string,
): SafeParseResult<Parts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts' from JSON`,
  );
}

/** @internal */
export const TaskStatusMessage$inboundSchema: z.ZodType<
  TaskStatusMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentAgentsKind$inboundSchema,
  messageId: z.string(),
  role: ExtendedMessageRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => ToolCallPart$inboundSchema),
      z.lazy(() => PartsTextPart$inboundSchema),
      z.lazy(() => DataPart$inboundSchema),
      z.lazy(() => PartsFilePart$inboundSchema),
      z.lazy(() => PartsToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type TaskStatusMessage$Outbound = {
  kind: string;
  messageId: string;
  role: string;
  parts: Array<
    | ToolCallPart$Outbound
    | PartsTextPart$Outbound
    | DataPart$Outbound
    | PartsFilePart$Outbound
    | PartsToolResultPart$Outbound
  >;
};

/** @internal */
export const TaskStatusMessage$outboundSchema: z.ZodType<
  TaskStatusMessage$Outbound,
  z.ZodTypeDef,
  TaskStatusMessage
> = z.object({
  kind: InvokeAgentAgentsKind$outboundSchema,
  messageId: z.string(),
  role: ExtendedMessageRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => ToolCallPart$outboundSchema),
      z.lazy(() => PartsTextPart$outboundSchema),
      z.lazy(() => DataPart$outboundSchema),
      z.lazy(() => PartsFilePart$outboundSchema),
      z.lazy(() => PartsToolResultPart$outboundSchema),
    ]),
  ),
});

export function taskStatusMessageToJSON(
  taskStatusMessage: TaskStatusMessage,
): string {
  return JSON.stringify(
    TaskStatusMessage$outboundSchema.parse(taskStatusMessage),
  );
}
export function taskStatusMessageFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatusMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatusMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatusMessage' from JSON`,
  );
}

/** @internal */
export const TaskStatus$inboundSchema: z.ZodType<
  TaskStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: TaskState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$inboundSchema).optional(),
});
/** @internal */
export type TaskStatus$Outbound = {
  state: string;
  timestamp?: string | undefined;
  message?: TaskStatusMessage$Outbound | undefined;
};

/** @internal */
export const TaskStatus$outboundSchema: z.ZodType<
  TaskStatus$Outbound,
  z.ZodTypeDef,
  TaskStatus
> = z.object({
  state: TaskState$outboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$outboundSchema).optional(),
});

export function taskStatusToJSON(taskStatus: TaskStatus): string {
  return JSON.stringify(TaskStatus$outboundSchema.parse(taskStatus));
}
export function taskStatusFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatus' from JSON`,
  );
}

/** @internal */
export const InvokeAgentA2ATaskResponse$inboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: InvokeAgentKind$inboundSchema,
  status: z.lazy(() => TaskStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InvokeAgentA2ATaskResponse$Outbound = {
  id: string;
  contextId: string;
  kind: string;
  status: TaskStatus$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentA2ATaskResponse$outboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse$Outbound,
  z.ZodTypeDef,
  InvokeAgentA2ATaskResponse
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: InvokeAgentKind$outboundSchema,
  status: z.lazy(() => TaskStatus$outboundSchema),
  metadata: z.record(z.any()).optional(),
});

export function invokeAgentA2ATaskResponseToJSON(
  invokeAgentA2ATaskResponse: InvokeAgentA2ATaskResponse,
): string {
  return JSON.stringify(
    InvokeAgentA2ATaskResponse$outboundSchema.parse(invokeAgentA2ATaskResponse),
  );
}
export function invokeAgentA2ATaskResponseFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentA2ATaskResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentA2ATaskResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentA2ATaskResponse' from JSON`,
  );
}
