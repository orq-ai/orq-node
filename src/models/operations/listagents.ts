/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListAgentsRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const ListAgentsObject = {
  List: "list",
} as const;
export type ListAgentsObject = ClosedEnum<typeof ListAgentsObject>;

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ListAgentsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ListAgentsStatus = ClosedEnum<typeof ListAgentsStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ListAgentsToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ListAgentsToolApprovalRequired = ClosedEnum<
  typeof ListAgentsToolApprovalRequired
>;

export type ListAgentsConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type ListAgentsTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<ListAgentsConditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type ListAgentsSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ListAgentsToolApprovalRequired | undefined;
  tools?: Array<ListAgentsTools> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentsVoice = ClosedEnum<typeof ListAgentsVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentsFormat = ClosedEnum<typeof ListAgentsFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentsFormat;
};

export const ListAgentsResponseFormatAgentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type ListAgentsResponseFormatAgentsResponseType = ClosedEnum<
  typeof ListAgentsResponseFormatAgentsResponseType
>;

export type ListAgentsResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type ListAgentsResponseFormat3 = {
  type: ListAgentsResponseFormatAgentsResponseType;
  jsonSchema: ListAgentsResponseFormatJsonSchema;
};

export const ListAgentsResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type ListAgentsResponseFormatAgentsType = ClosedEnum<
  typeof ListAgentsResponseFormatAgentsType
>;

export type ListAgentsResponseFormat2 = {
  type: ListAgentsResponseFormatAgentsType;
};

export const ListAgentsResponseFormatType = {
  Text: "text",
} as const;
export type ListAgentsResponseFormatType = ClosedEnum<
  typeof ListAgentsResponseFormatType
>;

export type ListAgentsResponseFormat1 = {
  type: ListAgentsResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentsResponseFormat =
  | ListAgentsResponseFormat3
  | ListAgentsResponseFormat1
  | ListAgentsResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ListAgentsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ListAgentsType = ClosedEnum<typeof ListAgentsType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const ListAgentsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type ListAgentsThinkingLevel = ClosedEnum<
  typeof ListAgentsThinkingLevel
>;

export type ListAgentsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ListAgentsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: ListAgentsThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentsToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentsToolChoiceType = ClosedEnum<
  typeof ListAgentsToolChoiceType
>;

export type ListAgentsToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ListAgentsToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentsToolChoiceType | undefined;
  function: ListAgentsToolChoiceFunction;
};

export const ListAgentsToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentsToolChoice1 = ClosedEnum<typeof ListAgentsToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentsToolChoice =
  | ListAgentsToolChoice2
  | ListAgentsToolChoice1;

export const ListAgentsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentsModalities = ClosedEnum<typeof ListAgentsModalities>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type ListAgentsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
 */
export type ListAgentsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentsResponseFormat3
    | ListAgentsResponseFormat1
    | ListAgentsResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListAgentsStreamOptions | null | undefined;
  thinking?: ListAgentsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ListAgentsToolChoice2 | ListAgentsToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListAgentsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: ListAgentsWebSearchOptions | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentsFallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentsFallbackModelsVoice = ClosedEnum<
  typeof ListAgentsFallbackModelsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentsFallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentsFallbackModelsFormat = ClosedEnum<
  typeof ListAgentsFallbackModelsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentsFallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentsFallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentsFallbackModelsFormat;
};

export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  >;

export type ListAgentsResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type ListAgentsResponseFormatAgents3 = {
  type:
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType;
  jsonSchema: ListAgentsResponseFormatAgentsJsonSchema;
};

export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONType = {
  JsonObject: "json_object",
} as const;
export type ListAgentsResponseFormatAgentsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONType
  >;

export type ListAgentsResponseFormatAgents2 = {
  type: ListAgentsResponseFormatAgentsResponse200ApplicationJSONType;
};

export const ListAgentsResponseFormatAgentsResponse200Type = {
  Text: "text",
} as const;
export type ListAgentsResponseFormatAgentsResponse200Type = ClosedEnum<
  typeof ListAgentsResponseFormatAgentsResponse200Type
>;

export type ListAgentsResponseFormatAgents1 = {
  type: ListAgentsResponseFormatAgentsResponse200Type;
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentsFallbackModelsResponseFormat =
  | ListAgentsResponseFormatAgents3
  | ListAgentsResponseFormatAgents1
  | ListAgentsResponseFormatAgents2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentsFallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentsFallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ListAgentsFallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ListAgentsFallbackModelsType = ClosedEnum<
  typeof ListAgentsFallbackModelsType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const ListAgentsFallbackModelsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type ListAgentsFallbackModelsThinkingLevel = ClosedEnum<
  typeof ListAgentsFallbackModelsThinkingLevel
>;

export type ListAgentsFallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ListAgentsFallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: ListAgentsFallbackModelsThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentsToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentsToolChoiceAgentsType = ClosedEnum<
  typeof ListAgentsToolChoiceAgentsType
>;

export type ListAgentsToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ListAgentsToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentsToolChoiceAgentsType | undefined;
  function: ListAgentsToolChoiceAgentsFunction;
};

export const ListAgentsToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentsToolChoiceAgents1 = ClosedEnum<
  typeof ListAgentsToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentsFallbackModelsToolChoice =
  | ListAgentsToolChoiceAgents2
  | ListAgentsToolChoiceAgents1;

export const ListAgentsFallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentsFallbackModelsModalities = ClosedEnum<
  typeof ListAgentsFallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type ListAgentsFallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type ListAgentsFallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentsFallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentsResponseFormatAgents3
    | ListAgentsResponseFormatAgents1
    | ListAgentsResponseFormatAgents2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListAgentsFallbackModelsStreamOptions | null | undefined;
  thinking?: ListAgentsFallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | ListAgentsToolChoiceAgents2
    | ListAgentsToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListAgentsFallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: ListAgentsFallbackModelsWebSearchOptions | undefined;
};

export type ListAgentsFallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: ListAgentsFallbackModelsParameters | undefined;
};

export type ListAgentsFallbackModels = ListAgentsFallbackModels2 | string;

export type ListAgentsModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
   */
  parameters?: ListAgentsParameters | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?: Array<ListAgentsFallbackModels2 | string> | null | undefined;
};

export type ListAgentsTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type ListAgentsMetrics = {
  totalCost?: number | undefined;
};

export type ListAgentsKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const ListAgentsHiddenPanels = {
  Model: "model",
  Tools: "tools",
  KnowledgeBases: "knowledge_bases",
  Variables: "variables",
  RuntimeConstraints: "runtime_constraints",
} as const;
export type ListAgentsHiddenPanels = ClosedEnum<typeof ListAgentsHiddenPanels>;

export type ListAgentsData = {
  id: string;
  key: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: ListAgentsStatus;
  settings?: ListAgentsSettings | undefined;
  model: ListAgentsModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<ListAgentsTeamOfAgents>;
  metrics?: ListAgentsMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<ListAgentsKnowledgeBases> | undefined;
  /**
   * List of hidden collapsed panels in configuration. Duplicates are not allowed.
   */
  hiddenPanels?: Array<ListAgentsHiddenPanels> | undefined;
};

/**
 * List of agents with their configurations including fallback models
 */
export type ListAgentsResponseBody = {
  object: ListAgentsObject;
  data: Array<ListAgentsData>;
  hasMore: boolean;
};

/** @internal */
export const ListAgentsRequest$inboundSchema: z.ZodType<
  ListAgentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().default(10),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type ListAgentsRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const ListAgentsRequest$outboundSchema: z.ZodType<
  ListAgentsRequest$Outbound,
  z.ZodTypeDef,
  ListAgentsRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listAgentsRequestToJSON(
  listAgentsRequest: ListAgentsRequest,
): string {
  return JSON.stringify(
    ListAgentsRequest$outboundSchema.parse(listAgentsRequest),
  );
}
export function listAgentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsRequest' from JSON`,
  );
}

/** @internal */
export const ListAgentsObject$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsObject
> = z.nativeEnum(ListAgentsObject);
/** @internal */
export const ListAgentsObject$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsObject
> = ListAgentsObject$inboundSchema;

/** @internal */
export const ListAgentsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsStatus
> = z.nativeEnum(ListAgentsStatus);
/** @internal */
export const ListAgentsStatus$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsStatus
> = ListAgentsStatus$inboundSchema;

/** @internal */
export const ListAgentsToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolApprovalRequired
> = z.nativeEnum(ListAgentsToolApprovalRequired);
/** @internal */
export const ListAgentsToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolApprovalRequired
> = ListAgentsToolApprovalRequired$inboundSchema;

/** @internal */
export const ListAgentsConditions$inboundSchema: z.ZodType<
  ListAgentsConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type ListAgentsConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const ListAgentsConditions$outboundSchema: z.ZodType<
  ListAgentsConditions$Outbound,
  z.ZodTypeDef,
  ListAgentsConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function listAgentsConditionsToJSON(
  listAgentsConditions: ListAgentsConditions,
): string {
  return JSON.stringify(
    ListAgentsConditions$outboundSchema.parse(listAgentsConditions),
  );
}
export function listAgentsConditionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsConditions' from JSON`,
  );
}

/** @internal */
export const ListAgentsTools$inboundSchema: z.ZodType<
  ListAgentsTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => ListAgentsConditions$inboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type ListAgentsTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<ListAgentsConditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const ListAgentsTools$outboundSchema: z.ZodType<
  ListAgentsTools$Outbound,
  z.ZodTypeDef,
  ListAgentsTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => ListAgentsConditions$outboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function listAgentsToolsToJSON(
  listAgentsTools: ListAgentsTools,
): string {
  return JSON.stringify(ListAgentsTools$outboundSchema.parse(listAgentsTools));
}
export function listAgentsToolsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsTools' from JSON`,
  );
}

/** @internal */
export const ListAgentsSettings$inboundSchema: z.ZodType<
  ListAgentsSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: ListAgentsToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => ListAgentsTools$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type ListAgentsSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<ListAgentsTools$Outbound> | undefined;
};

/** @internal */
export const ListAgentsSettings$outboundSchema: z.ZodType<
  ListAgentsSettings$Outbound,
  z.ZodTypeDef,
  ListAgentsSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: ListAgentsToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => ListAgentsTools$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function listAgentsSettingsToJSON(
  listAgentsSettings: ListAgentsSettings,
): string {
  return JSON.stringify(
    ListAgentsSettings$outboundSchema.parse(listAgentsSettings),
  );
}
export function listAgentsSettingsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsSettings' from JSON`,
  );
}

/** @internal */
export const ListAgentsVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsVoice
> = z.nativeEnum(ListAgentsVoice);
/** @internal */
export const ListAgentsVoice$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsVoice
> = ListAgentsVoice$inboundSchema;

/** @internal */
export const ListAgentsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFormat
> = z.nativeEnum(ListAgentsFormat);
/** @internal */
export const ListAgentsFormat$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFormat
> = ListAgentsFormat$inboundSchema;

/** @internal */
export const ListAgentsAudio$inboundSchema: z.ZodType<
  ListAgentsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentsVoice$inboundSchema,
  format: ListAgentsFormat$inboundSchema,
});
/** @internal */
export type ListAgentsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ListAgentsAudio$outboundSchema: z.ZodType<
  ListAgentsAudio$Outbound,
  z.ZodTypeDef,
  ListAgentsAudio
> = z.object({
  voice: ListAgentsVoice$outboundSchema,
  format: ListAgentsFormat$outboundSchema,
});

export function listAgentsAudioToJSON(
  listAgentsAudio: ListAgentsAudio,
): string {
  return JSON.stringify(ListAgentsAudio$outboundSchema.parse(listAgentsAudio));
}
export function listAgentsAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsResponseFormatAgentsResponseType> = z
    .nativeEnum(ListAgentsResponseFormatAgentsResponseType);
/** @internal */
export const ListAgentsResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentsResponseFormatAgentsResponseType> =
    ListAgentsResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const ListAgentsResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ListAgentsResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type ListAgentsResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ListAgentsResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ListAgentsResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function listAgentsResponseFormatJsonSchemaToJSON(
  listAgentsResponseFormatJsonSchema: ListAgentsResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ListAgentsResponseFormatJsonSchema$outboundSchema.parse(
      listAgentsResponseFormatJsonSchema,
    ),
  );
}
export function listAgentsResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormat3$inboundSchema: z.ZodType<
  ListAgentsResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsResponseFormatAgentsResponseType$inboundSchema,
  json_schema: z.lazy(() => ListAgentsResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ListAgentsResponseFormat3$Outbound = {
  type: string;
  json_schema: ListAgentsResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const ListAgentsResponseFormat3$outboundSchema: z.ZodType<
  ListAgentsResponseFormat3$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormat3
> = z.object({
  type: ListAgentsResponseFormatAgentsResponseType$outboundSchema,
  jsonSchema: z.lazy(() => ListAgentsResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function listAgentsResponseFormat3ToJSON(
  listAgentsResponseFormat3: ListAgentsResponseFormat3,
): string {
  return JSON.stringify(
    ListAgentsResponseFormat3$outboundSchema.parse(listAgentsResponseFormat3),
  );
}
export function listAgentsResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormat3' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsResponseFormatAgentsType
> = z.nativeEnum(ListAgentsResponseFormatAgentsType);
/** @internal */
export const ListAgentsResponseFormatAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsResponseFormatAgentsType
> = ListAgentsResponseFormatAgentsType$inboundSchema;

/** @internal */
export const ListAgentsResponseFormat2$inboundSchema: z.ZodType<
  ListAgentsResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type ListAgentsResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentsResponseFormat2$outboundSchema: z.ZodType<
  ListAgentsResponseFormat2$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormat2
> = z.object({
  type: ListAgentsResponseFormatAgentsType$outboundSchema,
});

export function listAgentsResponseFormat2ToJSON(
  listAgentsResponseFormat2: ListAgentsResponseFormat2,
): string {
  return JSON.stringify(
    ListAgentsResponseFormat2$outboundSchema.parse(listAgentsResponseFormat2),
  );
}
export function listAgentsResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormat2' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsResponseFormatType
> = z.nativeEnum(ListAgentsResponseFormatType);
/** @internal */
export const ListAgentsResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsResponseFormatType
> = ListAgentsResponseFormatType$inboundSchema;

/** @internal */
export const ListAgentsResponseFormat1$inboundSchema: z.ZodType<
  ListAgentsResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsResponseFormatType$inboundSchema,
});
/** @internal */
export type ListAgentsResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentsResponseFormat1$outboundSchema: z.ZodType<
  ListAgentsResponseFormat1$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormat1
> = z.object({
  type: ListAgentsResponseFormatType$outboundSchema,
});

export function listAgentsResponseFormat1ToJSON(
  listAgentsResponseFormat1: ListAgentsResponseFormat1,
): string {
  return JSON.stringify(
    ListAgentsResponseFormat1$outboundSchema.parse(listAgentsResponseFormat1),
  );
}
export function listAgentsResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormat1' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormat$inboundSchema: z.ZodType<
  ListAgentsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsResponseFormat3$inboundSchema),
  z.lazy(() => ListAgentsResponseFormat1$inboundSchema),
  z.lazy(() => ListAgentsResponseFormat2$inboundSchema),
]);
/** @internal */
export type ListAgentsResponseFormat$Outbound =
  | ListAgentsResponseFormat3$Outbound
  | ListAgentsResponseFormat1$Outbound
  | ListAgentsResponseFormat2$Outbound;

/** @internal */
export const ListAgentsResponseFormat$outboundSchema: z.ZodType<
  ListAgentsResponseFormat$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormat
> = z.union([
  z.lazy(() => ListAgentsResponseFormat3$outboundSchema),
  z.lazy(() => ListAgentsResponseFormat1$outboundSchema),
  z.lazy(() => ListAgentsResponseFormat2$outboundSchema),
]);

export function listAgentsResponseFormatToJSON(
  listAgentsResponseFormat: ListAgentsResponseFormat,
): string {
  return JSON.stringify(
    ListAgentsResponseFormat$outboundSchema.parse(listAgentsResponseFormat),
  );
}
export function listAgentsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentsStop$inboundSchema: z.ZodType<
  ListAgentsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type ListAgentsStop$Outbound = string | Array<string>;

/** @internal */
export const ListAgentsStop$outboundSchema: z.ZodType<
  ListAgentsStop$Outbound,
  z.ZodTypeDef,
  ListAgentsStop
> = z.union([z.string(), z.array(z.string())]);

export function listAgentsStopToJSON(listAgentsStop: ListAgentsStop): string {
  return JSON.stringify(ListAgentsStop$outboundSchema.parse(listAgentsStop));
}
export function listAgentsStopFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsStop' from JSON`,
  );
}

/** @internal */
export const ListAgentsStreamOptions$inboundSchema: z.ZodType<
  ListAgentsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type ListAgentsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ListAgentsStreamOptions$outboundSchema: z.ZodType<
  ListAgentsStreamOptions$Outbound,
  z.ZodTypeDef,
  ListAgentsStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function listAgentsStreamOptionsToJSON(
  listAgentsStreamOptions: ListAgentsStreamOptions,
): string {
  return JSON.stringify(
    ListAgentsStreamOptions$outboundSchema.parse(listAgentsStreamOptions),
  );
}
export function listAgentsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsType
> = z.nativeEnum(ListAgentsType);
/** @internal */
export const ListAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsType
> = ListAgentsType$inboundSchema;

/** @internal */
export const ListAgentsThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsThinkingLevel
> = z.nativeEnum(ListAgentsThinkingLevel);
/** @internal */
export const ListAgentsThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsThinkingLevel
> = ListAgentsThinkingLevel$inboundSchema;

/** @internal */
export const ListAgentsThinking$inboundSchema: z.ZodType<
  ListAgentsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: ListAgentsThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type ListAgentsThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const ListAgentsThinking$outboundSchema: z.ZodType<
  ListAgentsThinking$Outbound,
  z.ZodTypeDef,
  ListAgentsThinking
> = z.object({
  type: ListAgentsType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: ListAgentsThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function listAgentsThinkingToJSON(
  listAgentsThinking: ListAgentsThinking,
): string {
  return JSON.stringify(
    ListAgentsThinking$outboundSchema.parse(listAgentsThinking),
  );
}
export function listAgentsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceType
> = z.nativeEnum(ListAgentsToolChoiceType);
/** @internal */
export const ListAgentsToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceType
> = ListAgentsToolChoiceType$inboundSchema;

/** @internal */
export const ListAgentsToolChoiceFunction$inboundSchema: z.ZodType<
  ListAgentsToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ListAgentsToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ListAgentsToolChoiceFunction$outboundSchema: z.ZodType<
  ListAgentsToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ListAgentsToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function listAgentsToolChoiceFunctionToJSON(
  listAgentsToolChoiceFunction: ListAgentsToolChoiceFunction,
): string {
  return JSON.stringify(
    ListAgentsToolChoiceFunction$outboundSchema.parse(
      listAgentsToolChoiceFunction,
    ),
  );
}
export function listAgentsToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoice2$inboundSchema: z.ZodType<
  ListAgentsToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceFunction$inboundSchema),
});
/** @internal */
export type ListAgentsToolChoice2$Outbound = {
  type?: string | undefined;
  function: ListAgentsToolChoiceFunction$Outbound;
};

/** @internal */
export const ListAgentsToolChoice2$outboundSchema: z.ZodType<
  ListAgentsToolChoice2$Outbound,
  z.ZodTypeDef,
  ListAgentsToolChoice2
> = z.object({
  type: ListAgentsToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceFunction$outboundSchema),
});

export function listAgentsToolChoice2ToJSON(
  listAgentsToolChoice2: ListAgentsToolChoice2,
): string {
  return JSON.stringify(
    ListAgentsToolChoice2$outboundSchema.parse(listAgentsToolChoice2),
  );
}
export function listAgentsToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoice2' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoice1
> = z.nativeEnum(ListAgentsToolChoice1);
/** @internal */
export const ListAgentsToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoice1
> = ListAgentsToolChoice1$inboundSchema;

/** @internal */
export const ListAgentsToolChoice$inboundSchema: z.ZodType<
  ListAgentsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsToolChoice2$inboundSchema),
  ListAgentsToolChoice1$inboundSchema,
]);
/** @internal */
export type ListAgentsToolChoice$Outbound =
  | ListAgentsToolChoice2$Outbound
  | string;

/** @internal */
export const ListAgentsToolChoice$outboundSchema: z.ZodType<
  ListAgentsToolChoice$Outbound,
  z.ZodTypeDef,
  ListAgentsToolChoice
> = z.union([
  z.lazy(() => ListAgentsToolChoice2$outboundSchema),
  ListAgentsToolChoice1$outboundSchema,
]);

export function listAgentsToolChoiceToJSON(
  listAgentsToolChoice: ListAgentsToolChoice,
): string {
  return JSON.stringify(
    ListAgentsToolChoice$outboundSchema.parse(listAgentsToolChoice),
  );
}
export function listAgentsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentsModalities$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsModalities
> = z.nativeEnum(ListAgentsModalities);
/** @internal */
export const ListAgentsModalities$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsModalities
> = ListAgentsModalities$inboundSchema;

/** @internal */
export const ListAgentsWebSearchOptions$inboundSchema: z.ZodType<
  ListAgentsWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type ListAgentsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const ListAgentsWebSearchOptions$outboundSchema: z.ZodType<
  ListAgentsWebSearchOptions$Outbound,
  z.ZodTypeDef,
  ListAgentsWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function listAgentsWebSearchOptionsToJSON(
  listAgentsWebSearchOptions: ListAgentsWebSearchOptions,
): string {
  return JSON.stringify(
    ListAgentsWebSearchOptions$outboundSchema.parse(listAgentsWebSearchOptions),
  );
}
export function listAgentsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsParameters$inboundSchema: z.ZodType<
  ListAgentsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentsAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListAgentsResponseFormat3$inboundSchema),
    z.lazy(() => ListAgentsResponseFormat1$inboundSchema),
    z.lazy(() => ListAgentsResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListAgentsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentsThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListAgentsToolChoice2$inboundSchema),
    ListAgentsToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListAgentsModalities$inboundSchema))
    .optional(),
  web_search_options: z.lazy(() => ListAgentsWebSearchOptions$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type ListAgentsParameters$Outbound = {
  audio?: ListAgentsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ListAgentsResponseFormat3$Outbound
    | ListAgentsResponseFormat1$Outbound
    | ListAgentsResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: ListAgentsStreamOptions$Outbound | null | undefined;
  thinking?: ListAgentsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ListAgentsToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: ListAgentsWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const ListAgentsParameters$outboundSchema: z.ZodType<
  ListAgentsParameters$Outbound,
  z.ZodTypeDef,
  ListAgentsParameters
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentsAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ListAgentsResponseFormat3$outboundSchema),
    z.lazy(() => ListAgentsResponseFormat1$outboundSchema),
    z.lazy(() => ListAgentsResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ListAgentsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentsThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ListAgentsToolChoice2$outboundSchema),
    ListAgentsToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListAgentsModalities$outboundSchema))
    .optional(),
  webSearchOptions: z.lazy(() => ListAgentsWebSearchOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function listAgentsParametersToJSON(
  listAgentsParameters: ListAgentsParameters,
): string {
  return JSON.stringify(
    ListAgentsParameters$outboundSchema.parse(listAgentsParameters),
  );
}
export function listAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsVoice
> = z.nativeEnum(ListAgentsFallbackModelsVoice);
/** @internal */
export const ListAgentsFallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsVoice
> = ListAgentsFallbackModelsVoice$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsFormat
> = z.nativeEnum(ListAgentsFallbackModelsFormat);
/** @internal */
export const ListAgentsFallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsFormat
> = ListAgentsFallbackModelsFormat$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsAudio$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentsFallbackModelsVoice$inboundSchema,
  format: ListAgentsFallbackModelsFormat$inboundSchema,
});
/** @internal */
export type ListAgentsFallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ListAgentsFallbackModelsAudio$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsAudio
> = z.object({
  voice: ListAgentsFallbackModelsVoice$outboundSchema,
  format: ListAgentsFallbackModelsFormat$outboundSchema,
});

export function listAgentsFallbackModelsAudioToJSON(
  listAgentsFallbackModelsAudio: ListAgentsFallbackModelsAudio,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsAudio$outboundSchema.parse(
      listAgentsFallbackModelsAudio,
    ),
  );
}
export function listAgentsFallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > =
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const ListAgentsResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type ListAgentsResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ListAgentsResponseFormatAgentsJsonSchema$outboundSchema: z.ZodType<
  ListAgentsResponseFormatAgentsJsonSchema$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormatAgentsJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function listAgentsResponseFormatAgentsJsonSchemaToJSON(
  listAgentsResponseFormatAgentsJsonSchema:
    ListAgentsResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    ListAgentsResponseFormatAgentsJsonSchema$outboundSchema.parse(
      listAgentsResponseFormatAgentsJsonSchema,
    ),
  );
}
export function listAgentsResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgents3$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  json_schema: z.lazy(() =>
    ListAgentsResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ListAgentsResponseFormatAgents3$Outbound = {
  type: string;
  json_schema: ListAgentsResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const ListAgentsResponseFormatAgents3$outboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents3$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormatAgents3
> = z.object({
  type:
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  jsonSchema: z.lazy(() =>
    ListAgentsResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function listAgentsResponseFormatAgents3ToJSON(
  listAgentsResponseFormatAgents3: ListAgentsResponseFormatAgents3,
): string {
  return JSON.stringify(
    ListAgentsResponseFormatAgents3$outboundSchema.parse(
      listAgentsResponseFormatAgents3,
    ),
  );
}
export function listAgentsResponseFormatAgents3FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatAgents3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormatAgents3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatAgents3' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONType
  > = z.nativeEnum(
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONType,
  );
/** @internal */
export const ListAgentsResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentsResponseFormatAgentsResponse200ApplicationJSONType
  > =
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const ListAgentsResponseFormatAgents2$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema,
});
/** @internal */
export type ListAgentsResponseFormatAgents2$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentsResponseFormatAgents2$outboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents2$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormatAgents2
> = z.object({
  type:
    ListAgentsResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema,
});

export function listAgentsResponseFormatAgents2ToJSON(
  listAgentsResponseFormatAgents2: ListAgentsResponseFormatAgents2,
): string {
  return JSON.stringify(
    ListAgentsResponseFormatAgents2$outboundSchema.parse(
      listAgentsResponseFormatAgents2,
    ),
  );
}
export function listAgentsResponseFormatAgents2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormatAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatAgents2' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsResponseFormatAgentsResponse200Type> = z
    .nativeEnum(ListAgentsResponseFormatAgentsResponse200Type);
/** @internal */
export const ListAgentsResponseFormatAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentsResponseFormatAgentsResponse200Type> =
    ListAgentsResponseFormatAgentsResponse200Type$inboundSchema;

/** @internal */
export const ListAgentsResponseFormatAgents1$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsResponseFormatAgentsResponse200Type$inboundSchema,
});
/** @internal */
export type ListAgentsResponseFormatAgents1$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentsResponseFormatAgents1$outboundSchema: z.ZodType<
  ListAgentsResponseFormatAgents1$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseFormatAgents1
> = z.object({
  type: ListAgentsResponseFormatAgentsResponse200Type$outboundSchema,
});

export function listAgentsResponseFormatAgents1ToJSON(
  listAgentsResponseFormatAgents1: ListAgentsResponseFormatAgents1,
): string {
  return JSON.stringify(
    ListAgentsResponseFormatAgents1$outboundSchema.parse(
      listAgentsResponseFormatAgents1,
    ),
  );
}
export function listAgentsResponseFormatAgents1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormatAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatAgents1' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsResponseFormat$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsResponseFormatAgents3$inboundSchema),
  z.lazy(() => ListAgentsResponseFormatAgents1$inboundSchema),
  z.lazy(() => ListAgentsResponseFormatAgents2$inboundSchema),
]);
/** @internal */
export type ListAgentsFallbackModelsResponseFormat$Outbound =
  | ListAgentsResponseFormatAgents3$Outbound
  | ListAgentsResponseFormatAgents1$Outbound
  | ListAgentsResponseFormatAgents2$Outbound;

/** @internal */
export const ListAgentsFallbackModelsResponseFormat$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsResponseFormat$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsResponseFormat
> = z.union([
  z.lazy(() => ListAgentsResponseFormatAgents3$outboundSchema),
  z.lazy(() => ListAgentsResponseFormatAgents1$outboundSchema),
  z.lazy(() => ListAgentsResponseFormatAgents2$outboundSchema),
]);

export function listAgentsFallbackModelsResponseFormatToJSON(
  listAgentsFallbackModelsResponseFormat:
    ListAgentsFallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsResponseFormat$outboundSchema.parse(
      listAgentsFallbackModelsResponseFormat,
    ),
  );
}
export function listAgentsFallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsStop$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type ListAgentsFallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const ListAgentsFallbackModelsStop$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsStop$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function listAgentsFallbackModelsStopToJSON(
  listAgentsFallbackModelsStop: ListAgentsFallbackModelsStop,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsStop$outboundSchema.parse(
      listAgentsFallbackModelsStop,
    ),
  );
}
export function listAgentsFallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsStreamOptions$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type ListAgentsFallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ListAgentsFallbackModelsStreamOptions$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsStreamOptions$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function listAgentsFallbackModelsStreamOptionsToJSON(
  listAgentsFallbackModelsStreamOptions: ListAgentsFallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsStreamOptions$outboundSchema.parse(
      listAgentsFallbackModelsStreamOptions,
    ),
  );
}
export function listAgentsFallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsType
> = z.nativeEnum(ListAgentsFallbackModelsType);
/** @internal */
export const ListAgentsFallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsType
> = ListAgentsFallbackModelsType$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelsThinkingLevel> = z.nativeEnum(
    ListAgentsFallbackModelsThinkingLevel,
  );
/** @internal */
export const ListAgentsFallbackModelsThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelsThinkingLevel> =
    ListAgentsFallbackModelsThinkingLevel$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsThinking$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsFallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: ListAgentsFallbackModelsThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type ListAgentsFallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const ListAgentsFallbackModelsThinking$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsThinking
> = z.object({
  type: ListAgentsFallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: ListAgentsFallbackModelsThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function listAgentsFallbackModelsThinkingToJSON(
  listAgentsFallbackModelsThinking: ListAgentsFallbackModelsThinking,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsThinking$outboundSchema.parse(
      listAgentsFallbackModelsThinking,
    ),
  );
}
export function listAgentsFallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgentsType
> = z.nativeEnum(ListAgentsToolChoiceAgentsType);
/** @internal */
export const ListAgentsToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgentsType
> = ListAgentsToolChoiceAgentsType$inboundSchema;

/** @internal */
export const ListAgentsToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  ListAgentsToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ListAgentsToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ListAgentsToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  ListAgentsToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  ListAgentsToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function listAgentsToolChoiceAgentsFunctionToJSON(
  listAgentsToolChoiceAgentsFunction: ListAgentsToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    ListAgentsToolChoiceAgentsFunction$outboundSchema.parse(
      listAgentsToolChoiceAgentsFunction,
    ),
  );
}
export function listAgentsToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgents2$inboundSchema: z.ZodType<
  ListAgentsToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type ListAgentsToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: ListAgentsToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const ListAgentsToolChoiceAgents2$outboundSchema: z.ZodType<
  ListAgentsToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  ListAgentsToolChoiceAgents2
> = z.object({
  type: ListAgentsToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceAgentsFunction$outboundSchema),
});

export function listAgentsToolChoiceAgents2ToJSON(
  listAgentsToolChoiceAgents2: ListAgentsToolChoiceAgents2,
): string {
  return JSON.stringify(
    ListAgentsToolChoiceAgents2$outboundSchema.parse(
      listAgentsToolChoiceAgents2,
    ),
  );
}
export function listAgentsToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgents1
> = z.nativeEnum(ListAgentsToolChoiceAgents1);
/** @internal */
export const ListAgentsToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgents1
> = ListAgentsToolChoiceAgents1$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsToolChoice$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsToolChoiceAgents2$inboundSchema),
  ListAgentsToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type ListAgentsFallbackModelsToolChoice$Outbound =
  | ListAgentsToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const ListAgentsFallbackModelsToolChoice$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsToolChoice
> = z.union([
  z.lazy(() => ListAgentsToolChoiceAgents2$outboundSchema),
  ListAgentsToolChoiceAgents1$outboundSchema,
]);

export function listAgentsFallbackModelsToolChoiceToJSON(
  listAgentsFallbackModelsToolChoice: ListAgentsFallbackModelsToolChoice,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsToolChoice$outboundSchema.parse(
      listAgentsFallbackModelsToolChoice,
    ),
  );
}
export function listAgentsFallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsModalities$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsModalities
> = z.nativeEnum(ListAgentsFallbackModelsModalities);
/** @internal */
export const ListAgentsFallbackModelsModalities$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFallbackModelsModalities
> = ListAgentsFallbackModelsModalities$inboundSchema;

/** @internal */
export const ListAgentsFallbackModelsWebSearchOptions$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type ListAgentsFallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const ListAgentsFallbackModelsWebSearchOptions$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsWebSearchOptions$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function listAgentsFallbackModelsWebSearchOptionsToJSON(
  listAgentsFallbackModelsWebSearchOptions:
    ListAgentsFallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsWebSearchOptions$outboundSchema.parse(
      listAgentsFallbackModelsWebSearchOptions,
    ),
  );
}
export function listAgentsFallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelsWebSearchOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelsWebSearchOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelsParameters$inboundSchema: z.ZodType<
  ListAgentsFallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentsFallbackModelsAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListAgentsResponseFormatAgents3$inboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgents1$inboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgents2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListAgentsFallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentsFallbackModelsThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListAgentsToolChoiceAgents2$inboundSchema),
    ListAgentsToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(ListAgentsFallbackModelsModalities$inboundSchema),
  ).optional(),
  web_search_options: z.lazy(() =>
    ListAgentsFallbackModelsWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type ListAgentsFallbackModelsParameters$Outbound = {
  audio?: ListAgentsFallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ListAgentsResponseFormatAgents3$Outbound
    | ListAgentsResponseFormatAgents1$Outbound
    | ListAgentsResponseFormatAgents2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | ListAgentsFallbackModelsStreamOptions$Outbound
    | null
    | undefined;
  thinking?: ListAgentsFallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ListAgentsToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?:
    | ListAgentsFallbackModelsWebSearchOptions$Outbound
    | undefined;
};

/** @internal */
export const ListAgentsFallbackModelsParameters$outboundSchema: z.ZodType<
  ListAgentsFallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModelsParameters
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentsFallbackModelsAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ListAgentsResponseFormatAgents3$outboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgents1$outboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgents2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ListAgentsFallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentsFallbackModelsThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ListAgentsToolChoiceAgents2$outboundSchema),
    ListAgentsToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(ListAgentsFallbackModelsModalities$outboundSchema),
  ).optional(),
  webSearchOptions: z.lazy(() =>
    ListAgentsFallbackModelsWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function listAgentsFallbackModelsParametersToJSON(
  listAgentsFallbackModelsParameters: ListAgentsFallbackModelsParameters,
): string {
  return JSON.stringify(
    ListAgentsFallbackModelsParameters$outboundSchema.parse(
      listAgentsFallbackModelsParameters,
    ),
  );
}
export function listAgentsFallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModels2$inboundSchema: z.ZodType<
  ListAgentsFallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentsFallbackModelsParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type ListAgentsFallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: ListAgentsFallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const ListAgentsFallbackModels2$outboundSchema: z.ZodType<
  ListAgentsFallbackModels2$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentsFallbackModelsParameters$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function listAgentsFallbackModels2ToJSON(
  listAgentsFallbackModels2: ListAgentsFallbackModels2,
): string {
  return JSON.stringify(
    ListAgentsFallbackModels2$outboundSchema.parse(listAgentsFallbackModels2),
  );
}
export function listAgentsFallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModels2' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModels$inboundSchema: z.ZodType<
  ListAgentsFallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsFallbackModels2$inboundSchema),
  z.string(),
]);
/** @internal */
export type ListAgentsFallbackModels$Outbound =
  | ListAgentsFallbackModels2$Outbound
  | string;

/** @internal */
export const ListAgentsFallbackModels$outboundSchema: z.ZodType<
  ListAgentsFallbackModels$Outbound,
  z.ZodTypeDef,
  ListAgentsFallbackModels
> = z.union([
  z.lazy(() => ListAgentsFallbackModels2$outboundSchema),
  z.string(),
]);

export function listAgentsFallbackModelsToJSON(
  listAgentsFallbackModels: ListAgentsFallbackModels,
): string {
  return JSON.stringify(
    ListAgentsFallbackModels$outboundSchema.parse(listAgentsFallbackModels),
  );
}
export function listAgentsFallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModels' from JSON`,
  );
}

/** @internal */
export const ListAgentsModel$inboundSchema: z.ZodType<
  ListAgentsModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentsParameters$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => ListAgentsFallbackModels2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type ListAgentsModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: ListAgentsParameters$Outbound | undefined;
  fallback_models?:
    | Array<ListAgentsFallbackModels2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const ListAgentsModel$outboundSchema: z.ZodType<
  ListAgentsModel$Outbound,
  z.ZodTypeDef,
  ListAgentsModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentsParameters$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => ListAgentsFallbackModels2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function listAgentsModelToJSON(
  listAgentsModel: ListAgentsModel,
): string {
  return JSON.stringify(ListAgentsModel$outboundSchema.parse(listAgentsModel));
}
export function listAgentsModelFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsModel' from JSON`,
  );
}

/** @internal */
export const ListAgentsTeamOfAgents$inboundSchema: z.ZodType<
  ListAgentsTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type ListAgentsTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const ListAgentsTeamOfAgents$outboundSchema: z.ZodType<
  ListAgentsTeamOfAgents$Outbound,
  z.ZodTypeDef,
  ListAgentsTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function listAgentsTeamOfAgentsToJSON(
  listAgentsTeamOfAgents: ListAgentsTeamOfAgents,
): string {
  return JSON.stringify(
    ListAgentsTeamOfAgents$outboundSchema.parse(listAgentsTeamOfAgents),
  );
}
export function listAgentsTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const ListAgentsMetrics$inboundSchema: z.ZodType<
  ListAgentsMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type ListAgentsMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const ListAgentsMetrics$outboundSchema: z.ZodType<
  ListAgentsMetrics$Outbound,
  z.ZodTypeDef,
  ListAgentsMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function listAgentsMetricsToJSON(
  listAgentsMetrics: ListAgentsMetrics,
): string {
  return JSON.stringify(
    ListAgentsMetrics$outboundSchema.parse(listAgentsMetrics),
  );
}
export function listAgentsMetricsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsMetrics' from JSON`,
  );
}

/** @internal */
export const ListAgentsKnowledgeBases$inboundSchema: z.ZodType<
  ListAgentsKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type ListAgentsKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const ListAgentsKnowledgeBases$outboundSchema: z.ZodType<
  ListAgentsKnowledgeBases$Outbound,
  z.ZodTypeDef,
  ListAgentsKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function listAgentsKnowledgeBasesToJSON(
  listAgentsKnowledgeBases: ListAgentsKnowledgeBases,
): string {
  return JSON.stringify(
    ListAgentsKnowledgeBases$outboundSchema.parse(listAgentsKnowledgeBases),
  );
}
export function listAgentsKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const ListAgentsHiddenPanels$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsHiddenPanels
> = z.nativeEnum(ListAgentsHiddenPanels);
/** @internal */
export const ListAgentsHiddenPanels$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentsHiddenPanels
> = ListAgentsHiddenPanels$inboundSchema;

/** @internal */
export const ListAgentsData$inboundSchema: z.ZodType<
  ListAgentsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: ListAgentsStatus$inboundSchema,
  settings: z.lazy(() => ListAgentsSettings$inboundSchema).optional(),
  model: z.lazy(() => ListAgentsModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => ListAgentsTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => ListAgentsMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(z.lazy(() => ListAgentsKnowledgeBases$inboundSchema))
    .optional(),
  hidden_panels: z.array(ListAgentsHiddenPanels$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
    "hidden_panels": "hiddenPanels",
  });
});
/** @internal */
export type ListAgentsData$Outbound = {
  _id: string;
  key: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: ListAgentsSettings$Outbound | undefined;
  model: ListAgentsModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<ListAgentsTeamOfAgents$Outbound>;
  metrics?: ListAgentsMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<ListAgentsKnowledgeBases$Outbound> | undefined;
  hidden_panels?: Array<string> | undefined;
};

/** @internal */
export const ListAgentsData$outboundSchema: z.ZodType<
  ListAgentsData$Outbound,
  z.ZodTypeDef,
  ListAgentsData
> = z.object({
  id: z.string(),
  key: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: ListAgentsStatus$outboundSchema,
  settings: z.lazy(() => ListAgentsSettings$outboundSchema).optional(),
  model: z.lazy(() => ListAgentsModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(z.lazy(() => ListAgentsTeamOfAgents$outboundSchema)),
  metrics: z.lazy(() => ListAgentsMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(z.lazy(() => ListAgentsKnowledgeBases$outboundSchema))
    .optional(),
  hiddenPanels: z.array(ListAgentsHiddenPanels$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
    hiddenPanels: "hidden_panels",
  });
});

export function listAgentsDataToJSON(listAgentsData: ListAgentsData): string {
  return JSON.stringify(ListAgentsData$outboundSchema.parse(listAgentsData));
}
export function listAgentsDataFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsData' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseBody$inboundSchema: z.ZodType<
  ListAgentsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ListAgentsObject$inboundSchema,
  data: z.array(z.lazy(() => ListAgentsData$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});
/** @internal */
export type ListAgentsResponseBody$Outbound = {
  object: string;
  data: Array<ListAgentsData$Outbound>;
  has_more: boolean;
};

/** @internal */
export const ListAgentsResponseBody$outboundSchema: z.ZodType<
  ListAgentsResponseBody$Outbound,
  z.ZodTypeDef,
  ListAgentsResponseBody
> = z.object({
  object: ListAgentsObject$outboundSchema,
  data: z.array(z.lazy(() => ListAgentsData$outboundSchema)),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

export function listAgentsResponseBodyToJSON(
  listAgentsResponseBody: ListAgentsResponseBody,
): string {
  return JSON.stringify(
    ListAgentsResponseBody$outboundSchema.parse(listAgentsResponseBody),
  );
}
export function listAgentsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseBody' from JSON`,
  );
}
