/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListAgentsRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 200. When not provided, returns all agents without pagination.
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const ListAgentsObject = {
  List: "list",
} as const;
export type ListAgentsObject = ClosedEnum<typeof ListAgentsObject>;

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ListAgentsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ListAgentsStatus = ClosedEnum<typeof ListAgentsStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ListAgentsToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ListAgentsToolApprovalRequired = ClosedEnum<
  typeof ListAgentsToolApprovalRequired
>;

export type ListAgentsConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type ListAgentsTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval: boolean;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<ListAgentsConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout: number;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const ListAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type ListAgentsExecuteOn = ClosedEnum<typeof ListAgentsExecuteOn>;

export type ListAgentsEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: ListAgentsExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const ListAgentsAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type ListAgentsAgentsExecuteOn = ClosedEnum<
  typeof ListAgentsAgentsExecuteOn
>;

export type ListAgentsGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: ListAgentsAgentsExecuteOn;
};

export type ListAgentsSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations: number;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime: number;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired: ListAgentsToolApprovalRequired;
  tools?: Array<ListAgentsTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<ListAgentsEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<ListAgentsGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentsVoice = ClosedEnum<typeof ListAgentsVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentsFormat = ClosedEnum<typeof ListAgentsFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentsFormat;
};

export type ListAgentsResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type ListAgentsResponseFormatAgentsJSONSchema = {
  type: "json_schema";
  jsonSchema: ListAgentsResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ListAgentsResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ListAgentsResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentsResponseFormat =
  | ListAgentsResponseFormatText
  | ListAgentsResponseFormatJSONObject
  | ListAgentsResponseFormatAgentsJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const ListAgentsReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type ListAgentsReasoningEffort = ClosedEnum<
  typeof ListAgentsReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type ListAgentsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentsToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentsToolChoiceType = ClosedEnum<
  typeof ListAgentsToolChoiceType
>;

export type ListAgentsToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type ListAgentsToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentsToolChoiceType | undefined;
  function: ListAgentsToolChoiceFunction;
};

export const ListAgentsToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentsToolChoice1 = ClosedEnum<typeof ListAgentsToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentsToolChoice =
  | ListAgentsToolChoice2
  | ListAgentsToolChoice1;

export const ListAgentsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentsModalities = ClosedEnum<typeof ListAgentsModalities>;

/**
 * The key of the guardrail.
 */
export const ListAgentsId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type ListAgentsId1 = ClosedEnum<typeof ListAgentsId1>;

export type ListAgentsId = ListAgentsId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const ListAgentsAgentsResponseExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type ListAgentsAgentsResponseExecuteOn = ClosedEnum<
  typeof ListAgentsAgentsResponseExecuteOn
>;

export type ListAgentsAgentsGuardrails = {
  id: ListAgentsId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: ListAgentsAgentsResponseExecuteOn;
};

export type ListAgentsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type ListAgentsAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const ListAgentsType = {
  ExactMatch: "exact_match",
} as const;
export type ListAgentsType = ClosedEnum<typeof ListAgentsType>;

/**
 * Cache configuration for the request.
 */
export type ListAgentsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: ListAgentsType;
};

export const ListAgentsLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type ListAgentsLoadBalancerType = ClosedEnum<
  typeof ListAgentsLoadBalancerType
>;

export type ListAgentsLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type ListAgentsLoadBalancer1 = {
  type: ListAgentsLoadBalancerType;
  models: Array<ListAgentsLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type ListAgentsLoadBalancer = ListAgentsLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type ListAgentsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type ListAgentsParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentsResponseFormatText
    | ListAgentsResponseFormatJSONObject
    | ListAgentsResponseFormatAgentsJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: ListAgentsReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListAgentsStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ListAgentsToolChoice2 | ListAgentsToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListAgentsModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<ListAgentsAgentsGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<ListAgentsFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: ListAgentsAgentsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: ListAgentsCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: ListAgentsLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: ListAgentsTimeout | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type ListAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentsFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentsFallbackModelConfigurationVoice = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentsFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentsFallbackModelConfigurationFormat = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentsFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentsFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentsFallbackModelConfigurationFormat;
};

export type ListAgentsResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type ListAgentsResponseFormatAgentsResponse200JSONSchema = {
  type: "json_schema";
  jsonSchema: ListAgentsResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ListAgentsResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ListAgentsResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentsFallbackModelConfigurationResponseFormat =
  | ListAgentsResponseFormatAgentsText
  | ListAgentsResponseFormatAgentsJSONObject
  | ListAgentsResponseFormatAgentsResponse200JSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const ListAgentsFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type ListAgentsFallbackModelConfigurationReasoningEffort = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentsFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentsFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type ListAgentsFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentsToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentsToolChoiceAgentsType = ClosedEnum<
  typeof ListAgentsToolChoiceAgentsType
>;

export type ListAgentsToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type ListAgentsToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentsToolChoiceAgentsType | undefined;
  function: ListAgentsToolChoiceAgentsFunction;
};

export const ListAgentsToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentsToolChoiceAgents1 = ClosedEnum<
  typeof ListAgentsToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentsFallbackModelConfigurationToolChoice =
  | ListAgentsToolChoiceAgents2
  | ListAgentsToolChoiceAgents1;

export const ListAgentsFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentsFallbackModelConfigurationModalities = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const ListAgentsIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type ListAgentsIdAgents1 = ClosedEnum<typeof ListAgentsIdAgents1>;

export type ListAgentsFallbackModelConfigurationId =
  | ListAgentsIdAgents1
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const ListAgentsFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type ListAgentsFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationExecuteOn
>;

export type ListAgentsFallbackModelConfigurationGuardrails = {
  id: ListAgentsIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: ListAgentsFallbackModelConfigurationExecuteOn;
};

export type ListAgentsFallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type ListAgentsFallbackModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const ListAgentsFallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type ListAgentsFallbackModelConfigurationType = ClosedEnum<
  typeof ListAgentsFallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type ListAgentsFallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: ListAgentsFallbackModelConfigurationType;
};

export const ListAgentsLoadBalancerAgentsType = {
  WeightBased: "weight_based",
} as const;
export type ListAgentsLoadBalancerAgentsType = ClosedEnum<
  typeof ListAgentsLoadBalancerAgentsType
>;

export type ListAgentsLoadBalancerAgentsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type ListAgentsLoadBalancerAgents1 = {
  type: ListAgentsLoadBalancerAgentsType;
  models: Array<ListAgentsLoadBalancerAgentsModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type ListAgentsFallbackModelConfigurationLoadBalancer =
  ListAgentsLoadBalancerAgents1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type ListAgentsFallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type ListAgentsFallbackModelConfigurationParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentsFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentsResponseFormatAgentsText
    | ListAgentsResponseFormatAgentsJSONObject
    | ListAgentsResponseFormatAgentsResponse200JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | ListAgentsFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | ListAgentsFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | ListAgentsToolChoiceAgents2
    | ListAgentsToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<ListAgentsFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<ListAgentsFallbackModelConfigurationGuardrails>
    | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<ListAgentsFallbackModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: ListAgentsFallbackModelConfigurationAgentsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: ListAgentsFallbackModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: ListAgentsLoadBalancerAgents1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: ListAgentsFallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type ListAgentsFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type ListAgentsFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: ListAgentsFallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: ListAgentsFallbackModelConfigurationRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type ListAgentsFallbackModelConfiguration =
  | ListAgentsFallbackModelConfiguration2
  | string;

export type ListAgentsModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: ListAgentsParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: ListAgentsRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<ListAgentsFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type ListAgentsTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type ListAgentsMetrics = {
  totalCost: number;
};

export type ListAgentsKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const ListAgentsSource = {
  Internal: "internal",
  External: "external",
  Experiment: "experiment",
} as const;
export type ListAgentsSource = ClosedEnum<typeof ListAgentsSource>;

export type ListAgentsData = {
  id: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  displayName: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: ListAgentsStatus;
  settings?: ListAgentsSettings | undefined;
  model: ListAgentsModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<ListAgentsTeamOfAgents>;
  metrics?: ListAgentsMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<ListAgentsKnowledgeBases> | undefined;
  source?: ListAgentsSource | undefined;
};

/**
 * Successfully retrieved the list of agents. Returns a paginated response containing agent manifests with complete configurations, including primary and fallback models, tools, knowledge bases, and execution settings.
 */
export type ListAgentsResponseBody = {
  object: ListAgentsObject;
  data: Array<ListAgentsData>;
  hasMore: boolean;
};

/** @internal */
export type ListAgentsRequest$Outbound = {
  limit?: number | undefined;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const ListAgentsRequest$outboundSchema: z.ZodType<
  ListAgentsRequest$Outbound,
  z.ZodTypeDef,
  ListAgentsRequest
> = z.object({
  limit: z.number().optional(),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listAgentsRequestToJSON(
  listAgentsRequest: ListAgentsRequest,
): string {
  return JSON.stringify(
    ListAgentsRequest$outboundSchema.parse(listAgentsRequest),
  );
}

/** @internal */
export const ListAgentsObject$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsObject
> = z.nativeEnum(ListAgentsObject);

/** @internal */
export const ListAgentsStatus$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsStatus
> = z.nativeEnum(ListAgentsStatus);

/** @internal */
export const ListAgentsToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolApprovalRequired
> = z.nativeEnum(ListAgentsToolApprovalRequired);

/** @internal */
export const ListAgentsConditions$inboundSchema: z.ZodType<
  ListAgentsConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function listAgentsConditionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsConditions' from JSON`,
  );
}

/** @internal */
export const ListAgentsTools$inboundSchema: z.ZodType<
  ListAgentsTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => ListAgentsConditions$inboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});

export function listAgentsToolsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsTools' from JSON`,
  );
}

/** @internal */
export const ListAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsExecuteOn
> = z.nativeEnum(ListAgentsExecuteOn);

/** @internal */
export const ListAgentsEvaluators$inboundSchema: z.ZodType<
  ListAgentsEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: ListAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function listAgentsEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsEvaluators' from JSON`,
  );
}

/** @internal */
export const ListAgentsAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsAgentsExecuteOn
> = z.nativeEnum(ListAgentsAgentsExecuteOn);

/** @internal */
export const ListAgentsGuardrails$inboundSchema: z.ZodType<
  ListAgentsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: ListAgentsAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function listAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const ListAgentsSettings$inboundSchema: z.ZodType<
  ListAgentsSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: ListAgentsToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => ListAgentsTools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => ListAgentsEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => ListAgentsGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});

export function listAgentsSettingsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsSettings' from JSON`,
  );
}

/** @internal */
export const ListAgentsVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsVoice
> = z.nativeEnum(ListAgentsVoice);

/** @internal */
export const ListAgentsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsFormat
> = z.nativeEnum(ListAgentsFormat);

/** @internal */
export const ListAgentsAudio$inboundSchema: z.ZodType<
  ListAgentsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentsVoice$inboundSchema,
  format: ListAgentsFormat$inboundSchema,
});

export function listAgentsAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ListAgentsResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});

export function listAgentsResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsJSONSchema$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgentsJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => ListAgentsResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});

export function listAgentsResponseFormatAgentsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsResponseFormatAgentsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsResponseFormatAgentsJSONSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatJSONObject$inboundSchema: z.ZodType<
  ListAgentsResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});

export function listAgentsResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatText$inboundSchema: z.ZodType<
  ListAgentsResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function listAgentsResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatText' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormat$inboundSchema: z.ZodType<
  ListAgentsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsResponseFormatText$inboundSchema),
  z.lazy(() => ListAgentsResponseFormatJSONObject$inboundSchema),
  z.lazy(() => ListAgentsResponseFormatAgentsJSONSchema$inboundSchema),
]);

export function listAgentsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsReasoningEffort
> = z.nativeEnum(ListAgentsReasoningEffort);

/** @internal */
export const ListAgentsStop$inboundSchema: z.ZodType<
  ListAgentsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function listAgentsStopFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsStop' from JSON`,
  );
}

/** @internal */
export const ListAgentsStreamOptions$inboundSchema: z.ZodType<
  ListAgentsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function listAgentsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsThinking$inboundSchema: z.ZodType<
  ListAgentsThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function listAgentsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceType
> = z.nativeEnum(ListAgentsToolChoiceType);

/** @internal */
export const ListAgentsToolChoiceFunction$inboundSchema: z.ZodType<
  ListAgentsToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function listAgentsToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoice2$inboundSchema: z.ZodType<
  ListAgentsToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceFunction$inboundSchema),
});

export function listAgentsToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoice2' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoice1
> = z.nativeEnum(ListAgentsToolChoice1);

/** @internal */
export const ListAgentsToolChoice$inboundSchema: z.ZodType<
  ListAgentsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsToolChoice2$inboundSchema),
  ListAgentsToolChoice1$inboundSchema,
]);

export function listAgentsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentsModalities$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsModalities
> = z.nativeEnum(ListAgentsModalities);

/** @internal */
export const ListAgentsId1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsId1
> = z.nativeEnum(ListAgentsId1);

/** @internal */
export const ListAgentsId$inboundSchema: z.ZodType<
  ListAgentsId,
  z.ZodTypeDef,
  unknown
> = z.union([ListAgentsId1$inboundSchema, z.string()]);

export function listAgentsIdFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsId' from JSON`,
  );
}

/** @internal */
export const ListAgentsAgentsResponseExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsAgentsResponseExecuteOn
> = z.nativeEnum(ListAgentsAgentsResponseExecuteOn);

/** @internal */
export const ListAgentsAgentsGuardrails$inboundSchema: z.ZodType<
  ListAgentsAgentsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([ListAgentsId1$inboundSchema, z.string()]),
  execute_on: ListAgentsAgentsResponseExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});

export function listAgentsAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsAgentsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsAgentsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbacks$inboundSchema: z.ZodType<
  ListAgentsFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function listAgentsFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbacks' from JSON`,
  );
}

/** @internal */
export const ListAgentsAgentsRetry$inboundSchema: z.ZodType<
  ListAgentsAgentsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function listAgentsAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsAgentsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsAgentsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsAgentsRetry' from JSON`,
  );
}

/** @internal */
export const ListAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsType
> = z.nativeEnum(ListAgentsType);

/** @internal */
export const ListAgentsCache$inboundSchema: z.ZodType<
  ListAgentsCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: ListAgentsType$inboundSchema,
});

export function listAgentsCacheFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsCache' from JSON`,
  );
}

/** @internal */
export const ListAgentsLoadBalancerType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsLoadBalancerType
> = z.nativeEnum(ListAgentsLoadBalancerType);

/** @internal */
export const ListAgentsLoadBalancerModels$inboundSchema: z.ZodType<
  ListAgentsLoadBalancerModels,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function listAgentsLoadBalancerModelsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsLoadBalancerModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsLoadBalancerModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsLoadBalancerModels' from JSON`,
  );
}

/** @internal */
export const ListAgentsLoadBalancer1$inboundSchema: z.ZodType<
  ListAgentsLoadBalancer1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsLoadBalancerType$inboundSchema,
  models: z.array(z.lazy(() => ListAgentsLoadBalancerModels$inboundSchema)),
});

export function listAgentsLoadBalancer1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsLoadBalancer1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsLoadBalancer1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsLoadBalancer1' from JSON`,
  );
}

/** @internal */
export const ListAgentsLoadBalancer$inboundSchema: z.ZodType<
  ListAgentsLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => ListAgentsLoadBalancer1$inboundSchema);

export function listAgentsLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsLoadBalancer' from JSON`,
  );
}

/** @internal */
export const ListAgentsTimeout$inboundSchema: z.ZodType<
  ListAgentsTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function listAgentsTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsTimeout' from JSON`,
  );
}

/** @internal */
export const ListAgentsParameters$inboundSchema: z.ZodType<
  ListAgentsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => ListAgentsAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListAgentsResponseFormatText$inboundSchema),
    z.lazy(() => ListAgentsResponseFormatJSONObject$inboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgentsJSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: ListAgentsReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListAgentsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListAgentsToolChoice2$inboundSchema),
    ListAgentsToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListAgentsModalities$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => ListAgentsAgentsGuardrails$inboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => ListAgentsFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => ListAgentsAgentsRetry$inboundSchema).optional(),
  cache: z.lazy(() => ListAgentsCache$inboundSchema).optional(),
  load_balancer: z.lazy(() => ListAgentsLoadBalancer1$inboundSchema).optional(),
  timeout: z.lazy(() => ListAgentsTimeout$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function listAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentsRetry$inboundSchema: z.ZodType<
  ListAgentsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function listAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsRetry' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationVoice> = z
    .nativeEnum(ListAgentsFallbackModelConfigurationVoice);

/** @internal */
export const ListAgentsFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationFormat> = z
    .nativeEnum(ListAgentsFallbackModelConfigurationFormat);

/** @internal */
export const ListAgentsFallbackModelConfigurationAudio$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentsFallbackModelConfigurationVoice$inboundSchema,
  format: ListAgentsFallbackModelConfigurationFormat$inboundSchema,
});

export function listAgentsFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    ListAgentsResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function listAgentsResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    ListAgentsResponseFormatAgentsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      ListAgentsResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function listAgentsResponseFormatAgentsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsResponseFormatAgentsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsResponse200JSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsResponseFormatAgentsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsJSONObject$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgentsJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});

export function listAgentsResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseFormatAgentsText$inboundSchema: z.ZodType<
  ListAgentsResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function listAgentsResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => ListAgentsResponseFormatAgentsText$inboundSchema),
    z.lazy(() => ListAgentsResponseFormatAgentsJSONObject$inboundSchema),
    z.lazy(() =>
      ListAgentsResponseFormatAgentsResponse200JSONSchema$inboundSchema
    ),
  ]);

export function listAgentsFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationReasoningEffort$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationReasoningEffort> =
    z.nativeEnum(ListAgentsFallbackModelConfigurationReasoningEffort);

/** @internal */
export const ListAgentsFallbackModelConfigurationStop$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function listAgentsFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });

export function listAgentsFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);

export function listAgentsFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgentsType
> = z.nativeEnum(ListAgentsToolChoiceAgentsType);

/** @internal */
export const ListAgentsToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  ListAgentsToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function listAgentsToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgents2$inboundSchema: z.ZodType<
  ListAgentsToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentsToolChoiceAgentsFunction$inboundSchema),
});

export function listAgentsToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const ListAgentsToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsToolChoiceAgents1
> = z.nativeEnum(ListAgentsToolChoiceAgents1);

/** @internal */
export const ListAgentsFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => ListAgentsToolChoiceAgents2$inboundSchema),
    ListAgentsToolChoiceAgents1$inboundSchema,
  ]);

export function listAgentsFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationModalities> = z
    .nativeEnum(ListAgentsFallbackModelConfigurationModalities);

/** @internal */
export const ListAgentsIdAgents1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsIdAgents1
> = z.nativeEnum(ListAgentsIdAgents1);

/** @internal */
export const ListAgentsFallbackModelConfigurationId$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfigurationId,
  z.ZodTypeDef,
  unknown
> = z.union([ListAgentsIdAgents1$inboundSchema, z.string()]);

export function listAgentsFallbackModelConfigurationIdFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelConfigurationId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelConfigurationId' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationExecuteOn> = z
    .nativeEnum(ListAgentsFallbackModelConfigurationExecuteOn);

/** @internal */
export const ListAgentsFallbackModelConfigurationGuardrails$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationGuardrails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.union([ListAgentsIdAgents1$inboundSchema, z.string()]),
    execute_on: ListAgentsFallbackModelConfigurationExecuteOn$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "execute_on": "executeOn",
    });
  });

export function listAgentsFallbackModelConfigurationGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationGuardrails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationGuardrails' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationFallbacks$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationFallbacks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });

export function listAgentsFallbackModelConfigurationFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationFallbacks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationFallbacks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationFallbacks' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationAgentsRetry$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationAgentsRetry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });

export function listAgentsFallbackModelConfigurationAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationAgentsRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationAgentsRetry$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationAgentsRetry' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentsFallbackModelConfigurationType> = z
    .nativeEnum(ListAgentsFallbackModelConfigurationType);

/** @internal */
export const ListAgentsFallbackModelConfigurationCache$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfigurationCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: ListAgentsFallbackModelConfigurationType$inboundSchema,
});

export function listAgentsFallbackModelConfigurationCacheFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationCache,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationCache$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationCache' from JSON`,
  );
}

/** @internal */
export const ListAgentsLoadBalancerAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsLoadBalancerAgentsType
> = z.nativeEnum(ListAgentsLoadBalancerAgentsType);

/** @internal */
export const ListAgentsLoadBalancerAgentsModels$inboundSchema: z.ZodType<
  ListAgentsLoadBalancerAgentsModels,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function listAgentsLoadBalancerAgentsModelsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsLoadBalancerAgentsModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsLoadBalancerAgentsModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsLoadBalancerAgentsModels' from JSON`,
  );
}

/** @internal */
export const ListAgentsLoadBalancerAgents1$inboundSchema: z.ZodType<
  ListAgentsLoadBalancerAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentsLoadBalancerAgentsType$inboundSchema,
  models: z.array(
    z.lazy(() => ListAgentsLoadBalancerAgentsModels$inboundSchema),
  ),
});

export function listAgentsLoadBalancerAgents1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsLoadBalancerAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsLoadBalancerAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsLoadBalancerAgents1' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationLoadBalancer$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationLoadBalancer,
    z.ZodTypeDef,
    unknown
  > = z.lazy(() => ListAgentsLoadBalancerAgents1$inboundSchema);

export function listAgentsFallbackModelConfigurationLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationLoadBalancer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationLoadBalancer$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationLoadBalancer' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationTimeout$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationTimeout,
    z.ZodTypeDef,
    unknown
  > = z.object({
    call_timeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "call_timeout": "callTimeout",
    });
  });

export function listAgentsFallbackModelConfigurationTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationTimeout,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationTimeout$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationTimeout' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    ListAgentsFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => ListAgentsFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => ListAgentsResponseFormatAgentsText$inboundSchema),
      z.lazy(() => ListAgentsResponseFormatAgentsJSONObject$inboundSchema),
      z.lazy(() =>
        ListAgentsResponseFormatAgentsResponse200JSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort:
      ListAgentsFallbackModelConfigurationReasoningEffort$inboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        ListAgentsFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => ListAgentsToolChoiceAgents2$inboundSchema),
      ListAgentsToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(ListAgentsFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        ListAgentsFallbackModelConfigurationGuardrails$inboundSchema
      ),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() => ListAgentsFallbackModelConfigurationFallbacks$inboundSchema),
    ).optional(),
    retry: z.lazy(() =>
      ListAgentsFallbackModelConfigurationAgentsRetry$inboundSchema
    ).optional(),
    cache: z.lazy(() => ListAgentsFallbackModelConfigurationCache$inboundSchema)
      .optional(),
    load_balancer: z.lazy(() => ListAgentsLoadBalancerAgents1$inboundSchema)
      .optional(),
    timeout: z.lazy(() =>
      ListAgentsFallbackModelConfigurationTimeout$inboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
      "load_balancer": "loadBalancer",
    });
  });

export function listAgentsFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfigurationRetry$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfigurationRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function listAgentsFallbackModelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentsFallbackModelConfigurationRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfigurationRetry$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentsFallbackModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfiguration2$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    ListAgentsFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
  retry: z.lazy(() => ListAgentsFallbackModelConfigurationRetry$inboundSchema)
    .optional(),
});

export function listAgentsFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const ListAgentsFallbackModelConfiguration$inboundSchema: z.ZodType<
  ListAgentsFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentsFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);

export function listAgentsFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsFallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentsFallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const ListAgentsModel$inboundSchema: z.ZodType<
  ListAgentsModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentsParameters$inboundSchema).optional(),
  retry: z.lazy(() => ListAgentsRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => ListAgentsFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});

export function listAgentsModelFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsModel' from JSON`,
  );
}

/** @internal */
export const ListAgentsTeamOfAgents$inboundSchema: z.ZodType<
  ListAgentsTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function listAgentsTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const ListAgentsMetrics$inboundSchema: z.ZodType<
  ListAgentsMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});

export function listAgentsMetricsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsMetrics' from JSON`,
  );
}

/** @internal */
export const ListAgentsKnowledgeBases$inboundSchema: z.ZodType<
  ListAgentsKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});

export function listAgentsKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const ListAgentsSource$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentsSource
> = z.nativeEnum(ListAgentsSource);

/** @internal */
export const ListAgentsData$inboundSchema: z.ZodType<
  ListAgentsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: ListAgentsStatus$inboundSchema,
  settings: z.lazy(() => ListAgentsSettings$inboundSchema).optional(),
  model: z.lazy(() => ListAgentsModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => ListAgentsTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => ListAgentsMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(z.lazy(() => ListAgentsKnowledgeBases$inboundSchema))
    .optional(),
  source: ListAgentsSource$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});

export function listAgentsDataFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsData' from JSON`,
  );
}

/** @internal */
export const ListAgentsResponseBody$inboundSchema: z.ZodType<
  ListAgentsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ListAgentsObject$inboundSchema,
  data: z.array(z.lazy(() => ListAgentsData$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function listAgentsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentsResponseBody' from JSON`,
  );
}
