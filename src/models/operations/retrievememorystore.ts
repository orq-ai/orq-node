/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RetrieveMemoryStoreRequest = {
  /**
   * The unique key identifier of the memory store
   */
  memoryStoreKey: string;
};

export type RetrieveMemoryStoreEmbeddingConfig = {
  /**
   * The embeddings model to use for the knowledge base in the format "provider/model" for public models or "workspaceKey@provider/model" for private workspace models. This model will be used to embed the chunks when they are added to the knowledge base. Refer to the (Supported models)[/docs/proxy/supported-models] to browse available models.
   */
  model: string;
};

/**
 * Memory store details successfully retrieved.
 */
export type RetrieveMemoryStoreResponseBody = {
  /**
   * The unique identifier of the memory store
   */
  id: string;
  /**
   * The unique key of the memory store. The key is unique and inmmutable and cannot be repeated within the same workspace.
   */
  key: string;
  /**
   * The description of the memory store. Be as precise as possible to help the AI to understand the purpose of the memory store.
   */
  description: string;
  /**
   * The user ID of the creator
   */
  createdById?: string | undefined;
  /**
   * The user ID of the last updater
   */
  updatedById?: string | undefined;
  /**
   * The creation date of the memory store
   */
  created: string;
  /**
   * The last update date of the memory store
   */
  updated: string;
  /**
   * The default time to live of every memory document created within the memory store. Useful to control if the documents in the memory should be store for short or long term.
   */
  ttl?: number | undefined;
  embeddingConfig: RetrieveMemoryStoreEmbeddingConfig;
};

/** @internal */
export const RetrieveMemoryStoreRequest$inboundSchema: z.ZodType<
  RetrieveMemoryStoreRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  memory_store_key: z.string(),
}).transform((v) => {
  return remap$(v, {
    "memory_store_key": "memoryStoreKey",
  });
});
/** @internal */
export type RetrieveMemoryStoreRequest$Outbound = {
  memory_store_key: string;
};

/** @internal */
export const RetrieveMemoryStoreRequest$outboundSchema: z.ZodType<
  RetrieveMemoryStoreRequest$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoreRequest
> = z.object({
  memoryStoreKey: z.string(),
}).transform((v) => {
  return remap$(v, {
    memoryStoreKey: "memory_store_key",
  });
});

export function retrieveMemoryStoreRequestToJSON(
  retrieveMemoryStoreRequest: RetrieveMemoryStoreRequest,
): string {
  return JSON.stringify(
    RetrieveMemoryStoreRequest$outboundSchema.parse(retrieveMemoryStoreRequest),
  );
}
export function retrieveMemoryStoreRequestFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoreRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryStoreRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoreRequest' from JSON`,
  );
}

/** @internal */
export const RetrieveMemoryStoreEmbeddingConfig$inboundSchema: z.ZodType<
  RetrieveMemoryStoreEmbeddingConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type RetrieveMemoryStoreEmbeddingConfig$Outbound = {
  model: string;
};

/** @internal */
export const RetrieveMemoryStoreEmbeddingConfig$outboundSchema: z.ZodType<
  RetrieveMemoryStoreEmbeddingConfig$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoreEmbeddingConfig
> = z.object({
  model: z.string(),
});

export function retrieveMemoryStoreEmbeddingConfigToJSON(
  retrieveMemoryStoreEmbeddingConfig: RetrieveMemoryStoreEmbeddingConfig,
): string {
  return JSON.stringify(
    RetrieveMemoryStoreEmbeddingConfig$outboundSchema.parse(
      retrieveMemoryStoreEmbeddingConfig,
    ),
  );
}
export function retrieveMemoryStoreEmbeddingConfigFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoreEmbeddingConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveMemoryStoreEmbeddingConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoreEmbeddingConfig' from JSON`,
  );
}

/** @internal */
export const RetrieveMemoryStoreResponseBody$inboundSchema: z.ZodType<
  RetrieveMemoryStoreResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  created: z.string(),
  updated: z.string(),
  ttl: z.number().optional(),
  embedding_config: z.lazy(() =>
    RetrieveMemoryStoreEmbeddingConfig$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "embedding_config": "embeddingConfig",
  });
});
/** @internal */
export type RetrieveMemoryStoreResponseBody$Outbound = {
  _id: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  created: string;
  updated: string;
  ttl?: number | undefined;
  embedding_config: RetrieveMemoryStoreEmbeddingConfig$Outbound;
};

/** @internal */
export const RetrieveMemoryStoreResponseBody$outboundSchema: z.ZodType<
  RetrieveMemoryStoreResponseBody$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoreResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  created: z.string(),
  updated: z.string(),
  ttl: z.number().optional(),
  embeddingConfig: z.lazy(() =>
    RetrieveMemoryStoreEmbeddingConfig$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    embeddingConfig: "embedding_config",
  });
});

export function retrieveMemoryStoreResponseBodyToJSON(
  retrieveMemoryStoreResponseBody: RetrieveMemoryStoreResponseBody,
): string {
  return JSON.stringify(
    RetrieveMemoryStoreResponseBody$outboundSchema.parse(
      retrieveMemoryStoreResponseBody,
    ),
  );
}
export function retrieveMemoryStoreResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoreResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryStoreResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoreResponseBody' from JSON`,
  );
}
