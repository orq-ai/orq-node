/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export const CreateTranscriptionResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export type CreateTranscriptionResponseFormat = ClosedEnum<
  typeof CreateTranscriptionResponseFormat
>;

/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export const TimestampsGranularity = {
  None: "none",
  Word: "word",
  Character: "character",
} as const;
/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export type TimestampsGranularity = ClosedEnum<typeof TimestampsGranularity>;

export const TimestampGranularities = {
  Word: "word",
  Segment: "segment",
} as const;
export type TimestampGranularities = ClosedEnum<typeof TimestampGranularities>;

export type CreateTranscriptionFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateTranscriptionRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateTranscriptionContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

export const CreateTranscriptionLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateTranscriptionLoadBalancerType = ClosedEnum<
  typeof CreateTranscriptionLoadBalancerType
>;

export type CreateTranscriptionLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateTranscriptionLoadBalancer1 = {
  type: CreateTranscriptionLoadBalancerType;
  models: Array<CreateTranscriptionLoadBalancerModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateTranscriptionLoadBalancer = CreateTranscriptionLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateTranscriptionTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateTranscriptionOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateTranscriptionFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateTranscriptionRetry | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateTranscriptionContact | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: CreateTranscriptionLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateTranscriptionTimeout | undefined;
};

export type CreateTranscriptionFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Transcribes audio into the input language.
 */
export type CreateTranscriptionRequestBody = {
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
   */
  prompt?: string | undefined;
  /**
   * When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
   */
  enableLogging?: boolean | undefined;
  /**
   * Whether to annotate which speaker is currently talking in the uploaded file.
   */
  diarize?: boolean | undefined;
  /**
   * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
   */
  responseFormat?: CreateTranscriptionResponseFormat | undefined;
  /**
   * Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
   */
  tagAudioEvents?: boolean | undefined;
  /**
   * The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
   */
  numSpeakers?: number | undefined;
  /**
   * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
   */
  timestampsGranularity?: TimestampsGranularity | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number | undefined;
  /**
   * The language of the input audio. Supplying the input language in ISO-639-1 format will improve accuracy and latency.
   */
  language?: string | undefined;
  /**
   * The timestamp granularities to populate for this transcription. response_format must be set to verbose_json to use timestamp granularities. Either or both of these options are supported: "word" or "segment". Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.
   */
  timestampGranularities?: Array<TimestampGranularities> | undefined;
  orq?: CreateTranscriptionOrq | undefined;
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file?: CreateTranscriptionFile | Blob | undefined;
};

export type Words = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

export type Segments = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avgLogprob: number;
  compressionRatio: number;
  noSpeechProb: number;
};

export type CreateTranscriptionResponseBody2 = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<Words> | undefined;
  segments?: Array<Segments> | undefined;
};

export type CreateTranscriptionResponseBody1 = {
  text: string;
};

/**
 * Returns the transcription or verbose transcription
 */
export type CreateTranscriptionResponseBody =
  | CreateTranscriptionResponseBody1
  | CreateTranscriptionResponseBody2
  | string;

/** @internal */
export const CreateTranscriptionResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranscriptionResponseFormat
> = z.nativeEnum(CreateTranscriptionResponseFormat);

/** @internal */
export const TimestampsGranularity$outboundSchema: z.ZodNativeEnum<
  typeof TimestampsGranularity
> = z.nativeEnum(TimestampsGranularity);

/** @internal */
export const TimestampGranularities$outboundSchema: z.ZodNativeEnum<
  typeof TimestampGranularities
> = z.nativeEnum(TimestampGranularities);

/** @internal */
export type CreateTranscriptionFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateTranscriptionFallbacks$outboundSchema: z.ZodType<
  CreateTranscriptionFallbacks$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionFallbacks
> = z.object({
  model: z.string(),
});

export function createTranscriptionFallbacksToJSON(
  createTranscriptionFallbacks: CreateTranscriptionFallbacks,
): string {
  return JSON.stringify(
    CreateTranscriptionFallbacks$outboundSchema.parse(
      createTranscriptionFallbacks,
    ),
  );
}

/** @internal */
export type CreateTranscriptionRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateTranscriptionRetry$outboundSchema: z.ZodType<
  CreateTranscriptionRetry$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createTranscriptionRetryToJSON(
  createTranscriptionRetry: CreateTranscriptionRetry,
): string {
  return JSON.stringify(
    CreateTranscriptionRetry$outboundSchema.parse(createTranscriptionRetry),
  );
}

/** @internal */
export type CreateTranscriptionContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateTranscriptionContact$outboundSchema: z.ZodType<
  CreateTranscriptionContact$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createTranscriptionContactToJSON(
  createTranscriptionContact: CreateTranscriptionContact,
): string {
  return JSON.stringify(
    CreateTranscriptionContact$outboundSchema.parse(createTranscriptionContact),
  );
}

/** @internal */
export const CreateTranscriptionLoadBalancerType$outboundSchema:
  z.ZodNativeEnum<typeof CreateTranscriptionLoadBalancerType> = z.nativeEnum(
    CreateTranscriptionLoadBalancerType,
  );

/** @internal */
export type CreateTranscriptionLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateTranscriptionLoadBalancerModels$outboundSchema: z.ZodType<
  CreateTranscriptionLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createTranscriptionLoadBalancerModelsToJSON(
  createTranscriptionLoadBalancerModels: CreateTranscriptionLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateTranscriptionLoadBalancerModels$outboundSchema.parse(
      createTranscriptionLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateTranscriptionLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateTranscriptionLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateTranscriptionLoadBalancer1$outboundSchema: z.ZodType<
  CreateTranscriptionLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionLoadBalancer1
> = z.object({
  type: CreateTranscriptionLoadBalancerType$outboundSchema,
  models: z.array(
    z.lazy(() => CreateTranscriptionLoadBalancerModels$outboundSchema),
  ),
});

export function createTranscriptionLoadBalancer1ToJSON(
  createTranscriptionLoadBalancer1: CreateTranscriptionLoadBalancer1,
): string {
  return JSON.stringify(
    CreateTranscriptionLoadBalancer1$outboundSchema.parse(
      createTranscriptionLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateTranscriptionLoadBalancer$Outbound =
  CreateTranscriptionLoadBalancer1$Outbound;

/** @internal */
export const CreateTranscriptionLoadBalancer$outboundSchema: z.ZodType<
  CreateTranscriptionLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionLoadBalancer
> = z.lazy(() => CreateTranscriptionLoadBalancer1$outboundSchema);

export function createTranscriptionLoadBalancerToJSON(
  createTranscriptionLoadBalancer: CreateTranscriptionLoadBalancer,
): string {
  return JSON.stringify(
    CreateTranscriptionLoadBalancer$outboundSchema.parse(
      createTranscriptionLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateTranscriptionTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateTranscriptionTimeout$outboundSchema: z.ZodType<
  CreateTranscriptionTimeout$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createTranscriptionTimeoutToJSON(
  createTranscriptionTimeout: CreateTranscriptionTimeout,
): string {
  return JSON.stringify(
    CreateTranscriptionTimeout$outboundSchema.parse(createTranscriptionTimeout),
  );
}

/** @internal */
export type CreateTranscriptionOrq$Outbound = {
  name?: string | undefined;
  fallbacks?: Array<CreateTranscriptionFallbacks$Outbound> | undefined;
  retry?: CreateTranscriptionRetry$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateTranscriptionContact$Outbound | undefined;
  load_balancer?: CreateTranscriptionLoadBalancer1$Outbound | undefined;
  timeout?: CreateTranscriptionTimeout$Outbound | undefined;
};

/** @internal */
export const CreateTranscriptionOrq$outboundSchema: z.ZodType<
  CreateTranscriptionOrq$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionOrq
> = z.object({
  name: z.string().optional(),
  fallbacks: z.array(z.lazy(() => CreateTranscriptionFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => CreateTranscriptionRetry$outboundSchema).optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateTranscriptionContact$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateTranscriptionLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateTranscriptionTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createTranscriptionOrqToJSON(
  createTranscriptionOrq: CreateTranscriptionOrq,
): string {
  return JSON.stringify(
    CreateTranscriptionOrq$outboundSchema.parse(createTranscriptionOrq),
  );
}

/** @internal */
export type CreateTranscriptionFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const CreateTranscriptionFile$outboundSchema: z.ZodType<
  CreateTranscriptionFile$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

export function createTranscriptionFileToJSON(
  createTranscriptionFile: CreateTranscriptionFile,
): string {
  return JSON.stringify(
    CreateTranscriptionFile$outboundSchema.parse(createTranscriptionFile),
  );
}

/** @internal */
export type CreateTranscriptionRequestBody$Outbound = {
  model: string;
  prompt?: string | undefined;
  enable_logging: boolean;
  diarize: boolean;
  response_format?: string | undefined;
  tag_audio_events: boolean;
  num_speakers?: number | undefined;
  timestamps_granularity: string;
  temperature?: number | undefined;
  language?: string | undefined;
  timestamp_granularities?: Array<string> | undefined;
  orq?: CreateTranscriptionOrq$Outbound | undefined;
  file?: CreateTranscriptionFile$Outbound | Blob | undefined;
};

/** @internal */
export const CreateTranscriptionRequestBody$outboundSchema: z.ZodType<
  CreateTranscriptionRequestBody$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionRequestBody
> = z.object({
  model: z.string(),
  prompt: z.string().optional(),
  enableLogging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  responseFormat: CreateTranscriptionResponseFormat$outboundSchema.optional(),
  tagAudioEvents: z.boolean().default(true),
  numSpeakers: z.number().optional(),
  timestampsGranularity: TimestampsGranularity$outboundSchema.default("word"),
  temperature: z.number().optional(),
  language: z.string().optional(),
  timestampGranularities: z.array(TimestampGranularities$outboundSchema)
    .optional(),
  orq: z.lazy(() => CreateTranscriptionOrq$outboundSchema).optional(),
  file: z.lazy(() => CreateTranscriptionFile$outboundSchema).or(blobLikeSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    enableLogging: "enable_logging",
    responseFormat: "response_format",
    tagAudioEvents: "tag_audio_events",
    numSpeakers: "num_speakers",
    timestampsGranularity: "timestamps_granularity",
    timestampGranularities: "timestamp_granularities",
  });
});

export function createTranscriptionRequestBodyToJSON(
  createTranscriptionRequestBody: CreateTranscriptionRequestBody,
): string {
  return JSON.stringify(
    CreateTranscriptionRequestBody$outboundSchema.parse(
      createTranscriptionRequestBody,
    ),
  );
}

/** @internal */
export const Words$inboundSchema: z.ZodType<Words, z.ZodTypeDef, unknown> = z
  .object({
    word: z.string().optional(),
    start: z.number().optional(),
    end: z.number().optional(),
  });

export function wordsFromJSON(
  jsonString: string,
): SafeParseResult<Words, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Words$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Words' from JSON`,
  );
}

/** @internal */
export const Segments$inboundSchema: z.ZodType<
  Segments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avg_logprob: z.number(),
  compression_ratio: z.number(),
  no_speech_prob: z.number(),
}).transform((v) => {
  return remap$(v, {
    "avg_logprob": "avgLogprob",
    "compression_ratio": "compressionRatio",
    "no_speech_prob": "noSpeechProb",
  });
});

export function segmentsFromJSON(
  jsonString: string,
): SafeParseResult<Segments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Segments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Segments' from JSON`,
  );
}

/** @internal */
export const CreateTranscriptionResponseBody2$inboundSchema: z.ZodType<
  CreateTranscriptionResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => Words$inboundSchema)).optional(),
  segments: z.array(z.lazy(() => Segments$inboundSchema)).optional(),
});

export function createTranscriptionResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranscriptionResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranscriptionResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranscriptionResponseBody2' from JSON`,
  );
}

/** @internal */
export const CreateTranscriptionResponseBody1$inboundSchema: z.ZodType<
  CreateTranscriptionResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
});

export function createTranscriptionResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranscriptionResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranscriptionResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranscriptionResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateTranscriptionResponseBody$inboundSchema: z.ZodType<
  CreateTranscriptionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateTranscriptionResponseBody1$inboundSchema),
  z.lazy(() => CreateTranscriptionResponseBody2$inboundSchema),
  z.string(),
]);

export function createTranscriptionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateTranscriptionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranscriptionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranscriptionResponseBody' from JSON`,
  );
}
