/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest5Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest5Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5Status
>;

export const UpdateToolRequestBodyToolsRequest5Type = {
  Code: "code",
} as const;
export type UpdateToolRequestBodyToolsRequest5Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5Type
>;

export const UpdateToolRequestBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolRequestBodyLanguage = ClosedEnum<
  typeof UpdateToolRequestBodyLanguage
>;

export type UpdateToolRequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: UpdateToolRequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Updates an existing code execution tool configuration.
 */
export type UpdateCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest5Status | undefined;
  type: UpdateToolRequestBodyToolsRequest5Type;
  codeTool?: UpdateToolRequestBodyCodeTool | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest4Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest4Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4Status
>;

export const UpdateToolRequestBodyToolsRequest4Type = {
  Mcp: "mcp",
} as const;
export type UpdateToolRequestBodyToolsRequest4Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4Type
>;

export type RequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const UpdateToolRequestBodyToolsRequest4McpType = {
  Object: "object",
} as const;
export type UpdateToolRequestBodyToolsRequest4McpType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4McpType
>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type RequestBodyInputSchema = {
  type: UpdateToolRequestBodyToolsRequest4McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const RequestBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type RequestBodyConnectionType = ClosedEnum<
  typeof RequestBodyConnectionType
>;

export type RequestBodyMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: RequestBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: RequestBodyInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: RequestBodyConnectionType;
};

/**
 * Updates an existing MCP tool configuration.
 */
export type UpdateMCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest4Status | undefined;
  type: UpdateToolRequestBodyToolsRequest4Type;
  mcp?: RequestBodyMcp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequestStatus
>;

export const UpdateToolRequestBodyToolsRequestType = {
  Http: "http",
} as const;
export type UpdateToolRequestBodyToolsRequestType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequestType
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolRequestBodyMethod = ClosedEnum<
  typeof UpdateToolRequestBodyMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolRequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolRequestBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type UpdateToolRequestBodyDefaultValue = string | number | boolean;

export type UpdateToolRequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolRequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolRequestBodyArguments } | undefined;
};

/**
 * Updates an existing HTTP tool configuration.
 */
export type UpdateHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequestStatus | undefined;
  type: UpdateToolRequestBodyToolsRequestType;
  http?: UpdateToolRequestBodyHttp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsStatus
>;

export const UpdateToolRequestBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type UpdateToolRequestBodyToolsType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsType
>;

export type UpdateToolRequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * Updates an existing JSON Schema tool configuration.
 */
export type UpdateJSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsStatus | undefined;
  type: UpdateToolRequestBodyToolsType;
  jsonSchema?: UpdateToolRequestBodyJsonSchema | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyStatus = ClosedEnum<
  typeof UpdateToolRequestBodyStatus
>;

export const UpdateToolRequestBodyType = {
  Function: "function",
} as const;
export type UpdateToolRequestBodyType = ClosedEnum<
  typeof UpdateToolRequestBodyType
>;

export type UpdateToolRequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

/**
 * Updates an existing function tool configuration.
 */
export type UpdateFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyStatus | undefined;
  type: UpdateToolRequestBodyType;
  function?: UpdateToolRequestBodyFunction | undefined;
};

/**
 * The tool to update
 */
export type UpdateToolRequestBody =
  | UpdateFunctionTool
  | UpdateJSONSchemaTool
  | UpdateHTTPTool
  | UpdateMCPTool
  | UpdateCodeExecutionTool;

export type UpdateToolRequest = {
  toolId: string;
  /**
   * The tool to update
   */
  requestBody?:
    | UpdateFunctionTool
    | UpdateJSONSchemaTool
    | UpdateHTTPTool
    | UpdateMCPTool
    | UpdateCodeExecutionTool
    | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

export const UpdateToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type UpdateToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONType>;

export const UpdateToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolResponseBodyLanguage = ClosedEnum<
  typeof UpdateToolResponseBodyLanguage
>;

export type UpdateToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: UpdateToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type UpdateToolResponseBody5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?:
    | UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
    | undefined;
  versionHash?: string | undefined;
  type: UpdateToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: UpdateToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponse200Status
>;

export const UpdateToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type UpdateToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponse200Type
>;

export type UpdateToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type UpdateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type UpdateToolResponseBodyInputSchema = {
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const UpdateToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type UpdateToolResponseBodyConnectionType = ClosedEnum<
  typeof UpdateToolResponseBodyConnectionType
>;

export type UpdateToolResponseBodyMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: UpdateToolResponseBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: UpdateToolResponseBodyInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: UpdateToolResponseBodyConnectionType;
};

export type UpdateToolResponseBody4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: UpdateToolResponseBodyToolsResponse200Type;
  mcp: UpdateToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponseStatus
>;

export const UpdateToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type UpdateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolResponseBodyMethod = ClosedEnum<
  typeof UpdateToolResponseBodyMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolResponseBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type UpdateToolResponseBodyDefaultValue = string | number | boolean;

export type UpdateToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolResponseBodyArguments } | undefined;
};

export type UpdateToolResponseBody3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: UpdateToolResponseBodyToolsResponseType;
  http: UpdateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsStatus
>;

export const UpdateToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type UpdateToolResponseBodyToolsType = ClosedEnum<
  typeof UpdateToolResponseBodyToolsType
>;

export type UpdateToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

export type UpdateToolResponseBody2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: UpdateToolResponseBodyToolsType;
  jsonSchema: UpdateToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyStatus = ClosedEnum<
  typeof UpdateToolResponseBodyStatus
>;

export const UpdateToolResponseBodyType = {
  Function: "function",
} as const;
export type UpdateToolResponseBodyType = ClosedEnum<
  typeof UpdateToolResponseBodyType
>;

export type UpdateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type UpdateToolResponseBody1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: UpdateToolResponseBodyType;
  function: UpdateToolResponseBodyFunction;
};

/**
 * Successfully updated the tool.
 */
export type UpdateToolResponseBody =
  | UpdateToolResponseBody1
  | UpdateToolResponseBody2
  | UpdateToolResponseBody3
  | UpdateToolResponseBody4
  | UpdateToolResponseBody5;

/** @internal */
export const UpdateToolRequestBodyToolsRequest5Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest5Status);
/** @internal */
export const UpdateToolRequestBodyToolsRequest5Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Status> =
    UpdateToolRequestBodyToolsRequest5Status$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsRequest5Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest5Type,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequest5Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Type> =
    UpdateToolRequestBodyToolsRequest5Type$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyLanguage
> = z.nativeEnum(UpdateToolRequestBodyLanguage);
/** @internal */
export const UpdateToolRequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyLanguage
> = UpdateToolRequestBodyLanguage$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyCodeTool$inboundSchema: z.ZodType<
  UpdateToolRequestBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: UpdateToolRequestBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type UpdateToolRequestBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const UpdateToolRequestBodyCodeTool$outboundSchema: z.ZodType<
  UpdateToolRequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: UpdateToolRequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function updateToolRequestBodyCodeToolToJSON(
  updateToolRequestBodyCodeTool: UpdateToolRequestBodyCodeTool,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyCodeTool$outboundSchema.parse(
      updateToolRequestBodyCodeTool,
    ),
  );
}
export function updateToolRequestBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const UpdateCodeExecutionTool$inboundSchema: z.ZodType<
  UpdateCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest5Status$inboundSchema.default(
    "live",
  ),
  type: UpdateToolRequestBodyToolsRequest5Type$inboundSchema,
  code_tool: z.lazy(() => UpdateToolRequestBodyCodeTool$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type UpdateCodeExecutionTool$Outbound = {
  path?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: string;
  code_tool?: UpdateToolRequestBodyCodeTool$Outbound | undefined;
};

/** @internal */
export const UpdateCodeExecutionTool$outboundSchema: z.ZodType<
  UpdateCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  UpdateCodeExecutionTool
> = z.object({
  path: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest5Status$outboundSchema.default(
    "live",
  ),
  type: UpdateToolRequestBodyToolsRequest5Type$outboundSchema,
  codeTool: z.lazy(() => UpdateToolRequestBodyCodeTool$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function updateCodeExecutionToolToJSON(
  updateCodeExecutionTool: UpdateCodeExecutionTool,
): string {
  return JSON.stringify(
    UpdateCodeExecutionTool$outboundSchema.parse(updateCodeExecutionTool),
  );
}
export function updateCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4Status);
/** @internal */
export const UpdateToolRequestBodyToolsRequest4Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Status> =
    UpdateToolRequestBodyToolsRequest4Status$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsRequest4Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest4Type,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequest4Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Type> =
    UpdateToolRequestBodyToolsRequest4Type$inboundSchema;

/** @internal */
export const RequestBodyHeaders$inboundSchema: z.ZodType<
  RequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type RequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const RequestBodyHeaders$outboundSchema: z.ZodType<
  RequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  RequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function requestBodyHeadersToJSON(
  requestBodyHeaders: RequestBodyHeaders,
): string {
  return JSON.stringify(
    RequestBodyHeaders$outboundSchema.parse(requestBodyHeaders),
  );
}
export function requestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4McpType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4McpType> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4McpType);
/** @internal */
export const UpdateToolRequestBodyToolsRequest4McpType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4McpType> =
    UpdateToolRequestBodyToolsRequest4McpType$inboundSchema;

/** @internal */
export const RequestBodyInputSchema$inboundSchema: z.ZodType<
  RequestBodyInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateToolRequestBodyToolsRequest4McpType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type RequestBodyInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const RequestBodyInputSchema$outboundSchema: z.ZodType<
  RequestBodyInputSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyInputSchema
> = z.object({
  type: UpdateToolRequestBodyToolsRequest4McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function requestBodyInputSchemaToJSON(
  requestBodyInputSchema: RequestBodyInputSchema,
): string {
  return JSON.stringify(
    RequestBodyInputSchema$outboundSchema.parse(requestBodyInputSchema),
  );
}
export function requestBodyInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyInputSchema' from JSON`,
  );
}

/** @internal */
export const RequestBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyConnectionType
> = z.nativeEnum(RequestBodyConnectionType);
/** @internal */
export const RequestBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyConnectionType
> = RequestBodyConnectionType$inboundSchema;

/** @internal */
export const RequestBodyMcp$inboundSchema: z.ZodType<
  RequestBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_id: z.string(),
  tool_name: z.string(),
  server_url: z.string(),
  headers: z.record(z.lazy(() => RequestBodyHeaders$inboundSchema)).optional(),
  input_schema: z.lazy(() => RequestBodyInputSchema$inboundSchema),
  connection_type: RequestBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_id": "serverId",
    "tool_name": "toolName",
    "server_url": "serverUrl",
    "input_schema": "inputSchema",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type RequestBodyMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: RequestBodyHeaders$Outbound } | undefined;
  input_schema: RequestBodyInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const RequestBodyMcp$outboundSchema: z.ZodType<
  RequestBodyMcp$Outbound,
  z.ZodTypeDef,
  RequestBodyMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => RequestBodyHeaders$outboundSchema)).optional(),
  inputSchema: z.lazy(() => RequestBodyInputSchema$outboundSchema),
  connectionType: RequestBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

export function requestBodyMcpToJSON(requestBodyMcp: RequestBodyMcp): string {
  return JSON.stringify(RequestBodyMcp$outboundSchema.parse(requestBodyMcp));
}
export function requestBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyMcp' from JSON`,
  );
}

/** @internal */
export const UpdateMCPTool$inboundSchema: z.ZodType<
  UpdateMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest4Status$inboundSchema.default(
    "live",
  ),
  type: UpdateToolRequestBodyToolsRequest4Type$inboundSchema,
  mcp: z.lazy(() => RequestBodyMcp$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateMCPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: string;
  mcp?: RequestBodyMcp$Outbound | undefined;
};

/** @internal */
export const UpdateMCPTool$outboundSchema: z.ZodType<
  UpdateMCPTool$Outbound,
  z.ZodTypeDef,
  UpdateMCPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest4Status$outboundSchema.default(
    "live",
  ),
  type: UpdateToolRequestBodyToolsRequest4Type$outboundSchema,
  mcp: z.lazy(() => RequestBodyMcp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateMCPToolToJSON(updateMCPTool: UpdateMCPTool): string {
  return JSON.stringify(UpdateMCPTool$outboundSchema.parse(updateMCPTool));
}
export function updateMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMCPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequestStatus$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequestStatus);
/** @internal */
export const UpdateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestStatus> =
    UpdateToolRequestBodyToolsRequestStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestType> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequestType,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestType> =
    UpdateToolRequestBodyToolsRequestType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyMethod
> = z.nativeEnum(UpdateToolRequestBodyMethod);
/** @internal */
export const UpdateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyMethod
> = UpdateToolRequestBodyMethod$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyBlueprint$inboundSchema: z.ZodType<
  UpdateToolRequestBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: UpdateToolRequestBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolRequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolRequestBodyBlueprint$outboundSchema: z.ZodType<
  UpdateToolRequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: UpdateToolRequestBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolRequestBodyBlueprintToJSON(
  updateToolRequestBodyBlueprint: UpdateToolRequestBodyBlueprint,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyBlueprint$outboundSchema.parse(
      updateToolRequestBodyBlueprint,
    ),
  );
}
export function updateToolRequestBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest3Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest3Type,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest3Type> =
    UpdateToolRequestBodyToolsRequest3Type$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyDefaultValue$inboundSchema: z.ZodType<
  UpdateToolRequestBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateToolRequestBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateToolRequestBodyDefaultValue$outboundSchema: z.ZodType<
  UpdateToolRequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolRequestBodyDefaultValueToJSON(
  updateToolRequestBodyDefaultValue: UpdateToolRequestBodyDefaultValue,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyDefaultValue$outboundSchema.parse(
      updateToolRequestBodyDefaultValue,
    ),
  );
}
export function updateToolRequestBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyArguments$inboundSchema: z.ZodType<
  UpdateToolRequestBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateToolRequestBodyToolsRequest3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type UpdateToolRequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyArguments$outboundSchema: z.ZodType<
  UpdateToolRequestBodyArguments$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyArguments
> = z.object({
  type: UpdateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function updateToolRequestBodyArgumentsToJSON(
  updateToolRequestBodyArguments: UpdateToolRequestBodyArguments,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyArguments$outboundSchema.parse(
      updateToolRequestBodyArguments,
    ),
  );
}
export function updateToolRequestBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyArguments' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyHttp$inboundSchema: z.ZodType<
  UpdateToolRequestBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => UpdateToolRequestBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolRequestBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateToolRequestBodyHttp$Outbound = {
  blueprint: UpdateToolRequestBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: UpdateToolRequestBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const UpdateToolRequestBodyHttp$outboundSchema: z.ZodType<
  UpdateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => UpdateToolRequestBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolRequestBodyArguments$outboundSchema),
  ).optional(),
});

export function updateToolRequestBodyHttpToJSON(
  updateToolRequestBodyHttp: UpdateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyHttp$outboundSchema.parse(updateToolRequestBodyHttp),
  );
}
export function updateToolRequestBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyHttp' from JSON`,
  );
}

/** @internal */
export const UpdateHTTPTool$inboundSchema: z.ZodType<
  UpdateHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequestStatus$inboundSchema.default("live"),
  type: UpdateToolRequestBodyToolsRequestType$inboundSchema,
  http: z.lazy(() => UpdateToolRequestBodyHttp$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateHTTPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: string;
  http?: UpdateToolRequestBodyHttp$Outbound | undefined;
};

/** @internal */
export const UpdateHTTPTool$outboundSchema: z.ZodType<
  UpdateHTTPTool$Outbound,
  z.ZodTypeDef,
  UpdateHTTPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: UpdateToolRequestBodyToolsRequestType$outboundSchema,
  http: z.lazy(() => UpdateToolRequestBodyHttp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateHTTPToolToJSON(updateHTTPTool: UpdateHTTPTool): string {
  return JSON.stringify(UpdateHTTPTool$outboundSchema.parse(updateHTTPTool));
}
export function updateHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateHTTPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsStatus
> = z.nativeEnum(UpdateToolRequestBodyToolsStatus);
/** @internal */
export const UpdateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsStatus
> = UpdateToolRequestBodyToolsStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsType
> = z.nativeEnum(UpdateToolRequestBodyToolsType);
/** @internal */
export const UpdateToolRequestBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsType
> = UpdateToolRequestBodyToolsType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyJsonSchema$inboundSchema: z.ZodType<
  UpdateToolRequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});
/** @internal */
export type UpdateToolRequestBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict?: boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyJsonSchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});

export function updateToolRequestBodyJsonSchemaToJSON(
  updateToolRequestBodyJsonSchema: UpdateToolRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyJsonSchema$outboundSchema.parse(
      updateToolRequestBodyJsonSchema,
    ),
  );
}
export function updateToolRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateJSONSchemaTool$inboundSchema: z.ZodType<
  UpdateJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsStatus$inboundSchema.default("live"),
  type: UpdateToolRequestBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => UpdateToolRequestBodyJsonSchema$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type UpdateJSONSchemaTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: string;
  json_schema?: UpdateToolRequestBodyJsonSchema$Outbound | undefined;
};

/** @internal */
export const UpdateJSONSchemaTool$outboundSchema: z.ZodType<
  UpdateJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  UpdateJSONSchemaTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: UpdateToolRequestBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => UpdateToolRequestBodyJsonSchema$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function updateJSONSchemaToolToJSON(
  updateJSONSchemaTool: UpdateJSONSchemaTool,
): string {
  return JSON.stringify(
    UpdateJSONSchemaTool$outboundSchema.parse(updateJSONSchemaTool),
  );
}
export function updateJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyStatus
> = z.nativeEnum(UpdateToolRequestBodyStatus);
/** @internal */
export const UpdateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyStatus
> = UpdateToolRequestBodyStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyType
> = z.nativeEnum(UpdateToolRequestBodyType);
/** @internal */
export const UpdateToolRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyType
> = UpdateToolRequestBodyType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyFunction$inboundSchema: z.ZodType<
  UpdateToolRequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolRequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolRequestBodyFunction$outboundSchema: z.ZodType<
  UpdateToolRequestBodyFunction$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function updateToolRequestBodyFunctionToJSON(
  updateToolRequestBodyFunction: UpdateToolRequestBodyFunction,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyFunction$outboundSchema.parse(
      updateToolRequestBodyFunction,
    ),
  );
}
export function updateToolRequestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const UpdateFunctionTool$inboundSchema: z.ZodType<
  UpdateFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyStatus$inboundSchema.default("live"),
  type: UpdateToolRequestBodyType$inboundSchema,
  function: z.lazy(() => UpdateToolRequestBodyFunction$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateFunctionTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: string;
  function?: UpdateToolRequestBodyFunction$Outbound | undefined;
};

/** @internal */
export const UpdateFunctionTool$outboundSchema: z.ZodType<
  UpdateFunctionTool$Outbound,
  z.ZodTypeDef,
  UpdateFunctionTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyStatus$outboundSchema.default("live"),
  type: UpdateToolRequestBodyType$outboundSchema,
  function: z.lazy(() => UpdateToolRequestBodyFunction$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateFunctionToolToJSON(
  updateFunctionTool: UpdateFunctionTool,
): string {
  return JSON.stringify(
    UpdateFunctionTool$outboundSchema.parse(updateFunctionTool),
  );
}
export function updateFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFunctionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBody$inboundSchema: z.ZodType<
  UpdateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateFunctionTool$inboundSchema),
  z.lazy(() => UpdateJSONSchemaTool$inboundSchema),
  z.lazy(() => UpdateHTTPTool$inboundSchema),
  z.lazy(() => UpdateMCPTool$inboundSchema),
  z.lazy(() => UpdateCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type UpdateToolRequestBody$Outbound =
  | UpdateFunctionTool$Outbound
  | UpdateJSONSchemaTool$Outbound
  | UpdateHTTPTool$Outbound
  | UpdateMCPTool$Outbound
  | UpdateCodeExecutionTool$Outbound;

/** @internal */
export const UpdateToolRequestBody$outboundSchema: z.ZodType<
  UpdateToolRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBody
> = z.union([
  z.lazy(() => UpdateFunctionTool$outboundSchema),
  z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
  z.lazy(() => UpdateHTTPTool$outboundSchema),
  z.lazy(() => UpdateMCPTool$outboundSchema),
  z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
]);

export function updateToolRequestBodyToJSON(
  updateToolRequestBody: UpdateToolRequestBody,
): string {
  return JSON.stringify(
    UpdateToolRequestBody$outboundSchema.parse(updateToolRequestBody),
  );
}
export function updateToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequest$inboundSchema: z.ZodType<
  UpdateToolRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tool_id: z.string(),
  RequestBody: z.union([
    z.lazy(() => UpdateFunctionTool$inboundSchema),
    z.lazy(() => UpdateJSONSchemaTool$inboundSchema),
    z.lazy(() => UpdateHTTPTool$inboundSchema),
    z.lazy(() => UpdateMCPTool$inboundSchema),
    z.lazy(() => UpdateCodeExecutionTool$inboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateToolRequest$Outbound = {
  tool_id: string;
  RequestBody?:
    | UpdateFunctionTool$Outbound
    | UpdateJSONSchemaTool$Outbound
    | UpdateHTTPTool$Outbound
    | UpdateMCPTool$Outbound
    | UpdateCodeExecutionTool$Outbound
    | undefined;
};

/** @internal */
export const UpdateToolRequest$outboundSchema: z.ZodType<
  UpdateToolRequest$Outbound,
  z.ZodTypeDef,
  UpdateToolRequest
> = z.object({
  toolId: z.string(),
  requestBody: z.union([
    z.lazy(() => UpdateFunctionTool$outboundSchema),
    z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
    z.lazy(() => UpdateHTTPTool$outboundSchema),
    z.lazy(() => UpdateMCPTool$outboundSchema),
    z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requestBody: "RequestBody",
  });
});

export function updateToolRequestToJSON(
  updateToolRequest: UpdateToolRequest,
): string {
  return JSON.stringify(
    UpdateToolRequest$outboundSchema.parse(updateToolRequest),
  );
}
export function updateToolRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequest' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJSONType);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONType
  > = UpdateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyLanguage
> = z.nativeEnum(UpdateToolResponseBodyLanguage);
/** @internal */
export const UpdateToolResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyLanguage
> = UpdateToolResponseBodyLanguage$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: UpdateToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type UpdateToolResponseBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const UpdateToolResponseBodyCodeTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: UpdateToolResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function updateToolResponseBodyCodeToolToJSON(
  updateToolResponseBodyCodeTool: UpdateToolResponseBodyCodeTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyCodeTool$outboundSchema.parse(
      updateToolResponseBodyCodeTool,
    ),
  );
}
export function updateToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody5$inboundSchema: z.ZodType<
  UpdateToolResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KAJRW2V48AHXVGXT5ZH6CBYJ"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type: UpdateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => UpdateToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type UpdateToolResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: UpdateToolResponseBodyCodeTool$Outbound;
};

/** @internal */
export const UpdateToolResponseBody5$outboundSchema: z.ZodType<
  UpdateToolResponseBody5$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody5
> = z.object({
  id: z.string().default("01KAJRW2V48AHXVGXT5ZH6CBYJ"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema
      .default("live"),
  versionHash: z.string().optional(),
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => UpdateToolResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function updateToolResponseBody5ToJSON(
  updateToolResponseBody5: UpdateToolResponseBody5,
): string {
  return JSON.stringify(
    UpdateToolResponseBody5$outboundSchema.parse(updateToolResponseBody5),
  );
}
export function updateToolResponseBody5FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody5' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponse200Status);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Status> =
    UpdateToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponse200Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Type> =
    UpdateToolResponseBodyToolsResponse200Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type UpdateToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  UpdateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolResponseBodyHeadersToJSON(
  updateToolResponseBodyHeaders: UpdateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyHeaders$outboundSchema.parse(
      updateToolResponseBodyHeaders,
    ),
  );
}
export function updateToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson4Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyInputSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type UpdateToolResponseBodyInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const UpdateToolResponseBodyInputSchema$outboundSchema: z.ZodType<
  UpdateToolResponseBodyInputSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyInputSchema
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function updateToolResponseBodyInputSchemaToJSON(
  updateToolResponseBodyInputSchema: UpdateToolResponseBodyInputSchema,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyInputSchema$outboundSchema.parse(
      updateToolResponseBodyInputSchema,
    ),
  );
}
export function updateToolResponseBodyInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyInputSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyConnectionType> = z.nativeEnum(
    UpdateToolResponseBodyConnectionType,
  );
/** @internal */
export const UpdateToolResponseBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyConnectionType> =
    UpdateToolResponseBodyConnectionType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyMcp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_id: z.string(),
  tool_name: z.string(),
  server_url: z.string(),
  headers: z.record(z.lazy(() => UpdateToolResponseBodyHeaders$inboundSchema))
    .optional(),
  input_schema: z.lazy(() => UpdateToolResponseBodyInputSchema$inboundSchema),
  connection_type: UpdateToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_id": "serverId",
    "tool_name": "toolName",
    "server_url": "serverUrl",
    "input_schema": "inputSchema",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type UpdateToolResponseBodyMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: UpdateToolResponseBodyHeaders$Outbound } | undefined;
  input_schema: UpdateToolResponseBodyInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const UpdateToolResponseBodyMcp$outboundSchema: z.ZodType<
  UpdateToolResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => UpdateToolResponseBodyHeaders$outboundSchema))
    .optional(),
  inputSchema: z.lazy(() => UpdateToolResponseBodyInputSchema$outboundSchema),
  connectionType: UpdateToolResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

export function updateToolResponseBodyMcpToJSON(
  updateToolResponseBodyMcp: UpdateToolResponseBodyMcp,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyMcp$outboundSchema.parse(updateToolResponseBodyMcp),
  );
}
export function updateToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody4$inboundSchema: z.ZodType<
  UpdateToolResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KAJRW2V2K5QSTJAJTT3HEHXK"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: UpdateToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => UpdateToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: UpdateToolResponseBodyMcp$Outbound;
};

/** @internal */
export const UpdateToolResponseBody4$outboundSchema: z.ZodType<
  UpdateToolResponseBody4$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody4
> = z.object({
  id: z.string().default("01KAJRW2V2K5QSTJAJTT3HEHXK"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: UpdateToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => UpdateToolResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBody4ToJSON(
  updateToolResponseBody4: UpdateToolResponseBody4,
): string {
  return JSON.stringify(
    UpdateToolResponseBody4$outboundSchema.parse(updateToolResponseBody4),
  );
}
export function updateToolResponseBody4FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody4' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponseStatus);
/** @internal */
export const UpdateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseStatus> =
    UpdateToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseType> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponseType);
/** @internal */
export const UpdateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseType> =
    UpdateToolResponseBodyToolsResponseType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyMethod
> = z.nativeEnum(UpdateToolResponseBodyMethod);
/** @internal */
export const UpdateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyMethod
> = UpdateToolResponseBodyMethod$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  UpdateToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: UpdateToolResponseBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolResponseBodyBlueprint$outboundSchema: z.ZodType<
  UpdateToolResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: UpdateToolResponseBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolResponseBodyBlueprintToJSON(
  updateToolResponseBodyBlueprint: UpdateToolResponseBodyBlueprint,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyBlueprint$outboundSchema.parse(
      updateToolResponseBodyBlueprint,
    ),
  );
}
export function updateToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson3Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  UpdateToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateToolResponseBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateToolResponseBodyDefaultValue$outboundSchema: z.ZodType<
  UpdateToolResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolResponseBodyDefaultValueToJSON(
  updateToolResponseBodyDefaultValue: UpdateToolResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyDefaultValue$outboundSchema.parse(
      updateToolResponseBodyDefaultValue,
    ),
  );
}
export function updateToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyArguments$inboundSchema: z.ZodType<
  UpdateToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type UpdateToolResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const UpdateToolResponseBodyArguments$outboundSchema: z.ZodType<
  UpdateToolResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyArguments
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function updateToolResponseBodyArgumentsToJSON(
  updateToolResponseBodyArguments: UpdateToolResponseBodyArguments,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyArguments$outboundSchema.parse(
      updateToolResponseBodyArguments,
    ),
  );
}
export function updateToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyHttp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => UpdateToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolResponseBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateToolResponseBodyHttp$Outbound = {
  blueprint: UpdateToolResponseBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: UpdateToolResponseBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const UpdateToolResponseBodyHttp$outboundSchema: z.ZodType<
  UpdateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => UpdateToolResponseBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolResponseBodyArguments$outboundSchema),
  ).optional(),
});

export function updateToolResponseBodyHttpToJSON(
  updateToolResponseBodyHttp: UpdateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyHttp$outboundSchema.parse(updateToolResponseBodyHttp),
  );
}
export function updateToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody3$inboundSchema: z.ZodType<
  UpdateToolResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KAJRW2V1CM8XV3EEN7CJSQB8"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: UpdateToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => UpdateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: UpdateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const UpdateToolResponseBody3$outboundSchema: z.ZodType<
  UpdateToolResponseBody3$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody3
> = z.object({
  id: z.string().default("01KAJRW2V1CM8XV3EEN7CJSQB8"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: UpdateToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => UpdateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBody3ToJSON(
  updateToolResponseBody3: UpdateToolResponseBody3,
): string {
  return JSON.stringify(
    UpdateToolResponseBody3$outboundSchema.parse(updateToolResponseBody3),
  );
}
export function updateToolResponseBody3FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody3' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsStatus
> = z.nativeEnum(UpdateToolResponseBodyToolsStatus);
/** @internal */
export const UpdateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsStatus
> = UpdateToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsType
> = z.nativeEnum(UpdateToolResponseBodyToolsType);
/** @internal */
export const UpdateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsType
> = UpdateToolResponseBodyToolsType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});
/** @internal */
export type UpdateToolResponseBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict?: boolean | undefined;
};

/** @internal */
export const UpdateToolResponseBodyJsonSchema$outboundSchema: z.ZodType<
  UpdateToolResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});

export function updateToolResponseBodyJsonSchemaToJSON(
  updateToolResponseBodyJsonSchema: UpdateToolResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyJsonSchema$outboundSchema.parse(
      updateToolResponseBodyJsonSchema,
    ),
  );
}
export function updateToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody2$inboundSchema: z.ZodType<
  UpdateToolResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KAJRW2V06MMGRD5ZWQGS2GH9"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: UpdateToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => UpdateToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type UpdateToolResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: UpdateToolResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const UpdateToolResponseBody2$outboundSchema: z.ZodType<
  UpdateToolResponseBody2$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody2
> = z.object({
  id: z.string().default("01KAJRW2V06MMGRD5ZWQGS2GH9"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: UpdateToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => UpdateToolResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function updateToolResponseBody2ToJSON(
  updateToolResponseBody2: UpdateToolResponseBody2,
): string {
  return JSON.stringify(
    UpdateToolResponseBody2$outboundSchema.parse(updateToolResponseBody2),
  );
}
export function updateToolResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody2' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyStatus
> = z.nativeEnum(UpdateToolResponseBodyStatus);
/** @internal */
export const UpdateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyStatus
> = UpdateToolResponseBodyStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyType
> = z.nativeEnum(UpdateToolResponseBodyType);
/** @internal */
export const UpdateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyType
> = UpdateToolResponseBodyType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyFunction$inboundSchema: z.ZodType<
  UpdateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolResponseBodyFunction$outboundSchema: z.ZodType<
  UpdateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function updateToolResponseBodyFunctionToJSON(
  updateToolResponseBodyFunction: UpdateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyFunction$outboundSchema.parse(
      updateToolResponseBodyFunction,
    ),
  );
}
export function updateToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody1$inboundSchema: z.ZodType<
  UpdateToolResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01KAJRW2TY0PHQ14MHX90H34WJ"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: UpdateToolResponseBodyType$inboundSchema,
  function: z.lazy(() => UpdateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: UpdateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const UpdateToolResponseBody1$outboundSchema: z.ZodType<
  UpdateToolResponseBody1$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody1
> = z.object({
  id: z.string().default("01KAJRW2TY0PHQ14MHX90H34WJ"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: UpdateToolResponseBodyType$outboundSchema,
  function: z.lazy(() => UpdateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBody1ToJSON(
  updateToolResponseBody1: UpdateToolResponseBody1,
): string {
  return JSON.stringify(
    UpdateToolResponseBody1$outboundSchema.parse(updateToolResponseBody1),
  );
}
export function updateToolResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody1' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody$inboundSchema: z.ZodType<
  UpdateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateToolResponseBody1$inboundSchema),
  z.lazy(() => UpdateToolResponseBody2$inboundSchema),
  z.lazy(() => UpdateToolResponseBody3$inboundSchema),
  z.lazy(() => UpdateToolResponseBody4$inboundSchema),
  z.lazy(() => UpdateToolResponseBody5$inboundSchema),
]);
/** @internal */
export type UpdateToolResponseBody$Outbound =
  | UpdateToolResponseBody1$Outbound
  | UpdateToolResponseBody2$Outbound
  | UpdateToolResponseBody3$Outbound
  | UpdateToolResponseBody4$Outbound
  | UpdateToolResponseBody5$Outbound;

/** @internal */
export const UpdateToolResponseBody$outboundSchema: z.ZodType<
  UpdateToolResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody
> = z.union([
  z.lazy(() => UpdateToolResponseBody1$outboundSchema),
  z.lazy(() => UpdateToolResponseBody2$outboundSchema),
  z.lazy(() => UpdateToolResponseBody3$outboundSchema),
  z.lazy(() => UpdateToolResponseBody4$outboundSchema),
  z.lazy(() => UpdateToolResponseBody5$outboundSchema),
]);

export function updateToolResponseBodyToJSON(
  updateToolResponseBody: UpdateToolResponseBody,
): string {
  return JSON.stringify(
    UpdateToolResponseBody$outboundSchema.parse(updateToolResponseBody),
  );
}
export function updateToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody' from JSON`,
  );
}
