/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored
 */
export const Status = {
  Inactive: "inactive",
  ApprovalRequired: "approval_required",
  InProgress: "in_progress",
  Errored: "errored",
} as const;
/**
 * Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored
 */
export type Status = ClosedEnum<typeof Status>;

export type ListAgentTasksRequest = {
  /**
   * The unique key of the agent
   */
  agentKey: string;
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
  /**
   * Comma-separated list of task statuses to filter by. Available values: inactive, approval_required, in_progress, errored
   */
  status?: Status | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentTasksVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentTasksVoice = ClosedEnum<typeof ListAgentTasksVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentTasksFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentTasksFormat = ClosedEnum<typeof ListAgentTasksFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentTasksAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentTasksVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentTasksFormat;
};

export const ListAgentTasksResponseFormatAgentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type ListAgentTasksResponseFormatAgentsResponseType = ClosedEnum<
  typeof ListAgentTasksResponseFormatAgentsResponseType
>;

export type ListAgentTasksResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type ListAgentTasksResponseFormat3 = {
  type: ListAgentTasksResponseFormatAgentsResponseType;
  jsonSchema: ListAgentTasksResponseFormatJsonSchema;
};

export const ListAgentTasksResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type ListAgentTasksResponseFormatAgentsType = ClosedEnum<
  typeof ListAgentTasksResponseFormatAgentsType
>;

export type ListAgentTasksResponseFormat2 = {
  type: ListAgentTasksResponseFormatAgentsType;
};

export const ListAgentTasksResponseFormatType = {
  Text: "text",
} as const;
export type ListAgentTasksResponseFormatType = ClosedEnum<
  typeof ListAgentTasksResponseFormatType
>;

export type ListAgentTasksResponseFormat1 = {
  type: ListAgentTasksResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentTasksResponseFormat =
  | ListAgentTasksResponseFormat3
  | ListAgentTasksResponseFormat1
  | ListAgentTasksResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentTasksStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentTasksStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ListAgentTasksType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ListAgentTasksType = ClosedEnum<typeof ListAgentTasksType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const ListAgentTasksThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type ListAgentTasksThinkingLevel = ClosedEnum<
  typeof ListAgentTasksThinkingLevel
>;

export type ListAgentTasksThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ListAgentTasksType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: ListAgentTasksThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentTasksToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentTasksToolChoiceType = ClosedEnum<
  typeof ListAgentTasksToolChoiceType
>;

export type ListAgentTasksToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ListAgentTasksToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentTasksToolChoiceType | undefined;
  function: ListAgentTasksToolChoiceFunction;
};

export const ListAgentTasksToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentTasksToolChoice1 = ClosedEnum<
  typeof ListAgentTasksToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentTasksToolChoice =
  | ListAgentTasksToolChoice2
  | ListAgentTasksToolChoice1;

export const ListAgentTasksModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentTasksModalities = ClosedEnum<
  typeof ListAgentTasksModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type ListAgentTasksWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
 */
export type ListAgentTasksParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentTasksAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentTasksResponseFormat3
    | ListAgentTasksResponseFormat1
    | ListAgentTasksResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListAgentTasksStreamOptions | null | undefined;
  thinking?: ListAgentTasksThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | ListAgentTasksToolChoice2
    | ListAgentTasksToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListAgentTasksModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: ListAgentTasksWebSearchOptions | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListAgentTasksFallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListAgentTasksFallbackModelsVoice = ClosedEnum<
  typeof ListAgentTasksFallbackModelsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListAgentTasksFallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListAgentTasksFallbackModelsFormat = ClosedEnum<
  typeof ListAgentTasksFallbackModelsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListAgentTasksFallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListAgentTasksFallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListAgentTasksFallbackModelsFormat;
};

export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  >;

export type ListAgentTasksResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type ListAgentTasksResponseFormatAgents3 = {
  type:
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType;
  jsonSchema: ListAgentTasksResponseFormatAgentsJsonSchema;
};

export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType =
  {
    JsonObject: "json_object",
  } as const;
export type ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType
  >;

export type ListAgentTasksResponseFormatAgents2 = {
  type: ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType;
};

export const ListAgentTasksResponseFormatAgentsResponse200Type = {
  Text: "text",
} as const;
export type ListAgentTasksResponseFormatAgentsResponse200Type = ClosedEnum<
  typeof ListAgentTasksResponseFormatAgentsResponse200Type
>;

export type ListAgentTasksResponseFormatAgents1 = {
  type: ListAgentTasksResponseFormatAgentsResponse200Type;
};

/**
 * An object specifying the format that the model must output
 */
export type ListAgentTasksFallbackModelsResponseFormat =
  | ListAgentTasksResponseFormatAgents3
  | ListAgentTasksResponseFormatAgents1
  | ListAgentTasksResponseFormatAgents2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListAgentTasksFallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListAgentTasksFallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ListAgentTasksFallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ListAgentTasksFallbackModelsType = ClosedEnum<
  typeof ListAgentTasksFallbackModelsType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const ListAgentTasksFallbackModelsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type ListAgentTasksFallbackModelsThinkingLevel = ClosedEnum<
  typeof ListAgentTasksFallbackModelsThinkingLevel
>;

export type ListAgentTasksFallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ListAgentTasksFallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: ListAgentTasksFallbackModelsThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListAgentTasksToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListAgentTasksToolChoiceAgentsType = ClosedEnum<
  typeof ListAgentTasksToolChoiceAgentsType
>;

export type ListAgentTasksToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ListAgentTasksToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListAgentTasksToolChoiceAgentsType | undefined;
  function: ListAgentTasksToolChoiceAgentsFunction;
};

export const ListAgentTasksToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListAgentTasksToolChoiceAgents1 = ClosedEnum<
  typeof ListAgentTasksToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListAgentTasksFallbackModelsToolChoice =
  | ListAgentTasksToolChoiceAgents2
  | ListAgentTasksToolChoiceAgents1;

export const ListAgentTasksFallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListAgentTasksFallbackModelsModalities = ClosedEnum<
  typeof ListAgentTasksFallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type ListAgentTasksFallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type ListAgentTasksFallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListAgentTasksFallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListAgentTasksResponseFormatAgents3
    | ListAgentTasksResponseFormatAgents1
    | ListAgentTasksResponseFormatAgents2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListAgentTasksFallbackModelsStreamOptions | null | undefined;
  thinking?: ListAgentTasksFallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | ListAgentTasksToolChoiceAgents2
    | ListAgentTasksToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListAgentTasksFallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: ListAgentTasksFallbackModelsWebSearchOptions | undefined;
};

export type ListAgentTasksFallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: ListAgentTasksFallbackModelsParameters | undefined;
};

export type ListAgentTasksFallbackModels =
  | ListAgentTasksFallbackModels2
  | string;

export type ListAgentTasksModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
   */
  parameters?: ListAgentTasksParameters | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<ListAgentTasksFallbackModels2 | string>
    | null
    | undefined;
};

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ListAgentTasksToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ListAgentTasksToolApprovalRequired = ClosedEnum<
  typeof ListAgentTasksToolApprovalRequired
>;

export type ListAgentTasksConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type ListAgentTasksTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<ListAgentTasksConditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type ListAgentTasksSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ListAgentTasksToolApprovalRequired | undefined;
  tools?: Array<ListAgentTasksTools> | undefined;
};

export type AgentManifestSnapshot = {
  id: string;
  key: string;
  role: string;
  description: string;
  instructions: string;
  systemPrompt?: string | undefined;
  model: ListAgentTasksModel;
  settings?: ListAgentTasksSettings | undefined;
  projectId?: string | undefined;
};

/**
 * Memory configuration for this execution
 */
export type ListAgentTasksMemory = {
  /**
   * Entity identifier used for memory store isolation (user/session/conversation)
   */
  entityId: string;
};

export type ListAgentTasksState = {
  waitingForApproval?: boolean | undefined;
  inactive?: boolean | undefined;
  error?: string | undefined;
  iteration?: number | undefined;
  accumulatedExecutionTime?: number | undefined;
  variables?: { [k: string]: any } | undefined;
};

export type ListAgentTasksMetrics = {
  inputCost?: number | undefined;
  outputCost?: number | undefined;
  totalCost?: number | undefined;
  promptTokens?: number | undefined;
  completionTokens?: number | undefined;
  totalTokens?: number | undefined;
};

export type Tasks = {
  id: string;
  agentManifestSnapshot: AgentManifestSnapshot;
  createdById?: string | undefined;
  updatedById?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  name?: string | undefined;
  workspaceId: string;
  /**
   * Memory configuration for this execution
   */
  memory?: ListAgentTasksMemory | undefined;
  /**
   * Execution-level metadata as key-value pairs
   */
  metadata?: { [k: string]: any } | undefined;
  state: ListAgentTasksState;
  metrics: ListAgentTasksMetrics;
};

/**
 * Agent tasks retrieved
 */
export type ListAgentTasksResponseBody = {
  tasks: Array<Tasks>;
  overallTotal: number;
};

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);
/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/** @internal */
export const ListAgentTasksRequest$inboundSchema: z.ZodType<
  ListAgentTasksRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  limit: z.number().default(10),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
  status: Status$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type ListAgentTasksRequest$Outbound = {
  agent_key: string;
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
  status?: string | undefined;
};

/** @internal */
export const ListAgentTasksRequest$outboundSchema: z.ZodType<
  ListAgentTasksRequest$Outbound,
  z.ZodTypeDef,
  ListAgentTasksRequest
> = z.object({
  agentKey: z.string(),
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
  status: Status$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listAgentTasksRequestToJSON(
  listAgentTasksRequest: ListAgentTasksRequest,
): string {
  return JSON.stringify(
    ListAgentTasksRequest$outboundSchema.parse(listAgentTasksRequest),
  );
}
export function listAgentTasksRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksRequest' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksVoice
> = z.nativeEnum(ListAgentTasksVoice);
/** @internal */
export const ListAgentTasksVoice$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksVoice
> = ListAgentTasksVoice$inboundSchema;

/** @internal */
export const ListAgentTasksFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFormat
> = z.nativeEnum(ListAgentTasksFormat);
/** @internal */
export const ListAgentTasksFormat$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFormat
> = ListAgentTasksFormat$inboundSchema;

/** @internal */
export const ListAgentTasksAudio$inboundSchema: z.ZodType<
  ListAgentTasksAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentTasksVoice$inboundSchema,
  format: ListAgentTasksFormat$inboundSchema,
});
/** @internal */
export type ListAgentTasksAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ListAgentTasksAudio$outboundSchema: z.ZodType<
  ListAgentTasksAudio$Outbound,
  z.ZodTypeDef,
  ListAgentTasksAudio
> = z.object({
  voice: ListAgentTasksVoice$outboundSchema,
  format: ListAgentTasksFormat$outboundSchema,
});

export function listAgentTasksAudioToJSON(
  listAgentTasksAudio: ListAgentTasksAudio,
): string {
  return JSON.stringify(
    ListAgentTasksAudio$outboundSchema.parse(listAgentTasksAudio),
  );
}
export function listAgentTasksAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsResponseType> = z
    .nativeEnum(ListAgentTasksResponseFormatAgentsResponseType);
/** @internal */
export const ListAgentTasksResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsResponseType> =
    ListAgentTasksResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type ListAgentTasksResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function listAgentTasksResponseFormatJsonSchemaToJSON(
  listAgentTasksResponseFormatJsonSchema:
    ListAgentTasksResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormatJsonSchema$outboundSchema.parse(
      listAgentTasksResponseFormatJsonSchema,
    ),
  );
}
export function listAgentTasksResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormat3$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksResponseFormatAgentsResponseType$inboundSchema,
  json_schema: z.lazy(() =>
    ListAgentTasksResponseFormatJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ListAgentTasksResponseFormat3$Outbound = {
  type: string;
  json_schema: ListAgentTasksResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const ListAgentTasksResponseFormat3$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormat3$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormat3
> = z.object({
  type: ListAgentTasksResponseFormatAgentsResponseType$outboundSchema,
  jsonSchema: z.lazy(() =>
    ListAgentTasksResponseFormatJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function listAgentTasksResponseFormat3ToJSON(
  listAgentTasksResponseFormat3: ListAgentTasksResponseFormat3,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormat3$outboundSchema.parse(
      listAgentTasksResponseFormat3,
    ),
  );
}
export function listAgentTasksResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormat3' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsType> = z.nativeEnum(
    ListAgentTasksResponseFormatAgentsType,
  );
/** @internal */
export const ListAgentTasksResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsType> =
    ListAgentTasksResponseFormatAgentsType$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormat2$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type ListAgentTasksResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentTasksResponseFormat2$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormat2$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormat2
> = z.object({
  type: ListAgentTasksResponseFormatAgentsType$outboundSchema,
});

export function listAgentTasksResponseFormat2ToJSON(
  listAgentTasksResponseFormat2: ListAgentTasksResponseFormat2,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormat2$outboundSchema.parse(
      listAgentTasksResponseFormat2,
    ),
  );
}
export function listAgentTasksResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormat2' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksResponseFormatType
> = z.nativeEnum(ListAgentTasksResponseFormatType);
/** @internal */
export const ListAgentTasksResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksResponseFormatType
> = ListAgentTasksResponseFormatType$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormat1$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksResponseFormatType$inboundSchema,
});
/** @internal */
export type ListAgentTasksResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentTasksResponseFormat1$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormat1$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormat1
> = z.object({
  type: ListAgentTasksResponseFormatType$outboundSchema,
});

export function listAgentTasksResponseFormat1ToJSON(
  listAgentTasksResponseFormat1: ListAgentTasksResponseFormat1,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormat1$outboundSchema.parse(
      listAgentTasksResponseFormat1,
    ),
  );
}
export function listAgentTasksResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormat1' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormat$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentTasksResponseFormat3$inboundSchema),
  z.lazy(() => ListAgentTasksResponseFormat1$inboundSchema),
  z.lazy(() => ListAgentTasksResponseFormat2$inboundSchema),
]);
/** @internal */
export type ListAgentTasksResponseFormat$Outbound =
  | ListAgentTasksResponseFormat3$Outbound
  | ListAgentTasksResponseFormat1$Outbound
  | ListAgentTasksResponseFormat2$Outbound;

/** @internal */
export const ListAgentTasksResponseFormat$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormat$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormat
> = z.union([
  z.lazy(() => ListAgentTasksResponseFormat3$outboundSchema),
  z.lazy(() => ListAgentTasksResponseFormat1$outboundSchema),
  z.lazy(() => ListAgentTasksResponseFormat2$outboundSchema),
]);

export function listAgentTasksResponseFormatToJSON(
  listAgentTasksResponseFormat: ListAgentTasksResponseFormat,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormat$outboundSchema.parse(
      listAgentTasksResponseFormat,
    ),
  );
}
export function listAgentTasksResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksStop$inboundSchema: z.ZodType<
  ListAgentTasksStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type ListAgentTasksStop$Outbound = string | Array<string>;

/** @internal */
export const ListAgentTasksStop$outboundSchema: z.ZodType<
  ListAgentTasksStop$Outbound,
  z.ZodTypeDef,
  ListAgentTasksStop
> = z.union([z.string(), z.array(z.string())]);

export function listAgentTasksStopToJSON(
  listAgentTasksStop: ListAgentTasksStop,
): string {
  return JSON.stringify(
    ListAgentTasksStop$outboundSchema.parse(listAgentTasksStop),
  );
}
export function listAgentTasksStopFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksStop' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksStreamOptions$inboundSchema: z.ZodType<
  ListAgentTasksStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type ListAgentTasksStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksStreamOptions$outboundSchema: z.ZodType<
  ListAgentTasksStreamOptions$Outbound,
  z.ZodTypeDef,
  ListAgentTasksStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function listAgentTasksStreamOptionsToJSON(
  listAgentTasksStreamOptions: ListAgentTasksStreamOptions,
): string {
  return JSON.stringify(
    ListAgentTasksStreamOptions$outboundSchema.parse(
      listAgentTasksStreamOptions,
    ),
  );
}
export function listAgentTasksStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksType
> = z.nativeEnum(ListAgentTasksType);
/** @internal */
export const ListAgentTasksType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksType
> = ListAgentTasksType$inboundSchema;

/** @internal */
export const ListAgentTasksThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksThinkingLevel
> = z.nativeEnum(ListAgentTasksThinkingLevel);
/** @internal */
export const ListAgentTasksThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksThinkingLevel
> = ListAgentTasksThinkingLevel$inboundSchema;

/** @internal */
export const ListAgentTasksThinking$inboundSchema: z.ZodType<
  ListAgentTasksThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: ListAgentTasksThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type ListAgentTasksThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const ListAgentTasksThinking$outboundSchema: z.ZodType<
  ListAgentTasksThinking$Outbound,
  z.ZodTypeDef,
  ListAgentTasksThinking
> = z.object({
  type: ListAgentTasksType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: ListAgentTasksThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function listAgentTasksThinkingToJSON(
  listAgentTasksThinking: ListAgentTasksThinking,
): string {
  return JSON.stringify(
    ListAgentTasksThinking$outboundSchema.parse(listAgentTasksThinking),
  );
}
export function listAgentTasksThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceType
> = z.nativeEnum(ListAgentTasksToolChoiceType);
/** @internal */
export const ListAgentTasksToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceType
> = ListAgentTasksToolChoiceType$inboundSchema;

/** @internal */
export const ListAgentTasksToolChoiceFunction$inboundSchema: z.ZodType<
  ListAgentTasksToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ListAgentTasksToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ListAgentTasksToolChoiceFunction$outboundSchema: z.ZodType<
  ListAgentTasksToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ListAgentTasksToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function listAgentTasksToolChoiceFunctionToJSON(
  listAgentTasksToolChoiceFunction: ListAgentTasksToolChoiceFunction,
): string {
  return JSON.stringify(
    ListAgentTasksToolChoiceFunction$outboundSchema.parse(
      listAgentTasksToolChoiceFunction,
    ),
  );
}
export function listAgentTasksToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoice2$inboundSchema: z.ZodType<
  ListAgentTasksToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentTasksToolChoiceFunction$inboundSchema),
});
/** @internal */
export type ListAgentTasksToolChoice2$Outbound = {
  type?: string | undefined;
  function: ListAgentTasksToolChoiceFunction$Outbound;
};

/** @internal */
export const ListAgentTasksToolChoice2$outboundSchema: z.ZodType<
  ListAgentTasksToolChoice2$Outbound,
  z.ZodTypeDef,
  ListAgentTasksToolChoice2
> = z.object({
  type: ListAgentTasksToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ListAgentTasksToolChoiceFunction$outboundSchema),
});

export function listAgentTasksToolChoice2ToJSON(
  listAgentTasksToolChoice2: ListAgentTasksToolChoice2,
): string {
  return JSON.stringify(
    ListAgentTasksToolChoice2$outboundSchema.parse(listAgentTasksToolChoice2),
  );
}
export function listAgentTasksToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksToolChoice2' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoice1
> = z.nativeEnum(ListAgentTasksToolChoice1);
/** @internal */
export const ListAgentTasksToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoice1
> = ListAgentTasksToolChoice1$inboundSchema;

/** @internal */
export const ListAgentTasksToolChoice$inboundSchema: z.ZodType<
  ListAgentTasksToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentTasksToolChoice2$inboundSchema),
  ListAgentTasksToolChoice1$inboundSchema,
]);
/** @internal */
export type ListAgentTasksToolChoice$Outbound =
  | ListAgentTasksToolChoice2$Outbound
  | string;

/** @internal */
export const ListAgentTasksToolChoice$outboundSchema: z.ZodType<
  ListAgentTasksToolChoice$Outbound,
  z.ZodTypeDef,
  ListAgentTasksToolChoice
> = z.union([
  z.lazy(() => ListAgentTasksToolChoice2$outboundSchema),
  ListAgentTasksToolChoice1$outboundSchema,
]);

export function listAgentTasksToolChoiceToJSON(
  listAgentTasksToolChoice: ListAgentTasksToolChoice,
): string {
  return JSON.stringify(
    ListAgentTasksToolChoice$outboundSchema.parse(listAgentTasksToolChoice),
  );
}
export function listAgentTasksToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksModalities$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksModalities
> = z.nativeEnum(ListAgentTasksModalities);
/** @internal */
export const ListAgentTasksModalities$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksModalities
> = ListAgentTasksModalities$inboundSchema;

/** @internal */
export const ListAgentTasksWebSearchOptions$inboundSchema: z.ZodType<
  ListAgentTasksWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type ListAgentTasksWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksWebSearchOptions$outboundSchema: z.ZodType<
  ListAgentTasksWebSearchOptions$Outbound,
  z.ZodTypeDef,
  ListAgentTasksWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function listAgentTasksWebSearchOptionsToJSON(
  listAgentTasksWebSearchOptions: ListAgentTasksWebSearchOptions,
): string {
  return JSON.stringify(
    ListAgentTasksWebSearchOptions$outboundSchema.parse(
      listAgentTasksWebSearchOptions,
    ),
  );
}
export function listAgentTasksWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksParameters$inboundSchema: z.ZodType<
  ListAgentTasksParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentTasksAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListAgentTasksResponseFormat3$inboundSchema),
    z.lazy(() => ListAgentTasksResponseFormat1$inboundSchema),
    z.lazy(() => ListAgentTasksResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListAgentTasksStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentTasksThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListAgentTasksToolChoice2$inboundSchema),
    ListAgentTasksToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListAgentTasksModalities$inboundSchema))
    .optional(),
  web_search_options: z.lazy(() => ListAgentTasksWebSearchOptions$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type ListAgentTasksParameters$Outbound = {
  audio?: ListAgentTasksAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ListAgentTasksResponseFormat3$Outbound
    | ListAgentTasksResponseFormat1$Outbound
    | ListAgentTasksResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: ListAgentTasksStreamOptions$Outbound | null | undefined;
  thinking?: ListAgentTasksThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ListAgentTasksToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: ListAgentTasksWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const ListAgentTasksParameters$outboundSchema: z.ZodType<
  ListAgentTasksParameters$Outbound,
  z.ZodTypeDef,
  ListAgentTasksParameters
> = z.object({
  audio: z.nullable(z.lazy(() => ListAgentTasksAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ListAgentTasksResponseFormat3$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormat1$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ListAgentTasksStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentTasksThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ListAgentTasksToolChoice2$outboundSchema),
    ListAgentTasksToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListAgentTasksModalities$outboundSchema))
    .optional(),
  webSearchOptions: z.lazy(() => ListAgentTasksWebSearchOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function listAgentTasksParametersToJSON(
  listAgentTasksParameters: ListAgentTasksParameters,
): string {
  return JSON.stringify(
    ListAgentTasksParameters$outboundSchema.parse(listAgentTasksParameters),
  );
}
export function listAgentTasksParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsVoice
> = z.nativeEnum(ListAgentTasksFallbackModelsVoice);
/** @internal */
export const ListAgentTasksFallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsVoice
> = ListAgentTasksFallbackModelsVoice$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsFormat
> = z.nativeEnum(ListAgentTasksFallbackModelsFormat);
/** @internal */
export const ListAgentTasksFallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsFormat
> = ListAgentTasksFallbackModelsFormat$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsAudio$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListAgentTasksFallbackModelsVoice$inboundSchema,
  format: ListAgentTasksFallbackModelsFormat$inboundSchema,
});
/** @internal */
export type ListAgentTasksFallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ListAgentTasksFallbackModelsAudio$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModelsAudio
> = z.object({
  voice: ListAgentTasksFallbackModelsVoice$outboundSchema,
  format: ListAgentTasksFallbackModelsFormat$outboundSchema,
});

export function listAgentTasksFallbackModelsAudioToJSON(
  listAgentTasksFallbackModelsAudio: ListAgentTasksFallbackModelsAudio,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsAudio$outboundSchema.parse(
      listAgentTasksFallbackModelsAudio,
    ),
  );
}
export function listAgentTasksFallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksFallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > =
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormatAgentsJsonSchema$inboundSchema:
  z.ZodType<
    ListAgentTasksResponseFormatAgentsJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });
/** @internal */
export type ListAgentTasksResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    ListAgentTasksResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    ListAgentTasksResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function listAgentTasksResponseFormatAgentsJsonSchemaToJSON(
  listAgentTasksResponseFormatAgentsJsonSchema:
    ListAgentTasksResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormatAgentsJsonSchema$outboundSchema.parse(
      listAgentTasksResponseFormatAgentsJsonSchema,
    ),
  );
}
export function listAgentTasksResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentTasksResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentTasksResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgents3$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  json_schema: z.lazy(() =>
    ListAgentTasksResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ListAgentTasksResponseFormatAgents3$Outbound = {
  type: string;
  json_schema: ListAgentTasksResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const ListAgentTasksResponseFormatAgents3$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents3$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormatAgents3
> = z.object({
  type:
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  jsonSchema: z.lazy(() =>
    ListAgentTasksResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function listAgentTasksResponseFormatAgents3ToJSON(
  listAgentTasksResponseFormatAgents3: ListAgentTasksResponseFormatAgents3,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormatAgents3$outboundSchema.parse(
      listAgentTasksResponseFormatAgents3,
    ),
  );
}
export function listAgentTasksResponseFormatAgents3FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormatAgents3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksResponseFormatAgents3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormatAgents3' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType
  > = z.nativeEnum(
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType,
  );
/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType
  > =
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormatAgents2$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema,
});
/** @internal */
export type ListAgentTasksResponseFormatAgents2$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentTasksResponseFormatAgents2$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents2$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormatAgents2
> = z.object({
  type:
    ListAgentTasksResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema,
});

export function listAgentTasksResponseFormatAgents2ToJSON(
  listAgentTasksResponseFormatAgents2: ListAgentTasksResponseFormatAgents2,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormatAgents2$outboundSchema.parse(
      listAgentTasksResponseFormatAgents2,
    ),
  );
}
export function listAgentTasksResponseFormatAgents2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormatAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksResponseFormatAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormatAgents2' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsResponse200Type> = z
    .nativeEnum(ListAgentTasksResponseFormatAgentsResponse200Type);
/** @internal */
export const ListAgentTasksResponseFormatAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksResponseFormatAgentsResponse200Type> =
    ListAgentTasksResponseFormatAgentsResponse200Type$inboundSchema;

/** @internal */
export const ListAgentTasksResponseFormatAgents1$inboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksResponseFormatAgentsResponse200Type$inboundSchema,
});
/** @internal */
export type ListAgentTasksResponseFormatAgents1$Outbound = {
  type: string;
};

/** @internal */
export const ListAgentTasksResponseFormatAgents1$outboundSchema: z.ZodType<
  ListAgentTasksResponseFormatAgents1$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseFormatAgents1
> = z.object({
  type: ListAgentTasksResponseFormatAgentsResponse200Type$outboundSchema,
});

export function listAgentTasksResponseFormatAgents1ToJSON(
  listAgentTasksResponseFormatAgents1: ListAgentTasksResponseFormatAgents1,
): string {
  return JSON.stringify(
    ListAgentTasksResponseFormatAgents1$outboundSchema.parse(
      listAgentTasksResponseFormatAgents1,
    ),
  );
}
export function listAgentTasksResponseFormatAgents1FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseFormatAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksResponseFormatAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseFormatAgents1' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsResponseFormat$inboundSchema:
  z.ZodType<ListAgentTasksFallbackModelsResponseFormat, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => ListAgentTasksResponseFormatAgents3$inboundSchema),
      z.lazy(() => ListAgentTasksResponseFormatAgents1$inboundSchema),
      z.lazy(() => ListAgentTasksResponseFormatAgents2$inboundSchema),
    ]);
/** @internal */
export type ListAgentTasksFallbackModelsResponseFormat$Outbound =
  | ListAgentTasksResponseFormatAgents3$Outbound
  | ListAgentTasksResponseFormatAgents1$Outbound
  | ListAgentTasksResponseFormatAgents2$Outbound;

/** @internal */
export const ListAgentTasksFallbackModelsResponseFormat$outboundSchema:
  z.ZodType<
    ListAgentTasksFallbackModelsResponseFormat$Outbound,
    z.ZodTypeDef,
    ListAgentTasksFallbackModelsResponseFormat
  > = z.union([
    z.lazy(() => ListAgentTasksResponseFormatAgents3$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents1$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents2$outboundSchema),
  ]);

export function listAgentTasksFallbackModelsResponseFormatToJSON(
  listAgentTasksFallbackModelsResponseFormat:
    ListAgentTasksFallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsResponseFormat$outboundSchema.parse(
      listAgentTasksFallbackModelsResponseFormat,
    ),
  );
}
export function listAgentTasksFallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentTasksFallbackModelsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentTasksFallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsStop$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type ListAgentTasksFallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const ListAgentTasksFallbackModelsStop$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsStop$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function listAgentTasksFallbackModelsStopToJSON(
  listAgentTasksFallbackModelsStop: ListAgentTasksFallbackModelsStop,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsStop$outboundSchema.parse(
      listAgentTasksFallbackModelsStop,
    ),
  );
}
export function listAgentTasksFallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksFallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsStreamOptions$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type ListAgentTasksFallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksFallbackModelsStreamOptions$outboundSchema:
  z.ZodType<
    ListAgentTasksFallbackModelsStreamOptions$Outbound,
    z.ZodTypeDef,
    ListAgentTasksFallbackModelsStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function listAgentTasksFallbackModelsStreamOptionsToJSON(
  listAgentTasksFallbackModelsStreamOptions:
    ListAgentTasksFallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsStreamOptions$outboundSchema.parse(
      listAgentTasksFallbackModelsStreamOptions,
    ),
  );
}
export function listAgentTasksFallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentTasksFallbackModelsStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentTasksFallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsType
> = z.nativeEnum(ListAgentTasksFallbackModelsType);
/** @internal */
export const ListAgentTasksFallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksFallbackModelsType
> = ListAgentTasksFallbackModelsType$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksFallbackModelsThinkingLevel> = z
    .nativeEnum(ListAgentTasksFallbackModelsThinkingLevel);
/** @internal */
export const ListAgentTasksFallbackModelsThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksFallbackModelsThinkingLevel> =
    ListAgentTasksFallbackModelsThinkingLevel$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsThinking$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksFallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: ListAgentTasksFallbackModelsThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type ListAgentTasksFallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const ListAgentTasksFallbackModelsThinking$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModelsThinking
> = z.object({
  type: ListAgentTasksFallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: ListAgentTasksFallbackModelsThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function listAgentTasksFallbackModelsThinkingToJSON(
  listAgentTasksFallbackModelsThinking: ListAgentTasksFallbackModelsThinking,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsThinking$outboundSchema.parse(
      listAgentTasksFallbackModelsThinking,
    ),
  );
}
export function listAgentTasksFallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceAgentsType
> = z.nativeEnum(ListAgentTasksToolChoiceAgentsType);
/** @internal */
export const ListAgentTasksToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceAgentsType
> = ListAgentTasksToolChoiceAgentsType$inboundSchema;

/** @internal */
export const ListAgentTasksToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  ListAgentTasksToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ListAgentTasksToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ListAgentTasksToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  ListAgentTasksToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  ListAgentTasksToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function listAgentTasksToolChoiceAgentsFunctionToJSON(
  listAgentTasksToolChoiceAgentsFunction:
    ListAgentTasksToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    ListAgentTasksToolChoiceAgentsFunction$outboundSchema.parse(
      listAgentTasksToolChoiceAgentsFunction,
    ),
  );
}
export function listAgentTasksToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoiceAgents2$inboundSchema: z.ZodType<
  ListAgentTasksToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListAgentTasksToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => ListAgentTasksToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type ListAgentTasksToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: ListAgentTasksToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const ListAgentTasksToolChoiceAgents2$outboundSchema: z.ZodType<
  ListAgentTasksToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  ListAgentTasksToolChoiceAgents2
> = z.object({
  type: ListAgentTasksToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => ListAgentTasksToolChoiceAgentsFunction$outboundSchema),
});

export function listAgentTasksToolChoiceAgents2ToJSON(
  listAgentTasksToolChoiceAgents2: ListAgentTasksToolChoiceAgents2,
): string {
  return JSON.stringify(
    ListAgentTasksToolChoiceAgents2$outboundSchema.parse(
      listAgentTasksToolChoiceAgents2,
    ),
  );
}
export function listAgentTasksToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceAgents1
> = z.nativeEnum(ListAgentTasksToolChoiceAgents1);
/** @internal */
export const ListAgentTasksToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolChoiceAgents1
> = ListAgentTasksToolChoiceAgents1$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsToolChoice$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentTasksToolChoiceAgents2$inboundSchema),
  ListAgentTasksToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type ListAgentTasksFallbackModelsToolChoice$Outbound =
  | ListAgentTasksToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const ListAgentTasksFallbackModelsToolChoice$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModelsToolChoice
> = z.union([
  z.lazy(() => ListAgentTasksToolChoiceAgents2$outboundSchema),
  ListAgentTasksToolChoiceAgents1$outboundSchema,
]);

export function listAgentTasksFallbackModelsToolChoiceToJSON(
  listAgentTasksFallbackModelsToolChoice:
    ListAgentTasksFallbackModelsToolChoice,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsToolChoice$outboundSchema.parse(
      listAgentTasksFallbackModelsToolChoice,
    ),
  );
}
export function listAgentTasksFallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsModalities$inboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksFallbackModelsModalities> = z.nativeEnum(
    ListAgentTasksFallbackModelsModalities,
  );
/** @internal */
export const ListAgentTasksFallbackModelsModalities$outboundSchema:
  z.ZodNativeEnum<typeof ListAgentTasksFallbackModelsModalities> =
    ListAgentTasksFallbackModelsModalities$inboundSchema;

/** @internal */
export const ListAgentTasksFallbackModelsWebSearchOptions$inboundSchema:
  z.ZodType<
    ListAgentTasksFallbackModelsWebSearchOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type ListAgentTasksFallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const ListAgentTasksFallbackModelsWebSearchOptions$outboundSchema:
  z.ZodType<
    ListAgentTasksFallbackModelsWebSearchOptions$Outbound,
    z.ZodTypeDef,
    ListAgentTasksFallbackModelsWebSearchOptions
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function listAgentTasksFallbackModelsWebSearchOptionsToJSON(
  listAgentTasksFallbackModelsWebSearchOptions:
    ListAgentTasksFallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsWebSearchOptions$outboundSchema.parse(
      listAgentTasksFallbackModelsWebSearchOptions,
    ),
  );
}
export function listAgentTasksFallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListAgentTasksFallbackModelsWebSearchOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsWebSearchOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListAgentTasksFallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModelsParameters$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(
    z.lazy(() => ListAgentTasksFallbackModelsAudio$inboundSchema),
  ).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListAgentTasksResponseFormatAgents3$inboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents1$inboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListAgentTasksFallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentTasksFallbackModelsThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListAgentTasksToolChoiceAgents2$inboundSchema),
    ListAgentTasksToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(ListAgentTasksFallbackModelsModalities$inboundSchema),
  ).optional(),
  web_search_options: z.lazy(() =>
    ListAgentTasksFallbackModelsWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type ListAgentTasksFallbackModelsParameters$Outbound = {
  audio?: ListAgentTasksFallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ListAgentTasksResponseFormatAgents3$Outbound
    | ListAgentTasksResponseFormatAgents1$Outbound
    | ListAgentTasksResponseFormatAgents2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | ListAgentTasksFallbackModelsStreamOptions$Outbound
    | null
    | undefined;
  thinking?: ListAgentTasksFallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ListAgentTasksToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?:
    | ListAgentTasksFallbackModelsWebSearchOptions$Outbound
    | undefined;
};

/** @internal */
export const ListAgentTasksFallbackModelsParameters$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModelsParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => ListAgentTasksFallbackModelsAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ListAgentTasksResponseFormatAgents3$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents1$outboundSchema),
    z.lazy(() => ListAgentTasksResponseFormatAgents2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ListAgentTasksFallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => ListAgentTasksFallbackModelsThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ListAgentTasksToolChoiceAgents2$outboundSchema),
    ListAgentTasksToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(ListAgentTasksFallbackModelsModalities$outboundSchema),
  ).optional(),
  webSearchOptions: z.lazy(() =>
    ListAgentTasksFallbackModelsWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function listAgentTasksFallbackModelsParametersToJSON(
  listAgentTasksFallbackModelsParameters:
    ListAgentTasksFallbackModelsParameters,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModelsParameters$outboundSchema.parse(
      listAgentTasksFallbackModelsParameters,
    ),
  );
}
export function listAgentTasksFallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListAgentTasksFallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModels2$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentTasksFallbackModelsParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type ListAgentTasksFallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: ListAgentTasksFallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const ListAgentTasksFallbackModels2$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModels2$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() =>
    ListAgentTasksFallbackModelsParameters$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function listAgentTasksFallbackModels2ToJSON(
  listAgentTasksFallbackModels2: ListAgentTasksFallbackModels2,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModels2$outboundSchema.parse(
      listAgentTasksFallbackModels2,
    ),
  );
}
export function listAgentTasksFallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksFallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModels2' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksFallbackModels$inboundSchema: z.ZodType<
  ListAgentTasksFallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListAgentTasksFallbackModels2$inboundSchema),
  z.string(),
]);
/** @internal */
export type ListAgentTasksFallbackModels$Outbound =
  | ListAgentTasksFallbackModels2$Outbound
  | string;

/** @internal */
export const ListAgentTasksFallbackModels$outboundSchema: z.ZodType<
  ListAgentTasksFallbackModels$Outbound,
  z.ZodTypeDef,
  ListAgentTasksFallbackModels
> = z.union([
  z.lazy(() => ListAgentTasksFallbackModels2$outboundSchema),
  z.string(),
]);

export function listAgentTasksFallbackModelsToJSON(
  listAgentTasksFallbackModels: ListAgentTasksFallbackModels,
): string {
  return JSON.stringify(
    ListAgentTasksFallbackModels$outboundSchema.parse(
      listAgentTasksFallbackModels,
    ),
  );
}
export function listAgentTasksFallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksFallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksFallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksFallbackModels' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksModel$inboundSchema: z.ZodType<
  ListAgentTasksModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentTasksParameters$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => ListAgentTasksFallbackModels2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type ListAgentTasksModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: ListAgentTasksParameters$Outbound | undefined;
  fallback_models?:
    | Array<ListAgentTasksFallbackModels2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const ListAgentTasksModel$outboundSchema: z.ZodType<
  ListAgentTasksModel$Outbound,
  z.ZodTypeDef,
  ListAgentTasksModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ListAgentTasksParameters$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => ListAgentTasksFallbackModels2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function listAgentTasksModelToJSON(
  listAgentTasksModel: ListAgentTasksModel,
): string {
  return JSON.stringify(
    ListAgentTasksModel$outboundSchema.parse(listAgentTasksModel),
  );
}
export function listAgentTasksModelFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksModel' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolApprovalRequired
> = z.nativeEnum(ListAgentTasksToolApprovalRequired);
/** @internal */
export const ListAgentTasksToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ListAgentTasksToolApprovalRequired
> = ListAgentTasksToolApprovalRequired$inboundSchema;

/** @internal */
export const ListAgentTasksConditions$inboundSchema: z.ZodType<
  ListAgentTasksConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type ListAgentTasksConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const ListAgentTasksConditions$outboundSchema: z.ZodType<
  ListAgentTasksConditions$Outbound,
  z.ZodTypeDef,
  ListAgentTasksConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function listAgentTasksConditionsToJSON(
  listAgentTasksConditions: ListAgentTasksConditions,
): string {
  return JSON.stringify(
    ListAgentTasksConditions$outboundSchema.parse(listAgentTasksConditions),
  );
}
export function listAgentTasksConditionsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksConditions' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksTools$inboundSchema: z.ZodType<
  ListAgentTasksTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => ListAgentTasksConditions$inboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type ListAgentTasksTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<ListAgentTasksConditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const ListAgentTasksTools$outboundSchema: z.ZodType<
  ListAgentTasksTools$Outbound,
  z.ZodTypeDef,
  ListAgentTasksTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => ListAgentTasksConditions$outboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function listAgentTasksToolsToJSON(
  listAgentTasksTools: ListAgentTasksTools,
): string {
  return JSON.stringify(
    ListAgentTasksTools$outboundSchema.parse(listAgentTasksTools),
  );
}
export function listAgentTasksToolsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksTools' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksSettings$inboundSchema: z.ZodType<
  ListAgentTasksSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: ListAgentTasksToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => ListAgentTasksTools$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type ListAgentTasksSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<ListAgentTasksTools$Outbound> | undefined;
};

/** @internal */
export const ListAgentTasksSettings$outboundSchema: z.ZodType<
  ListAgentTasksSettings$Outbound,
  z.ZodTypeDef,
  ListAgentTasksSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: ListAgentTasksToolApprovalRequired$outboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => ListAgentTasksTools$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function listAgentTasksSettingsToJSON(
  listAgentTasksSettings: ListAgentTasksSettings,
): string {
  return JSON.stringify(
    ListAgentTasksSettings$outboundSchema.parse(listAgentTasksSettings),
  );
}
export function listAgentTasksSettingsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksSettings' from JSON`,
  );
}

/** @internal */
export const AgentManifestSnapshot$inboundSchema: z.ZodType<
  AgentManifestSnapshot,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  system_prompt: z.string().optional(),
  model: z.lazy(() => ListAgentTasksModel$inboundSchema),
  settings: z.lazy(() => ListAgentTasksSettings$inboundSchema).optional(),
  project_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "system_prompt": "systemPrompt",
    "project_id": "projectId",
  });
});
/** @internal */
export type AgentManifestSnapshot$Outbound = {
  _id: string;
  key: string;
  role: string;
  description: string;
  instructions: string;
  system_prompt?: string | undefined;
  model: ListAgentTasksModel$Outbound;
  settings?: ListAgentTasksSettings$Outbound | undefined;
  project_id?: string | undefined;
};

/** @internal */
export const AgentManifestSnapshot$outboundSchema: z.ZodType<
  AgentManifestSnapshot$Outbound,
  z.ZodTypeDef,
  AgentManifestSnapshot
> = z.object({
  id: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  systemPrompt: z.string().optional(),
  model: z.lazy(() => ListAgentTasksModel$outboundSchema),
  settings: z.lazy(() => ListAgentTasksSettings$outboundSchema).optional(),
  projectId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    systemPrompt: "system_prompt",
    projectId: "project_id",
  });
});

export function agentManifestSnapshotToJSON(
  agentManifestSnapshot: AgentManifestSnapshot,
): string {
  return JSON.stringify(
    AgentManifestSnapshot$outboundSchema.parse(agentManifestSnapshot),
  );
}
export function agentManifestSnapshotFromJSON(
  jsonString: string,
): SafeParseResult<AgentManifestSnapshot, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentManifestSnapshot$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentManifestSnapshot' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksMemory$inboundSchema: z.ZodType<
  ListAgentTasksMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type ListAgentTasksMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const ListAgentTasksMemory$outboundSchema: z.ZodType<
  ListAgentTasksMemory$Outbound,
  z.ZodTypeDef,
  ListAgentTasksMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function listAgentTasksMemoryToJSON(
  listAgentTasksMemory: ListAgentTasksMemory,
): string {
  return JSON.stringify(
    ListAgentTasksMemory$outboundSchema.parse(listAgentTasksMemory),
  );
}
export function listAgentTasksMemoryFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksMemory' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksState$inboundSchema: z.ZodType<
  ListAgentTasksState,
  z.ZodTypeDef,
  unknown
> = z.object({
  waiting_for_approval: z.boolean().default(false),
  inactive: z.boolean().default(true),
  error: z.string().optional(),
  iteration: z.number().int().default(1),
  accumulated_execution_time: z.number().default(0),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "waiting_for_approval": "waitingForApproval",
    "accumulated_execution_time": "accumulatedExecutionTime",
  });
});
/** @internal */
export type ListAgentTasksState$Outbound = {
  waiting_for_approval: boolean;
  inactive: boolean;
  error?: string | undefined;
  iteration: number;
  accumulated_execution_time: number;
  variables?: { [k: string]: any } | undefined;
};

/** @internal */
export const ListAgentTasksState$outboundSchema: z.ZodType<
  ListAgentTasksState$Outbound,
  z.ZodTypeDef,
  ListAgentTasksState
> = z.object({
  waitingForApproval: z.boolean().default(false),
  inactive: z.boolean().default(true),
  error: z.string().optional(),
  iteration: z.number().int().default(1),
  accumulatedExecutionTime: z.number().default(0),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    waitingForApproval: "waiting_for_approval",
    accumulatedExecutionTime: "accumulated_execution_time",
  });
});

export function listAgentTasksStateToJSON(
  listAgentTasksState: ListAgentTasksState,
): string {
  return JSON.stringify(
    ListAgentTasksState$outboundSchema.parse(listAgentTasksState),
  );
}
export function listAgentTasksStateFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksState, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksState$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksState' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksMetrics$inboundSchema: z.ZodType<
  ListAgentTasksMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_cost: z.number().default(0),
  output_cost: z.number().default(0),
  total_cost: z.number().default(0),
  prompt_tokens: z.number().int().default(0),
  completion_tokens: z.number().int().default(0),
  total_tokens: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    "input_cost": "inputCost",
    "output_cost": "outputCost",
    "total_cost": "totalCost",
    "prompt_tokens": "promptTokens",
    "completion_tokens": "completionTokens",
    "total_tokens": "totalTokens",
  });
});
/** @internal */
export type ListAgentTasksMetrics$Outbound = {
  input_cost: number;
  output_cost: number;
  total_cost: number;
  prompt_tokens: number;
  completion_tokens: number;
  total_tokens: number;
};

/** @internal */
export const ListAgentTasksMetrics$outboundSchema: z.ZodType<
  ListAgentTasksMetrics$Outbound,
  z.ZodTypeDef,
  ListAgentTasksMetrics
> = z.object({
  inputCost: z.number().default(0),
  outputCost: z.number().default(0),
  totalCost: z.number().default(0),
  promptTokens: z.number().int().default(0),
  completionTokens: z.number().int().default(0),
  totalTokens: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    inputCost: "input_cost",
    outputCost: "output_cost",
    totalCost: "total_cost",
    promptTokens: "prompt_tokens",
    completionTokens: "completion_tokens",
    totalTokens: "total_tokens",
  });
});

export function listAgentTasksMetricsToJSON(
  listAgentTasksMetrics: ListAgentTasksMetrics,
): string {
  return JSON.stringify(
    ListAgentTasksMetrics$outboundSchema.parse(listAgentTasksMetrics),
  );
}
export function listAgentTasksMetricsFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksMetrics' from JSON`,
  );
}

/** @internal */
export const Tasks$inboundSchema: z.ZodType<Tasks, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    agent_manifest_snapshot: z.lazy(() => AgentManifestSnapshot$inboundSchema),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    created: z.string().optional(),
    updated: z.string().optional(),
    name: z.string().optional(),
    workspace_id: z.string(),
    memory: z.lazy(() => ListAgentTasksMemory$inboundSchema).optional(),
    metadata: z.record(z.any()).optional(),
    state: z.lazy(() => ListAgentTasksState$inboundSchema),
    metrics: z.lazy(() => ListAgentTasksMetrics$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "agent_manifest_snapshot": "agentManifestSnapshot",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "workspace_id": "workspaceId",
    });
  });
/** @internal */
export type Tasks$Outbound = {
  _id: string;
  agent_manifest_snapshot: AgentManifestSnapshot$Outbound;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  name?: string | undefined;
  workspace_id: string;
  memory?: ListAgentTasksMemory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  state: ListAgentTasksState$Outbound;
  metrics: ListAgentTasksMetrics$Outbound;
};

/** @internal */
export const Tasks$outboundSchema: z.ZodType<
  Tasks$Outbound,
  z.ZodTypeDef,
  Tasks
> = z.object({
  id: z.string(),
  agentManifestSnapshot: z.lazy(() => AgentManifestSnapshot$outboundSchema),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  name: z.string().optional(),
  workspaceId: z.string(),
  memory: z.lazy(() => ListAgentTasksMemory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  state: z.lazy(() => ListAgentTasksState$outboundSchema),
  metrics: z.lazy(() => ListAgentTasksMetrics$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    agentManifestSnapshot: "agent_manifest_snapshot",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    workspaceId: "workspace_id",
  });
});

export function tasksToJSON(tasks: Tasks): string {
  return JSON.stringify(Tasks$outboundSchema.parse(tasks));
}
export function tasksFromJSON(
  jsonString: string,
): SafeParseResult<Tasks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tasks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tasks' from JSON`,
  );
}

/** @internal */
export const ListAgentTasksResponseBody$inboundSchema: z.ZodType<
  ListAgentTasksResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  tasks: z.array(z.lazy(() => Tasks$inboundSchema)),
  overall_total: z.number(),
}).transform((v) => {
  return remap$(v, {
    "overall_total": "overallTotal",
  });
});
/** @internal */
export type ListAgentTasksResponseBody$Outbound = {
  tasks: Array<Tasks$Outbound>;
  overall_total: number;
};

/** @internal */
export const ListAgentTasksResponseBody$outboundSchema: z.ZodType<
  ListAgentTasksResponseBody$Outbound,
  z.ZodTypeDef,
  ListAgentTasksResponseBody
> = z.object({
  tasks: z.array(z.lazy(() => Tasks$outboundSchema)),
  overallTotal: z.number(),
}).transform((v) => {
  return remap$(v, {
    overallTotal: "overall_total",
  });
});

export function listAgentTasksResponseBodyToJSON(
  listAgentTasksResponseBody: ListAgentTasksResponseBody,
): string {
  return JSON.stringify(
    ListAgentTasksResponseBody$outboundSchema.parse(listAgentTasksResponseBody),
  );
}
export function listAgentTasksResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListAgentTasksResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListAgentTasksResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListAgentTasksResponseBody' from JSON`,
  );
}
