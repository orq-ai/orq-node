/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllPromptsRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllPromptsObject = {
  List: "list",
} as const;
export type GetAllPromptsObject = ClosedEnum<typeof GetAllPromptsObject>;

export const GetAllPromptsType = {
  Prompt: "prompt",
} as const;
export type GetAllPromptsType = ClosedEnum<typeof GetAllPromptsType>;

/**
 * The modality of the model
 */
export const GetAllPromptsModelType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Ocr: "ocr",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The modality of the model
 */
export type GetAllPromptsModelType = ClosedEnum<typeof GetAllPromptsModelType>;

/**
 * Only supported on `image` models.
 */
export const GetAllPromptsFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type GetAllPromptsFormat = ClosedEnum<typeof GetAllPromptsFormat>;

export const GetAllPromptsResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type GetAllPromptsResponseFormat6 = ClosedEnum<
  typeof GetAllPromptsResponseFormat6
>;

export const GetAllPromptsResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type GetAllPromptsResponseFormat5 = ClosedEnum<
  typeof GetAllPromptsResponseFormat5
>;

export const GetAllPromptsResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type GetAllPromptsResponseFormat4 = ClosedEnum<
  typeof GetAllPromptsResponseFormat4
>;

export const GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  {
    Text: "text",
  } as const;
export type GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  >;

export type GetAllPromptsResponseFormat3 = {
  type:
    GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType;
};

export const GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType =
  {
    JsonObject: "json_object",
  } as const;
export type GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType
  >;

export type GetAllPromptsResponseFormat2 = {
  type: GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType;
};

export const GetAllPromptsResponseFormatPromptsResponse200Type = {
  JsonSchema: "json_schema",
} as const;
export type GetAllPromptsResponseFormatPromptsResponse200Type = ClosedEnum<
  typeof GetAllPromptsResponseFormatPromptsResponse200Type
>;

export type GetAllPromptsResponseFormatPromptsResponseJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type GetAllPromptsResponseFormat1 = {
  type: GetAllPromptsResponseFormatPromptsResponse200Type;
  displayName?: string | undefined;
  jsonSchema: GetAllPromptsResponseFormatPromptsResponseJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type GetAllPromptsPromptsResponseFormat =
  | GetAllPromptsResponseFormat1
  | GetAllPromptsResponseFormat2
  | GetAllPromptsResponseFormat3
  | GetAllPromptsResponseFormat4
  | GetAllPromptsResponseFormat5
  | GetAllPromptsResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const GetAllPromptsPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type GetAllPromptsPhotoRealVersion = ClosedEnum<
  typeof GetAllPromptsPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const GetAllPromptsEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type GetAllPromptsEncodingFormat = ClosedEnum<
  typeof GetAllPromptsEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const GetAllPromptsPromptsReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type GetAllPromptsPromptsReasoningEffort = ClosedEnum<
  typeof GetAllPromptsPromptsReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const GetAllPromptsVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type GetAllPromptsVerbosity = ClosedEnum<typeof GetAllPromptsVerbosity>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const GetAllPromptsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type GetAllPromptsThinkingLevel = ClosedEnum<
  typeof GetAllPromptsThinkingLevel
>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type GetAllPromptsModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: GetAllPromptsFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | GetAllPromptsResponseFormat1
    | GetAllPromptsResponseFormat2
    | GetAllPromptsResponseFormat3
    | GetAllPromptsResponseFormat4
    | GetAllPromptsResponseFormat5
    | GetAllPromptsResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: GetAllPromptsPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: GetAllPromptsEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: GetAllPromptsPromptsReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: GetAllPromptsVerbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: GetAllPromptsThinkingLevel | undefined;
};

export const GetAllPromptsProvider = {
  Openai: "openai",
  Groq: "groq",
  Cohere: "cohere",
  Azure: "azure",
  Aws: "aws",
  Google: "google",
  GoogleAi: "google-ai",
  Huggingface: "huggingface",
  Togetherai: "togetherai",
  Perplexity: "perplexity",
  Anthropic: "anthropic",
  Leonardoai: "leonardoai",
  Fal: "fal",
  Nvidia: "nvidia",
  Jina: "jina",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Cerebras: "cerebras",
  Openailike: "openailike",
  Bytedance: "bytedance",
  Mistral: "mistral",
  Deepseek: "deepseek",
  Contextualai: "contextualai",
  Moonshotai: "moonshotai",
  Zai: "zai",
  Slack: "slack",
} as const;
export type GetAllPromptsProvider = ClosedEnum<typeof GetAllPromptsProvider>;

/**
 * The role of the prompt message
 */
export const GetAllPromptsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type GetAllPromptsRole = ClosedEnum<typeof GetAllPromptsRole>;

export type GetAllPrompts2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type GetAllPrompts23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: GetAllPrompts2File;
};

export type GetAllPrompts2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type GetAllPrompts22 = {
  type: "image_url";
  imageUrl: GetAllPrompts2ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type GetAllPrompts21 = {
  type: "text";
  text: string;
};

export type GetAllPromptsContent2 =
  | GetAllPrompts21
  | GetAllPrompts22
  | GetAllPrompts23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type GetAllPromptsContent =
  | string
  | Array<GetAllPrompts21 | GetAllPrompts22 | GetAllPrompts23>;

export const GetAllPromptsPromptsResponseType = {
  Function: "function",
} as const;
export type GetAllPromptsPromptsResponseType = ClosedEnum<
  typeof GetAllPromptsPromptsResponseType
>;

export type GetAllPromptsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type GetAllPromptsToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: GetAllPromptsPromptsResponseType;
  function: GetAllPromptsFunction;
};

export type GetAllPromptsMessages = {
  /**
   * The role of the prompt message
   */
  role: GetAllPromptsRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<GetAllPrompts21 | GetAllPrompts22 | GetAllPrompts23>
    | null;
  toolCalls?: Array<GetAllPromptsToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type GetAllPromptsPromptConfig = {
  stream?: boolean | undefined;
  model?: string | null | undefined;
  /**
   * The id of the resource
   */
  modelDbId?: string | null | undefined;
  /**
   * The modality of the model
   */
  modelType?: GetAllPromptsModelType | null | undefined;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  modelParameters?: GetAllPromptsModelParameters | undefined;
  provider?: GetAllPromptsProvider | null | undefined;
  /**
   * The ID of the integration to use
   */
  integrationId?: string | null | undefined;
  version?: string | undefined;
  messages: Array<GetAllPromptsMessages>;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const GetAllPromptsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type GetAllPromptsVoice = ClosedEnum<typeof GetAllPromptsVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const GetAllPromptsPromptsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type GetAllPromptsPromptsFormat = ClosedEnum<
  typeof GetAllPromptsPromptsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type GetAllPromptsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: GetAllPromptsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: GetAllPromptsPromptsFormat;
};

export type GetAllPromptsResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type GetAllPromptsResponseFormatPromptsJSONSchema = {
  type: "json_schema";
  jsonSchema: GetAllPromptsResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type GetAllPromptsResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type GetAllPromptsResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type GetAllPromptsResponseFormat =
  | GetAllPromptsResponseFormatText
  | GetAllPromptsResponseFormatJSONObject
  | GetAllPromptsResponseFormatPromptsJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const GetAllPromptsReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type GetAllPromptsReasoningEffort = ClosedEnum<
  typeof GetAllPromptsReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type GetAllPromptsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type GetAllPromptsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type GetAllPromptsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const GetAllPromptsToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type GetAllPromptsToolChoiceType = ClosedEnum<
  typeof GetAllPromptsToolChoiceType
>;

export type GetAllPromptsToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type GetAllPromptsToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: GetAllPromptsToolChoiceType | undefined;
  function: GetAllPromptsToolChoiceFunction;
};

export const GetAllPromptsToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type GetAllPromptsToolChoice1 = ClosedEnum<
  typeof GetAllPromptsToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type GetAllPromptsToolChoice =
  | GetAllPromptsToolChoice2
  | GetAllPromptsToolChoice1;

export const GetAllPromptsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type GetAllPromptsModalities = ClosedEnum<
  typeof GetAllPromptsModalities
>;

/**
 * The key of the guardrail.
 */
export const GetAllPromptsId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type GetAllPromptsId1 = ClosedEnum<typeof GetAllPromptsId1>;

export type GetAllPromptsId = GetAllPromptsId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const GetAllPromptsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type GetAllPromptsExecuteOn = ClosedEnum<typeof GetAllPromptsExecuteOn>;

export type GetAllPromptsGuardrails = {
  id: GetAllPromptsId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: GetAllPromptsExecuteOn;
};

export type GetAllPromptsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type GetAllPromptsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const GetAllPromptsPromptsType = {
  ExactMatch: "exact_match",
} as const;
export type GetAllPromptsPromptsType = ClosedEnum<
  typeof GetAllPromptsPromptsType
>;

/**
 * Cache configuration for the request.
 */
export type GetAllPromptsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: GetAllPromptsPromptsType;
};

export const GetAllPromptsLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type GetAllPromptsLoadBalancerType = ClosedEnum<
  typeof GetAllPromptsLoadBalancerType
>;

export type GetAllPromptsLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type GetAllPromptsLoadBalancer1 = {
  type: GetAllPromptsLoadBalancerType;
  models: Array<GetAllPromptsLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type GetAllPromptsLoadBalancer = GetAllPromptsLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type GetAllPromptsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type GetAllPromptsContentPromptsResponse2002 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type GetAllPromptsMessagesPromptsResponse200Content =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const GetAllPromptsMessagesPromptsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type GetAllPromptsMessagesPromptsType = ClosedEnum<
  typeof GetAllPromptsMessagesPromptsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const GetAllPromptsMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type GetAllPromptsMessagesTtl = ClosedEnum<
  typeof GetAllPromptsMessagesTtl
>;

export type GetAllPromptsMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: GetAllPromptsMessagesPromptsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: GetAllPromptsMessagesTtl;
};

export type GetAllPromptsMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: GetAllPromptsMessagesCacheControl | undefined;
};

export type GetAllPromptsContentPromptsResponse2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type GetAllPromptsMessagesPromptsResponseContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type GetAllPromptsMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const GetAllPromptsMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type GetAllPromptsMessagesType = ClosedEnum<
  typeof GetAllPromptsMessagesType
>;

export type GetAllPromptsMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type GetAllPromptsMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: GetAllPromptsMessagesType;
  function: GetAllPromptsMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type GetAllPromptsMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: GetAllPromptsMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<GetAllPromptsMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const GetAllPrompts2PromptsResponse200ApplicationJSONType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type GetAllPrompts2PromptsResponse200ApplicationJSONType = ClosedEnum<
  typeof GetAllPrompts2PromptsResponse200ApplicationJSONType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const GetAllPrompts2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type GetAllPrompts2Ttl = ClosedEnum<typeof GetAllPrompts2Ttl>;

export type GetAllPrompts2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: GetAllPrompts2PromptsResponse200ApplicationJSONType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: GetAllPrompts2Ttl;
};

export type GetAllPrompts24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: GetAllPrompts2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type GetAllPromptsContentPrompts2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | GetAllPrompts24;

/**
 * The contents of the user message.
 */
export type GetAllPromptsMessagesPromptsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | GetAllPrompts24
  >;

export type GetAllPromptsMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | GetAllPrompts24
    >;
};

/**
 * The contents of the system message.
 */
export type GetAllPromptsMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type GetAllPromptsMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type GetAllPromptsPromptsMessages =
  | GetAllPromptsMessagesSystemMessage
  | GetAllPromptsMessagesUserMessage
  | GetAllPromptsMessagesAssistantMessage
  | GetAllPromptsMessagesToolMessage;

/**
 * Prompt configuration with model and messages. Use this instead of prompt_config.
 */
export type GetAllPromptsPromptField = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: GetAllPromptsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | GetAllPromptsResponseFormatText
    | GetAllPromptsResponseFormatJSONObject
    | GetAllPromptsResponseFormatPromptsJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: GetAllPromptsReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: GetAllPromptsStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: GetAllPromptsToolChoice2 | GetAllPromptsToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<GetAllPromptsModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<GetAllPromptsGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<GetAllPromptsFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: GetAllPromptsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: GetAllPromptsCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: GetAllPromptsLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: GetAllPromptsTimeout | undefined;
  /**
   * Array of messages that make up the conversation. Each message has a role (system, user, assistant, or tool) and content.
   */
  messages?:
    | Array<
      | GetAllPromptsMessagesSystemMessage
      | GetAllPromptsMessagesUserMessage
      | GetAllPromptsMessagesAssistantMessage
      | GetAllPromptsMessagesToolMessage
    >
    | undefined;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-3-5-sonnet-20241022`. For private models, use format: `{workspaceKey}@{provider}/{model}`.
   */
  model?: string | null | undefined;
  version?: string | undefined;
};

export const GetAllPromptsUseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type GetAllPromptsUseCases = ClosedEnum<typeof GetAllPromptsUseCases>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const GetAllPromptsLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type GetAllPromptsLanguage = ClosedEnum<typeof GetAllPromptsLanguage>;

export type GetAllPromptsMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<GetAllPromptsUseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: GetAllPromptsLanguage | null | undefined;
};

/**
 * A prompt entity with configuration, metadata, and versioning.
 */
export type GetAllPromptsPrompt = {
  id: string;
  type: GetAllPromptsType;
  owner: string;
  domainId: string;
  created: string;
  updated: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The prompt’s name, meant to be displayable in the UI.
   */
  displayName: string;
  /**
   * The prompt’s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  /**
   * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  promptConfig?: GetAllPromptsPromptConfig | undefined;
  /**
   * Prompt configuration with model and messages. Use this instead of prompt_config.
   */
  prompt: GetAllPromptsPromptField;
  metadata?: GetAllPromptsMetadata | undefined;
};

/**
 * Prompts retrieved.
 */
export type GetAllPromptsResponseBody = {
  object: GetAllPromptsObject;
  data: Array<GetAllPromptsPrompt>;
  hasMore: boolean;
};

/** @internal */
export type GetAllPromptsRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllPromptsRequest$outboundSchema: z.ZodType<
  GetAllPromptsRequest$Outbound,
  z.ZodTypeDef,
  GetAllPromptsRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function getAllPromptsRequestToJSON(
  getAllPromptsRequest: GetAllPromptsRequest,
): string {
  return JSON.stringify(
    GetAllPromptsRequest$outboundSchema.parse(getAllPromptsRequest),
  );
}

/** @internal */
export const GetAllPromptsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsObject
> = z.nativeEnum(GetAllPromptsObject);

/** @internal */
export const GetAllPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsType
> = z.nativeEnum(GetAllPromptsType);

/** @internal */
export const GetAllPromptsModelType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsModelType
> = z.nativeEnum(GetAllPromptsModelType);

/** @internal */
export const GetAllPromptsFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsFormat
> = z.nativeEnum(GetAllPromptsFormat);

/** @internal */
export const GetAllPromptsResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsResponseFormat6
> = z.nativeEnum(GetAllPromptsResponseFormat6);

/** @internal */
export const GetAllPromptsResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsResponseFormat5
> = z.nativeEnum(GetAllPromptsResponseFormat5);

/** @internal */
export const GetAllPromptsResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsResponseFormat4
> = z.nativeEnum(GetAllPromptsResponseFormat4);

/** @internal */
export const GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const GetAllPromptsResponseFormat3$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema,
});

export function getAllPromptsResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormat3' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType
  > = z.nativeEnum(
    GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType,
  );

/** @internal */
export const GetAllPromptsResponseFormat2$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllPromptsResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema,
});

export function getAllPromptsResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormat2' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatPromptsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof GetAllPromptsResponseFormatPromptsResponse200Type> = z
    .nativeEnum(GetAllPromptsResponseFormatPromptsResponse200Type);

/** @internal */
export const GetAllPromptsResponseFormatPromptsResponseJsonSchema$inboundSchema:
  z.ZodType<
    GetAllPromptsResponseFormatPromptsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function getAllPromptsResponseFormatPromptsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAllPromptsResponseFormatPromptsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsResponseFormatPromptsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAllPromptsResponseFormatPromptsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormat1$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllPromptsResponseFormatPromptsResponse200Type$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    GetAllPromptsResponseFormatPromptsResponseJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});

export function getAllPromptsResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormat1' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptsResponseFormat$inboundSchema: z.ZodType<
  GetAllPromptsPromptsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllPromptsResponseFormat1$inboundSchema),
  z.lazy(() => GetAllPromptsResponseFormat2$inboundSchema),
  z.lazy(() => GetAllPromptsResponseFormat3$inboundSchema),
  GetAllPromptsResponseFormat4$inboundSchema,
  GetAllPromptsResponseFormat5$inboundSchema,
  GetAllPromptsResponseFormat6$inboundSchema,
]);

export function getAllPromptsPromptsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsPromptsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsPromptsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsPromptsResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsPhotoRealVersion
> = z.nativeEnum(GetAllPromptsPhotoRealVersion);

/** @internal */
export const GetAllPromptsEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsEncodingFormat
> = z.nativeEnum(GetAllPromptsEncodingFormat);

/** @internal */
export const GetAllPromptsPromptsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsPromptsReasoningEffort
> = z.nativeEnum(GetAllPromptsPromptsReasoningEffort);

/** @internal */
export const GetAllPromptsVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsVerbosity
> = z.nativeEnum(GetAllPromptsVerbosity);

/** @internal */
export const GetAllPromptsThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsThinkingLevel
> = z.nativeEnum(GetAllPromptsThinkingLevel);

/** @internal */
export const GetAllPromptsModelParameters$inboundSchema: z.ZodType<
  GetAllPromptsModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: GetAllPromptsFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => GetAllPromptsResponseFormat1$inboundSchema),
      z.lazy(() => GetAllPromptsResponseFormat2$inboundSchema),
      z.lazy(() => GetAllPromptsResponseFormat3$inboundSchema),
      GetAllPromptsResponseFormat4$inboundSchema,
      GetAllPromptsResponseFormat5$inboundSchema,
      GetAllPromptsResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: GetAllPromptsPhotoRealVersion$inboundSchema.optional(),
  encoding_format: GetAllPromptsEncodingFormat$inboundSchema.optional(),
  reasoningEffort: GetAllPromptsPromptsReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: GetAllPromptsVerbosity$inboundSchema.optional(),
  thinkingLevel: GetAllPromptsThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

export function getAllPromptsModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsModelParameters' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsProvider$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsProvider
> = z.nativeEnum(GetAllPromptsProvider);

/** @internal */
export const GetAllPromptsRole$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsRole
> = z.nativeEnum(GetAllPromptsRole);

/** @internal */
export const GetAllPrompts2File$inboundSchema: z.ZodType<
  GetAllPrompts2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});

export function getAllPrompts2FileFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts2File' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts23$inboundSchema: z.ZodType<
  GetAllPrompts23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => GetAllPrompts2File$inboundSchema),
});

export function getAllPrompts23FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts23' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts2ImageUrl$inboundSchema: z.ZodType<
  GetAllPrompts2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function getAllPrompts2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts2ImageUrl' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts22$inboundSchema: z.ZodType<
  GetAllPrompts22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => GetAllPrompts2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

export function getAllPrompts22FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts22' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts21$inboundSchema: z.ZodType<
  GetAllPrompts21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function getAllPrompts21FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts21' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsContent2$inboundSchema: z.ZodType<
  GetAllPromptsContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllPrompts21$inboundSchema),
  z.lazy(() => GetAllPrompts22$inboundSchema),
  z.lazy(() => GetAllPrompts23$inboundSchema),
]);

export function getAllPromptsContent2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsContent2' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsContent$inboundSchema: z.ZodType<
  GetAllPromptsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => GetAllPrompts21$inboundSchema),
    z.lazy(() => GetAllPrompts22$inboundSchema),
    z.lazy(() => GetAllPrompts23$inboundSchema),
  ])),
]);

export function getAllPromptsContentFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsContent' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsPromptsResponseType
> = z.nativeEnum(GetAllPromptsPromptsResponseType);

/** @internal */
export const GetAllPromptsFunction$inboundSchema: z.ZodType<
  GetAllPromptsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function getAllPromptsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsFunction' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsToolCalls$inboundSchema: z.ZodType<
  GetAllPromptsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: GetAllPromptsPromptsResponseType$inboundSchema,
  function: z.lazy(() => GetAllPromptsFunction$inboundSchema),
});

export function getAllPromptsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsToolCalls' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessages$inboundSchema: z.ZodType<
  GetAllPromptsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: GetAllPromptsRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => GetAllPrompts21$inboundSchema),
        z.lazy(() => GetAllPrompts22$inboundSchema),
        z.lazy(() => GetAllPrompts23$inboundSchema),
      ])),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => GetAllPromptsToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});

export function getAllPromptsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessages' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptConfig$inboundSchema: z.ZodType<
  GetAllPromptsPromptConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  stream: z.boolean().optional(),
  model: z.nullable(z.string()).optional(),
  model_db_id: z.nullable(z.string()).optional(),
  model_type: z.nullable(GetAllPromptsModelType$inboundSchema).optional(),
  model_parameters: z.lazy(() => GetAllPromptsModelParameters$inboundSchema)
    .optional(),
  provider: z.nullable(GetAllPromptsProvider$inboundSchema).optional(),
  integration_id: z.nullable(z.string()).optional(),
  version: z.string().optional(),
  messages: z.array(z.lazy(() => GetAllPromptsMessages$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "model_db_id": "modelDbId",
    "model_type": "modelType",
    "model_parameters": "modelParameters",
    "integration_id": "integrationId",
  });
});

export function getAllPromptsPromptConfigFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsPromptConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsPromptConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsPromptConfig' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsVoice$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsVoice
> = z.nativeEnum(GetAllPromptsVoice);

/** @internal */
export const GetAllPromptsPromptsFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsPromptsFormat
> = z.nativeEnum(GetAllPromptsPromptsFormat);

/** @internal */
export const GetAllPromptsAudio$inboundSchema: z.ZodType<
  GetAllPromptsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: GetAllPromptsVoice$inboundSchema,
  format: GetAllPromptsPromptsFormat$inboundSchema,
});

export function getAllPromptsAudioFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsAudio' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatJsonSchema$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});

export function getAllPromptsResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatPromptsJSONSchema$inboundSchema:
  z.ZodType<
    GetAllPromptsResponseFormatPromptsJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      GetAllPromptsResponseFormatJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function getAllPromptsResponseFormatPromptsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAllPromptsResponseFormatPromptsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsResponseFormatPromptsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAllPromptsResponseFormatPromptsJSONSchema' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatJSONObject$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});

export function getAllPromptsResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormatText$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function getAllPromptsResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormatText' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseFormat$inboundSchema: z.ZodType<
  GetAllPromptsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllPromptsResponseFormatText$inboundSchema),
  z.lazy(() => GetAllPromptsResponseFormatJSONObject$inboundSchema),
  z.lazy(() => GetAllPromptsResponseFormatPromptsJSONSchema$inboundSchema),
]);

export function getAllPromptsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsReasoningEffort
> = z.nativeEnum(GetAllPromptsReasoningEffort);

/** @internal */
export const GetAllPromptsStop$inboundSchema: z.ZodType<
  GetAllPromptsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function getAllPromptsStopFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsStop' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsStreamOptions$inboundSchema: z.ZodType<
  GetAllPromptsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function getAllPromptsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsStreamOptions' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsThinking$inboundSchema: z.ZodType<
  GetAllPromptsThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function getAllPromptsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsThinking' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsToolChoiceType
> = z.nativeEnum(GetAllPromptsToolChoiceType);

/** @internal */
export const GetAllPromptsToolChoiceFunction$inboundSchema: z.ZodType<
  GetAllPromptsToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function getAllPromptsToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsToolChoice2$inboundSchema: z.ZodType<
  GetAllPromptsToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllPromptsToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => GetAllPromptsToolChoiceFunction$inboundSchema),
});

export function getAllPromptsToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsToolChoice2' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsToolChoice1
> = z.nativeEnum(GetAllPromptsToolChoice1);

/** @internal */
export const GetAllPromptsToolChoice$inboundSchema: z.ZodType<
  GetAllPromptsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllPromptsToolChoice2$inboundSchema),
  GetAllPromptsToolChoice1$inboundSchema,
]);

export function getAllPromptsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsToolChoice' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsModalities$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsModalities
> = z.nativeEnum(GetAllPromptsModalities);

/** @internal */
export const GetAllPromptsId1$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsId1
> = z.nativeEnum(GetAllPromptsId1);

/** @internal */
export const GetAllPromptsId$inboundSchema: z.ZodType<
  GetAllPromptsId,
  z.ZodTypeDef,
  unknown
> = z.union([GetAllPromptsId1$inboundSchema, z.string()]);

export function getAllPromptsIdFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsId' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsExecuteOn
> = z.nativeEnum(GetAllPromptsExecuteOn);

/** @internal */
export const GetAllPromptsGuardrails$inboundSchema: z.ZodType<
  GetAllPromptsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([GetAllPromptsId1$inboundSchema, z.string()]),
  execute_on: GetAllPromptsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});

export function getAllPromptsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsGuardrails' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsFallbacks$inboundSchema: z.ZodType<
  GetAllPromptsFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function getAllPromptsFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsFallbacks' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsRetry$inboundSchema: z.ZodType<
  GetAllPromptsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function getAllPromptsRetryFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsRetry' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsPromptsType
> = z.nativeEnum(GetAllPromptsPromptsType);

/** @internal */
export const GetAllPromptsCache$inboundSchema: z.ZodType<
  GetAllPromptsCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: GetAllPromptsPromptsType$inboundSchema,
});

export function getAllPromptsCacheFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsCache' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsLoadBalancerType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsLoadBalancerType
> = z.nativeEnum(GetAllPromptsLoadBalancerType);

/** @internal */
export const GetAllPromptsLoadBalancerModels$inboundSchema: z.ZodType<
  GetAllPromptsLoadBalancerModels,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function getAllPromptsLoadBalancerModelsFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsLoadBalancerModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsLoadBalancerModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsLoadBalancerModels' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsLoadBalancer1$inboundSchema: z.ZodType<
  GetAllPromptsLoadBalancer1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllPromptsLoadBalancerType$inboundSchema,
  models: z.array(z.lazy(() => GetAllPromptsLoadBalancerModels$inboundSchema)),
});

export function getAllPromptsLoadBalancer1FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsLoadBalancer1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsLoadBalancer1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsLoadBalancer1' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsLoadBalancer$inboundSchema: z.ZodType<
  GetAllPromptsLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => GetAllPromptsLoadBalancer1$inboundSchema);

export function getAllPromptsLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsLoadBalancer' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsTimeout$inboundSchema: z.ZodType<
  GetAllPromptsTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function getAllPromptsTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsTimeout' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsContentPromptsResponse2002$inboundSchema: z.ZodType<
  GetAllPromptsContentPromptsResponse2002,
  z.ZodTypeDef,
  unknown
> = components.TextContentPartSchema$inboundSchema;

export function getAllPromptsContentPromptsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  GetAllPromptsContentPromptsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsContentPromptsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAllPromptsContentPromptsResponse2002' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesPromptsResponse200Content$inboundSchema:
  z.ZodType<
    GetAllPromptsMessagesPromptsResponse200Content,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);

export function getAllPromptsMessagesPromptsResponse200ContentFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAllPromptsMessagesPromptsResponse200Content,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsMessagesPromptsResponse200Content$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAllPromptsMessagesPromptsResponse200Content' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsMessagesPromptsType
> = z.nativeEnum(GetAllPromptsMessagesPromptsType);

/** @internal */
export const GetAllPromptsMessagesTtl$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsMessagesTtl
> = z.nativeEnum(GetAllPromptsMessagesTtl);

/** @internal */
export const GetAllPromptsMessagesCacheControl$inboundSchema: z.ZodType<
  GetAllPromptsMessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllPromptsMessagesPromptsType$inboundSchema,
  ttl: GetAllPromptsMessagesTtl$inboundSchema.default("5m"),
});

export function getAllPromptsMessagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesToolMessage$inboundSchema: z.ZodType<
  GetAllPromptsMessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.nullable(z.string()),
  cache_control: z.lazy(() => GetAllPromptsMessagesCacheControl$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});

export function getAllPromptsMessagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsContentPromptsResponse2$inboundSchema: z.ZodType<
  GetAllPromptsContentPromptsResponse2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$inboundSchema,
  components.ReasoningPartSchema$inboundSchema,
  components.RedactedReasoningPartSchema$inboundSchema,
]);

export function getAllPromptsContentPromptsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsContentPromptsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsContentPromptsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsContentPromptsResponse2' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesPromptsResponseContent$inboundSchema:
  z.ZodType<
    GetAllPromptsMessagesPromptsResponseContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);

export function getAllPromptsMessagesPromptsResponseContentFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAllPromptsMessagesPromptsResponseContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsMessagesPromptsResponseContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAllPromptsMessagesPromptsResponseContent' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesAudio$inboundSchema: z.ZodType<
  GetAllPromptsMessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

export function getAllPromptsMessagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesAudio' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsMessagesType
> = z.nativeEnum(GetAllPromptsMessagesType);

/** @internal */
export const GetAllPromptsMessagesFunction$inboundSchema: z.ZodType<
  GetAllPromptsMessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function getAllPromptsMessagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesFunction' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesToolCalls$inboundSchema: z.ZodType<
  GetAllPromptsMessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: GetAllPromptsMessagesType$inboundSchema,
  function: z.lazy(() => GetAllPromptsMessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});

export function getAllPromptsMessagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesAssistantMessage$inboundSchema: z.ZodType<
  GetAllPromptsMessagesAssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$inboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$inboundSchema,
          components.ReasoningPartSchema$inboundSchema,
          components.RedactedReasoningPartSchema$inboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => GetAllPromptsMessagesAudio$inboundSchema))
    .optional(),
  tool_calls: z.array(
    z.lazy(() => GetAllPromptsMessagesToolCalls$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});

export function getAllPromptsMessagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesAssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsMessagesAssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts2PromptsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<typeof GetAllPrompts2PromptsResponse200ApplicationJSONType> =
    z.nativeEnum(GetAllPrompts2PromptsResponse200ApplicationJSONType);

/** @internal */
export const GetAllPrompts2Ttl$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPrompts2Ttl
> = z.nativeEnum(GetAllPrompts2Ttl);

/** @internal */
export const GetAllPrompts2CacheControl$inboundSchema: z.ZodType<
  GetAllPrompts2CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllPrompts2PromptsResponse200ApplicationJSONType$inboundSchema,
  ttl: GetAllPrompts2Ttl$inboundSchema.default("5m"),
});

export function getAllPrompts2CacheControlFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts2CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts2CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts2CacheControl' from JSON`,
  );
}

/** @internal */
export const GetAllPrompts24$inboundSchema: z.ZodType<
  GetAllPrompts24,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  cache_control: z.lazy(() => GetAllPrompts2CacheControl$inboundSchema)
    .optional(),
  file: components.FileContentPartSchema$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});

export function getAllPrompts24FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPrompts24, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPrompts24$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPrompts24' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsContentPrompts2$inboundSchema: z.ZodType<
  GetAllPromptsContentPrompts2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => GetAllPrompts24$inboundSchema),
]);

export function getAllPromptsContentPrompts2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsContentPrompts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsContentPrompts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsContentPrompts2' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesPromptsContent$inboundSchema: z.ZodType<
  GetAllPromptsMessagesPromptsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$inboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.ImageContentPartSchema$inboundSchema,
      components.AudioContentPartSchema$inboundSchema,
      z.lazy(() => GetAllPrompts24$inboundSchema),
    ]),
  ),
]);

export function getAllPromptsMessagesPromptsContentFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesPromptsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsMessagesPromptsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesPromptsContent' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesUserMessage$inboundSchema: z.ZodType<
  GetAllPromptsMessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => GetAllPrompts24$inboundSchema),
      ]),
    ),
  ]),
});

export function getAllPromptsMessagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesContent$inboundSchema: z.ZodType<
  GetAllPromptsMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);

export function getAllPromptsMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesContent' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsMessagesSystemMessage$inboundSchema: z.ZodType<
  GetAllPromptsMessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});

export function getAllPromptsMessagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMessagesSystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAllPromptsMessagesSystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptsMessages$inboundSchema: z.ZodType<
  GetAllPromptsPromptsMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllPromptsMessagesSystemMessage$inboundSchema),
  z.lazy(() => GetAllPromptsMessagesUserMessage$inboundSchema),
  z.lazy(() => GetAllPromptsMessagesAssistantMessage$inboundSchema),
  z.lazy(() => GetAllPromptsMessagesToolMessage$inboundSchema),
]);

export function getAllPromptsPromptsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsPromptsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsPromptsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsPromptsMessages' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPromptField$inboundSchema: z.ZodType<
  GetAllPromptsPromptField,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => GetAllPromptsAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => GetAllPromptsResponseFormatText$inboundSchema),
    z.lazy(() => GetAllPromptsResponseFormatJSONObject$inboundSchema),
    z.lazy(() => GetAllPromptsResponseFormatPromptsJSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: GetAllPromptsReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => GetAllPromptsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => GetAllPromptsToolChoice2$inboundSchema),
    GetAllPromptsToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(GetAllPromptsModalities$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => GetAllPromptsGuardrails$inboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => GetAllPromptsFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => GetAllPromptsRetry$inboundSchema).optional(),
  cache: z.lazy(() => GetAllPromptsCache$inboundSchema).optional(),
  load_balancer: z.lazy(() => GetAllPromptsLoadBalancer1$inboundSchema)
    .optional(),
  timeout: z.lazy(() => GetAllPromptsTimeout$inboundSchema).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => GetAllPromptsMessagesSystemMessage$inboundSchema),
      z.lazy(() => GetAllPromptsMessagesUserMessage$inboundSchema),
      z.lazy(() => GetAllPromptsMessagesAssistantMessage$inboundSchema),
      z.lazy(() => GetAllPromptsMessagesToolMessage$inboundSchema),
    ]),
  ).optional(),
  model: z.nullable(z.string()).optional(),
  version: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function getAllPromptsPromptFieldFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsPromptField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsPromptField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsPromptField' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsUseCases$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsUseCases
> = z.nativeEnum(GetAllPromptsUseCases);

/** @internal */
export const GetAllPromptsLanguage$inboundSchema: z.ZodNativeEnum<
  typeof GetAllPromptsLanguage
> = z.nativeEnum(GetAllPromptsLanguage);

/** @internal */
export const GetAllPromptsMetadata$inboundSchema: z.ZodType<
  GetAllPromptsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  use_cases: z.array(GetAllPromptsUseCases$inboundSchema).optional(),
  language: z.nullable(GetAllPromptsLanguage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "use_cases": "useCases",
  });
});

export function getAllPromptsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsMetadata' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsPrompt$inboundSchema: z.ZodType<
  GetAllPromptsPrompt,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  type: GetAllPromptsType$inboundSchema,
  owner: z.string(),
  domain_id: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  display_name: z.string(),
  description: z.nullable(z.string()).optional(),
  prompt_config: z.lazy(() => GetAllPromptsPromptConfig$inboundSchema)
    .optional(),
  prompt: z.lazy(() => GetAllPromptsPromptField$inboundSchema),
  metadata: z.lazy(() => GetAllPromptsMetadata$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "display_name": "displayName",
    "prompt_config": "promptConfig",
  });
});

export function getAllPromptsPromptFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsPrompt' from JSON`,
  );
}

/** @internal */
export const GetAllPromptsResponseBody$inboundSchema: z.ZodType<
  GetAllPromptsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllPromptsObject$inboundSchema,
  data: z.array(z.lazy(() => GetAllPromptsPrompt$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function getAllPromptsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllPromptsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllPromptsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllPromptsResponseBody' from JSON`,
  );
}
