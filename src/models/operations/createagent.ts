/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const Voice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type Voice = ClosedEnum<typeof Voice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ModelFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ModelFormat = ClosedEnum<typeof ModelFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ModelAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: Voice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ModelFormat;
};

export const CreateAgentResponseFormatAgentsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateAgentResponseFormatAgentsType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsType
>;

export type JsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type ResponseFormat3 = {
  type: CreateAgentResponseFormatAgentsType;
  jsonSchema: JsonSchema;
};

export const CreateAgentResponseFormatType = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatType = ClosedEnum<
  typeof CreateAgentResponseFormatType
>;

export type ResponseFormat2 = {
  type: CreateAgentResponseFormatType;
};

export const ResponseFormatType = {
  Text: "text",
} as const;
export type ResponseFormatType = ClosedEnum<typeof ResponseFormatType>;

export type ResponseFormat1 = {
  type: ResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type ResponseFormat =
  | ResponseFormat3
  | ResponseFormat1
  | ResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type Stop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentModelType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentModelType = ClosedEnum<typeof CreateAgentModelType>;

export type Thinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentModelType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ToolChoiceType = ClosedEnum<typeof ToolChoiceType>;

export type ToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ToolChoiceType | undefined;
  function: ToolChoiceFunction;
};

export const ToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ToolChoice1 = ClosedEnum<typeof ToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ToolChoice = ToolChoice2 | ToolChoice1;

export const Modalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type Modalities = ClosedEnum<typeof Modalities>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type WebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p (nucleus sampling), frequency_penalty, presence_penalty, response_format, reasoning_effort. Not all parameters work with all models.
 */
export type ParametersT = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ModelAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ResponseFormat3
    | ResponseFormat1
    | ResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamOptions | null | undefined;
  thinking?: Thinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ToolChoice2 | ToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<Modalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: WebSearchOptions | undefined;
};

/**
 * Model configuration with parameters
 */
export type Model2 = {
  /**
   * Model ID or provider/model string
   */
  id: string;
  /**
   * Optional integration ID for custom configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p (nucleus sampling), frequency_penalty, presence_penalty, response_format, reasoning_effort. Not all parameters work with all models.
   */
  parameters?: ParametersT | undefined;
};

/**
 * The primary language model that powers the agent. Can be a simple string (e.g., "anthropic/claude-3-sonnet-20240229") or an object with model ID and parameters.
 */
export type Model = Model2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const FallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type FallbackModelsVoice = ClosedEnum<typeof FallbackModelsVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const FallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type FallbackModelsFormat = ClosedEnum<typeof FallbackModelsFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type FallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: FallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: FallbackModelsFormat;
};

export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  {
    JsonSchema: "json_schema",
  } as const;
export type CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  >;

export type ResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type CreateAgentResponseFormat3 = {
  type: CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType;
  jsonSchema: ResponseFormatJsonSchema;
};

export const CreateAgentResponseFormatAgentsRequestRequestBodyType = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatAgentsRequestRequestBodyType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
>;

export type CreateAgentResponseFormat2 = {
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType;
};

export const CreateAgentResponseFormatAgentsRequestType = {
  Text: "text",
} as const;
export type CreateAgentResponseFormatAgentsRequestType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsRequestType
>;

export type CreateAgentResponseFormat1 = {
  type: CreateAgentResponseFormatAgentsRequestType;
};

/**
 * An object specifying the format that the model must output
 */
export type FallbackModelsResponseFormat =
  | CreateAgentResponseFormat3
  | CreateAgentResponseFormat1
  | CreateAgentResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type FallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type FallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const FallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type FallbackModelsType = ClosedEnum<typeof FallbackModelsType>;

export type FallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: FallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceType = ClosedEnum<
  typeof CreateAgentToolChoiceType
>;

export type CreateAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceType | undefined;
  function: CreateAgentToolChoiceFunction;
};

export const CreateAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoice1 = ClosedEnum<typeof CreateAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type FallbackModelsToolChoice =
  | CreateAgentToolChoice2
  | CreateAgentToolChoice1;

export const FallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type FallbackModelsModalities = ClosedEnum<
  typeof FallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type FallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type FallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: FallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormat3
    | CreateAgentResponseFormat1
    | CreateAgentResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: FallbackModelsStreamOptions | null | undefined;
  thinking?: FallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: CreateAgentToolChoice2 | CreateAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<FallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: FallbackModelsWebSearchOptions | undefined;
};

export type FallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: FallbackModelsParameters | undefined;
};

export type FallbackModels = FallbackModels2 | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

/**
 * Function tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
/**
 * Function tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type FunctionTool = {
  /**
   * Function tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type;
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Code execution tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
/**
 * Code execution tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type CodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type;
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * HTTP tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
/**
 * HTTP tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type HTTPTool = {
  /**
   * HTTP tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type;
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type CurrentDateTool = {
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type QueryKnowledgeBaseTool = {
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type RetrieveKnowledgeBasesTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type DeleteMemoryDocumentTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Lists available memory stores
 */
export type RetrieveMemoryStoresTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  >;

/**
 * Writes information to agent memory stores
 */
export type WriteMemoryStoreTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType = {
  QueryMemoryStore: "query_memory_store",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType =
  ClosedEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType>;

/**
 * Queries agent memory stores for context
 */
export type QueryMemoryStoreTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDAgentsRequestType
>;

/**
 * Retrieves available agents in the system
 */
export type RetrieveAgentsTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDAgentsType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type CallSubAgentTool = {
  type: CreateAgentAgentToolInputCRUDAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDType = {
  WebScraper: "web_scraper",
} as const;
export type CreateAgentAgentToolInputCRUDType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type WebScraperTool = {
  type: CreateAgentAgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const AgentToolInputCRUDType = {
  GoogleSearch: "google_search",
} as const;
export type AgentToolInputCRUDType = ClosedEnum<typeof AgentToolInputCRUDType>;

/**
 * Performs Google searches to retrieve web content
 */
export type GoogleSearchTool = {
  type: AgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function) must reference pre-created tools by key or id.
 */
export type AgentToolInputCRUD =
  | GoogleSearchTool
  | WebScraperTool
  | CallSubAgentTool
  | RetrieveAgentsTool
  | QueryMemoryStoreTool
  | WriteMemoryStoreTool
  | RetrieveMemoryStoresTool
  | DeleteMemoryDocumentTool
  | RetrieveKnowledgeBasesTool
  | QueryKnowledgeBaseTool
  | CurrentDateTool
  | HTTPTool
  | CodeExecutionTool
  | FunctionTool;

/**
 * Configuration settings for the agent's behavior
 */
export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | GoogleSearchTool
      | WebScraperTool
      | CallSubAgentTool
      | RetrieveAgentsTool
      | QueryMemoryStoreTool
      | WriteMemoryStoreTool
      | RetrieveMemoryStoresTool
      | DeleteMemoryDocumentTool
      | RetrieveKnowledgeBasesTool
      | QueryKnowledgeBaseTool
      | CurrentDateTool
      | HTTPTool
      | CodeExecutionTool
      | FunctionTool
    >
    | undefined;
};

export type KnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type TeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type CreateAgentRequestBody = {
  /**
   * The path where the agent will be stored in the project structure
   */
  path: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  /**
   * The role or function of the agent
   */
  role: string;
  /**
   * A brief description of what the agent does
   */
  description: string;
  /**
   * Detailed instructions that guide the agent's behavior
   */
  instructions: string;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * The primary language model that powers the agent. Can be a simple string (e.g., "anthropic/claude-3-sonnet-20240229") or an object with model ID and parameters.
   */
  model: Model2 | string;
  /**
   * Optional array of fallback models (string IDs or config objects) to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities.
   */
  fallbackModels?: Array<FallbackModels2 | string> | undefined;
  /**
   * Configuration settings for the agent's behavior
   */
  settings: Settings;
  /**
   * Optional array of memory store keys for the agent to access
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Optional array of knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<KnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<TeamOfAgents> | undefined;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateAgentStatus = ClosedEnum<typeof CreateAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const CreateAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type CreateAgentToolApprovalRequired = ClosedEnum<
  typeof CreateAgentToolApprovalRequired
>;

export type Conditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type CreateAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<Conditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type CreateAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: CreateAgentToolApprovalRequired | undefined;
  tools?: Array<CreateAgentTools> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentVoice = ClosedEnum<typeof CreateAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentFormat = ClosedEnum<typeof CreateAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentFormat;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType = {
  JsonSchema: "json_schema",
} as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  >;

export type CreateAgentResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type CreateAgentResponseFormatAgents3 = {
  type: CreateAgentResponseFormatAgentsResponse201ApplicationJSONType;
  jsonSchema: CreateAgentResponseFormatJsonSchema;
};

export const CreateAgentResponseFormatAgentsResponse201Type = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatAgentsResponse201Type = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsResponse201Type
>;

export type CreateAgentResponseFormatAgents2 = {
  type: CreateAgentResponseFormatAgentsResponse201Type;
};

export const CreateAgentResponseFormatAgentsResponseType = {
  Text: "text",
} as const;
export type CreateAgentResponseFormatAgentsResponseType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsResponseType
>;

export type CreateAgentResponseFormatAgents1 = {
  type: CreateAgentResponseFormatAgentsResponseType;
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentResponseFormat =
  | CreateAgentResponseFormatAgents3
  | CreateAgentResponseFormatAgents1
  | CreateAgentResponseFormatAgents2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentType = ClosedEnum<typeof CreateAgentType>;

export type CreateAgentThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceAgentsType = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsType
>;

export type CreateAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceAgentsType | undefined;
  function: CreateAgentToolChoiceAgentsFunction;
};

export const CreateAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoiceAgents1 = ClosedEnum<
  typeof CreateAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentToolChoice =
  | CreateAgentToolChoiceAgents2
  | CreateAgentToolChoiceAgents1;

export const CreateAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentModalities = ClosedEnum<typeof CreateAgentModalities>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type CreateAgentWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
 */
export type CreateAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormatAgents3
    | CreateAgentResponseFormatAgents1
    | CreateAgentResponseFormatAgents2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateAgentStreamOptions | null | undefined;
  thinking?: CreateAgentThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentToolChoiceAgents2
    | CreateAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateAgentModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: CreateAgentWebSearchOptions | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentFallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentFallbackModelsVoice = ClosedEnum<
  typeof CreateAgentFallbackModelsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentFallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentFallbackModelsFormat = ClosedEnum<
  typeof CreateAgentFallbackModelsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentFallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentFallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentFallbackModelsFormat;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType =
  {
    JsonSchema: "json_schema",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  >;

export type CreateAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type CreateAgentResponseFormatAgentsResponse3 = {
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType;
  jsonSchema: CreateAgentResponseFormatAgentsJsonSchema;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType =
  {
    JsonObject: "json_object",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  >;

export type CreateAgentResponseFormatAgentsResponse2 = {
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  {
    Text: "text",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  >;

export type CreateAgentResponseFormatAgentsResponse1 = {
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType;
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentFallbackModelsResponseFormat =
  | CreateAgentResponseFormatAgentsResponse3
  | CreateAgentResponseFormatAgentsResponse1
  | CreateAgentResponseFormatAgentsResponse2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentFallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentFallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentFallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentFallbackModelsType = ClosedEnum<
  typeof CreateAgentFallbackModelsType
>;

export type CreateAgentFallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentFallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceAgentsResponseType = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsResponseType
>;

export type CreateAgentToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceAgentsResponseType | undefined;
  function: CreateAgentToolChoiceAgentsResponseFunction;
};

export const CreateAgentToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoiceAgentsResponse1 = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentFallbackModelsToolChoice =
  | CreateAgentToolChoiceAgentsResponse2
  | CreateAgentToolChoiceAgentsResponse1;

export const CreateAgentFallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentFallbackModelsModalities = ClosedEnum<
  typeof CreateAgentFallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type CreateAgentFallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type CreateAgentFallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentFallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormatAgentsResponse3
    | CreateAgentResponseFormatAgentsResponse1
    | CreateAgentResponseFormatAgentsResponse2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateAgentFallbackModelsStreamOptions | null | undefined;
  thinking?: CreateAgentFallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentToolChoiceAgentsResponse2
    | CreateAgentToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateAgentFallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: CreateAgentFallbackModelsWebSearchOptions | undefined;
};

export type CreateAgentFallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: CreateAgentFallbackModelsParameters | undefined;
};

export type CreateAgentFallbackModels = CreateAgentFallbackModels2 | string;

export type CreateAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p, frequency_penalty, presence_penalty, response_format (JSON mode), reasoning_effort, seed (determinism). Model-specific support varies.
   */
  parameters?: CreateAgentParameters | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<CreateAgentFallbackModels2 | string>
    | null
    | undefined;
};

export type CreateAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type Metrics = {
  totalCost?: number | undefined;
};

export type CreateAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const HiddenPanels = {
  Model: "model",
  Tools: "tools",
  KnowledgeBases: "knowledge_bases",
  Variables: "variables",
  RuntimeConstraints: "runtime_constraints",
} as const;
export type HiddenPanels = ClosedEnum<typeof HiddenPanels>;

/**
 * Agent created successfully
 */
export type CreateAgentResponseBody = {
  id: string;
  key: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateAgentStatus;
  settings?: CreateAgentSettings | undefined;
  model: CreateAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<CreateAgentTeamOfAgents>;
  metrics?: Metrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<CreateAgentKnowledgeBases> | undefined;
  /**
   * List of hidden collapsed panels in configuration. Duplicates are not allowed.
   */
  hiddenPanels?: Array<HiddenPanels> | undefined;
};

/** @internal */
export const Voice$inboundSchema: z.ZodNativeEnum<typeof Voice> = z.nativeEnum(
  Voice,
);
/** @internal */
export const Voice$outboundSchema: z.ZodNativeEnum<typeof Voice> =
  Voice$inboundSchema;

/** @internal */
export const ModelFormat$inboundSchema: z.ZodNativeEnum<typeof ModelFormat> = z
  .nativeEnum(ModelFormat);
/** @internal */
export const ModelFormat$outboundSchema: z.ZodNativeEnum<typeof ModelFormat> =
  ModelFormat$inboundSchema;

/** @internal */
export const ModelAudio$inboundSchema: z.ZodType<
  ModelAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: Voice$inboundSchema,
  format: ModelFormat$inboundSchema,
});
/** @internal */
export type ModelAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ModelAudio$outboundSchema: z.ZodType<
  ModelAudio$Outbound,
  z.ZodTypeDef,
  ModelAudio
> = z.object({
  voice: Voice$outboundSchema,
  format: ModelFormat$outboundSchema,
});

export function modelAudioToJSON(modelAudio: ModelAudio): string {
  return JSON.stringify(ModelAudio$outboundSchema.parse(modelAudio));
}
export function modelAudioFromJSON(
  jsonString: string,
): SafeParseResult<ModelAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatAgentsType
> = z.nativeEnum(CreateAgentResponseFormatAgentsType);
/** @internal */
export const CreateAgentResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsType> =
    CreateAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const JsonSchema$inboundSchema: z.ZodType<
  JsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type JsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const JsonSchema$outboundSchema: z.ZodType<
  JsonSchema$Outbound,
  z.ZodTypeDef,
  JsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function jsonSchemaToJSON(jsonSchema: JsonSchema): string {
  return JSON.stringify(JsonSchema$outboundSchema.parse(jsonSchema));
}
export function jsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<JsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormat3$inboundSchema: z.ZodType<
  ResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsType$inboundSchema,
  json_schema: z.lazy(() => JsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ResponseFormat3$Outbound = {
  type: string;
  json_schema: JsonSchema$Outbound;
};

/** @internal */
export const ResponseFormat3$outboundSchema: z.ZodType<
  ResponseFormat3$Outbound,
  z.ZodTypeDef,
  ResponseFormat3
> = z.object({
  type: CreateAgentResponseFormatAgentsType$outboundSchema,
  jsonSchema: z.lazy(() => JsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function responseFormat3ToJSON(
  responseFormat3: ResponseFormat3,
): string {
  return JSON.stringify(ResponseFormat3$outboundSchema.parse(responseFormat3));
}
export function responseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat3' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatType
> = z.nativeEnum(CreateAgentResponseFormatType);
/** @internal */
export const CreateAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatType
> = CreateAgentResponseFormatType$inboundSchema;

/** @internal */
export const ResponseFormat2$inboundSchema: z.ZodType<
  ResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type ResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormat2$outboundSchema: z.ZodType<
  ResponseFormat2$Outbound,
  z.ZodTypeDef,
  ResponseFormat2
> = z.object({
  type: CreateAgentResponseFormatType$outboundSchema,
});

export function responseFormat2ToJSON(
  responseFormat2: ResponseFormat2,
): string {
  return JSON.stringify(ResponseFormat2$outboundSchema.parse(responseFormat2));
}
export function responseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat2' from JSON`,
  );
}

/** @internal */
export const ResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormatType
> = z.nativeEnum(ResponseFormatType);
/** @internal */
export const ResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseFormatType
> = ResponseFormatType$inboundSchema;

/** @internal */
export const ResponseFormat1$inboundSchema: z.ZodType<
  ResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ResponseFormatType$inboundSchema,
});
/** @internal */
export type ResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormat1$outboundSchema: z.ZodType<
  ResponseFormat1$Outbound,
  z.ZodTypeDef,
  ResponseFormat1
> = z.object({
  type: ResponseFormatType$outboundSchema,
});

export function responseFormat1ToJSON(
  responseFormat1: ResponseFormat1,
): string {
  return JSON.stringify(ResponseFormat1$outboundSchema.parse(responseFormat1));
}
export function responseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat1' from JSON`,
  );
}

/** @internal */
export const ResponseFormat$inboundSchema: z.ZodType<
  ResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseFormat3$inboundSchema),
  z.lazy(() => ResponseFormat1$inboundSchema),
  z.lazy(() => ResponseFormat2$inboundSchema),
]);
/** @internal */
export type ResponseFormat$Outbound =
  | ResponseFormat3$Outbound
  | ResponseFormat1$Outbound
  | ResponseFormat2$Outbound;

/** @internal */
export const ResponseFormat$outboundSchema: z.ZodType<
  ResponseFormat$Outbound,
  z.ZodTypeDef,
  ResponseFormat
> = z.union([
  z.lazy(() => ResponseFormat3$outboundSchema),
  z.lazy(() => ResponseFormat1$outboundSchema),
  z.lazy(() => ResponseFormat2$outboundSchema),
]);

export function responseFormatToJSON(responseFormat: ResponseFormat): string {
  return JSON.stringify(ResponseFormat$outboundSchema.parse(responseFormat));
}
export function responseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat' from JSON`,
  );
}

/** @internal */
export const Stop$inboundSchema: z.ZodType<Stop, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);
/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}
export function stopFromJSON(
  jsonString: string,
): SafeParseResult<Stop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stop' from JSON`,
  );
}

/** @internal */
export const StreamOptions$inboundSchema: z.ZodType<
  StreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type StreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamOptions$outboundSchema: z.ZodType<
  StreamOptions$Outbound,
  z.ZodTypeDef,
  StreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamOptionsToJSON(streamOptions: StreamOptions): string {
  return JSON.stringify(StreamOptions$outboundSchema.parse(streamOptions));
}
export function streamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentModelType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModelType
> = z.nativeEnum(CreateAgentModelType);
/** @internal */
export const CreateAgentModelType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModelType
> = CreateAgentModelType$inboundSchema;

/** @internal */
export const Thinking$inboundSchema: z.ZodType<
  Thinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentModelType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type Thinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const Thinking$outboundSchema: z.ZodType<
  Thinking$Outbound,
  z.ZodTypeDef,
  Thinking
> = z.object({
  type: CreateAgentModelType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function thinkingToJSON(thinking: Thinking): string {
  return JSON.stringify(Thinking$outboundSchema.parse(thinking));
}
export function thinkingFromJSON(
  jsonString: string,
): SafeParseResult<Thinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thinking' from JSON`,
  );
}

/** @internal */
export const ToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = z.nativeEnum(ToolChoiceType);
/** @internal */
export const ToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = ToolChoiceType$inboundSchema;

/** @internal */
export const ToolChoiceFunction$inboundSchema: z.ZodType<
  ToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ToolChoiceFunction$outboundSchema: z.ZodType<
  ToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function toolChoiceFunctionToJSON(
  toolChoiceFunction: ToolChoiceFunction,
): string {
  return JSON.stringify(
    ToolChoiceFunction$outboundSchema.parse(toolChoiceFunction),
  );
}
export function toolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ToolChoice2$inboundSchema: z.ZodType<
  ToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$inboundSchema),
});
/** @internal */
export type ToolChoice2$Outbound = {
  type?: string | undefined;
  function: ToolChoiceFunction$Outbound;
};

/** @internal */
export const ToolChoice2$outboundSchema: z.ZodType<
  ToolChoice2$Outbound,
  z.ZodTypeDef,
  ToolChoice2
> = z.object({
  type: ToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$outboundSchema),
});

export function toolChoice2ToJSON(toolChoice2: ToolChoice2): string {
  return JSON.stringify(ToolChoice2$outboundSchema.parse(toolChoice2));
}
export function toolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice2' from JSON`,
  );
}

/** @internal */
export const ToolChoice1$inboundSchema: z.ZodNativeEnum<typeof ToolChoice1> = z
  .nativeEnum(ToolChoice1);
/** @internal */
export const ToolChoice1$outboundSchema: z.ZodNativeEnum<typeof ToolChoice1> =
  ToolChoice1$inboundSchema;

/** @internal */
export const ToolChoice$inboundSchema: z.ZodType<
  ToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ToolChoice2$inboundSchema),
  ToolChoice1$inboundSchema,
]);
/** @internal */
export type ToolChoice$Outbound = ToolChoice2$Outbound | string;

/** @internal */
export const ToolChoice$outboundSchema: z.ZodType<
  ToolChoice$Outbound,
  z.ZodTypeDef,
  ToolChoice
> = z.union([
  z.lazy(() => ToolChoice2$outboundSchema),
  ToolChoice1$outboundSchema,
]);

export function toolChoiceToJSON(toolChoice: ToolChoice): string {
  return JSON.stringify(ToolChoice$outboundSchema.parse(toolChoice));
}
export function toolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice' from JSON`,
  );
}

/** @internal */
export const Modalities$inboundSchema: z.ZodNativeEnum<typeof Modalities> = z
  .nativeEnum(Modalities);
/** @internal */
export const Modalities$outboundSchema: z.ZodNativeEnum<typeof Modalities> =
  Modalities$inboundSchema;

/** @internal */
export const WebSearchOptions$inboundSchema: z.ZodType<
  WebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type WebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const WebSearchOptions$outboundSchema: z.ZodType<
  WebSearchOptions$Outbound,
  z.ZodTypeDef,
  WebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function webSearchOptionsToJSON(
  webSearchOptions: WebSearchOptions,
): string {
  return JSON.stringify(
    WebSearchOptions$outboundSchema.parse(webSearchOptions),
  );
}
export function webSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<WebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebSearchOptions' from JSON`,
  );
}

/** @internal */
export const ParametersT$inboundSchema: z.ZodType<
  ParametersT,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ModelAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ResponseFormat3$inboundSchema),
    z.lazy(() => ResponseFormat1$inboundSchema),
    z.lazy(() => ResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(z.lazy(() => StreamOptions$inboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ToolChoice2$inboundSchema),
    ToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$inboundSchema)).optional(),
  web_search_options: z.lazy(() => WebSearchOptions$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type ParametersT$Outbound = {
  audio?: ModelAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ResponseFormat3$Outbound
    | ResponseFormat1$Outbound
    | ResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: StreamOptions$Outbound | null | undefined;
  thinking?: Thinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: WebSearchOptions$Outbound | undefined;
};

/** @internal */
export const ParametersT$outboundSchema: z.ZodType<
  ParametersT$Outbound,
  z.ZodTypeDef,
  ParametersT
> = z.object({
  audio: z.nullable(z.lazy(() => ModelAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ResponseFormat3$outboundSchema),
    z.lazy(() => ResponseFormat1$outboundSchema),
    z.lazy(() => ResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => StreamOptions$outboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ToolChoice2$outboundSchema),
    ToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$outboundSchema)).optional(),
  webSearchOptions: z.lazy(() => WebSearchOptions$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function parametersToJSON(parametersT: ParametersT): string {
  return JSON.stringify(ParametersT$outboundSchema.parse(parametersT));
}
export function parametersFromJSON(
  jsonString: string,
): SafeParseResult<ParametersT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParametersT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParametersT' from JSON`,
  );
}

/** @internal */
export const Model2$inboundSchema: z.ZodType<Model2, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    integration_id: z.nullable(z.string()).optional(),
    parameters: z.lazy(() => ParametersT$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "integration_id": "integrationId",
    });
  });
/** @internal */
export type Model2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: ParametersT$Outbound | undefined;
};

/** @internal */
export const Model2$outboundSchema: z.ZodType<
  Model2$Outbound,
  z.ZodTypeDef,
  Model2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ParametersT$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function model2ToJSON(model2: Model2): string {
  return JSON.stringify(Model2$outboundSchema.parse(model2));
}
export function model2FromJSON(
  jsonString: string,
): SafeParseResult<Model2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model2' from JSON`,
  );
}

/** @internal */
export const Model$inboundSchema: z.ZodType<Model, z.ZodTypeDef, unknown> = z
  .union([z.lazy(() => Model2$inboundSchema), z.string()]);
/** @internal */
export type Model$Outbound = Model2$Outbound | string;

/** @internal */
export const Model$outboundSchema: z.ZodType<
  Model$Outbound,
  z.ZodTypeDef,
  Model
> = z.union([z.lazy(() => Model2$outboundSchema), z.string()]);

export function modelToJSON(model: Model): string {
  return JSON.stringify(Model$outboundSchema.parse(model));
}
export function modelFromJSON(
  jsonString: string,
): SafeParseResult<Model, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model' from JSON`,
  );
}

/** @internal */
export const FallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsVoice
> = z.nativeEnum(FallbackModelsVoice);
/** @internal */
export const FallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsVoice
> = FallbackModelsVoice$inboundSchema;

/** @internal */
export const FallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsFormat
> = z.nativeEnum(FallbackModelsFormat);
/** @internal */
export const FallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsFormat
> = FallbackModelsFormat$inboundSchema;

/** @internal */
export const FallbackModelsAudio$inboundSchema: z.ZodType<
  FallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: FallbackModelsVoice$inboundSchema,
  format: FallbackModelsFormat$inboundSchema,
});
/** @internal */
export type FallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const FallbackModelsAudio$outboundSchema: z.ZodType<
  FallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  FallbackModelsAudio
> = z.object({
  voice: FallbackModelsVoice$outboundSchema,
  format: FallbackModelsFormat$outboundSchema,
});

export function fallbackModelsAudioToJSON(
  fallbackModelsAudio: FallbackModelsAudio,
): string {
  return JSON.stringify(
    FallbackModelsAudio$outboundSchema.parse(fallbackModelsAudio),
  );
}
export function fallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > =
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema;

/** @internal */
export const ResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type ResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function responseFormatJsonSchemaToJSON(
  responseFormatJsonSchema: ResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ResponseFormatJsonSchema$outboundSchema.parse(responseFormatJsonSchema),
  );
}
export function responseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormat3$inboundSchema: z.ZodType<
  CreateAgentResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema,
  json_schema: z.lazy(() => ResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type CreateAgentResponseFormat3$Outbound = {
  type: string;
  json_schema: ResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentResponseFormat3$outboundSchema: z.ZodType<
  CreateAgentResponseFormat3$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormat3
> = z.object({
  type:
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema,
  jsonSchema: z.lazy(() => ResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function createAgentResponseFormat3ToJSON(
  createAgentResponseFormat3: CreateAgentResponseFormat3,
): string {
  return JSON.stringify(
    CreateAgentResponseFormat3$outboundSchema.parse(createAgentResponseFormat3),
  );
}
export function createAgentResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormat3' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
  > = z.nativeEnum(CreateAgentResponseFormatAgentsRequestRequestBodyType);
/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
  > = CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormat2$inboundSchema: z.ZodType<
  CreateAgentResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormat2$outboundSchema: z.ZodType<
  CreateAgentResponseFormat2$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormat2
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema,
});

export function createAgentResponseFormat2ToJSON(
  createAgentResponseFormat2: CreateAgentResponseFormat2,
): string {
  return JSON.stringify(
    CreateAgentResponseFormat2$outboundSchema.parse(createAgentResponseFormat2),
  );
}
export function createAgentResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormat2' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsRequestType> = z
    .nativeEnum(CreateAgentResponseFormatAgentsRequestType);
/** @internal */
export const CreateAgentResponseFormatAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsRequestType> =
    CreateAgentResponseFormatAgentsRequestType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormat1$inboundSchema: z.ZodType<
  CreateAgentResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormat1$outboundSchema: z.ZodType<
  CreateAgentResponseFormat1$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormat1
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestType$outboundSchema,
});

export function createAgentResponseFormat1ToJSON(
  createAgentResponseFormat1: CreateAgentResponseFormat1,
): string {
  return JSON.stringify(
    CreateAgentResponseFormat1$outboundSchema.parse(createAgentResponseFormat1),
  );
}
export function createAgentResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormat1' from JSON`,
  );
}

/** @internal */
export const FallbackModelsResponseFormat$inboundSchema: z.ZodType<
  FallbackModelsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentResponseFormat3$inboundSchema),
  z.lazy(() => CreateAgentResponseFormat1$inboundSchema),
  z.lazy(() => CreateAgentResponseFormat2$inboundSchema),
]);
/** @internal */
export type FallbackModelsResponseFormat$Outbound =
  | CreateAgentResponseFormat3$Outbound
  | CreateAgentResponseFormat1$Outbound
  | CreateAgentResponseFormat2$Outbound;

/** @internal */
export const FallbackModelsResponseFormat$outboundSchema: z.ZodType<
  FallbackModelsResponseFormat$Outbound,
  z.ZodTypeDef,
  FallbackModelsResponseFormat
> = z.union([
  z.lazy(() => CreateAgentResponseFormat3$outboundSchema),
  z.lazy(() => CreateAgentResponseFormat1$outboundSchema),
  z.lazy(() => CreateAgentResponseFormat2$outboundSchema),
]);

export function fallbackModelsResponseFormatToJSON(
  fallbackModelsResponseFormat: FallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    FallbackModelsResponseFormat$outboundSchema.parse(
      fallbackModelsResponseFormat,
    ),
  );
}
export function fallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const FallbackModelsStop$inboundSchema: z.ZodType<
  FallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type FallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const FallbackModelsStop$outboundSchema: z.ZodType<
  FallbackModelsStop$Outbound,
  z.ZodTypeDef,
  FallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function fallbackModelsStopToJSON(
  fallbackModelsStop: FallbackModelsStop,
): string {
  return JSON.stringify(
    FallbackModelsStop$outboundSchema.parse(fallbackModelsStop),
  );
}
export function fallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const FallbackModelsStreamOptions$inboundSchema: z.ZodType<
  FallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type FallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const FallbackModelsStreamOptions$outboundSchema: z.ZodType<
  FallbackModelsStreamOptions$Outbound,
  z.ZodTypeDef,
  FallbackModelsStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function fallbackModelsStreamOptionsToJSON(
  fallbackModelsStreamOptions: FallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    FallbackModelsStreamOptions$outboundSchema.parse(
      fallbackModelsStreamOptions,
    ),
  );
}
export function fallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const FallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsType
> = z.nativeEnum(FallbackModelsType);
/** @internal */
export const FallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsType
> = FallbackModelsType$inboundSchema;

/** @internal */
export const FallbackModelsThinking$inboundSchema: z.ZodType<
  FallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type FallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const FallbackModelsThinking$outboundSchema: z.ZodType<
  FallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  FallbackModelsThinking
> = z.object({
  type: FallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function fallbackModelsThinkingToJSON(
  fallbackModelsThinking: FallbackModelsThinking,
): string {
  return JSON.stringify(
    FallbackModelsThinking$outboundSchema.parse(fallbackModelsThinking),
  );
}
export function fallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceType
> = z.nativeEnum(CreateAgentToolChoiceType);
/** @internal */
export const CreateAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceType
> = CreateAgentToolChoiceType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceFunction$inboundSchema: z.ZodType<
  CreateAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type CreateAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceFunction$outboundSchema: z.ZodType<
  CreateAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function createAgentToolChoiceFunctionToJSON(
  createAgentToolChoiceFunction: CreateAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceFunction$outboundSchema.parse(
      createAgentToolChoiceFunction,
    ),
  );
}
export function createAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoice2$inboundSchema: z.ZodType<
  CreateAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type CreateAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoice2$outboundSchema: z.ZodType<
  CreateAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoice2
> = z.object({
  type: CreateAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceFunction$outboundSchema),
});

export function createAgentToolChoice2ToJSON(
  createAgentToolChoice2: CreateAgentToolChoice2,
): string {
  return JSON.stringify(
    CreateAgentToolChoice2$outboundSchema.parse(createAgentToolChoice2),
  );
}
export function createAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoice1
> = z.nativeEnum(CreateAgentToolChoice1);
/** @internal */
export const CreateAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoice1
> = CreateAgentToolChoice1$inboundSchema;

/** @internal */
export const FallbackModelsToolChoice$inboundSchema: z.ZodType<
  FallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentToolChoice2$inboundSchema),
  CreateAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type FallbackModelsToolChoice$Outbound =
  | CreateAgentToolChoice2$Outbound
  | string;

/** @internal */
export const FallbackModelsToolChoice$outboundSchema: z.ZodType<
  FallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  FallbackModelsToolChoice
> = z.union([
  z.lazy(() => CreateAgentToolChoice2$outboundSchema),
  CreateAgentToolChoice1$outboundSchema,
]);

export function fallbackModelsToolChoiceToJSON(
  fallbackModelsToolChoice: FallbackModelsToolChoice,
): string {
  return JSON.stringify(
    FallbackModelsToolChoice$outboundSchema.parse(fallbackModelsToolChoice),
  );
}
export function fallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const FallbackModelsModalities$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsModalities
> = z.nativeEnum(FallbackModelsModalities);
/** @internal */
export const FallbackModelsModalities$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelsModalities
> = FallbackModelsModalities$inboundSchema;

/** @internal */
export const FallbackModelsWebSearchOptions$inboundSchema: z.ZodType<
  FallbackModelsWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type FallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const FallbackModelsWebSearchOptions$outboundSchema: z.ZodType<
  FallbackModelsWebSearchOptions$Outbound,
  z.ZodTypeDef,
  FallbackModelsWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function fallbackModelsWebSearchOptionsToJSON(
  fallbackModelsWebSearchOptions: FallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    FallbackModelsWebSearchOptions$outboundSchema.parse(
      fallbackModelsWebSearchOptions,
    ),
  );
}
export function fallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const FallbackModelsParameters$inboundSchema: z.ZodType<
  FallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => FallbackModelsAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentResponseFormat3$inboundSchema),
    z.lazy(() => CreateAgentResponseFormat1$inboundSchema),
    z.lazy(() => CreateAgentResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => FallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelsThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentToolChoice2$inboundSchema),
    CreateAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(FallbackModelsModalities$inboundSchema))
    .optional(),
  web_search_options: z.lazy(() => FallbackModelsWebSearchOptions$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type FallbackModelsParameters$Outbound = {
  audio?: FallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormat3$Outbound
    | CreateAgentResponseFormat1$Outbound
    | CreateAgentResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: FallbackModelsStreamOptions$Outbound | null | undefined;
  thinking?: FallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: FallbackModelsWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const FallbackModelsParameters$outboundSchema: z.ZodType<
  FallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  FallbackModelsParameters
> = z.object({
  audio: z.nullable(z.lazy(() => FallbackModelsAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateAgentResponseFormat3$outboundSchema),
    z.lazy(() => CreateAgentResponseFormat1$outboundSchema),
    z.lazy(() => CreateAgentResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => FallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelsThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentToolChoice2$outboundSchema),
    CreateAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(FallbackModelsModalities$outboundSchema))
    .optional(),
  webSearchOptions: z.lazy(() => FallbackModelsWebSearchOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function fallbackModelsParametersToJSON(
  fallbackModelsParameters: FallbackModelsParameters,
): string {
  return JSON.stringify(
    FallbackModelsParameters$outboundSchema.parse(fallbackModelsParameters),
  );
}
export function fallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const FallbackModels2$inboundSchema: z.ZodType<
  FallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => FallbackModelsParameters$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type FallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: FallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const FallbackModels2$outboundSchema: z.ZodType<
  FallbackModels2$Outbound,
  z.ZodTypeDef,
  FallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => FallbackModelsParameters$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function fallbackModels2ToJSON(
  fallbackModels2: FallbackModels2,
): string {
  return JSON.stringify(FallbackModels2$outboundSchema.parse(fallbackModels2));
}
export function fallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<FallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModels2' from JSON`,
  );
}

/** @internal */
export const FallbackModels$inboundSchema: z.ZodType<
  FallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => FallbackModels2$inboundSchema), z.string()]);
/** @internal */
export type FallbackModels$Outbound = FallbackModels2$Outbound | string;

/** @internal */
export const FallbackModels$outboundSchema: z.ZodType<
  FallbackModels$Outbound,
  z.ZodTypeDef,
  FallbackModels
> = z.union([z.lazy(() => FallbackModels2$outboundSchema), z.string()]);

export function fallbackModelsToJSON(fallbackModels: FallbackModels): string {
  return JSON.stringify(FallbackModels$outboundSchema.parse(fallbackModels));
}
export function fallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModels' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);
/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = ToolApprovalRequired$inboundSchema;

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema;

/** @internal */
export const FunctionTool$inboundSchema: z.ZodType<
  FunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type FunctionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const FunctionTool$outboundSchema: z.ZodType<
  FunctionTool$Outbound,
  z.ZodTypeDef,
  FunctionTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function functionToolToJSON(functionTool: FunctionTool): string {
  return JSON.stringify(FunctionTool$outboundSchema.parse(functionTool));
}
export function functionToolFromJSON(
  jsonString: string,
): SafeParseResult<FunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema;

/** @internal */
export const CodeExecutionTool$inboundSchema: z.ZodType<
  CodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CodeExecutionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const CodeExecutionTool$outboundSchema: z.ZodType<
  CodeExecutionTool$Outbound,
  z.ZodTypeDef,
  CodeExecutionTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function codeExecutionToolToJSON(
  codeExecutionTool: CodeExecutionTool,
): string {
  return JSON.stringify(
    CodeExecutionTool$outboundSchema.parse(codeExecutionTool),
  );
}
export function codeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<CodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema;

/** @internal */
export const HTTPTool$inboundSchema: z.ZodType<
  HTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type HTTPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const HTTPTool$outboundSchema: z.ZodType<
  HTTPTool$Outbound,
  z.ZodTypeDef,
  HTTPTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function httpToolToJSON(httpTool: HTTPTool): string {
  return JSON.stringify(HTTPTool$outboundSchema.parse(httpTool));
}
export function httpToolFromJSON(
  jsonString: string,
): SafeParseResult<HTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HTTPTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema;

/** @internal */
export const CurrentDateTool$inboundSchema: z.ZodType<
  CurrentDateTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CurrentDateTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const CurrentDateTool$outboundSchema: z.ZodType<
  CurrentDateTool$Outbound,
  z.ZodTypeDef,
  CurrentDateTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function currentDateToolToJSON(
  currentDateTool: CurrentDateTool,
): string {
  return JSON.stringify(CurrentDateTool$outboundSchema.parse(currentDateTool));
}
export function currentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<CurrentDateTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CurrentDateTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CurrentDateTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema;

/** @internal */
export const QueryKnowledgeBaseTool$inboundSchema: z.ZodType<
  QueryKnowledgeBaseTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const QueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  QueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  QueryKnowledgeBaseTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryKnowledgeBaseToolToJSON(
  queryKnowledgeBaseTool: QueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    QueryKnowledgeBaseTool$outboundSchema.parse(queryKnowledgeBaseTool),
  );
}
export function queryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryKnowledgeBaseTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryKnowledgeBaseTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema;

/** @internal */
export const RetrieveKnowledgeBasesTool$inboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveKnowledgeBasesTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const RetrieveKnowledgeBasesTool$outboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool$Outbound,
  z.ZodTypeDef,
  RetrieveKnowledgeBasesTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveKnowledgeBasesToolToJSON(
  retrieveKnowledgeBasesTool: RetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    RetrieveKnowledgeBasesTool$outboundSchema.parse(retrieveKnowledgeBasesTool),
  );
}
export function retrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveKnowledgeBasesTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveKnowledgeBasesTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema;

/** @internal */
export const DeleteMemoryDocumentTool$inboundSchema: z.ZodType<
  DeleteMemoryDocumentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type DeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const DeleteMemoryDocumentTool$outboundSchema: z.ZodType<
  DeleteMemoryDocumentTool$Outbound,
  z.ZodTypeDef,
  DeleteMemoryDocumentTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function deleteMemoryDocumentToolToJSON(
  deleteMemoryDocumentTool: DeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    DeleteMemoryDocumentTool$outboundSchema.parse(deleteMemoryDocumentTool),
  );
}
export function deleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<DeleteMemoryDocumentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteMemoryDocumentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema;

/** @internal */
export const RetrieveMemoryStoresTool$inboundSchema: z.ZodType<
  RetrieveMemoryStoresTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const RetrieveMemoryStoresTool$outboundSchema: z.ZodType<
  RetrieveMemoryStoresTool$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoresTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveMemoryStoresToolToJSON(
  retrieveMemoryStoresTool: RetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    RetrieveMemoryStoresTool$outboundSchema.parse(retrieveMemoryStoresTool),
  );
}
export function retrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoresTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryStoresTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema;

/** @internal */
export const WriteMemoryStoreTool$inboundSchema: z.ZodType<
  WriteMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const WriteMemoryStoreTool$outboundSchema: z.ZodType<
  WriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  WriteMemoryStoreTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function writeMemoryStoreToolToJSON(
  writeMemoryStoreTool: WriteMemoryStoreTool,
): string {
  return JSON.stringify(
    WriteMemoryStoreTool$outboundSchema.parse(writeMemoryStoreTool),
  );
}
export function writeMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<WriteMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WriteMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
  > = z.nativeEnum(CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
  > = CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const QueryMemoryStoreTool$inboundSchema: z.ZodType<
  QueryMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const QueryMemoryStoreTool$outboundSchema: z.ZodType<
  QueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  QueryMemoryStoreTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryMemoryStoreToolToJSON(
  queryMemoryStoreTool: QueryMemoryStoreTool,
): string {
  return JSON.stringify(
    QueryMemoryStoreTool$outboundSchema.parse(queryMemoryStoreTool),
  );
}
export function queryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestType> = z
    .nativeEnum(CreateAgentAgentToolInputCRUDAgentsRequestType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestType> =
    CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema;

/** @internal */
export const RetrieveAgentsTool$inboundSchema: z.ZodType<
  RetrieveAgentsTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const RetrieveAgentsTool$outboundSchema: z.ZodType<
  RetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  RetrieveAgentsTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveAgentsToolToJSON(
  retrieveAgentsTool: RetrieveAgentsTool,
): string {
  return JSON.stringify(
    RetrieveAgentsTool$outboundSchema.parse(retrieveAgentsTool),
  );
}
export function retrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentsTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentsTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsType> = z
    .nativeEnum(CreateAgentAgentToolInputCRUDAgentsType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsType> =
    CreateAgentAgentToolInputCRUDAgentsType$inboundSchema;

/** @internal */
export const CallSubAgentTool$inboundSchema: z.ZodType<
  CallSubAgentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CallSubAgentTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const CallSubAgentTool$outboundSchema: z.ZodType<
  CallSubAgentTool$Outbound,
  z.ZodTypeDef,
  CallSubAgentTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function callSubAgentToolToJSON(
  callSubAgentTool: CallSubAgentTool,
): string {
  return JSON.stringify(
    CallSubAgentTool$outboundSchema.parse(callSubAgentTool),
  );
}
export function callSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<CallSubAgentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CallSubAgentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentAgentToolInputCRUDType
> = z.nativeEnum(CreateAgentAgentToolInputCRUDType);
/** @internal */
export const CreateAgentAgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentAgentToolInputCRUDType
> = CreateAgentAgentToolInputCRUDType$inboundSchema;

/** @internal */
export const WebScraperTool$inboundSchema: z.ZodType<
  WebScraperTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WebScraperTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const WebScraperTool$outboundSchema: z.ZodType<
  WebScraperTool$Outbound,
  z.ZodTypeDef,
  WebScraperTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function webScraperToolToJSON(webScraperTool: WebScraperTool): string {
  return JSON.stringify(WebScraperTool$outboundSchema.parse(webScraperTool));
}
export function webScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<WebScraperTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebScraperTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebScraperTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDType$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputCRUDType
> = z.nativeEnum(AgentToolInputCRUDType);
/** @internal */
export const AgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputCRUDType
> = AgentToolInputCRUDType$inboundSchema;

/** @internal */
export const GoogleSearchTool$inboundSchema: z.ZodType<
  GoogleSearchTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AgentToolInputCRUDType$inboundSchema,
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type GoogleSearchTool$Outbound = {
  type: string;
  requires_approval: boolean;
};

/** @internal */
export const GoogleSearchTool$outboundSchema: z.ZodType<
  GoogleSearchTool$Outbound,
  z.ZodTypeDef,
  GoogleSearchTool
> = z.object({
  type: AgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function googleSearchToolToJSON(
  googleSearchTool: GoogleSearchTool,
): string {
  return JSON.stringify(
    GoogleSearchTool$outboundSchema.parse(googleSearchTool),
  );
}
export function googleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<GoogleSearchTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GoogleSearchTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUD$inboundSchema: z.ZodType<
  AgentToolInputCRUD,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GoogleSearchTool$inboundSchema),
  z.lazy(() => WebScraperTool$inboundSchema),
  z.lazy(() => CallSubAgentTool$inboundSchema),
  z.lazy(() => RetrieveAgentsTool$inboundSchema),
  z.lazy(() => QueryMemoryStoreTool$inboundSchema),
  z.lazy(() => WriteMemoryStoreTool$inboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
  z.lazy(() => CurrentDateTool$inboundSchema),
  z.lazy(() => HTTPTool$inboundSchema),
  z.lazy(() => CodeExecutionTool$inboundSchema),
  z.lazy(() => FunctionTool$inboundSchema),
]);
/** @internal */
export type AgentToolInputCRUD$Outbound =
  | GoogleSearchTool$Outbound
  | WebScraperTool$Outbound
  | CallSubAgentTool$Outbound
  | RetrieveAgentsTool$Outbound
  | QueryMemoryStoreTool$Outbound
  | WriteMemoryStoreTool$Outbound
  | RetrieveMemoryStoresTool$Outbound
  | DeleteMemoryDocumentTool$Outbound
  | RetrieveKnowledgeBasesTool$Outbound
  | QueryKnowledgeBaseTool$Outbound
  | CurrentDateTool$Outbound
  | HTTPTool$Outbound
  | CodeExecutionTool$Outbound
  | FunctionTool$Outbound;

/** @internal */
export const AgentToolInputCRUD$outboundSchema: z.ZodType<
  AgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUD
> = z.union([
  z.lazy(() => GoogleSearchTool$outboundSchema),
  z.lazy(() => WebScraperTool$outboundSchema),
  z.lazy(() => CallSubAgentTool$outboundSchema),
  z.lazy(() => RetrieveAgentsTool$outboundSchema),
  z.lazy(() => QueryMemoryStoreTool$outboundSchema),
  z.lazy(() => WriteMemoryStoreTool$outboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => CurrentDateTool$outboundSchema),
  z.lazy(() => HTTPTool$outboundSchema),
  z.lazy(() => CodeExecutionTool$outboundSchema),
  z.lazy(() => FunctionTool$outboundSchema),
]);

export function agentToolInputCRUDToJSON(
  agentToolInputCRUD: AgentToolInputCRUD,
): string {
  return JSON.stringify(
    AgentToolInputCRUD$outboundSchema.parse(agentToolInputCRUD),
  );
}
export function agentToolInputCRUDFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUD, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUD$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUD' from JSON`,
  );
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$inboundSchema),
      z.lazy(() => WebScraperTool$inboundSchema),
      z.lazy(() => CallSubAgentTool$inboundSchema),
      z.lazy(() => RetrieveAgentsTool$inboundSchema),
      z.lazy(() => QueryMemoryStoreTool$inboundSchema),
      z.lazy(() => WriteMemoryStoreTool$inboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
      z.lazy(() => CurrentDateTool$inboundSchema),
      z.lazy(() => HTTPTool$inboundSchema),
      z.lazy(() => CodeExecutionTool$inboundSchema),
      z.lazy(() => FunctionTool$inboundSchema),
    ]),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type Settings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | GoogleSearchTool$Outbound
      | WebScraperTool$Outbound
      | CallSubAgentTool$Outbound
      | RetrieveAgentsTool$Outbound
      | QueryMemoryStoreTool$Outbound
      | WriteMemoryStoreTool$Outbound
      | RetrieveMemoryStoresTool$Outbound
      | DeleteMemoryDocumentTool$Outbound
      | RetrieveKnowledgeBasesTool$Outbound
      | QueryKnowledgeBaseTool$Outbound
      | CurrentDateTool$Outbound
      | HTTPTool$Outbound
      | CodeExecutionTool$Outbound
      | FunctionTool$Outbound
    >
    | undefined;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$outboundSchema),
      z.lazy(() => WebScraperTool$outboundSchema),
      z.lazy(() => CallSubAgentTool$outboundSchema),
      z.lazy(() => RetrieveAgentsTool$outboundSchema),
      z.lazy(() => QueryMemoryStoreTool$outboundSchema),
      z.lazy(() => WriteMemoryStoreTool$outboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => CurrentDateTool$outboundSchema),
      z.lazy(() => HTTPTool$outboundSchema),
      z.lazy(() => CodeExecutionTool$outboundSchema),
      z.lazy(() => FunctionTool$outboundSchema),
    ]),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}
export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const KnowledgeBases$inboundSchema: z.ZodType<
  KnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type KnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const KnowledgeBases$outboundSchema: z.ZodType<
  KnowledgeBases$Outbound,
  z.ZodTypeDef,
  KnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function knowledgeBasesToJSON(knowledgeBases: KnowledgeBases): string {
  return JSON.stringify(KnowledgeBases$outboundSchema.parse(knowledgeBases));
}
export function knowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeBases' from JSON`,
  );
}

/** @internal */
export const TeamOfAgents$inboundSchema: z.ZodType<
  TeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type TeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const TeamOfAgents$outboundSchema: z.ZodType<
  TeamOfAgents$Outbound,
  z.ZodTypeDef,
  TeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function teamOfAgentsToJSON(teamOfAgents: TeamOfAgents): string {
  return JSON.stringify(TeamOfAgents$outboundSchema.parse(teamOfAgents));
}
export function teamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<TeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamOfAgents' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestBody$inboundSchema: z.ZodType<
  CreateAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  system_prompt: z.string().optional(),
  model: z.union([z.lazy(() => Model2$inboundSchema), z.string()]),
  fallback_models: z.array(
    z.union([z.lazy(() => FallbackModels2$inboundSchema), z.string()]),
  ).optional(),
  settings: z.lazy(() => Settings$inboundSchema),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(z.lazy(() => KnowledgeBases$inboundSchema))
    .optional(),
  team_of_agents: z.array(z.lazy(() => TeamOfAgents$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "system_prompt": "systemPrompt",
    "fallback_models": "fallbackModels",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});
/** @internal */
export type CreateAgentRequestBody$Outbound = {
  path: string;
  key: string;
  role: string;
  description: string;
  instructions: string;
  system_prompt?: string | undefined;
  model: Model2$Outbound | string;
  fallback_models?: Array<FallbackModels2$Outbound | string> | undefined;
  settings: Settings$Outbound;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<KnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<TeamOfAgents$Outbound> | undefined;
};

/** @internal */
export const CreateAgentRequestBody$outboundSchema: z.ZodType<
  CreateAgentRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestBody
> = z.object({
  path: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  systemPrompt: z.string().optional(),
  model: z.union([z.lazy(() => Model2$outboundSchema), z.string()]),
  fallbackModels: z.array(
    z.union([z.lazy(() => FallbackModels2$outboundSchema), z.string()]),
  ).optional(),
  settings: z.lazy(() => Settings$outboundSchema),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => KnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => TeamOfAgents$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function createAgentRequestBodyToJSON(
  createAgentRequestBody: CreateAgentRequestBody,
): string {
  return JSON.stringify(
    CreateAgentRequestBody$outboundSchema.parse(createAgentRequestBody),
  );
}
export function createAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentStatus
> = z.nativeEnum(CreateAgentStatus);
/** @internal */
export const CreateAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentStatus
> = CreateAgentStatus$inboundSchema;

/** @internal */
export const CreateAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolApprovalRequired
> = z.nativeEnum(CreateAgentToolApprovalRequired);
/** @internal */
export const CreateAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolApprovalRequired
> = CreateAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type Conditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const Conditions$outboundSchema: z.ZodType<
  Conditions$Outbound,
  z.ZodTypeDef,
  Conditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function conditionsToJSON(conditions: Conditions): string {
  return JSON.stringify(Conditions$outboundSchema.parse(conditions));
}
export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const CreateAgentTools$inboundSchema: z.ZodType<
  CreateAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => Conditions$inboundSchema)).optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CreateAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<Conditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const CreateAgentTools$outboundSchema: z.ZodType<
  CreateAgentTools$Outbound,
  z.ZodTypeDef,
  CreateAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => Conditions$outboundSchema)).optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function createAgentToolsToJSON(
  createAgentTools: CreateAgentTools,
): string {
  return JSON.stringify(
    CreateAgentTools$outboundSchema.parse(createAgentTools),
  );
}
export function createAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentTools' from JSON`,
  );
}

/** @internal */
export const CreateAgentSettings$inboundSchema: z.ZodType<
  CreateAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: CreateAgentToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => CreateAgentTools$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type CreateAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<CreateAgentTools$Outbound> | undefined;
};

/** @internal */
export const CreateAgentSettings$outboundSchema: z.ZodType<
  CreateAgentSettings$Outbound,
  z.ZodTypeDef,
  CreateAgentSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: CreateAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => CreateAgentTools$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function createAgentSettingsToJSON(
  createAgentSettings: CreateAgentSettings,
): string {
  return JSON.stringify(
    CreateAgentSettings$outboundSchema.parse(createAgentSettings),
  );
}
export function createAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentSettings' from JSON`,
  );
}

/** @internal */
export const CreateAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentVoice
> = z.nativeEnum(CreateAgentVoice);
/** @internal */
export const CreateAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentVoice
> = CreateAgentVoice$inboundSchema;

/** @internal */
export const CreateAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFormat
> = z.nativeEnum(CreateAgentFormat);
/** @internal */
export const CreateAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFormat
> = CreateAgentFormat$inboundSchema;

/** @internal */
export const CreateAgentAudio$inboundSchema: z.ZodType<
  CreateAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateAgentVoice$inboundSchema,
  format: CreateAgentFormat$inboundSchema,
});
/** @internal */
export type CreateAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentAudio$outboundSchema: z.ZodType<
  CreateAgentAudio$Outbound,
  z.ZodTypeDef,
  CreateAgentAudio
> = z.object({
  voice: CreateAgentVoice$outboundSchema,
  format: CreateAgentFormat$outboundSchema,
});

export function createAgentAudioToJSON(
  createAgentAudio: CreateAgentAudio,
): string {
  return JSON.stringify(
    CreateAgentAudio$outboundSchema.parse(createAgentAudio),
  );
}
export function createAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatJsonSchema$inboundSchema: z.ZodType<
  CreateAgentResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type CreateAgentResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateAgentResponseFormatJsonSchema$outboundSchema: z.ZodType<
  CreateAgentResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function createAgentResponseFormatJsonSchemaToJSON(
  createAgentResponseFormatJsonSchema: CreateAgentResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatJsonSchema$outboundSchema.parse(
      createAgentResponseFormatJsonSchema,
    ),
  );
}
export function createAgentResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgents3$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema,
  json_schema: z.lazy(() => CreateAgentResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type CreateAgentResponseFormatAgents3$Outbound = {
  type: string;
  json_schema: CreateAgentResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentResponseFormatAgents3$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents3$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgents3
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema,
  jsonSchema: z.lazy(() => CreateAgentResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function createAgentResponseFormatAgents3ToJSON(
  createAgentResponseFormatAgents3: CreateAgentResponseFormatAgents3,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgents3$outboundSchema.parse(
      createAgentResponseFormatAgents3,
    ),
  );
}
export function createAgentResponseFormatAgents3FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatAgents3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormatAgents3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgents3' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponse201Type> = z
    .nativeEnum(CreateAgentResponseFormatAgentsResponse201Type);
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponse201Type> =
    CreateAgentResponseFormatAgentsResponse201Type$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgents2$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsResponse201Type$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgents2$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgents2$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents2$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgents2
> = z.object({
  type: CreateAgentResponseFormatAgentsResponse201Type$outboundSchema,
});

export function createAgentResponseFormatAgents2ToJSON(
  createAgentResponseFormatAgents2: CreateAgentResponseFormatAgents2,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgents2$outboundSchema.parse(
      createAgentResponseFormatAgents2,
    ),
  );
}
export function createAgentResponseFormatAgents2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormatAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgents2' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponseType> = z
    .nativeEnum(CreateAgentResponseFormatAgentsResponseType);
/** @internal */
export const CreateAgentResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponseType> =
    CreateAgentResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgents1$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsResponseType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgents1$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgents1$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgents1$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgents1
> = z.object({
  type: CreateAgentResponseFormatAgentsResponseType$outboundSchema,
});

export function createAgentResponseFormatAgents1ToJSON(
  createAgentResponseFormatAgents1: CreateAgentResponseFormatAgents1,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgents1$outboundSchema.parse(
      createAgentResponseFormatAgents1,
    ),
  );
}
export function createAgentResponseFormatAgents1FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormatAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgents1' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormat$inboundSchema: z.ZodType<
  CreateAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentResponseFormatAgents3$inboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgents1$inboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgents2$inboundSchema),
]);
/** @internal */
export type CreateAgentResponseFormat$Outbound =
  | CreateAgentResponseFormatAgents3$Outbound
  | CreateAgentResponseFormatAgents1$Outbound
  | CreateAgentResponseFormatAgents2$Outbound;

/** @internal */
export const CreateAgentResponseFormat$outboundSchema: z.ZodType<
  CreateAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormat
> = z.union([
  z.lazy(() => CreateAgentResponseFormatAgents3$outboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgents1$outboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgents2$outboundSchema),
]);

export function createAgentResponseFormatToJSON(
  createAgentResponseFormat: CreateAgentResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentResponseFormat$outboundSchema.parse(createAgentResponseFormat),
  );
}
export function createAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentStop$inboundSchema: z.ZodType<
  CreateAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentStop$Outbound = string | Array<string>;

/** @internal */
export const CreateAgentStop$outboundSchema: z.ZodType<
  CreateAgentStop$Outbound,
  z.ZodTypeDef,
  CreateAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function createAgentStopToJSON(
  createAgentStop: CreateAgentStop,
): string {
  return JSON.stringify(CreateAgentStop$outboundSchema.parse(createAgentStop));
}
export function createAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentStreamOptions$inboundSchema: z.ZodType<
  CreateAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type CreateAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateAgentStreamOptions$outboundSchema: z.ZodType<
  CreateAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createAgentStreamOptionsToJSON(
  createAgentStreamOptions: CreateAgentStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentStreamOptions$outboundSchema.parse(createAgentStreamOptions),
  );
}
export function createAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentType
> = z.nativeEnum(CreateAgentType);
/** @internal */
export const CreateAgentType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentType
> = CreateAgentType$inboundSchema;

/** @internal */
export const CreateAgentThinking$inboundSchema: z.ZodType<
  CreateAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type CreateAgentThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const CreateAgentThinking$outboundSchema: z.ZodType<
  CreateAgentThinking$Outbound,
  z.ZodTypeDef,
  CreateAgentThinking
> = z.object({
  type: CreateAgentType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function createAgentThinkingToJSON(
  createAgentThinking: CreateAgentThinking,
): string {
  return JSON.stringify(
    CreateAgentThinking$outboundSchema.parse(createAgentThinking),
  );
}
export function createAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgentsType
> = z.nativeEnum(CreateAgentToolChoiceAgentsType);
/** @internal */
export const CreateAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgentsType
> = CreateAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type CreateAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function createAgentToolChoiceAgentsFunctionToJSON(
  createAgentToolChoiceAgentsFunction: CreateAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsFunction$outboundSchema.parse(
      createAgentToolChoiceAgentsFunction,
    ),
  );
}
export function createAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type CreateAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgents2
> = z.object({
  type: CreateAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceAgentsFunction$outboundSchema),
});

export function createAgentToolChoiceAgents2ToJSON(
  createAgentToolChoiceAgents2: CreateAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgents2$outboundSchema.parse(
      createAgentToolChoiceAgents2,
    ),
  );
}
export function createAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgents1
> = z.nativeEnum(CreateAgentToolChoiceAgents1);
/** @internal */
export const CreateAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgents1
> = CreateAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const CreateAgentToolChoice$inboundSchema: z.ZodType<
  CreateAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgents2$inboundSchema),
  CreateAgentToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type CreateAgentToolChoice$Outbound =
  | CreateAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const CreateAgentToolChoice$outboundSchema: z.ZodType<
  CreateAgentToolChoice$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoice
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgents2$outboundSchema),
  CreateAgentToolChoiceAgents1$outboundSchema,
]);

export function createAgentToolChoiceToJSON(
  createAgentToolChoice: CreateAgentToolChoice,
): string {
  return JSON.stringify(
    CreateAgentToolChoice$outboundSchema.parse(createAgentToolChoice),
  );
}
export function createAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModalities
> = z.nativeEnum(CreateAgentModalities);
/** @internal */
export const CreateAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModalities
> = CreateAgentModalities$inboundSchema;

/** @internal */
export const CreateAgentWebSearchOptions$inboundSchema: z.ZodType<
  CreateAgentWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CreateAgentWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CreateAgentWebSearchOptions$outboundSchema: z.ZodType<
  CreateAgentWebSearchOptions$Outbound,
  z.ZodTypeDef,
  CreateAgentWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function createAgentWebSearchOptionsToJSON(
  createAgentWebSearchOptions: CreateAgentWebSearchOptions,
): string {
  return JSON.stringify(
    CreateAgentWebSearchOptions$outboundSchema.parse(
      createAgentWebSearchOptions,
    ),
  );
}
export function createAgentWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentParameters$inboundSchema: z.ZodType<
  CreateAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentResponseFormatAgents3$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgents1$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgents2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateAgentStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgents2$inboundSchema),
    CreateAgentToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentModalities$inboundSchema))
    .optional(),
  web_search_options: z.lazy(() => CreateAgentWebSearchOptions$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type CreateAgentParameters$Outbound = {
  audio?: CreateAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormatAgents3$Outbound
    | CreateAgentResponseFormatAgents1$Outbound
    | CreateAgentResponseFormatAgents2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: CreateAgentStreamOptions$Outbound | null | undefined;
  thinking?: CreateAgentThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: CreateAgentWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const CreateAgentParameters$outboundSchema: z.ZodType<
  CreateAgentParameters$Outbound,
  z.ZodTypeDef,
  CreateAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateAgentResponseFormatAgents3$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgents1$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgents2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateAgentStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgents2$outboundSchema),
    CreateAgentToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentModalities$outboundSchema))
    .optional(),
  webSearchOptions: z.lazy(() => CreateAgentWebSearchOptions$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function createAgentParametersToJSON(
  createAgentParameters: CreateAgentParameters,
): string {
  return JSON.stringify(
    CreateAgentParameters$outboundSchema.parse(createAgentParameters),
  );
}
export function createAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsVoice
> = z.nativeEnum(CreateAgentFallbackModelsVoice);
/** @internal */
export const CreateAgentFallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsVoice
> = CreateAgentFallbackModelsVoice$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsFormat
> = z.nativeEnum(CreateAgentFallbackModelsFormat);
/** @internal */
export const CreateAgentFallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsFormat
> = CreateAgentFallbackModelsFormat$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelsAudio$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateAgentFallbackModelsVoice$inboundSchema,
  format: CreateAgentFallbackModelsFormat$inboundSchema,
});
/** @internal */
export type CreateAgentFallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentFallbackModelsAudio$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsAudio
> = z.object({
  voice: CreateAgentFallbackModelsVoice$outboundSchema,
  format: CreateAgentFallbackModelsFormat$outboundSchema,
});

export function createAgentFallbackModelsAudioToJSON(
  createAgentFallbackModelsAudio: CreateAgentFallbackModelsAudio,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsAudio$outboundSchema.parse(
      createAgentFallbackModelsAudio,
    ),
  );
}
export function createAgentFallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentFallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type CreateAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function createAgentResponseFormatAgentsJsonSchemaToJSON(
  createAgentResponseFormatAgentsJsonSchema:
    CreateAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      createAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function createAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse3$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema,
  json_schema: z.lazy(() =>
    CreateAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type CreateAgentResponseFormatAgentsResponse3$Outbound = {
  type: string;
  json_schema: CreateAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentResponseFormatAgentsResponse3$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse3$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgentsResponse3
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$outboundSchema,
  jsonSchema: z.lazy(() =>
    CreateAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function createAgentResponseFormatAgentsResponse3ToJSON(
  createAgentResponseFormatAgentsResponse3:
    CreateAgentResponseFormatAgentsResponse3,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse3$outboundSchema.parse(
      createAgentResponseFormatAgentsResponse3,
    ),
  );
}
export function createAgentResponseFormatAgentsResponse3FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse3,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse3$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse3' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsResponse2$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgentsResponse2$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgentsResponse2$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse2$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgentsResponse2
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$outboundSchema,
});

export function createAgentResponseFormatAgentsResponse2ToJSON(
  createAgentResponseFormatAgentsResponse2:
    CreateAgentResponseFormatAgentsResponse2,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse2$outboundSchema.parse(
      createAgentResponseFormatAgentsResponse2,
    ),
  );
}
export function createAgentResponseFormatAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsResponse1$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgentsResponse1$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgentsResponse1$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsResponse1$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgentsResponse1
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema,
});

export function createAgentResponseFormatAgentsResponse1ToJSON(
  createAgentResponseFormatAgentsResponse1:
    CreateAgentResponseFormatAgentsResponse1,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse1$outboundSchema.parse(
      createAgentResponseFormatAgentsResponse1,
    ),
  );
}
export function createAgentResponseFormatAgentsResponse1FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse1' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsResponseFormat$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentResponseFormatAgentsResponse3$inboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgentsResponse1$inboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgentsResponse2$inboundSchema),
]);
/** @internal */
export type CreateAgentFallbackModelsResponseFormat$Outbound =
  | CreateAgentResponseFormatAgentsResponse3$Outbound
  | CreateAgentResponseFormatAgentsResponse1$Outbound
  | CreateAgentResponseFormatAgentsResponse2$Outbound;

/** @internal */
export const CreateAgentFallbackModelsResponseFormat$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsResponseFormat
> = z.union([
  z.lazy(() => CreateAgentResponseFormatAgentsResponse3$outboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgentsResponse1$outboundSchema),
  z.lazy(() => CreateAgentResponseFormatAgentsResponse2$outboundSchema),
]);

export function createAgentFallbackModelsResponseFormatToJSON(
  createAgentFallbackModelsResponseFormat:
    CreateAgentFallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsResponseFormat$outboundSchema.parse(
      createAgentFallbackModelsResponseFormat,
    ),
  );
}
export function createAgentFallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelsResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsStop$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentFallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const CreateAgentFallbackModelsStop$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsStop$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function createAgentFallbackModelsStopToJSON(
  createAgentFallbackModelsStop: CreateAgentFallbackModelsStop,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsStop$outboundSchema.parse(
      createAgentFallbackModelsStop,
    ),
  );
}
export function createAgentFallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentFallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsStreamOptions$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type CreateAgentFallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateAgentFallbackModelsStreamOptions$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createAgentFallbackModelsStreamOptionsToJSON(
  createAgentFallbackModelsStreamOptions:
    CreateAgentFallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsStreamOptions$outboundSchema.parse(
      createAgentFallbackModelsStreamOptions,
    ),
  );
}
export function createAgentFallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsType
> = z.nativeEnum(CreateAgentFallbackModelsType);
/** @internal */
export const CreateAgentFallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsType
> = CreateAgentFallbackModelsType$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelsThinking$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentFallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type CreateAgentFallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const CreateAgentFallbackModelsThinking$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsThinking
> = z.object({
  type: CreateAgentFallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function createAgentFallbackModelsThinkingToJSON(
  createAgentFallbackModelsThinking: CreateAgentFallbackModelsThinking,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsThinking$outboundSchema.parse(
      createAgentFallbackModelsThinking,
    ),
  );
}
export function createAgentFallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentFallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponseType> = z
    .nativeEnum(CreateAgentToolChoiceAgentsResponseType);
/** @internal */
export const CreateAgentToolChoiceAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponseType> =
    CreateAgentToolChoiceAgentsResponseType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    CreateAgentToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
  });
/** @internal */
export type CreateAgentToolChoiceAgentsResponseFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceAgentsResponseFunction$outboundSchema:
  z.ZodType<
    CreateAgentToolChoiceAgentsResponseFunction$Outbound,
    z.ZodTypeDef,
    CreateAgentToolChoiceAgentsResponseFunction
  > = z.object({
    name: z.string().optional(),
  });

export function createAgentToolChoiceAgentsResponseFunctionToJSON(
  createAgentToolChoiceAgentsResponseFunction:
    CreateAgentToolChoiceAgentsResponseFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsResponseFunction$outboundSchema.parse(
      createAgentToolChoiceAgentsResponseFunction,
    ),
  );
}
export function createAgentToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponse2$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceAgentsResponseType$inboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentToolChoiceAgentsResponseFunction$inboundSchema
  ),
});
/** @internal */
export type CreateAgentToolChoiceAgentsResponse2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceAgentsResponseFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoiceAgentsResponse2$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsResponse2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgentsResponse2
> = z.object({
  type: CreateAgentToolChoiceAgentsResponseType$outboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentToolChoiceAgentsResponseFunction$outboundSchema
  ),
});

export function createAgentToolChoiceAgentsResponse2ToJSON(
  createAgentToolChoiceAgentsResponse2: CreateAgentToolChoiceAgentsResponse2,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsResponse2$outboundSchema.parse(
      createAgentToolChoiceAgentsResponse2,
    ),
  );
}
export function createAgentToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgentsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponse1> = z.nativeEnum(
    CreateAgentToolChoiceAgentsResponse1,
  );
/** @internal */
export const CreateAgentToolChoiceAgentsResponse1$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponse1> =
    CreateAgentToolChoiceAgentsResponse1$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelsToolChoice$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgentsResponse2$inboundSchema),
  CreateAgentToolChoiceAgentsResponse1$inboundSchema,
]);
/** @internal */
export type CreateAgentFallbackModelsToolChoice$Outbound =
  | CreateAgentToolChoiceAgentsResponse2$Outbound
  | string;

/** @internal */
export const CreateAgentFallbackModelsToolChoice$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsToolChoice
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgentsResponse2$outboundSchema),
  CreateAgentToolChoiceAgentsResponse1$outboundSchema,
]);

export function createAgentFallbackModelsToolChoiceToJSON(
  createAgentFallbackModelsToolChoice: CreateAgentFallbackModelsToolChoice,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsToolChoice$outboundSchema.parse(
      createAgentFallbackModelsToolChoice,
    ),
  );
}
export function createAgentFallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFallbackModelsModalities
> = z.nativeEnum(CreateAgentFallbackModelsModalities);
/** @internal */
export const CreateAgentFallbackModelsModalities$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelsModalities> =
    CreateAgentFallbackModelsModalities$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelsWebSearchOptions$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type CreateAgentFallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const CreateAgentFallbackModelsWebSearchOptions$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelsWebSearchOptions$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelsWebSearchOptions
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function createAgentFallbackModelsWebSearchOptionsToJSON(
  createAgentFallbackModelsWebSearchOptions:
    CreateAgentFallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsWebSearchOptions$outboundSchema.parse(
      createAgentFallbackModelsWebSearchOptions,
    ),
  );
}
export function createAgentFallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelsWebSearchOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelsWebSearchOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelsParameters$inboundSchema: z.ZodType<
  CreateAgentFallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentFallbackModelsAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentResponseFormatAgentsResponse3$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsResponse1$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsResponse2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateAgentFallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentFallbackModelsThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgentsResponse2$inboundSchema),
    CreateAgentToolChoiceAgentsResponse1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(CreateAgentFallbackModelsModalities$inboundSchema),
  ).optional(),
  web_search_options: z.lazy(() =>
    CreateAgentFallbackModelsWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type CreateAgentFallbackModelsParameters$Outbound = {
  audio?: CreateAgentFallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormatAgentsResponse3$Outbound
    | CreateAgentResponseFormatAgentsResponse1$Outbound
    | CreateAgentResponseFormatAgentsResponse2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | CreateAgentFallbackModelsStreamOptions$Outbound
    | null
    | undefined;
  thinking?: CreateAgentFallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | CreateAgentToolChoiceAgentsResponse2$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?:
    | CreateAgentFallbackModelsWebSearchOptions$Outbound
    | undefined;
};

/** @internal */
export const CreateAgentFallbackModelsParameters$outboundSchema: z.ZodType<
  CreateAgentFallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelsParameters
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentFallbackModelsAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateAgentResponseFormatAgentsResponse3$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsResponse1$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsResponse2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateAgentFallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentFallbackModelsThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgentsResponse2$outboundSchema),
    CreateAgentToolChoiceAgentsResponse1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(CreateAgentFallbackModelsModalities$outboundSchema),
  ).optional(),
  webSearchOptions: z.lazy(() =>
    CreateAgentFallbackModelsWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function createAgentFallbackModelsParametersToJSON(
  createAgentFallbackModelsParameters: CreateAgentFallbackModelsParameters,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelsParameters$outboundSchema.parse(
      createAgentFallbackModelsParameters,
    ),
  );
}
export function createAgentFallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModels2$inboundSchema: z.ZodType<
  CreateAgentFallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentFallbackModelsParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type CreateAgentFallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: CreateAgentFallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const CreateAgentFallbackModels2$outboundSchema: z.ZodType<
  CreateAgentFallbackModels2$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentFallbackModelsParameters$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function createAgentFallbackModels2ToJSON(
  createAgentFallbackModels2: CreateAgentFallbackModels2,
): string {
  return JSON.stringify(
    CreateAgentFallbackModels2$outboundSchema.parse(createAgentFallbackModels2),
  );
}
export function createAgentFallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentFallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModels2' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModels$inboundSchema: z.ZodType<
  CreateAgentFallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentFallbackModels2$inboundSchema),
  z.string(),
]);
/** @internal */
export type CreateAgentFallbackModels$Outbound =
  | CreateAgentFallbackModels2$Outbound
  | string;

/** @internal */
export const CreateAgentFallbackModels$outboundSchema: z.ZodType<
  CreateAgentFallbackModels$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModels
> = z.union([
  z.lazy(() => CreateAgentFallbackModels2$outboundSchema),
  z.string(),
]);

export function createAgentFallbackModelsToJSON(
  createAgentFallbackModels: CreateAgentFallbackModels,
): string {
  return JSON.stringify(
    CreateAgentFallbackModels$outboundSchema.parse(createAgentFallbackModels),
  );
}
export function createAgentFallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentFallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModels' from JSON`,
  );
}

/** @internal */
export const CreateAgentModel$inboundSchema: z.ZodType<
  CreateAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentParameters$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => CreateAgentFallbackModels2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type CreateAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: CreateAgentParameters$Outbound | undefined;
  fallback_models?:
    | Array<CreateAgentFallbackModels2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const CreateAgentModel$outboundSchema: z.ZodType<
  CreateAgentModel$Outbound,
  z.ZodTypeDef,
  CreateAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentParameters$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => CreateAgentFallbackModels2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function createAgentModelToJSON(
  createAgentModel: CreateAgentModel,
): string {
  return JSON.stringify(
    CreateAgentModel$outboundSchema.parse(createAgentModel),
  );
}
export function createAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentModel' from JSON`,
  );
}

/** @internal */
export const CreateAgentTeamOfAgents$inboundSchema: z.ZodType<
  CreateAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type CreateAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const CreateAgentTeamOfAgents$outboundSchema: z.ZodType<
  CreateAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  CreateAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function createAgentTeamOfAgentsToJSON(
  createAgentTeamOfAgents: CreateAgentTeamOfAgents,
): string {
  return JSON.stringify(
    CreateAgentTeamOfAgents$outboundSchema.parse(createAgentTeamOfAgents),
  );
}
export function createAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const Metrics$inboundSchema: z.ZodType<Metrics, z.ZodTypeDef, unknown> =
  z.object({
    total_cost: z.number().default(0),
  }).transform((v) => {
    return remap$(v, {
      "total_cost": "totalCost",
    });
  });
/** @internal */
export type Metrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const Metrics$outboundSchema: z.ZodType<
  Metrics$Outbound,
  z.ZodTypeDef,
  Metrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function metricsToJSON(metrics: Metrics): string {
  return JSON.stringify(Metrics$outboundSchema.parse(metrics));
}
export function metricsFromJSON(
  jsonString: string,
): SafeParseResult<Metrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metrics' from JSON`,
  );
}

/** @internal */
export const CreateAgentKnowledgeBases$inboundSchema: z.ZodType<
  CreateAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type CreateAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const CreateAgentKnowledgeBases$outboundSchema: z.ZodType<
  CreateAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function createAgentKnowledgeBasesToJSON(
  createAgentKnowledgeBases: CreateAgentKnowledgeBases,
): string {
  return JSON.stringify(
    CreateAgentKnowledgeBases$outboundSchema.parse(createAgentKnowledgeBases),
  );
}
export function createAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const HiddenPanels$inboundSchema: z.ZodNativeEnum<typeof HiddenPanels> =
  z.nativeEnum(HiddenPanels);
/** @internal */
export const HiddenPanels$outboundSchema: z.ZodNativeEnum<typeof HiddenPanels> =
  HiddenPanels$inboundSchema;

/** @internal */
export const CreateAgentResponseBody$inboundSchema: z.ZodType<
  CreateAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentStatus$inboundSchema,
  settings: z.lazy(() => CreateAgentSettings$inboundSchema).optional(),
  model: z.lazy(() => CreateAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => CreateAgentTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => Metrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => CreateAgentKnowledgeBases$inboundSchema),
  ).optional(),
  hidden_panels: z.array(HiddenPanels$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
    "hidden_panels": "hiddenPanels",
  });
});
/** @internal */
export type CreateAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: CreateAgentSettings$Outbound | undefined;
  model: CreateAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<CreateAgentTeamOfAgents$Outbound>;
  metrics?: Metrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<CreateAgentKnowledgeBases$Outbound> | undefined;
  hidden_panels?: Array<string> | undefined;
};

/** @internal */
export const CreateAgentResponseBody$outboundSchema: z.ZodType<
  CreateAgentResponseBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentStatus$outboundSchema,
  settings: z.lazy(() => CreateAgentSettings$outboundSchema).optional(),
  model: z.lazy(() => CreateAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(z.lazy(() => CreateAgentTeamOfAgents$outboundSchema)),
  metrics: z.lazy(() => Metrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => CreateAgentKnowledgeBases$outboundSchema),
  ).optional(),
  hiddenPanels: z.array(HiddenPanels$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
    hiddenPanels: "hidden_panels",
  });
});

export function createAgentResponseBodyToJSON(
  createAgentResponseBody: CreateAgentResponseBody,
): string {
  return JSON.stringify(
    CreateAgentResponseBody$outboundSchema.parse(createAgentResponseBody),
  );
}
export function createAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseBody' from JSON`,
  );
}
