/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DeploymentGetConfigContentDeployments2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfigPrefixMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfigPrefixMessagesType = ClosedEnum<
  typeof DeploymentGetConfigPrefixMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const PrefixMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type PrefixMessagesTtl = ClosedEnum<typeof PrefixMessagesTtl>;

export type PrefixMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfigPrefixMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: PrefixMessagesTtl | undefined;
};

export type ToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: PrefixMessagesCacheControl | undefined;
};

export type DeploymentGetConfigContent2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type Audio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const PrefixMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type PrefixMessagesType = ClosedEnum<typeof PrefixMessagesType>;

export type PrefixMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type PrefixMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: PrefixMessagesType;
  function: PrefixMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type AssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: Audio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<PrefixMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfig2DeploymentsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfig2DeploymentsType = ClosedEnum<
  typeof DeploymentGetConfig2DeploymentsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type Ttl = ClosedEnum<typeof Ttl>;

export type CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfig2DeploymentsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: Ttl | undefined;
};

export type Four = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type Content2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | Four;

/**
 * The contents of the user message.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | Four
  >;

export type UserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | Four
    >;
};

/**
 * The contents of the developer message.
 */
export type DeploymentGetConfigPrefixMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

export type DeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type PrefixMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type SystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type PrefixMessages =
  | SystemMessage
  | DeveloperMessage
  | UserMessage
  | AssistantMessage
  | ToolMessage;

export type DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfigMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfigMessagesType = ClosedEnum<
  typeof DeploymentGetConfigMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const MessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type MessagesTtl = ClosedEnum<typeof MessagesTtl>;

export type MessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfigMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: MessagesTtl | undefined;
};

export type MessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: MessagesCacheControl | undefined;
};

export type DeploymentGetConfigContentDeploymentsRequestRequestBody2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type DeploymentGetConfigMessagesDeploymentsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type MessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const MessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type MessagesType = ClosedEnum<typeof MessagesType>;

export type MessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type MessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: MessagesType;
  function: MessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type MessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: MessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<MessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfig2DeploymentsRequestRequestBodyType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfig2DeploymentsRequestRequestBodyType = ClosedEnum<
  typeof DeploymentGetConfig2DeploymentsRequestRequestBodyType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const TwoTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type TwoTtl = ClosedEnum<typeof TwoTtl>;

export type TwoCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfig2DeploymentsRequestRequestBodyType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: TwoTtl | undefined;
};

export type Two4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: TwoCacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type DeploymentGetConfigContentDeploymentsRequest2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | Two4;

/**
 * The contents of the user message.
 */
export type DeploymentGetConfigMessagesDeploymentsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | Two4
  >;

export type MessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | Two4
    >;
};

/**
 * The contents of the developer message.
 */
export type DeploymentGetConfigMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

export type MessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type MessagesContent = string | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type MessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type DeploymentGetConfigMessages =
  | MessagesSystemMessage
  | MessagesDeveloperMessage
  | MessagesUserMessage
  | MessagesAssistantMessage
  | MessagesToolMessage;

/**
 * Metadata about the document
 */
export type Metadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: Metadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
  /**
   * Whether to include the usage metrics in the response.
   */
  includeUsage?: boolean | undefined;
  /**
   * A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage.
   */
  mockResponse?: string | undefined;
};

export type Thread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Exists
 */
export type OrExists = {
  exists: boolean;
};

export type DeploymentGetConfigOrNin = string | number | boolean;

/**
 * Not in
 */
export type OrNin = {
  nin: Array<string | number | boolean>;
};

export type DeploymentGetConfigOrIn = string | number | boolean;

/**
 * In
 */
export type OrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type OrLte = {
  lte: number;
};

/**
 * Less than
 */
export type OrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type OrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type OrGt = {
  gt: number;
};

export type DeploymentGetConfigOrNe = string | number | boolean;

/**
 * Not equal to
 */
export type OrNe = {
  ne: string | number | boolean;
};

export type DeploymentGetConfigOrEq = string | number | boolean;

/**
 * Equal to
 */
export type OrEq = {
  eq: string | number | boolean;
};

export type KnowledgeFilterOr =
  | OrEq
  | OrNe
  | OrGt
  | OrGte
  | OrLt
  | OrLte
  | OrIn
  | OrNin
  | OrExists;

/**
 * Or
 */
export type Or = {
  or: Array<
    {
      [k: string]:
        | OrEq
        | OrNe
        | OrGt
        | OrGte
        | OrLt
        | OrLte
        | OrIn
        | OrNin
        | OrExists;
    }
  >;
};

/**
 * Exists
 */
export type AndExists = {
  exists: boolean;
};

export type DeploymentGetConfigAndNin = string | number | boolean;

/**
 * Not in
 */
export type AndNin = {
  nin: Array<string | number | boolean>;
};

export type DeploymentGetConfigAndIn = string | number | boolean;

/**
 * In
 */
export type AndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type AndLte = {
  lte: number;
};

/**
 * Less than
 */
export type AndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type AndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type AndGt = {
  gt: number;
};

export type DeploymentGetConfigAndNe = string | number | boolean;

/**
 * Not equal to
 */
export type AndNe = {
  ne: string | number | boolean;
};

export type DeploymentGetConfigAndEq = string | number | boolean;

/**
 * Equal to
 */
export type AndEq = {
  eq: string | number | boolean;
};

export type KnowledgeFilterAnd =
  | AndEq
  | AndNe
  | AndGt
  | AndGte
  | AndLt
  | AndLte
  | AndIn
  | AndNin
  | AndExists;

/**
 * And
 */
export type And = {
  and: Array<
    {
      [k: string]:
        | AndEq
        | AndNe
        | AndGt
        | AndGte
        | AndLt
        | AndLte
        | AndIn
        | AndNin
        | AndExists;
    }
  >;
};

/**
 * Exists
 */
export type Exists = {
  exists: boolean;
};

export type OneNin = string | number | boolean;

/**
 * Not in
 */
export type Nin = {
  nin: Array<string | number | boolean>;
};

export type OneIn = string | number | boolean;

/**
 * In
 */
export type In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type Lte = {
  lte: number;
};

/**
 * Less than
 */
export type Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type Gt = {
  gt: number;
};

export type OneNe = string | number | boolean;

/**
 * Not equal to
 */
export type Ne = {
  ne: string | number | boolean;
};

export type OneEq = string | number | boolean;

/**
 * Equal to
 */
export type Eq = {
  eq: string | number | boolean;
};

export type KnowledgeFilter1 =
  | Eq
  | Ne
  | Gt
  | Gte
  | Lt
  | Lte
  | In
  | Nin
  | Exists;

/**
 * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
 */
export type KnowledgeFilter = And | Or | {
  [k: string]: Eq | Ne | Gt | Gte | Lt | Lte | In | Nin | Exists;
};

export type DeploymentGetConfigRequestBody = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: any } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your deployment routing configuration
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?:
    | Array<
      | SystemMessage
      | DeveloperMessage
      | UserMessage
      | AssistantMessage
      | ToolMessage
    >
    | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?:
    | Array<
      | MessagesSystemMessage
      | MessagesDeveloperMessage
      | MessagesUserMessage
      | MessagesAssistantMessage
      | MessagesToolMessage
    >
    | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicIdentity | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of documents from your external knowledge base (e.g., chunks retrieved from your own vector database or RAG pipeline) that provide context for the model response. These documents can be used by evaluators and guardrails to assess the relevance and accuracy of the model output against the provided context.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
  thread?: Thread | undefined;
  /**
   * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
   */
  knowledgeFilter?: And | Or | {
    [k: string]: Eq | Ne | Gt | Gte | Lt | Lte | In | Nin | Exists;
  } | undefined;
};

/**
 * The type of the model. Current `chat`,`completion` and `image` are supported
 */
export const DeploymentGetConfigType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Ocr: "ocr",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The type of the model. Current `chat`,`completion` and `image` are supported
 */
export type DeploymentGetConfigType = ClosedEnum<
  typeof DeploymentGetConfigType
>;

/**
 * The role of the prompt message
 */
export const DeploymentGetConfigRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentGetConfigRole = ClosedEnum<
  typeof DeploymentGetConfigRole
>;

export type TwoFile = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type DeploymentGetConfig23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: TwoFile;
};

export type TwoImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type DeploymentGetConfig22 = {
  type: "image_url";
  imageUrl: TwoImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type DeploymentGetConfig21 = {
  type: "text";
  text: string;
};

export type DeploymentGetConfigContentDeploymentsResponse2 =
  | DeploymentGetConfig21
  | DeploymentGetConfig22
  | DeploymentGetConfig23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type DeploymentGetConfigContent =
  | string
  | Array<
    DeploymentGetConfig21 | DeploymentGetConfig22 | DeploymentGetConfig23
  >;

export const DeploymentGetConfigDeploymentsResponseType = {
  Function: "function",
} as const;
export type DeploymentGetConfigDeploymentsResponseType = ClosedEnum<
  typeof DeploymentGetConfigDeploymentsResponseType
>;

export type DeploymentGetConfigDeploymentsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type DeploymentGetConfigToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentGetConfigDeploymentsResponseType;
  function: DeploymentGetConfigDeploymentsFunction;
};

export type DeploymentGetConfigDeploymentsMessages = {
  /**
   * The role of the prompt message
   */
  role: DeploymentGetConfigRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<
      DeploymentGetConfig21 | DeploymentGetConfig22 | DeploymentGetConfig23
    >
    | null;
  toolCalls?: Array<DeploymentGetConfigToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * Only supported on `image` models.
 */
export const DeploymentGetConfigFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type DeploymentGetConfigFormat = ClosedEnum<
  typeof DeploymentGetConfigFormat
>;

export const ResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type ResponseFormat6 = ClosedEnum<typeof ResponseFormat6>;

export const ResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type ResponseFormat5 = ClosedEnum<typeof ResponseFormat5>;

export const ResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type ResponseFormat4 = ClosedEnum<typeof ResponseFormat4>;

export const DeploymentGetConfigResponseFormatDeploymentsType = {
  Text: "text",
} as const;
export type DeploymentGetConfigResponseFormatDeploymentsType = ClosedEnum<
  typeof DeploymentGetConfigResponseFormatDeploymentsType
>;

export type ResponseFormat3 = {
  type: DeploymentGetConfigResponseFormatDeploymentsType;
};

export const DeploymentGetConfigResponseFormatType = {
  JsonObject: "json_object",
} as const;
export type DeploymentGetConfigResponseFormatType = ClosedEnum<
  typeof DeploymentGetConfigResponseFormatType
>;

export type ResponseFormat2 = {
  type: DeploymentGetConfigResponseFormatType;
};

export const DeploymentGetConfigResponseFormatDeploymentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type DeploymentGetConfigResponseFormatDeploymentsResponseType =
  ClosedEnum<typeof DeploymentGetConfigResponseFormatDeploymentsResponseType>;

export type DeploymentGetConfigResponseFormatJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type ResponseFormat1 = {
  type: DeploymentGetConfigResponseFormatDeploymentsResponseType;
  displayName?: string | undefined;
  jsonSchema: DeploymentGetConfigResponseFormatJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type DeploymentGetConfigResponseFormat =
  | ResponseFormat1
  | ResponseFormat2
  | ResponseFormat3
  | ResponseFormat4
  | ResponseFormat5
  | ResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const PhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type PhotoRealVersion = ClosedEnum<typeof PhotoRealVersion>;

/**
 * The format to return the embeddings
 */
export const DeploymentGetConfigEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type DeploymentGetConfigEncodingFormat = ClosedEnum<
  typeof DeploymentGetConfigEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const DeploymentGetConfigReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type DeploymentGetConfigReasoningEffort = ClosedEnum<
  typeof DeploymentGetConfigReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const Verbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type Verbosity = ClosedEnum<typeof Verbosity>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const ThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type ThinkingLevel = ClosedEnum<typeof ThinkingLevel>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type DeploymentGetConfigParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: DeploymentGetConfigFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | ResponseFormat1
    | ResponseFormat2
    | ResponseFormat3
    | ResponseFormat4
    | ResponseFormat5
    | ResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: PhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: DeploymentGetConfigEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: DeploymentGetConfigReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: Verbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: ThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const DeploymentGetConfigDeploymentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type DeploymentGetConfigDeploymentsType = ClosedEnum<
  typeof DeploymentGetConfigDeploymentsType
>;

export type DeploymentGetConfigFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object.
   *
   * @remarks
   *
   *  Omitting `parameters` defines a function with an empty parameter list.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type DeploymentGetConfigTools = {
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: DeploymentGetConfigDeploymentsType;
  function: DeploymentGetConfigFunction;
};

/**
 * The deployment configuration
 */
export type DeploymentGetConfigResponseBody = {
  /**
   * A unique identifier for the response. Can be used to add metrics to the transaction.
   */
  id: string;
  /**
   * The provider of the model
   */
  provider: string;
  /**
   * The model of the configuration
   */
  model: string;
  /**
   * The type of the model. Current `chat`,`completion` and `image` are supported
   */
  type?: DeploymentGetConfigType | undefined;
  /**
   * The current version of the deployment
   */
  version: string;
  messages: Array<DeploymentGetConfigDeploymentsMessages>;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  parameters: DeploymentGetConfigParameters;
  /**
   * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
   */
  tools?: Array<DeploymentGetConfigTools> | undefined;
};

/** @internal */
export type DeploymentGetConfigContentDeployments2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeployments2$outboundSchema: z.ZodType<
  DeploymentGetConfigContentDeployments2$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigContentDeployments2
> = components.TextContentPartSchema$outboundSchema;

export function deploymentGetConfigContentDeployments2ToJSON(
  deploymentGetConfigContentDeployments2:
    DeploymentGetConfigContentDeployments2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeployments2$outboundSchema.parse(
      deploymentGetConfigContentDeployments2,
    ),
  );
}

/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent:
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$outboundSchema
      .parse(
        deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
      ),
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigPrefixMessagesType> = z.nativeEnum(
    DeploymentGetConfigPrefixMessagesType,
  );

/** @internal */
export const PrefixMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesTtl
> = z.nativeEnum(PrefixMessagesTtl);

/** @internal */
export type PrefixMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const PrefixMessagesCacheControl$outboundSchema: z.ZodType<
  PrefixMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  PrefixMessagesCacheControl
> = z.object({
  type: DeploymentGetConfigPrefixMessagesType$outboundSchema,
  ttl: PrefixMessagesTtl$outboundSchema.default("5m"),
});

export function prefixMessagesCacheControlToJSON(
  prefixMessagesCacheControl: PrefixMessagesCacheControl,
): string {
  return JSON.stringify(
    PrefixMessagesCacheControl$outboundSchema.parse(prefixMessagesCacheControl),
  );
}

/** @internal */
export type ToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: PrefixMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const ToolMessage$outboundSchema: z.ZodType<
  ToolMessage$Outbound,
  z.ZodTypeDef,
  ToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() => PrefixMessagesCacheControl$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function toolMessageToJSON(toolMessage: ToolMessage): string {
  return JSON.stringify(ToolMessage$outboundSchema.parse(toolMessage));
}

/** @internal */
export type DeploymentGetConfigContent2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContent2$outboundSchema: z.ZodType<
  DeploymentGetConfigContent2$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigContent2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$outboundSchema,
  components.ReasoningPartSchema$outboundSchema,
  components.RedactedReasoningPartSchema$outboundSchema,
]);

export function deploymentGetConfigContent2ToJSON(
  deploymentGetConfigContent2: DeploymentGetConfigContent2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContent2$outboundSchema.parse(
      deploymentGetConfigContent2,
    ),
  );
}

/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsRequestContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsRequestContent:
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$outboundSchema
      .parse(deploymentGetConfigPrefixMessagesDeploymentsRequestContent),
  );
}

/** @internal */
export type Audio$Outbound = {
  id: string;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
});

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}

/** @internal */
export const PrefixMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesType
> = z.nativeEnum(PrefixMessagesType);

/** @internal */
export type PrefixMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const PrefixMessagesFunction$outboundSchema: z.ZodType<
  PrefixMessagesFunction$Outbound,
  z.ZodTypeDef,
  PrefixMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function prefixMessagesFunctionToJSON(
  prefixMessagesFunction: PrefixMessagesFunction,
): string {
  return JSON.stringify(
    PrefixMessagesFunction$outboundSchema.parse(prefixMessagesFunction),
  );
}

/** @internal */
export type PrefixMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: PrefixMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const PrefixMessagesToolCalls$outboundSchema: z.ZodType<
  PrefixMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  PrefixMessagesToolCalls
> = z.object({
  id: z.string(),
  type: PrefixMessagesType$outboundSchema,
  function: z.lazy(() => PrefixMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function prefixMessagesToolCallsToJSON(
  prefixMessagesToolCalls: PrefixMessagesToolCalls,
): string {
  return JSON.stringify(
    PrefixMessagesToolCalls$outboundSchema.parse(prefixMessagesToolCalls),
  );
}

/** @internal */
export type AssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: Audio$Outbound | null | undefined;
  tool_calls?: Array<PrefixMessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const AssistantMessage$outboundSchema: z.ZodType<
  AssistantMessage$Outbound,
  z.ZodTypeDef,
  AssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => PrefixMessagesToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function assistantMessageToJSON(
  assistantMessage: AssistantMessage,
): string {
  return JSON.stringify(
    AssistantMessage$outboundSchema.parse(assistantMessage),
  );
}

/** @internal */
export const DeploymentGetConfig2DeploymentsType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfig2DeploymentsType> = z.nativeEnum(
    DeploymentGetConfig2DeploymentsType,
  );

/** @internal */
export const Ttl$outboundSchema: z.ZodNativeEnum<typeof Ttl> = z.nativeEnum(
  Ttl,
);

/** @internal */
export type CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CacheControl$outboundSchema: z.ZodType<
  CacheControl$Outbound,
  z.ZodTypeDef,
  CacheControl
> = z.object({
  type: DeploymentGetConfig2DeploymentsType$outboundSchema,
  ttl: Ttl$outboundSchema.default("5m"),
});

export function cacheControlToJSON(cacheControl: CacheControl): string {
  return JSON.stringify(CacheControl$outboundSchema.parse(cacheControl));
}

/** @internal */
export type Four$Outbound = {
  type: "file";
  cache_control?: CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() => CacheControl$outboundSchema).optional(),
    file: components.FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

/** @internal */
export type Content2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | Four$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => Four$outboundSchema),
]);

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}

/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | Four$Outbound
  >;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsContent:
    DeploymentGetConfigPrefixMessagesDeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsContent$outboundSchema.parse(
      deploymentGetConfigPrefixMessagesDeploymentsContent,
    ),
  );
}

/** @internal */
export type UserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | Four$Outbound
    >;
};

/** @internal */
export const UserMessage$outboundSchema: z.ZodType<
  UserMessage$Outbound,
  z.ZodTypeDef,
  UserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]),
});

export function userMessageToJSON(userMessage: UserMessage): string {
  return JSON.stringify(UserMessage$outboundSchema.parse(userMessage));
}

/** @internal */
export type DeploymentGetConfigPrefixMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigPrefixMessagesContent$outboundSchema: z.ZodType<
  DeploymentGetConfigPrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigPrefixMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function deploymentGetConfigPrefixMessagesContentToJSON(
  deploymentGetConfigPrefixMessagesContent:
    DeploymentGetConfigPrefixMessagesContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesContent$outboundSchema.parse(
      deploymentGetConfigPrefixMessagesContent,
    ),
  );
}

/** @internal */
export type DeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const DeveloperMessage$outboundSchema: z.ZodType<
  DeveloperMessage$Outbound,
  z.ZodTypeDef,
  DeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function developerMessageToJSON(
  developerMessage: DeveloperMessage,
): string {
  return JSON.stringify(
    DeveloperMessage$outboundSchema.parse(developerMessage),
  );
}

/** @internal */
export type PrefixMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const PrefixMessagesContent$outboundSchema: z.ZodType<
  PrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  PrefixMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function prefixMessagesContentToJSON(
  prefixMessagesContent: PrefixMessagesContent,
): string {
  return JSON.stringify(
    PrefixMessagesContent$outboundSchema.parse(prefixMessagesContent),
  );
}

/** @internal */
export type SystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const SystemMessage$outboundSchema: z.ZodType<
  SystemMessage$Outbound,
  z.ZodTypeDef,
  SystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function systemMessageToJSON(systemMessage: SystemMessage): string {
  return JSON.stringify(SystemMessage$outboundSchema.parse(systemMessage));
}

/** @internal */
export type PrefixMessages$Outbound =
  | SystemMessage$Outbound
  | DeveloperMessage$Outbound
  | UserMessage$Outbound
  | AssistantMessage$Outbound
  | ToolMessage$Outbound;

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.union([
  z.lazy(() => SystemMessage$outboundSchema),
  z.lazy(() => DeveloperMessage$outboundSchema),
  z.lazy(() => UserMessage$outboundSchema),
  z.lazy(() => AssistantMessage$outboundSchema),
  z.lazy(() => ToolMessage$outboundSchema),
]);

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}

/** @internal */
export type DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2
  > = components.TextContentPartSchema$outboundSchema;

export function deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2ToJSON(
  deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2:
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$outboundSchema
      .parse(deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2),
  );
}

/** @internal */
export type DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function deploymentGetConfigMessagesDeploymentsRequestRequestBodyContentToJSON(
  deploymentGetConfigMessagesDeploymentsRequestRequestBodyContent:
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$outboundSchema
      .parse(deploymentGetConfigMessagesDeploymentsRequestRequestBodyContent),
  );
}

/** @internal */
export const DeploymentGetConfigMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigMessagesType
> = z.nativeEnum(DeploymentGetConfigMessagesType);

/** @internal */
export const MessagesTtl$outboundSchema: z.ZodNativeEnum<typeof MessagesTtl> = z
  .nativeEnum(MessagesTtl);

/** @internal */
export type MessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const MessagesCacheControl$outboundSchema: z.ZodType<
  MessagesCacheControl$Outbound,
  z.ZodTypeDef,
  MessagesCacheControl
> = z.object({
  type: DeploymentGetConfigMessagesType$outboundSchema,
  ttl: MessagesTtl$outboundSchema.default("5m"),
});

export function messagesCacheControlToJSON(
  messagesCacheControl: MessagesCacheControl,
): string {
  return JSON.stringify(
    MessagesCacheControl$outboundSchema.parse(messagesCacheControl),
  );
}

/** @internal */
export type MessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: MessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const MessagesToolMessage$outboundSchema: z.ZodType<
  MessagesToolMessage$Outbound,
  z.ZodTypeDef,
  MessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() => MessagesCacheControl$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function messagesToolMessageToJSON(
  messagesToolMessage: MessagesToolMessage,
): string {
  return JSON.stringify(
    MessagesToolMessage$outboundSchema.parse(messagesToolMessage),
  );
}

/** @internal */
export type DeploymentGetConfigContentDeploymentsRequestRequestBody2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBody2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBody2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequestRequestBody2
  > = z.union([
    components.TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.RefusalPartSchema$outboundSchema,
    components.ReasoningPartSchema$outboundSchema,
    components.RedactedReasoningPartSchema$outboundSchema,
  ]);

export function deploymentGetConfigContentDeploymentsRequestRequestBody2ToJSON(
  deploymentGetConfigContentDeploymentsRequestRequestBody2:
    DeploymentGetConfigContentDeploymentsRequestRequestBody2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequestRequestBody2$outboundSchema
      .parse(deploymentGetConfigContentDeploymentsRequestRequestBody2),
  );
}

/** @internal */
export type DeploymentGetConfigMessagesDeploymentsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function deploymentGetConfigMessagesDeploymentsRequestContentToJSON(
  deploymentGetConfigMessagesDeploymentsRequestContent:
    DeploymentGetConfigMessagesDeploymentsRequestContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsRequestContent$outboundSchema.parse(
      deploymentGetConfigMessagesDeploymentsRequestContent,
    ),
  );
}

/** @internal */
export type MessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const MessagesAudio$outboundSchema: z.ZodType<
  MessagesAudio$Outbound,
  z.ZodTypeDef,
  MessagesAudio
> = z.object({
  id: z.string(),
});

export function messagesAudioToJSON(messagesAudio: MessagesAudio): string {
  return JSON.stringify(MessagesAudio$outboundSchema.parse(messagesAudio));
}

/** @internal */
export const MessagesType$outboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  z.nativeEnum(MessagesType);

/** @internal */
export type MessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const MessagesFunction$outboundSchema: z.ZodType<
  MessagesFunction$Outbound,
  z.ZodTypeDef,
  MessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function messagesFunctionToJSON(
  messagesFunction: MessagesFunction,
): string {
  return JSON.stringify(
    MessagesFunction$outboundSchema.parse(messagesFunction),
  );
}

/** @internal */
export type MessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: MessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const MessagesToolCalls$outboundSchema: z.ZodType<
  MessagesToolCalls$Outbound,
  z.ZodTypeDef,
  MessagesToolCalls
> = z.object({
  id: z.string(),
  type: MessagesType$outboundSchema,
  function: z.lazy(() => MessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function messagesToolCallsToJSON(
  messagesToolCalls: MessagesToolCalls,
): string {
  return JSON.stringify(
    MessagesToolCalls$outboundSchema.parse(messagesToolCalls),
  );
}

/** @internal */
export type MessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: MessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<MessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const MessagesAssistantMessage$outboundSchema: z.ZodType<
  MessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  MessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => MessagesToolCalls$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function messagesAssistantMessageToJSON(
  messagesAssistantMessage: MessagesAssistantMessage,
): string {
  return JSON.stringify(
    MessagesAssistantMessage$outboundSchema.parse(messagesAssistantMessage),
  );
}

/** @internal */
export const DeploymentGetConfig2DeploymentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfig2DeploymentsRequestRequestBodyType
  > = z.nativeEnum(DeploymentGetConfig2DeploymentsRequestRequestBodyType);

/** @internal */
export const TwoTtl$outboundSchema: z.ZodNativeEnum<typeof TwoTtl> = z
  .nativeEnum(TwoTtl);

/** @internal */
export type TwoCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const TwoCacheControl$outboundSchema: z.ZodType<
  TwoCacheControl$Outbound,
  z.ZodTypeDef,
  TwoCacheControl
> = z.object({
  type: DeploymentGetConfig2DeploymentsRequestRequestBodyType$outboundSchema,
  ttl: TwoTtl$outboundSchema.default("5m"),
});

export function twoCacheControlToJSON(
  twoCacheControl: TwoCacheControl,
): string {
  return JSON.stringify(TwoCacheControl$outboundSchema.parse(twoCacheControl));
}

/** @internal */
export type Two4$Outbound = {
  type: "file";
  cache_control?: TwoCacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const Two4$outboundSchema: z.ZodType<Two4$Outbound, z.ZodTypeDef, Two4> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() => TwoCacheControl$outboundSchema).optional(),
    file: components.FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function two4ToJSON(two4: Two4): string {
  return JSON.stringify(Two4$outboundSchema.parse(two4));
}

/** @internal */
export type DeploymentGetConfigContentDeploymentsRequest2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | Two4$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequest2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequest2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequest2
  > = z.union([
    components.TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.ImageContentPartSchema$outboundSchema,
    components.AudioContentPartSchema$outboundSchema,
    z.lazy(() => Two4$outboundSchema),
  ]);

export function deploymentGetConfigContentDeploymentsRequest2ToJSON(
  deploymentGetConfigContentDeploymentsRequest2:
    DeploymentGetConfigContentDeploymentsRequest2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequest2$outboundSchema.parse(
      deploymentGetConfigContentDeploymentsRequest2,
    ),
  );
}

/** @internal */
export type DeploymentGetConfigMessagesDeploymentsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | Two4$Outbound
  >;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Two4$outboundSchema),
      ]),
    ),
  ]);

export function deploymentGetConfigMessagesDeploymentsContentToJSON(
  deploymentGetConfigMessagesDeploymentsContent:
    DeploymentGetConfigMessagesDeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsContent$outboundSchema.parse(
      deploymentGetConfigMessagesDeploymentsContent,
    ),
  );
}

/** @internal */
export type MessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | Two4$Outbound
    >;
};

/** @internal */
export const MessagesUserMessage$outboundSchema: z.ZodType<
  MessagesUserMessage$Outbound,
  z.ZodTypeDef,
  MessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Two4$outboundSchema),
      ]),
    ),
  ]),
});

export function messagesUserMessageToJSON(
  messagesUserMessage: MessagesUserMessage,
): string {
  return JSON.stringify(
    MessagesUserMessage$outboundSchema.parse(messagesUserMessage),
  );
}

/** @internal */
export type DeploymentGetConfigMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigMessagesContent$outboundSchema: z.ZodType<
  DeploymentGetConfigMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function deploymentGetConfigMessagesContentToJSON(
  deploymentGetConfigMessagesContent: DeploymentGetConfigMessagesContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesContent$outboundSchema.parse(
      deploymentGetConfigMessagesContent,
    ),
  );
}

/** @internal */
export type MessagesDeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesDeveloperMessage$outboundSchema: z.ZodType<
  MessagesDeveloperMessage$Outbound,
  z.ZodTypeDef,
  MessagesDeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function messagesDeveloperMessageToJSON(
  messagesDeveloperMessage: MessagesDeveloperMessage,
): string {
  return JSON.stringify(
    MessagesDeveloperMessage$outboundSchema.parse(messagesDeveloperMessage),
  );
}

/** @internal */
export type MessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const MessagesContent$outboundSchema: z.ZodType<
  MessagesContent$Outbound,
  z.ZodTypeDef,
  MessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function messagesContentToJSON(
  messagesContent: MessagesContent,
): string {
  return JSON.stringify(MessagesContent$outboundSchema.parse(messagesContent));
}

/** @internal */
export type MessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesSystemMessage$outboundSchema: z.ZodType<
  MessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  MessagesSystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function messagesSystemMessageToJSON(
  messagesSystemMessage: MessagesSystemMessage,
): string {
  return JSON.stringify(
    MessagesSystemMessage$outboundSchema.parse(messagesSystemMessage),
  );
}

/** @internal */
export type DeploymentGetConfigMessages$Outbound =
  | MessagesSystemMessage$Outbound
  | MessagesDeveloperMessage$Outbound
  | MessagesUserMessage$Outbound
  | MessagesAssistantMessage$Outbound
  | MessagesToolMessage$Outbound;

/** @internal */
export const DeploymentGetConfigMessages$outboundSchema: z.ZodType<
  DeploymentGetConfigMessages$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigMessages
> = z.union([
  z.lazy(() => MessagesSystemMessage$outboundSchema),
  z.lazy(() => MessagesDeveloperMessage$outboundSchema),
  z.lazy(() => MessagesUserMessage$outboundSchema),
  z.lazy(() => MessagesAssistantMessage$outboundSchema),
  z.lazy(() => MessagesToolMessage$outboundSchema),
]);

export function deploymentGetConfigMessagesToJSON(
  deploymentGetConfigMessages: DeploymentGetConfigMessages,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessages$outboundSchema.parse(
      deploymentGetConfigMessages,
    ),
  );
}

/** @internal */
export type Metadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$outboundSchema).optional(),
});

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}

/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
  include_usage: boolean;
  mock_response?: string | undefined;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
  includeUsage: z.boolean().default(false),
  mockResponse: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
    includeUsage: "include_usage",
    mockResponse: "mock_response",
  });
});

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}

/** @internal */
export type Thread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Thread$outboundSchema: z.ZodType<
  Thread$Outbound,
  z.ZodTypeDef,
  Thread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function threadToJSON(thread: Thread): string {
  return JSON.stringify(Thread$outboundSchema.parse(thread));
}

/** @internal */
export type OrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const OrExists$outboundSchema: z.ZodType<
  OrExists$Outbound,
  z.ZodTypeDef,
  OrExists
> = z.object({
  exists: z.boolean(),
});

export function orExistsToJSON(orExists: OrExists): string {
  return JSON.stringify(OrExists$outboundSchema.parse(orExists));
}

/** @internal */
export type DeploymentGetConfigOrNin$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrNin$outboundSchema: z.ZodType<
  DeploymentGetConfigOrNin$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrNinToJSON(
  deploymentGetConfigOrNin: DeploymentGetConfigOrNin,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrNin$outboundSchema.parse(deploymentGetConfigOrNin),
  );
}

/** @internal */
export type OrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const OrNin$outboundSchema: z.ZodType<
  OrNin$Outbound,
  z.ZodTypeDef,
  OrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function orNinToJSON(orNin: OrNin): string {
  return JSON.stringify(OrNin$outboundSchema.parse(orNin));
}

/** @internal */
export type DeploymentGetConfigOrIn$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrIn$outboundSchema: z.ZodType<
  DeploymentGetConfigOrIn$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrInToJSON(
  deploymentGetConfigOrIn: DeploymentGetConfigOrIn,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrIn$outboundSchema.parse(deploymentGetConfigOrIn),
  );
}

/** @internal */
export type OrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const OrIn$outboundSchema: z.ZodType<OrIn$Outbound, z.ZodTypeDef, OrIn> =
  z.object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function orInToJSON(orIn: OrIn): string {
  return JSON.stringify(OrIn$outboundSchema.parse(orIn));
}

/** @internal */
export type OrLte$Outbound = {
  lte: number;
};

/** @internal */
export const OrLte$outboundSchema: z.ZodType<
  OrLte$Outbound,
  z.ZodTypeDef,
  OrLte
> = z.object({
  lte: z.number(),
});

export function orLteToJSON(orLte: OrLte): string {
  return JSON.stringify(OrLte$outboundSchema.parse(orLte));
}

/** @internal */
export type OrLt$Outbound = {
  lt: number;
};

/** @internal */
export const OrLt$outboundSchema: z.ZodType<OrLt$Outbound, z.ZodTypeDef, OrLt> =
  z.object({
    lt: z.number(),
  });

export function orLtToJSON(orLt: OrLt): string {
  return JSON.stringify(OrLt$outboundSchema.parse(orLt));
}

/** @internal */
export type OrGte$Outbound = {
  gte: number;
};

/** @internal */
export const OrGte$outboundSchema: z.ZodType<
  OrGte$Outbound,
  z.ZodTypeDef,
  OrGte
> = z.object({
  gte: z.number(),
});

export function orGteToJSON(orGte: OrGte): string {
  return JSON.stringify(OrGte$outboundSchema.parse(orGte));
}

/** @internal */
export type OrGt$Outbound = {
  gt: number;
};

/** @internal */
export const OrGt$outboundSchema: z.ZodType<OrGt$Outbound, z.ZodTypeDef, OrGt> =
  z.object({
    gt: z.number(),
  });

export function orGtToJSON(orGt: OrGt): string {
  return JSON.stringify(OrGt$outboundSchema.parse(orGt));
}

/** @internal */
export type DeploymentGetConfigOrNe$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrNe$outboundSchema: z.ZodType<
  DeploymentGetConfigOrNe$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrNeToJSON(
  deploymentGetConfigOrNe: DeploymentGetConfigOrNe,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrNe$outboundSchema.parse(deploymentGetConfigOrNe),
  );
}

/** @internal */
export type OrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const OrNe$outboundSchema: z.ZodType<OrNe$Outbound, z.ZodTypeDef, OrNe> =
  z.object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });

export function orNeToJSON(orNe: OrNe): string {
  return JSON.stringify(OrNe$outboundSchema.parse(orNe));
}

/** @internal */
export type DeploymentGetConfigOrEq$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrEq$outboundSchema: z.ZodType<
  DeploymentGetConfigOrEq$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrEqToJSON(
  deploymentGetConfigOrEq: DeploymentGetConfigOrEq,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrEq$outboundSchema.parse(deploymentGetConfigOrEq),
  );
}

/** @internal */
export type OrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const OrEq$outboundSchema: z.ZodType<OrEq$Outbound, z.ZodTypeDef, OrEq> =
  z.object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });

export function orEqToJSON(orEq: OrEq): string {
  return JSON.stringify(OrEq$outboundSchema.parse(orEq));
}

/** @internal */
export type KnowledgeFilterOr$Outbound =
  | OrEq$Outbound
  | OrNe$Outbound
  | OrGt$Outbound
  | OrGte$Outbound
  | OrLt$Outbound
  | OrLte$Outbound
  | OrIn$Outbound
  | OrNin$Outbound
  | OrExists$Outbound;

/** @internal */
export const KnowledgeFilterOr$outboundSchema: z.ZodType<
  KnowledgeFilterOr$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterOr
> = z.union([
  z.lazy(() => OrEq$outboundSchema),
  z.lazy(() => OrNe$outboundSchema),
  z.lazy(() => OrGt$outboundSchema),
  z.lazy(() => OrGte$outboundSchema),
  z.lazy(() => OrLt$outboundSchema),
  z.lazy(() => OrLte$outboundSchema),
  z.lazy(() => OrIn$outboundSchema),
  z.lazy(() => OrNin$outboundSchema),
  z.lazy(() => OrExists$outboundSchema),
]);

export function knowledgeFilterOrToJSON(
  knowledgeFilterOr: KnowledgeFilterOr,
): string {
  return JSON.stringify(
    KnowledgeFilterOr$outboundSchema.parse(knowledgeFilterOr),
  );
}

/** @internal */
export type Or$Outbound = {
  or: Array<
    {
      [k: string]:
        | OrEq$Outbound
        | OrNe$Outbound
        | OrGt$Outbound
        | OrGte$Outbound
        | OrLt$Outbound
        | OrLte$Outbound
        | OrIn$Outbound
        | OrNin$Outbound
        | OrExists$Outbound;
    }
  >;
};

/** @internal */
export const Or$outboundSchema: z.ZodType<Or$Outbound, z.ZodTypeDef, Or> = z
  .object({
    or: z.array(
      z.record(z.union([
        z.lazy(() => OrEq$outboundSchema),
        z.lazy(() =>
          OrNe$outboundSchema
        ),
        z.lazy(() => OrGt$outboundSchema),
        z.lazy(() => OrGte$outboundSchema),
        z.lazy(() => OrLt$outboundSchema),
        z.lazy(() => OrLte$outboundSchema),
        z.lazy(() => OrIn$outboundSchema),
        z.lazy(() => OrNin$outboundSchema),
        z.lazy(() => OrExists$outboundSchema),
      ])),
    ),
  });

export function orToJSON(or: Or): string {
  return JSON.stringify(Or$outboundSchema.parse(or));
}

/** @internal */
export type AndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const AndExists$outboundSchema: z.ZodType<
  AndExists$Outbound,
  z.ZodTypeDef,
  AndExists
> = z.object({
  exists: z.boolean(),
});

export function andExistsToJSON(andExists: AndExists): string {
  return JSON.stringify(AndExists$outboundSchema.parse(andExists));
}

/** @internal */
export type DeploymentGetConfigAndNin$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndNin$outboundSchema: z.ZodType<
  DeploymentGetConfigAndNin$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndNinToJSON(
  deploymentGetConfigAndNin: DeploymentGetConfigAndNin,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndNin$outboundSchema.parse(deploymentGetConfigAndNin),
  );
}

/** @internal */
export type AndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const AndNin$outboundSchema: z.ZodType<
  AndNin$Outbound,
  z.ZodTypeDef,
  AndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function andNinToJSON(andNin: AndNin): string {
  return JSON.stringify(AndNin$outboundSchema.parse(andNin));
}

/** @internal */
export type DeploymentGetConfigAndIn$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndIn$outboundSchema: z.ZodType<
  DeploymentGetConfigAndIn$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndInToJSON(
  deploymentGetConfigAndIn: DeploymentGetConfigAndIn,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndIn$outboundSchema.parse(deploymentGetConfigAndIn),
  );
}

/** @internal */
export type AndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const AndIn$outboundSchema: z.ZodType<
  AndIn$Outbound,
  z.ZodTypeDef,
  AndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function andInToJSON(andIn: AndIn): string {
  return JSON.stringify(AndIn$outboundSchema.parse(andIn));
}

/** @internal */
export type AndLte$Outbound = {
  lte: number;
};

/** @internal */
export const AndLte$outboundSchema: z.ZodType<
  AndLte$Outbound,
  z.ZodTypeDef,
  AndLte
> = z.object({
  lte: z.number(),
});

export function andLteToJSON(andLte: AndLte): string {
  return JSON.stringify(AndLte$outboundSchema.parse(andLte));
}

/** @internal */
export type AndLt$Outbound = {
  lt: number;
};

/** @internal */
export const AndLt$outboundSchema: z.ZodType<
  AndLt$Outbound,
  z.ZodTypeDef,
  AndLt
> = z.object({
  lt: z.number(),
});

export function andLtToJSON(andLt: AndLt): string {
  return JSON.stringify(AndLt$outboundSchema.parse(andLt));
}

/** @internal */
export type AndGte$Outbound = {
  gte: number;
};

/** @internal */
export const AndGte$outboundSchema: z.ZodType<
  AndGte$Outbound,
  z.ZodTypeDef,
  AndGte
> = z.object({
  gte: z.number(),
});

export function andGteToJSON(andGte: AndGte): string {
  return JSON.stringify(AndGte$outboundSchema.parse(andGte));
}

/** @internal */
export type AndGt$Outbound = {
  gt: number;
};

/** @internal */
export const AndGt$outboundSchema: z.ZodType<
  AndGt$Outbound,
  z.ZodTypeDef,
  AndGt
> = z.object({
  gt: z.number(),
});

export function andGtToJSON(andGt: AndGt): string {
  return JSON.stringify(AndGt$outboundSchema.parse(andGt));
}

/** @internal */
export type DeploymentGetConfigAndNe$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndNe$outboundSchema: z.ZodType<
  DeploymentGetConfigAndNe$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndNeToJSON(
  deploymentGetConfigAndNe: DeploymentGetConfigAndNe,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndNe$outboundSchema.parse(deploymentGetConfigAndNe),
  );
}

/** @internal */
export type AndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const AndNe$outboundSchema: z.ZodType<
  AndNe$Outbound,
  z.ZodTypeDef,
  AndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function andNeToJSON(andNe: AndNe): string {
  return JSON.stringify(AndNe$outboundSchema.parse(andNe));
}

/** @internal */
export type DeploymentGetConfigAndEq$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndEq$outboundSchema: z.ZodType<
  DeploymentGetConfigAndEq$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndEqToJSON(
  deploymentGetConfigAndEq: DeploymentGetConfigAndEq,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndEq$outboundSchema.parse(deploymentGetConfigAndEq),
  );
}

/** @internal */
export type AndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const AndEq$outboundSchema: z.ZodType<
  AndEq$Outbound,
  z.ZodTypeDef,
  AndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function andEqToJSON(andEq: AndEq): string {
  return JSON.stringify(AndEq$outboundSchema.parse(andEq));
}

/** @internal */
export type KnowledgeFilterAnd$Outbound =
  | AndEq$Outbound
  | AndNe$Outbound
  | AndGt$Outbound
  | AndGte$Outbound
  | AndLt$Outbound
  | AndLte$Outbound
  | AndIn$Outbound
  | AndNin$Outbound
  | AndExists$Outbound;

/** @internal */
export const KnowledgeFilterAnd$outboundSchema: z.ZodType<
  KnowledgeFilterAnd$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterAnd
> = z.union([
  z.lazy(() => AndEq$outboundSchema),
  z.lazy(() => AndNe$outboundSchema),
  z.lazy(() => AndGt$outboundSchema),
  z.lazy(() => AndGte$outboundSchema),
  z.lazy(() => AndLt$outboundSchema),
  z.lazy(() => AndLte$outboundSchema),
  z.lazy(() => AndIn$outboundSchema),
  z.lazy(() => AndNin$outboundSchema),
  z.lazy(() => AndExists$outboundSchema),
]);

export function knowledgeFilterAndToJSON(
  knowledgeFilterAnd: KnowledgeFilterAnd,
): string {
  return JSON.stringify(
    KnowledgeFilterAnd$outboundSchema.parse(knowledgeFilterAnd),
  );
}

/** @internal */
export type And$Outbound = {
  and: Array<
    {
      [k: string]:
        | AndEq$Outbound
        | AndNe$Outbound
        | AndGt$Outbound
        | AndGte$Outbound
        | AndLt$Outbound
        | AndLte$Outbound
        | AndIn$Outbound
        | AndNin$Outbound
        | AndExists$Outbound;
    }
  >;
};

/** @internal */
export const And$outboundSchema: z.ZodType<And$Outbound, z.ZodTypeDef, And> = z
  .object({
    and: z.array(
      z.record(z.union([
        z.lazy(() => AndEq$outboundSchema),
        z.lazy(() =>
          AndNe$outboundSchema
        ),
        z.lazy(() => AndGt$outboundSchema),
        z.lazy(() => AndGte$outboundSchema),
        z.lazy(() => AndLt$outboundSchema),
        z.lazy(() => AndLte$outboundSchema),
        z.lazy(() => AndIn$outboundSchema),
        z.lazy(() => AndNin$outboundSchema),
        z.lazy(() => AndExists$outboundSchema),
      ])),
    ),
  });

export function andToJSON(and: And): string {
  return JSON.stringify(And$outboundSchema.parse(and));
}

/** @internal */
export type Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const Exists$outboundSchema: z.ZodType<
  Exists$Outbound,
  z.ZodTypeDef,
  Exists
> = z.object({
  exists: z.boolean(),
});

export function existsToJSON(exists: Exists): string {
  return JSON.stringify(Exists$outboundSchema.parse(exists));
}

/** @internal */
export type OneNin$Outbound = string | number | boolean;

/** @internal */
export const OneNin$outboundSchema: z.ZodType<
  OneNin$Outbound,
  z.ZodTypeDef,
  OneNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneNinToJSON(oneNin: OneNin): string {
  return JSON.stringify(OneNin$outboundSchema.parse(oneNin));
}

/** @internal */
export type Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const Nin$outboundSchema: z.ZodType<Nin$Outbound, z.ZodTypeDef, Nin> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function ninToJSON(nin: Nin): string {
  return JSON.stringify(Nin$outboundSchema.parse(nin));
}

/** @internal */
export type OneIn$Outbound = string | number | boolean;

/** @internal */
export const OneIn$outboundSchema: z.ZodType<
  OneIn$Outbound,
  z.ZodTypeDef,
  OneIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneInToJSON(oneIn: OneIn): string {
  return JSON.stringify(OneIn$outboundSchema.parse(oneIn));
}

/** @internal */
export type In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const In$outboundSchema: z.ZodType<In$Outbound, z.ZodTypeDef, In> = z
  .object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function inToJSON(value: In): string {
  return JSON.stringify(In$outboundSchema.parse(value));
}

/** @internal */
export type Lte$Outbound = {
  lte: number;
};

/** @internal */
export const Lte$outboundSchema: z.ZodType<Lte$Outbound, z.ZodTypeDef, Lte> = z
  .object({
    lte: z.number(),
  });

export function lteToJSON(lte: Lte): string {
  return JSON.stringify(Lte$outboundSchema.parse(lte));
}

/** @internal */
export type Lt$Outbound = {
  lt: number;
};

/** @internal */
export const Lt$outboundSchema: z.ZodType<Lt$Outbound, z.ZodTypeDef, Lt> = z
  .object({
    lt: z.number(),
  });

export function ltToJSON(lt: Lt): string {
  return JSON.stringify(Lt$outboundSchema.parse(lt));
}

/** @internal */
export type Gte$Outbound = {
  gte: number;
};

/** @internal */
export const Gte$outboundSchema: z.ZodType<Gte$Outbound, z.ZodTypeDef, Gte> = z
  .object({
    gte: z.number(),
  });

export function gteToJSON(gte: Gte): string {
  return JSON.stringify(Gte$outboundSchema.parse(gte));
}

/** @internal */
export type Gt$Outbound = {
  gt: number;
};

/** @internal */
export const Gt$outboundSchema: z.ZodType<Gt$Outbound, z.ZodTypeDef, Gt> = z
  .object({
    gt: z.number(),
  });

export function gtToJSON(gt: Gt): string {
  return JSON.stringify(Gt$outboundSchema.parse(gt));
}

/** @internal */
export type OneNe$Outbound = string | number | boolean;

/** @internal */
export const OneNe$outboundSchema: z.ZodType<
  OneNe$Outbound,
  z.ZodTypeDef,
  OneNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneNeToJSON(oneNe: OneNe): string {
  return JSON.stringify(OneNe$outboundSchema.parse(oneNe));
}

/** @internal */
export type Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const Ne$outboundSchema: z.ZodType<Ne$Outbound, z.ZodTypeDef, Ne> = z
  .object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });

export function neToJSON(ne: Ne): string {
  return JSON.stringify(Ne$outboundSchema.parse(ne));
}

/** @internal */
export type OneEq$Outbound = string | number | boolean;

/** @internal */
export const OneEq$outboundSchema: z.ZodType<
  OneEq$Outbound,
  z.ZodTypeDef,
  OneEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneEqToJSON(oneEq: OneEq): string {
  return JSON.stringify(OneEq$outboundSchema.parse(oneEq));
}

/** @internal */
export type Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const Eq$outboundSchema: z.ZodType<Eq$Outbound, z.ZodTypeDef, Eq> = z
  .object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });

export function eqToJSON(eq: Eq): string {
  return JSON.stringify(Eq$outboundSchema.parse(eq));
}

/** @internal */
export type KnowledgeFilter1$Outbound =
  | Eq$Outbound
  | Ne$Outbound
  | Gt$Outbound
  | Gte$Outbound
  | Lt$Outbound
  | Lte$Outbound
  | In$Outbound
  | Nin$Outbound
  | Exists$Outbound;

/** @internal */
export const KnowledgeFilter1$outboundSchema: z.ZodType<
  KnowledgeFilter1$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter1
> = z.union([
  z.lazy(() => Eq$outboundSchema),
  z.lazy(() => Ne$outboundSchema),
  z.lazy(() => Gt$outboundSchema),
  z.lazy(() => Gte$outboundSchema),
  z.lazy(() => Lt$outboundSchema),
  z.lazy(() => Lte$outboundSchema),
  z.lazy(() => In$outboundSchema),
  z.lazy(() => Nin$outboundSchema),
  z.lazy(() => Exists$outboundSchema),
]);

export function knowledgeFilter1ToJSON(
  knowledgeFilter1: KnowledgeFilter1,
): string {
  return JSON.stringify(
    KnowledgeFilter1$outboundSchema.parse(knowledgeFilter1),
  );
}

/** @internal */
export type KnowledgeFilter$Outbound = And$Outbound | Or$Outbound | {
  [k: string]:
    | Eq$Outbound
    | Ne$Outbound
    | Gt$Outbound
    | Gte$Outbound
    | Lt$Outbound
    | Lte$Outbound
    | In$Outbound
    | Nin$Outbound
    | Exists$Outbound;
};

/** @internal */
export const KnowledgeFilter$outboundSchema: z.ZodType<
  KnowledgeFilter$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter
> = z.union([
  z.lazy(() => And$outboundSchema),
  z.lazy(() => Or$outboundSchema),
  z.record(z.union([
    z.lazy(() => Eq$outboundSchema),
    z.lazy(() => Ne$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => In$outboundSchema),
    z.lazy(() => Nin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ])),
]);

export function knowledgeFilterToJSON(
  knowledgeFilter: KnowledgeFilter,
): string {
  return JSON.stringify(KnowledgeFilter$outboundSchema.parse(knowledgeFilter));
}

/** @internal */
export type DeploymentGetConfigRequestBody$Outbound = {
  key: string;
  inputs?: { [k: string]: any } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?:
    | Array<
      | SystemMessage$Outbound
      | DeveloperMessage$Outbound
      | UserMessage$Outbound
      | AssistantMessage$Outbound
      | ToolMessage$Outbound
    >
    | undefined;
  messages?:
    | Array<
      | MessagesSystemMessage$Outbound
      | MessagesDeveloperMessage$Outbound
      | MessagesUserMessage$Outbound
      | MessagesAssistantMessage$Outbound
      | MessagesToolMessage$Outbound
    >
    | undefined;
  identity?: components.PublicIdentity$Outbound | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
  thread?: Thread$Outbound | undefined;
  knowledge_filter?: And$Outbound | Or$Outbound | {
    [k: string]:
      | Eq$Outbound
      | Ne$Outbound
      | Gt$Outbound
      | Gte$Outbound
      | Lt$Outbound
      | Lte$Outbound
      | In$Outbound
      | Nin$Outbound
      | Exists$Outbound;
  } | undefined;
};

/** @internal */
export const DeploymentGetConfigRequestBody$outboundSchema: z.ZodType<
  DeploymentGetConfigRequestBody$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigRequestBody
> = z.object({
  key: z.string(),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(
    z.union([
      z.lazy(() => SystemMessage$outboundSchema),
      z.lazy(() => DeveloperMessage$outboundSchema),
      z.lazy(() => UserMessage$outboundSchema),
      z.lazy(() => AssistantMessage$outboundSchema),
      z.lazy(() => ToolMessage$outboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesSystemMessage$outboundSchema),
      z.lazy(() => MessagesDeveloperMessage$outboundSchema),
      z.lazy(() => MessagesUserMessage$outboundSchema),
      z.lazy(() => MessagesAssistantMessage$outboundSchema),
      z.lazy(() => MessagesToolMessage$outboundSchema),
    ]),
  ).optional(),
  identity: components.PublicIdentity$outboundSchema.optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
  thread: z.lazy(() => Thread$outboundSchema).optional(),
  knowledgeFilter: z.union([
    z.lazy(() => And$outboundSchema),
    z.lazy(() => Or$outboundSchema),
    z.record(z.union([
      z.lazy(() => Eq$outboundSchema),
      z.lazy(() => Ne$outboundSchema),
      z.lazy(() => Gt$outboundSchema),
      z.lazy(() => Gte$outboundSchema),
      z.lazy(() => Lt$outboundSchema),
      z.lazy(() => Lte$outboundSchema),
      z.lazy(() => In$outboundSchema),
      z.lazy(() => Nin$outboundSchema),
      z.lazy(() => Exists$outboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
    knowledgeFilter: "knowledge_filter",
  });
});

export function deploymentGetConfigRequestBodyToJSON(
  deploymentGetConfigRequestBody: DeploymentGetConfigRequestBody,
): string {
  return JSON.stringify(
    DeploymentGetConfigRequestBody$outboundSchema.parse(
      deploymentGetConfigRequestBody,
    ),
  );
}

/** @internal */
export const DeploymentGetConfigType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigType
> = z.nativeEnum(DeploymentGetConfigType);

/** @internal */
export const DeploymentGetConfigRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigRole
> = z.nativeEnum(DeploymentGetConfigRole);

/** @internal */
export const TwoFile$inboundSchema: z.ZodType<TwoFile, z.ZodTypeDef, unknown> =
  z.object({
    file_data: z.string().optional(),
    uri: z.string().optional(),
    mimeType: z.string().optional(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });

export function twoFileFromJSON(
  jsonString: string,
): SafeParseResult<TwoFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoFile' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig23$inboundSchema: z.ZodType<
  DeploymentGetConfig23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => TwoFile$inboundSchema),
});

export function deploymentGetConfig23FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig23' from JSON`,
  );
}

/** @internal */
export const TwoImageUrl$inboundSchema: z.ZodType<
  TwoImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function twoImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<TwoImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoImageUrl' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig22$inboundSchema: z.ZodType<
  DeploymentGetConfig22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => TwoImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

export function deploymentGetConfig22FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig22' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig21$inboundSchema: z.ZodType<
  DeploymentGetConfig21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function deploymentGetConfig21FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig21' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContentDeploymentsResponse2$inboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsResponse2,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => DeploymentGetConfig21$inboundSchema),
    z.lazy(() => DeploymentGetConfig22$inboundSchema),
    z.lazy(() => DeploymentGetConfig23$inboundSchema),
  ]);

export function deploymentGetConfigContentDeploymentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigContentDeploymentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeploymentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigContentDeploymentsResponse2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContent$inboundSchema: z.ZodType<
  DeploymentGetConfigContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => DeploymentGetConfig21$inboundSchema),
    z.lazy(() => DeploymentGetConfig22$inboundSchema),
    z.lazy(() => DeploymentGetConfig23$inboundSchema),
  ])),
]);

export function deploymentGetConfigContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContent' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigDeploymentsResponseType> = z
    .nativeEnum(DeploymentGetConfigDeploymentsResponseType);

/** @internal */
export const DeploymentGetConfigDeploymentsFunction$inboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function deploymentGetConfigDeploymentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigDeploymentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigDeploymentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigDeploymentsFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigToolCalls$inboundSchema: z.ZodType<
  DeploymentGetConfigToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentGetConfigDeploymentsResponseType$inboundSchema,
  function: z.lazy(() => DeploymentGetConfigDeploymentsFunction$inboundSchema),
});

export function deploymentGetConfigToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigToolCalls' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsMessages$inboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentGetConfigRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => DeploymentGetConfig21$inboundSchema),
          z.lazy(() => DeploymentGetConfig22$inboundSchema),
          z.lazy(() => DeploymentGetConfig23$inboundSchema),
        ]),
      ),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => DeploymentGetConfigToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});

export function deploymentGetConfigDeploymentsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigDeploymentsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigDeploymentsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigDeploymentsMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigFormat
> = z.nativeEnum(DeploymentGetConfigFormat);

/** @internal */
export const ResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormat6
> = z.nativeEnum(ResponseFormat6);

/** @internal */
export const ResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormat5
> = z.nativeEnum(ResponseFormat5);

/** @internal */
export const ResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormat4
> = z.nativeEnum(ResponseFormat4);

/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatDeploymentsType> = z
    .nativeEnum(DeploymentGetConfigResponseFormatDeploymentsType);

/** @internal */
export const ResponseFormat3$inboundSchema: z.ZodType<
  ResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsType$inboundSchema,
});

export function responseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat3' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormatType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatType> = z.nativeEnum(
    DeploymentGetConfigResponseFormatType,
  );

/** @internal */
export const ResponseFormat2$inboundSchema: z.ZodType<
  ResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatType$inboundSchema,
});

export function responseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfigResponseFormatDeploymentsResponseType
  > = z.nativeEnum(DeploymentGetConfigResponseFormatDeploymentsResponseType);

/** @internal */
export const DeploymentGetConfigResponseFormatJsonSchema$inboundSchema:
  z.ZodType<
    DeploymentGetConfigResponseFormatJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function deploymentGetConfigResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigResponseFormatJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigResponseFormatJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormat1$inboundSchema: z.ZodType<
  ResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsResponseType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    DeploymentGetConfigResponseFormatJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});

export function responseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat1' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormat$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseFormat1$inboundSchema),
  z.lazy(() => ResponseFormat2$inboundSchema),
  z.lazy(() => ResponseFormat3$inboundSchema),
  ResponseFormat4$inboundSchema,
  ResponseFormat5$inboundSchema,
  ResponseFormat6$inboundSchema,
]);

export function deploymentGetConfigResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseFormat' from JSON`,
  );
}

/** @internal */
export const PhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof PhotoRealVersion
> = z.nativeEnum(PhotoRealVersion);

/** @internal */
export const DeploymentGetConfigEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigEncodingFormat
> = z.nativeEnum(DeploymentGetConfigEncodingFormat);

/** @internal */
export const DeploymentGetConfigReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigReasoningEffort
> = z.nativeEnum(DeploymentGetConfigReasoningEffort);

/** @internal */
export const Verbosity$inboundSchema: z.ZodNativeEnum<typeof Verbosity> = z
  .nativeEnum(Verbosity);

/** @internal */
export const ThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof ThinkingLevel
> = z.nativeEnum(ThinkingLevel);

/** @internal */
export const DeploymentGetConfigParameters$inboundSchema: z.ZodType<
  DeploymentGetConfigParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: DeploymentGetConfigFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => ResponseFormat1$inboundSchema),
      z.lazy(() => ResponseFormat2$inboundSchema),
      z.lazy(() => ResponseFormat3$inboundSchema),
      ResponseFormat4$inboundSchema,
      ResponseFormat5$inboundSchema,
      ResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: PhotoRealVersion$inboundSchema.optional(),
  encoding_format: DeploymentGetConfigEncodingFormat$inboundSchema.optional(),
  reasoningEffort: DeploymentGetConfigReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: Verbosity$inboundSchema.optional(),
  thinkingLevel: ThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

export function deploymentGetConfigParametersFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigParameters' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigDeploymentsType
> = z.nativeEnum(DeploymentGetConfigDeploymentsType);

/** @internal */
export const DeploymentGetConfigFunction$inboundSchema: z.ZodType<
  DeploymentGetConfigFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.record(z.any()).optional(),
});

export function deploymentGetConfigFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigTools$inboundSchema: z.ZodType<
  DeploymentGetConfigTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigDeploymentsType$inboundSchema,
  function: z.lazy(() => DeploymentGetConfigFunction$inboundSchema),
});

export function deploymentGetConfigToolsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigTools' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseBody$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  provider: z.string(),
  model: z.string(),
  type: DeploymentGetConfigType$inboundSchema.optional(),
  version: z.string(),
  messages: z.array(
    z.lazy(() => DeploymentGetConfigDeploymentsMessages$inboundSchema),
  ),
  parameters: z.lazy(() => DeploymentGetConfigParameters$inboundSchema),
  tools: z.array(z.lazy(() => DeploymentGetConfigTools$inboundSchema))
    .optional(),
});

export function deploymentGetConfigResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseBody' from JSON`,
  );
}
