/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListKnowledgeBasesRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const ListKnowledgeBasesObject = {
  List: "list",
} as const;
export type ListKnowledgeBasesObject = ClosedEnum<
  typeof ListKnowledgeBasesObject
>;

export const ListKnowledgeBasesDataKnowledgeType = {
  External: "external",
} as const;
export type ListKnowledgeBasesDataKnowledgeType = ClosedEnum<
  typeof ListKnowledgeBasesDataKnowledgeType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type DataRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK: number;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold: number;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type DataAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type DataRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK: number;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold: number;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: DataRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: DataAgenticRagConfig | null | undefined;
};

export type DataExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
};

export type Data2 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type: ListKnowledgeBasesDataKnowledgeType;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?: DataRetrievalSettings | undefined;
  externalConfig: DataExternalConfig;
};

export const ListKnowledgeBasesDataType = {
  Internal: "internal",
} as const;
export type ListKnowledgeBasesDataType = ClosedEnum<
  typeof ListKnowledgeBasesDataType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const DataRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type DataRetrievalType = ClosedEnum<typeof DataRetrievalType>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type ListKnowledgeBasesDataRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK: number;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold: number;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type ListKnowledgeBasesDataAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type ListKnowledgeBasesDataRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType: DataRetrievalType;
  /**
   * The number of results to return from the search.
   */
  topK: number;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold: number;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: ListKnowledgeBasesDataRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: ListKnowledgeBasesDataAgenticRagConfig | null | undefined;
};

export type Data1 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type: ListKnowledgeBasesDataType;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: ListKnowledgeBasesDataRetrievalSettings | undefined;
  /**
   * The embeddings model used for the knowledge base.
   */
  model: string;
};

export type ListKnowledgeBasesData = Data1 | Data2;

/**
 * Knowledge bases retrieved
 */
export type ListKnowledgeBasesResponseBody = {
  object: ListKnowledgeBasesObject;
  data: Array<Data1 | Data2>;
  hasMore: boolean;
};

/** @internal */
export type ListKnowledgeBasesRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const ListKnowledgeBasesRequest$outboundSchema: z.ZodType<
  ListKnowledgeBasesRequest$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listKnowledgeBasesRequestToJSON(
  listKnowledgeBasesRequest: ListKnowledgeBasesRequest,
): string {
  return JSON.stringify(
    ListKnowledgeBasesRequest$outboundSchema.parse(listKnowledgeBasesRequest),
  );
}

/** @internal */
export const ListKnowledgeBasesObject$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesObject
> = z.nativeEnum(ListKnowledgeBasesObject);

/** @internal */
export const ListKnowledgeBasesDataKnowledgeType$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesDataKnowledgeType
> = z.nativeEnum(ListKnowledgeBasesDataKnowledgeType);

/** @internal */
export const DataRerankConfig$inboundSchema: z.ZodType<
  DataRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});

export function dataRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataRerankConfig' from JSON`,
  );
}

/** @internal */
export const DataAgenticRagConfig$inboundSchema: z.ZodType<
  DataAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function dataAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const DataRetrievalSettings$inboundSchema: z.ZodType<
  DataRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(z.lazy(() => DataRerankConfig$inboundSchema))
    .optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => DataAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});

export function dataRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<DataRetrievalSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataRetrievalSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const DataExternalConfig$inboundSchema: z.ZodType<
  DataExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
  });
});

export function dataExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataExternalConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataExternalConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataExternalConfig' from JSON`,
  );
}

/** @internal */
export const Data2$inboundSchema: z.ZodType<Data2, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    created: z.string(),
    description: z.string().optional(),
    key: z.string(),
    domain_id: z.string(),
    path: z.string().optional(),
    created_by_id: z.nullable(z.string()).optional(),
    updated_by_id: z.nullable(z.string()).optional(),
    updated: z.string(),
    type: ListKnowledgeBasesDataKnowledgeType$inboundSchema.default("external"),
    retrieval_settings: z.lazy(() => DataRetrievalSettings$inboundSchema)
      .optional(),
    external_config: z.lazy(() => DataExternalConfig$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "domain_id": "domainId",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "retrieval_settings": "retrievalSettings",
      "external_config": "externalConfig",
    });
  });

export function data2FromJSON(
  jsonString: string,
): SafeParseResult<Data2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data2' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataType$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesDataType
> = z.nativeEnum(ListKnowledgeBasesDataType);

/** @internal */
export const DataRetrievalType$inboundSchema: z.ZodNativeEnum<
  typeof DataRetrievalType
> = z.nativeEnum(DataRetrievalType);

/** @internal */
export const ListKnowledgeBasesDataRerankConfig$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});

export function listKnowledgeBasesDataRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesDataRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesDataRerankConfig' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataAgenticRagConfig$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function listKnowledgeBasesDataAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesDataAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesDataAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataRetrievalSettings$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  retrieval_type: DataRetrievalType$inboundSchema.default("hybrid_search"),
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataRerankConfig$inboundSchema),
  ).optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "retrieval_type": "retrievalType",
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});

export function listKnowledgeBasesDataRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListKnowledgeBasesDataRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListKnowledgeBasesDataRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const Data1$inboundSchema: z.ZodType<Data1, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    created: z.string(),
    description: z.string().optional(),
    key: z.string(),
    domain_id: z.string(),
    path: z.string().optional(),
    created_by_id: z.nullable(z.string()).optional(),
    updated_by_id: z.nullable(z.string()).optional(),
    updated: z.string(),
    type: ListKnowledgeBasesDataType$inboundSchema.default("internal"),
    retrieval_settings: z.lazy(() =>
      ListKnowledgeBasesDataRetrievalSettings$inboundSchema
    ).optional(),
    model: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "domain_id": "domainId",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "retrieval_settings": "retrievalSettings",
    });
  });

export function data1FromJSON(
  jsonString: string,
): SafeParseResult<Data1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data1' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesData$inboundSchema: z.ZodType<
  ListKnowledgeBasesData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Data1$inboundSchema),
  z.lazy(() => Data2$inboundSchema),
]);

export function listKnowledgeBasesDataFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesData' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesResponseBody$inboundSchema: z.ZodType<
  ListKnowledgeBasesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ListKnowledgeBasesObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$inboundSchema),
      z.lazy(() => Data2$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function listKnowledgeBasesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesResponseBody' from JSON`,
  );
}
