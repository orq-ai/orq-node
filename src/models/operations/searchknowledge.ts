/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export const SearchType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export type SearchType = ClosedEnum<typeof SearchType>;

/**
 * Exists
 */
export type SearchKnowledgeOrExists = {
  exists: boolean;
};

export type SearchKnowledgeOrKnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledgeOrNin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledgeOrKnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledgeOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledgeOrLte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledgeOrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledgeOrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type SearchKnowledgeOrGt = {
  gt: number;
};

export type SearchKnowledgeOrKnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledgeOrNe = {
  ne: string | number | boolean;
};

export type SearchKnowledgeOrKnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledgeOrEq = {
  eq: string | number | boolean;
};

export type SearchKnowledgeFilterByOr =
  | SearchKnowledgeOrEq
  | SearchKnowledgeOrNe
  | SearchKnowledgeOrGt
  | SearchKnowledgeOrGte
  | SearchKnowledgeOrLt
  | SearchKnowledgeOrLte
  | SearchKnowledgeOrIn
  | SearchKnowledgeOrNin
  | SearchKnowledgeOrExists;

/**
 * Or
 */
export type FilterByOr = {
  or: Array<
    {
      [k: string]:
        | SearchKnowledgeOrEq
        | SearchKnowledgeOrNe
        | SearchKnowledgeOrGt
        | SearchKnowledgeOrGte
        | SearchKnowledgeOrLt
        | SearchKnowledgeOrLte
        | SearchKnowledgeOrIn
        | SearchKnowledgeOrNin
        | SearchKnowledgeOrExists;
    }
  >;
};

/**
 * Exists
 */
export type SearchKnowledgeAndExists = {
  exists: boolean;
};

export type SearchKnowledgeAndKnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledgeAndNin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledgeAndKnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledgeAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledgeAndLte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledgeAndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledgeAndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type SearchKnowledgeAndGt = {
  gt: number;
};

export type SearchKnowledgeAndKnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledgeAndNe = {
  ne: string | number | boolean;
};

export type SearchKnowledgeAndKnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledgeAndEq = {
  eq: string | number | boolean;
};

export type SearchKnowledgeFilterByAnd =
  | SearchKnowledgeAndEq
  | SearchKnowledgeAndNe
  | SearchKnowledgeAndGt
  | SearchKnowledgeAndGte
  | SearchKnowledgeAndLt
  | SearchKnowledgeAndLte
  | SearchKnowledgeAndIn
  | SearchKnowledgeAndNin
  | SearchKnowledgeAndExists;

/**
 * And
 */
export type FilterByAnd = {
  and: Array<
    {
      [k: string]:
        | SearchKnowledgeAndEq
        | SearchKnowledgeAndNe
        | SearchKnowledgeAndGt
        | SearchKnowledgeAndGte
        | SearchKnowledgeAndLt
        | SearchKnowledgeAndLte
        | SearchKnowledgeAndIn
        | SearchKnowledgeAndNin
        | SearchKnowledgeAndExists;
    }
  >;
};

/**
 * Exists
 */
export type SearchKnowledge1Exists = {
  exists: boolean;
};

export type SearchKnowledge1KnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledge1Nin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledge1KnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledge1In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledge1Lte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledge1Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledge1Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type SearchKnowledge1Gt = {
  gt: number;
};

export type SearchKnowledge1KnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledge1Ne = {
  ne: string | number | boolean;
};

export type SearchKnowledge1KnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledge1Eq = {
  eq: string | number | boolean;
};

export type FilterBy1 =
  | SearchKnowledge1Eq
  | SearchKnowledge1Ne
  | SearchKnowledge1Gt
  | SearchKnowledge1Gte
  | SearchKnowledge1Lt
  | SearchKnowledge1Lte
  | SearchKnowledge1In
  | SearchKnowledge1Nin
  | SearchKnowledge1Exists;

/**
 * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://docs.orq.ai/docs/knowledge/api#knowledge-base-search) for more information.
 */
export type FilterBy = FilterByAnd | FilterByOr | {
  [k: string]:
    | SearchKnowledge1Eq
    | SearchKnowledge1Ne
    | SearchKnowledge1Gt
    | SearchKnowledge1Gte
    | SearchKnowledge1Lt
    | SearchKnowledge1Lte
    | SearchKnowledge1In
    | SearchKnowledge1Nin
    | SearchKnowledge1Exists;
};

/**
 * Additional search options
 */
export type SearchOptions = {
  /**
   * Whether to include the vector in the chunk
   */
  includeVectors?: boolean | undefined;
  /**
   * Whether to include the metadata in the chunk
   */
  includeMetadata?: boolean | undefined;
  /**
   * Whether to include the scores in the chunk
   */
  includeScores?: boolean | undefined;
};

/**
 * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
 */
export type RerankConfig = {
  /**
   * The name of the rerank model to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/rerank-models).
   */
  model: string;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The number of top results to return after reranking. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
};

/**
 * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
 */
export type AgenticRagConfig = {
  /**
   * The name of the model for the Agent to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/chat-models).
   */
  model: string;
};

/**
 * A search request for chunks in a knowledge base
 */
export type SearchKnowledgeRequestBody = {
  /**
   * The query to use to search the knowledge base
   */
  query: string;
  /**
   * The number of results to return. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
  /**
   * The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`
   */
  threshold?: number | undefined;
  /**
   * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
   */
  searchType?: SearchType | undefined;
  /**
   * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://docs.orq.ai/docs/knowledge/api#knowledge-base-search) for more information.
   */
  filterBy?: FilterByAnd | FilterByOr | {
    [k: string]:
      | SearchKnowledge1Eq
      | SearchKnowledge1Ne
      | SearchKnowledge1Gt
      | SearchKnowledge1Gte
      | SearchKnowledge1Lt
      | SearchKnowledge1Lte
      | SearchKnowledge1In
      | SearchKnowledge1Nin
      | SearchKnowledge1Exists;
  } | undefined;
  /**
   * Additional search options
   */
  searchOptions?: SearchOptions | undefined;
  /**
   * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
   */
  rerankConfig?: RerankConfig | undefined;
  /**
   * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
   */
  agenticRagConfig?: AgenticRagConfig | undefined;
};

export type SearchKnowledgeRequest = {
  /**
   * The unique identifier or key of the knowledge base
   */
  knowledgeId: string;
  /**
   * A search request for chunks in a knowledge base
   */
  requestBody?: SearchKnowledgeRequestBody | undefined;
};

export type Scores = {
  rerankScore?: number | undefined;
  searchScore?: number | undefined;
};

export type Matches = {
  id: string;
  text: string;
  vector?: Array<number> | undefined;
  metadata?: { [k: string]: any } | undefined;
  scores?: Scores | undefined;
};

/**
 * Search knowledge base
 */
export type SearchKnowledgeResponseBody = {
  matches: Array<Matches>;
};

/** @internal */
export const SearchType$outboundSchema: z.ZodNativeEnum<typeof SearchType> = z
  .nativeEnum(SearchType);

/** @internal */
export type SearchKnowledgeOrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledgeOrExists$outboundSchema: z.ZodType<
  SearchKnowledgeOrExists$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrExists
> = z.object({
  exists: z.boolean(),
});

export function searchKnowledgeOrExistsToJSON(
  searchKnowledgeOrExists: SearchKnowledgeOrExists,
): string {
  return JSON.stringify(
    SearchKnowledgeOrExists$outboundSchema.parse(searchKnowledgeOrExists),
  );
}

/** @internal */
export type SearchKnowledgeOrKnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeOrKnowledgeNinToJSON(
  searchKnowledgeOrKnowledgeNin: SearchKnowledgeOrKnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeNin$outboundSchema.parse(
      searchKnowledgeOrKnowledgeNin,
    ),
  );
}

/** @internal */
export type SearchKnowledgeOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeOrNin$outboundSchema: z.ZodType<
  SearchKnowledgeOrNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledgeOrNinToJSON(
  searchKnowledgeOrNin: SearchKnowledgeOrNin,
): string {
  return JSON.stringify(
    SearchKnowledgeOrNin$outboundSchema.parse(searchKnowledgeOrNin),
  );
}

/** @internal */
export type SearchKnowledgeOrKnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeOrKnowledgeInToJSON(
  searchKnowledgeOrKnowledgeIn: SearchKnowledgeOrKnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeIn$outboundSchema.parse(
      searchKnowledgeOrKnowledgeIn,
    ),
  );
}

/** @internal */
export type SearchKnowledgeOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeOrIn$outboundSchema: z.ZodType<
  SearchKnowledgeOrIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledgeOrInToJSON(
  searchKnowledgeOrIn: SearchKnowledgeOrIn,
): string {
  return JSON.stringify(
    SearchKnowledgeOrIn$outboundSchema.parse(searchKnowledgeOrIn),
  );
}

/** @internal */
export type SearchKnowledgeOrLte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledgeOrLte$outboundSchema: z.ZodType<
  SearchKnowledgeOrLte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrLte
> = z.object({
  lte: z.number(),
});

export function searchKnowledgeOrLteToJSON(
  searchKnowledgeOrLte: SearchKnowledgeOrLte,
): string {
  return JSON.stringify(
    SearchKnowledgeOrLte$outboundSchema.parse(searchKnowledgeOrLte),
  );
}

/** @internal */
export type SearchKnowledgeOrLt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledgeOrLt$outboundSchema: z.ZodType<
  SearchKnowledgeOrLt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrLt
> = z.object({
  lt: z.number(),
});

export function searchKnowledgeOrLtToJSON(
  searchKnowledgeOrLt: SearchKnowledgeOrLt,
): string {
  return JSON.stringify(
    SearchKnowledgeOrLt$outboundSchema.parse(searchKnowledgeOrLt),
  );
}

/** @internal */
export type SearchKnowledgeOrGte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledgeOrGte$outboundSchema: z.ZodType<
  SearchKnowledgeOrGte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrGte
> = z.object({
  gte: z.number(),
});

export function searchKnowledgeOrGteToJSON(
  searchKnowledgeOrGte: SearchKnowledgeOrGte,
): string {
  return JSON.stringify(
    SearchKnowledgeOrGte$outboundSchema.parse(searchKnowledgeOrGte),
  );
}

/** @internal */
export type SearchKnowledgeOrGt$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledgeOrGt$outboundSchema: z.ZodType<
  SearchKnowledgeOrGt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrGt
> = z.object({
  gt: z.number(),
});

export function searchKnowledgeOrGtToJSON(
  searchKnowledgeOrGt: SearchKnowledgeOrGt,
): string {
  return JSON.stringify(
    SearchKnowledgeOrGt$outboundSchema.parse(searchKnowledgeOrGt),
  );
}

/** @internal */
export type SearchKnowledgeOrKnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeOrKnowledgeNeToJSON(
  searchKnowledgeOrKnowledgeNe: SearchKnowledgeOrKnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeNe$outboundSchema.parse(
      searchKnowledgeOrKnowledgeNe,
    ),
  );
}

/** @internal */
export type SearchKnowledgeOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeOrNe$outboundSchema: z.ZodType<
  SearchKnowledgeOrNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledgeOrNeToJSON(
  searchKnowledgeOrNe: SearchKnowledgeOrNe,
): string {
  return JSON.stringify(
    SearchKnowledgeOrNe$outboundSchema.parse(searchKnowledgeOrNe),
  );
}

/** @internal */
export type SearchKnowledgeOrKnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeOrKnowledgeEqToJSON(
  searchKnowledgeOrKnowledgeEq: SearchKnowledgeOrKnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeEq$outboundSchema.parse(
      searchKnowledgeOrKnowledgeEq,
    ),
  );
}

/** @internal */
export type SearchKnowledgeOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeOrEq$outboundSchema: z.ZodType<
  SearchKnowledgeOrEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledgeOrEqToJSON(
  searchKnowledgeOrEq: SearchKnowledgeOrEq,
): string {
  return JSON.stringify(
    SearchKnowledgeOrEq$outboundSchema.parse(searchKnowledgeOrEq),
  );
}

/** @internal */
export type SearchKnowledgeFilterByOr$Outbound =
  | SearchKnowledgeOrEq$Outbound
  | SearchKnowledgeOrNe$Outbound
  | SearchKnowledgeOrGt$Outbound
  | SearchKnowledgeOrGte$Outbound
  | SearchKnowledgeOrLt$Outbound
  | SearchKnowledgeOrLte$Outbound
  | SearchKnowledgeOrIn$Outbound
  | SearchKnowledgeOrNin$Outbound
  | SearchKnowledgeOrExists$Outbound;

/** @internal */
export const SearchKnowledgeFilterByOr$outboundSchema: z.ZodType<
  SearchKnowledgeFilterByOr$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeFilterByOr
> = z.union([
  z.lazy(() => SearchKnowledgeOrEq$outboundSchema),
  z.lazy(() => SearchKnowledgeOrNe$outboundSchema),
  z.lazy(() => SearchKnowledgeOrGt$outboundSchema),
  z.lazy(() => SearchKnowledgeOrGte$outboundSchema),
  z.lazy(() => SearchKnowledgeOrLt$outboundSchema),
  z.lazy(() => SearchKnowledgeOrLte$outboundSchema),
  z.lazy(() => SearchKnowledgeOrIn$outboundSchema),
  z.lazy(() => SearchKnowledgeOrNin$outboundSchema),
  z.lazy(() => SearchKnowledgeOrExists$outboundSchema),
]);

export function searchKnowledgeFilterByOrToJSON(
  searchKnowledgeFilterByOr: SearchKnowledgeFilterByOr,
): string {
  return JSON.stringify(
    SearchKnowledgeFilterByOr$outboundSchema.parse(searchKnowledgeFilterByOr),
  );
}

/** @internal */
export type FilterByOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | SearchKnowledgeOrEq$Outbound
        | SearchKnowledgeOrNe$Outbound
        | SearchKnowledgeOrGt$Outbound
        | SearchKnowledgeOrGte$Outbound
        | SearchKnowledgeOrLt$Outbound
        | SearchKnowledgeOrLte$Outbound
        | SearchKnowledgeOrIn$Outbound
        | SearchKnowledgeOrNin$Outbound
        | SearchKnowledgeOrExists$Outbound;
    }
  >;
};

/** @internal */
export const FilterByOr$outboundSchema: z.ZodType<
  FilterByOr$Outbound,
  z.ZodTypeDef,
  FilterByOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeOrEq$outboundSchema),
      z.lazy(() =>
        SearchKnowledgeOrNe$outboundSchema
      ),
      z.lazy(() => SearchKnowledgeOrGt$outboundSchema),
      z.lazy(() => SearchKnowledgeOrGte$outboundSchema),
      z.lazy(() => SearchKnowledgeOrLt$outboundSchema),
      z.lazy(() => SearchKnowledgeOrLte$outboundSchema),
      z.lazy(() => SearchKnowledgeOrIn$outboundSchema),
      z.lazy(() => SearchKnowledgeOrNin$outboundSchema),
      z.lazy(() => SearchKnowledgeOrExists$outboundSchema),
    ])),
  ),
});

export function filterByOrToJSON(filterByOr: FilterByOr): string {
  return JSON.stringify(FilterByOr$outboundSchema.parse(filterByOr));
}

/** @internal */
export type SearchKnowledgeAndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledgeAndExists$outboundSchema: z.ZodType<
  SearchKnowledgeAndExists$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndExists
> = z.object({
  exists: z.boolean(),
});

export function searchKnowledgeAndExistsToJSON(
  searchKnowledgeAndExists: SearchKnowledgeAndExists,
): string {
  return JSON.stringify(
    SearchKnowledgeAndExists$outboundSchema.parse(searchKnowledgeAndExists),
  );
}

/** @internal */
export type SearchKnowledgeAndKnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeAndKnowledgeNinToJSON(
  searchKnowledgeAndKnowledgeNin: SearchKnowledgeAndKnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeNin$outboundSchema.parse(
      searchKnowledgeAndKnowledgeNin,
    ),
  );
}

/** @internal */
export type SearchKnowledgeAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeAndNin$outboundSchema: z.ZodType<
  SearchKnowledgeAndNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledgeAndNinToJSON(
  searchKnowledgeAndNin: SearchKnowledgeAndNin,
): string {
  return JSON.stringify(
    SearchKnowledgeAndNin$outboundSchema.parse(searchKnowledgeAndNin),
  );
}

/** @internal */
export type SearchKnowledgeAndKnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeAndKnowledgeInToJSON(
  searchKnowledgeAndKnowledgeIn: SearchKnowledgeAndKnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeIn$outboundSchema.parse(
      searchKnowledgeAndKnowledgeIn,
    ),
  );
}

/** @internal */
export type SearchKnowledgeAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeAndIn$outboundSchema: z.ZodType<
  SearchKnowledgeAndIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledgeAndInToJSON(
  searchKnowledgeAndIn: SearchKnowledgeAndIn,
): string {
  return JSON.stringify(
    SearchKnowledgeAndIn$outboundSchema.parse(searchKnowledgeAndIn),
  );
}

/** @internal */
export type SearchKnowledgeAndLte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledgeAndLte$outboundSchema: z.ZodType<
  SearchKnowledgeAndLte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndLte
> = z.object({
  lte: z.number(),
});

export function searchKnowledgeAndLteToJSON(
  searchKnowledgeAndLte: SearchKnowledgeAndLte,
): string {
  return JSON.stringify(
    SearchKnowledgeAndLte$outboundSchema.parse(searchKnowledgeAndLte),
  );
}

/** @internal */
export type SearchKnowledgeAndLt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledgeAndLt$outboundSchema: z.ZodType<
  SearchKnowledgeAndLt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndLt
> = z.object({
  lt: z.number(),
});

export function searchKnowledgeAndLtToJSON(
  searchKnowledgeAndLt: SearchKnowledgeAndLt,
): string {
  return JSON.stringify(
    SearchKnowledgeAndLt$outboundSchema.parse(searchKnowledgeAndLt),
  );
}

/** @internal */
export type SearchKnowledgeAndGte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledgeAndGte$outboundSchema: z.ZodType<
  SearchKnowledgeAndGte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndGte
> = z.object({
  gte: z.number(),
});

export function searchKnowledgeAndGteToJSON(
  searchKnowledgeAndGte: SearchKnowledgeAndGte,
): string {
  return JSON.stringify(
    SearchKnowledgeAndGte$outboundSchema.parse(searchKnowledgeAndGte),
  );
}

/** @internal */
export type SearchKnowledgeAndGt$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledgeAndGt$outboundSchema: z.ZodType<
  SearchKnowledgeAndGt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndGt
> = z.object({
  gt: z.number(),
});

export function searchKnowledgeAndGtToJSON(
  searchKnowledgeAndGt: SearchKnowledgeAndGt,
): string {
  return JSON.stringify(
    SearchKnowledgeAndGt$outboundSchema.parse(searchKnowledgeAndGt),
  );
}

/** @internal */
export type SearchKnowledgeAndKnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeAndKnowledgeNeToJSON(
  searchKnowledgeAndKnowledgeNe: SearchKnowledgeAndKnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeNe$outboundSchema.parse(
      searchKnowledgeAndKnowledgeNe,
    ),
  );
}

/** @internal */
export type SearchKnowledgeAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeAndNe$outboundSchema: z.ZodType<
  SearchKnowledgeAndNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledgeAndNeToJSON(
  searchKnowledgeAndNe: SearchKnowledgeAndNe,
): string {
  return JSON.stringify(
    SearchKnowledgeAndNe$outboundSchema.parse(searchKnowledgeAndNe),
  );
}

/** @internal */
export type SearchKnowledgeAndKnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledgeAndKnowledgeEqToJSON(
  searchKnowledgeAndKnowledgeEq: SearchKnowledgeAndKnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeEq$outboundSchema.parse(
      searchKnowledgeAndKnowledgeEq,
    ),
  );
}

/** @internal */
export type SearchKnowledgeAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeAndEq$outboundSchema: z.ZodType<
  SearchKnowledgeAndEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledgeAndEqToJSON(
  searchKnowledgeAndEq: SearchKnowledgeAndEq,
): string {
  return JSON.stringify(
    SearchKnowledgeAndEq$outboundSchema.parse(searchKnowledgeAndEq),
  );
}

/** @internal */
export type SearchKnowledgeFilterByAnd$Outbound =
  | SearchKnowledgeAndEq$Outbound
  | SearchKnowledgeAndNe$Outbound
  | SearchKnowledgeAndGt$Outbound
  | SearchKnowledgeAndGte$Outbound
  | SearchKnowledgeAndLt$Outbound
  | SearchKnowledgeAndLte$Outbound
  | SearchKnowledgeAndIn$Outbound
  | SearchKnowledgeAndNin$Outbound
  | SearchKnowledgeAndExists$Outbound;

/** @internal */
export const SearchKnowledgeFilterByAnd$outboundSchema: z.ZodType<
  SearchKnowledgeFilterByAnd$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeFilterByAnd
> = z.union([
  z.lazy(() => SearchKnowledgeAndEq$outboundSchema),
  z.lazy(() => SearchKnowledgeAndNe$outboundSchema),
  z.lazy(() => SearchKnowledgeAndGt$outboundSchema),
  z.lazy(() => SearchKnowledgeAndGte$outboundSchema),
  z.lazy(() => SearchKnowledgeAndLt$outboundSchema),
  z.lazy(() => SearchKnowledgeAndLte$outboundSchema),
  z.lazy(() => SearchKnowledgeAndIn$outboundSchema),
  z.lazy(() => SearchKnowledgeAndNin$outboundSchema),
  z.lazy(() => SearchKnowledgeAndExists$outboundSchema),
]);

export function searchKnowledgeFilterByAndToJSON(
  searchKnowledgeFilterByAnd: SearchKnowledgeFilterByAnd,
): string {
  return JSON.stringify(
    SearchKnowledgeFilterByAnd$outboundSchema.parse(searchKnowledgeFilterByAnd),
  );
}

/** @internal */
export type FilterByAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | SearchKnowledgeAndEq$Outbound
        | SearchKnowledgeAndNe$Outbound
        | SearchKnowledgeAndGt$Outbound
        | SearchKnowledgeAndGte$Outbound
        | SearchKnowledgeAndLt$Outbound
        | SearchKnowledgeAndLte$Outbound
        | SearchKnowledgeAndIn$Outbound
        | SearchKnowledgeAndNin$Outbound
        | SearchKnowledgeAndExists$Outbound;
    }
  >;
};

/** @internal */
export const FilterByAnd$outboundSchema: z.ZodType<
  FilterByAnd$Outbound,
  z.ZodTypeDef,
  FilterByAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeAndEq$outboundSchema),
      z.lazy(() =>
        SearchKnowledgeAndNe$outboundSchema
      ),
      z.lazy(() => SearchKnowledgeAndGt$outboundSchema),
      z.lazy(() => SearchKnowledgeAndGte$outboundSchema),
      z.lazy(() => SearchKnowledgeAndLt$outboundSchema),
      z.lazy(() => SearchKnowledgeAndLte$outboundSchema),
      z.lazy(() => SearchKnowledgeAndIn$outboundSchema),
      z.lazy(() => SearchKnowledgeAndNin$outboundSchema),
      z.lazy(() => SearchKnowledgeAndExists$outboundSchema),
    ])),
  ),
});

export function filterByAndToJSON(filterByAnd: FilterByAnd): string {
  return JSON.stringify(FilterByAnd$outboundSchema.parse(filterByAnd));
}

/** @internal */
export type SearchKnowledge1Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledge1Exists$outboundSchema: z.ZodType<
  SearchKnowledge1Exists$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Exists
> = z.object({
  exists: z.boolean(),
});

export function searchKnowledge1ExistsToJSON(
  searchKnowledge1Exists: SearchKnowledge1Exists,
): string {
  return JSON.stringify(
    SearchKnowledge1Exists$outboundSchema.parse(searchKnowledge1Exists),
  );
}

/** @internal */
export type SearchKnowledge1KnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledge1KnowledgeNinToJSON(
  searchKnowledge1KnowledgeNin: SearchKnowledge1KnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeNin$outboundSchema.parse(
      searchKnowledge1KnowledgeNin,
    ),
  );
}

/** @internal */
export type SearchKnowledge1Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledge1Nin$outboundSchema: z.ZodType<
  SearchKnowledge1Nin$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Nin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledge1NinToJSON(
  searchKnowledge1Nin: SearchKnowledge1Nin,
): string {
  return JSON.stringify(
    SearchKnowledge1Nin$outboundSchema.parse(searchKnowledge1Nin),
  );
}

/** @internal */
export type SearchKnowledge1KnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledge1KnowledgeInToJSON(
  searchKnowledge1KnowledgeIn: SearchKnowledge1KnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeIn$outboundSchema.parse(
      searchKnowledge1KnowledgeIn,
    ),
  );
}

/** @internal */
export type SearchKnowledge1In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledge1In$outboundSchema: z.ZodType<
  SearchKnowledge1In$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1In
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function searchKnowledge1InToJSON(
  searchKnowledge1In: SearchKnowledge1In,
): string {
  return JSON.stringify(
    SearchKnowledge1In$outboundSchema.parse(searchKnowledge1In),
  );
}

/** @internal */
export type SearchKnowledge1Lte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledge1Lte$outboundSchema: z.ZodType<
  SearchKnowledge1Lte$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Lte
> = z.object({
  lte: z.number(),
});

export function searchKnowledge1LteToJSON(
  searchKnowledge1Lte: SearchKnowledge1Lte,
): string {
  return JSON.stringify(
    SearchKnowledge1Lte$outboundSchema.parse(searchKnowledge1Lte),
  );
}

/** @internal */
export type SearchKnowledge1Lt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledge1Lt$outboundSchema: z.ZodType<
  SearchKnowledge1Lt$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Lt
> = z.object({
  lt: z.number(),
});

export function searchKnowledge1LtToJSON(
  searchKnowledge1Lt: SearchKnowledge1Lt,
): string {
  return JSON.stringify(
    SearchKnowledge1Lt$outboundSchema.parse(searchKnowledge1Lt),
  );
}

/** @internal */
export type SearchKnowledge1Gte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledge1Gte$outboundSchema: z.ZodType<
  SearchKnowledge1Gte$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Gte
> = z.object({
  gte: z.number(),
});

export function searchKnowledge1GteToJSON(
  searchKnowledge1Gte: SearchKnowledge1Gte,
): string {
  return JSON.stringify(
    SearchKnowledge1Gte$outboundSchema.parse(searchKnowledge1Gte),
  );
}

/** @internal */
export type SearchKnowledge1Gt$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledge1Gt$outboundSchema: z.ZodType<
  SearchKnowledge1Gt$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Gt
> = z.object({
  gt: z.number(),
});

export function searchKnowledge1GtToJSON(
  searchKnowledge1Gt: SearchKnowledge1Gt,
): string {
  return JSON.stringify(
    SearchKnowledge1Gt$outboundSchema.parse(searchKnowledge1Gt),
  );
}

/** @internal */
export type SearchKnowledge1KnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledge1KnowledgeNeToJSON(
  searchKnowledge1KnowledgeNe: SearchKnowledge1KnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeNe$outboundSchema.parse(
      searchKnowledge1KnowledgeNe,
    ),
  );
}

/** @internal */
export type SearchKnowledge1Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledge1Ne$outboundSchema: z.ZodType<
  SearchKnowledge1Ne$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Ne
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledge1NeToJSON(
  searchKnowledge1Ne: SearchKnowledge1Ne,
): string {
  return JSON.stringify(
    SearchKnowledge1Ne$outboundSchema.parse(searchKnowledge1Ne),
  );
}

/** @internal */
export type SearchKnowledge1KnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function searchKnowledge1KnowledgeEqToJSON(
  searchKnowledge1KnowledgeEq: SearchKnowledge1KnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeEq$outboundSchema.parse(
      searchKnowledge1KnowledgeEq,
    ),
  );
}

/** @internal */
export type SearchKnowledge1Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledge1Eq$outboundSchema: z.ZodType<
  SearchKnowledge1Eq$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Eq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function searchKnowledge1EqToJSON(
  searchKnowledge1Eq: SearchKnowledge1Eq,
): string {
  return JSON.stringify(
    SearchKnowledge1Eq$outboundSchema.parse(searchKnowledge1Eq),
  );
}

/** @internal */
export type FilterBy1$Outbound =
  | SearchKnowledge1Eq$Outbound
  | SearchKnowledge1Ne$Outbound
  | SearchKnowledge1Gt$Outbound
  | SearchKnowledge1Gte$Outbound
  | SearchKnowledge1Lt$Outbound
  | SearchKnowledge1Lte$Outbound
  | SearchKnowledge1In$Outbound
  | SearchKnowledge1Nin$Outbound
  | SearchKnowledge1Exists$Outbound;

/** @internal */
export const FilterBy1$outboundSchema: z.ZodType<
  FilterBy1$Outbound,
  z.ZodTypeDef,
  FilterBy1
> = z.union([
  z.lazy(() => SearchKnowledge1Eq$outboundSchema),
  z.lazy(() => SearchKnowledge1Ne$outboundSchema),
  z.lazy(() => SearchKnowledge1Gt$outboundSchema),
  z.lazy(() => SearchKnowledge1Gte$outboundSchema),
  z.lazy(() => SearchKnowledge1Lt$outboundSchema),
  z.lazy(() => SearchKnowledge1Lte$outboundSchema),
  z.lazy(() => SearchKnowledge1In$outboundSchema),
  z.lazy(() => SearchKnowledge1Nin$outboundSchema),
  z.lazy(() => SearchKnowledge1Exists$outboundSchema),
]);

export function filterBy1ToJSON(filterBy1: FilterBy1): string {
  return JSON.stringify(FilterBy1$outboundSchema.parse(filterBy1));
}

/** @internal */
export type FilterBy$Outbound = FilterByAnd$Outbound | FilterByOr$Outbound | {
  [k: string]:
    | SearchKnowledge1Eq$Outbound
    | SearchKnowledge1Ne$Outbound
    | SearchKnowledge1Gt$Outbound
    | SearchKnowledge1Gte$Outbound
    | SearchKnowledge1Lt$Outbound
    | SearchKnowledge1Lte$Outbound
    | SearchKnowledge1In$Outbound
    | SearchKnowledge1Nin$Outbound
    | SearchKnowledge1Exists$Outbound;
};

/** @internal */
export const FilterBy$outboundSchema: z.ZodType<
  FilterBy$Outbound,
  z.ZodTypeDef,
  FilterBy
> = z.union([
  z.lazy(() => FilterByAnd$outboundSchema),
  z.lazy(() => FilterByOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => SearchKnowledge1Eq$outboundSchema),
    z.lazy(() => SearchKnowledge1Ne$outboundSchema),
    z.lazy(() => SearchKnowledge1Gt$outboundSchema),
    z.lazy(() => SearchKnowledge1Gte$outboundSchema),
    z.lazy(() => SearchKnowledge1Lt$outboundSchema),
    z.lazy(() => SearchKnowledge1Lte$outboundSchema),
    z.lazy(() => SearchKnowledge1In$outboundSchema),
    z.lazy(() => SearchKnowledge1Nin$outboundSchema),
    z.lazy(() => SearchKnowledge1Exists$outboundSchema),
  ])),
]);

export function filterByToJSON(filterBy: FilterBy): string {
  return JSON.stringify(FilterBy$outboundSchema.parse(filterBy));
}

/** @internal */
export type SearchOptions$Outbound = {
  include_vectors?: boolean | undefined;
  include_metadata?: boolean | undefined;
  include_scores?: boolean | undefined;
};

/** @internal */
export const SearchOptions$outboundSchema: z.ZodType<
  SearchOptions$Outbound,
  z.ZodTypeDef,
  SearchOptions
> = z.object({
  includeVectors: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeScores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeVectors: "include_vectors",
    includeMetadata: "include_metadata",
    includeScores: "include_scores",
  });
});

export function searchOptionsToJSON(searchOptions: SearchOptions): string {
  return JSON.stringify(SearchOptions$outboundSchema.parse(searchOptions));
}

/** @internal */
export type RerankConfig$Outbound = {
  model: string;
  threshold: number;
  top_k: number;
};

/** @internal */
export const RerankConfig$outboundSchema: z.ZodType<
  RerankConfig$Outbound,
  z.ZodTypeDef,
  RerankConfig
> = z.object({
  model: z.string(),
  threshold: z.number().default(0),
  topK: z.number().int().default(10),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
  });
});

export function rerankConfigToJSON(rerankConfig: RerankConfig): string {
  return JSON.stringify(RerankConfig$outboundSchema.parse(rerankConfig));
}

/** @internal */
export type AgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const AgenticRagConfig$outboundSchema: z.ZodType<
  AgenticRagConfig$Outbound,
  z.ZodTypeDef,
  AgenticRagConfig
> = z.object({
  model: z.string(),
});

export function agenticRagConfigToJSON(
  agenticRagConfig: AgenticRagConfig,
): string {
  return JSON.stringify(
    AgenticRagConfig$outboundSchema.parse(agenticRagConfig),
  );
}

/** @internal */
export type SearchKnowledgeRequestBody$Outbound = {
  query: string;
  top_k?: number | undefined;
  threshold?: number | undefined;
  search_type: string;
  filter_by?: FilterByAnd$Outbound | FilterByOr$Outbound | {
    [k: string]:
      | SearchKnowledge1Eq$Outbound
      | SearchKnowledge1Ne$Outbound
      | SearchKnowledge1Gt$Outbound
      | SearchKnowledge1Gte$Outbound
      | SearchKnowledge1Lt$Outbound
      | SearchKnowledge1Lte$Outbound
      | SearchKnowledge1In$Outbound
      | SearchKnowledge1Nin$Outbound
      | SearchKnowledge1Exists$Outbound;
  } | undefined;
  search_options?: SearchOptions$Outbound | undefined;
  rerank_config?: RerankConfig$Outbound | undefined;
  agentic_rag_config?: AgenticRagConfig$Outbound | undefined;
};

/** @internal */
export const SearchKnowledgeRequestBody$outboundSchema: z.ZodType<
  SearchKnowledgeRequestBody$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeRequestBody
> = z.object({
  query: z.string(),
  topK: z.number().int().optional(),
  threshold: z.number().optional(),
  searchType: SearchType$outboundSchema.default("hybrid_search"),
  filterBy: z.union([
    z.lazy(() => FilterByAnd$outboundSchema),
    z.lazy(() => FilterByOr$outboundSchema),
    z.record(z.union([
      z.lazy(() => SearchKnowledge1Eq$outboundSchema),
      z.lazy(() => SearchKnowledge1Ne$outboundSchema),
      z.lazy(() => SearchKnowledge1Gt$outboundSchema),
      z.lazy(() => SearchKnowledge1Gte$outboundSchema),
      z.lazy(() => SearchKnowledge1Lt$outboundSchema),
      z.lazy(() => SearchKnowledge1Lte$outboundSchema),
      z.lazy(() => SearchKnowledge1In$outboundSchema),
      z.lazy(() => SearchKnowledge1Nin$outboundSchema),
      z.lazy(() => SearchKnowledge1Exists$outboundSchema),
    ])),
  ]).optional(),
  searchOptions: z.lazy(() => SearchOptions$outboundSchema).optional(),
  rerankConfig: z.lazy(() => RerankConfig$outboundSchema).optional(),
  agenticRagConfig: z.lazy(() => AgenticRagConfig$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    searchType: "search_type",
    filterBy: "filter_by",
    searchOptions: "search_options",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function searchKnowledgeRequestBodyToJSON(
  searchKnowledgeRequestBody: SearchKnowledgeRequestBody,
): string {
  return JSON.stringify(
    SearchKnowledgeRequestBody$outboundSchema.parse(searchKnowledgeRequestBody),
  );
}

/** @internal */
export type SearchKnowledgeRequest$Outbound = {
  knowledge_id: string;
  RequestBody?: SearchKnowledgeRequestBody$Outbound | undefined;
};

/** @internal */
export const SearchKnowledgeRequest$outboundSchema: z.ZodType<
  SearchKnowledgeRequest$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeRequest
> = z.object({
  knowledgeId: z.string(),
  requestBody: z.lazy(() => SearchKnowledgeRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    requestBody: "RequestBody",
  });
});

export function searchKnowledgeRequestToJSON(
  searchKnowledgeRequest: SearchKnowledgeRequest,
): string {
  return JSON.stringify(
    SearchKnowledgeRequest$outboundSchema.parse(searchKnowledgeRequest),
  );
}

/** @internal */
export const Scores$inboundSchema: z.ZodType<Scores, z.ZodTypeDef, unknown> = z
  .object({
    rerank_score: z.number().optional(),
    search_score: z.number().optional(),
  }).transform((v) => {
    return remap$(v, {
      "rerank_score": "rerankScore",
      "search_score": "searchScore",
    });
  });

export function scoresFromJSON(
  jsonString: string,
): SafeParseResult<Scores, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Scores$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Scores' from JSON`,
  );
}

/** @internal */
export const Matches$inboundSchema: z.ZodType<Matches, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    text: z.string(),
    vector: z.array(z.number()).optional(),
    metadata: z.record(z.any()).optional(),
    scores: z.lazy(() => Scores$inboundSchema).optional(),
  });

export function matchesFromJSON(
  jsonString: string,
): SafeParseResult<Matches, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Matches$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Matches' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeResponseBody$inboundSchema: z.ZodType<
  SearchKnowledgeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  matches: z.array(z.lazy(() => Matches$inboundSchema)),
});

export function searchKnowledgeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeResponseBody' from JSON`,
  );
}
