/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllToolsRequest = {
  /**
   * Maximum number of tools per page (1-200). Omit to return all tools.
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllToolsObject = {
  List: "list",
} as const;
export type GetAllToolsObject = ClosedEnum<typeof GetAllToolsObject>;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponse200Status = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Status
>;

export const GetAllToolsDataToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONType = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200ApplicationJSONType
>;

export const DataLanguage = {
  Python: "python",
} as const;
export type DataLanguage = ClosedEnum<typeof DataLanguage>;

export type DataCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: DataLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type Data5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponse200ApplicationJSONType;
  codeTool: DataCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponseStatus = ClosedEnum<
  typeof GetAllToolsDataToolsResponseStatus
>;

export const GetAllToolsDataToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type GetAllToolsDataToolsResponse200Type = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Type
>;

export type DataHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType = {
  Object: "object",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  >;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type DataInputSchema = {
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const DataConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DataConnectionType = ClosedEnum<typeof DataConnectionType>;

export type DataMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: DataHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: DataInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DataConnectionType;
};

export type Data4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponse200Type;
  mcp: DataMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsStatus = ClosedEnum<
  typeof GetAllToolsDataToolsStatus
>;

export const GetAllToolsDataToolsResponseType = {
  Http: "http",
} as const;
export type GetAllToolsDataToolsResponseType = ClosedEnum<
  typeof GetAllToolsDataToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const GetAllToolsDataMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type GetAllToolsDataMethod = ClosedEnum<typeof GetAllToolsDataMethod>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DataBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: GetAllToolsDataMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  >;

/**
 * The default value of the argument.
 */
export type DataDefaultValue = string | number | boolean;

export type DataArguments = {
  /**
   * The type of the argument.
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type GetAllToolsDataHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DataBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DataArguments } | undefined;
};

export type Data3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponseType;
  http: GetAllToolsDataHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataStatus = ClosedEnum<typeof GetAllToolsDataStatus>;

export const GetAllToolsDataToolsType = {
  JsonSchema: "json_schema",
} as const;
export type GetAllToolsDataToolsType = ClosedEnum<
  typeof GetAllToolsDataToolsType
>;

export type DataJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

export type Data2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsType;
  jsonSchema: DataJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DataStatus = ClosedEnum<typeof DataStatus>;

export const GetAllToolsDataType = {
  Function: "function",
} as const;
export type GetAllToolsDataType = ClosedEnum<typeof GetAllToolsDataType>;

export type GetAllToolsDataFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type Data1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DataStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataType;
  function: GetAllToolsDataFunction;
};

export type GetAllToolsData = Data1 | Data2 | Data3 | Data4 | Data5;

/**
 * Successfully retrieved the list of tools.
 */
export type GetAllToolsResponseBody = {
  object: GetAllToolsObject;
  data: Array<Data1 | Data2 | Data3 | Data4 | Data5>;
  hasMore: boolean;
};

/** @internal */
export const GetAllToolsRequest$inboundSchema: z.ZodType<
  GetAllToolsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().optional(),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type GetAllToolsRequest$Outbound = {
  limit?: number | undefined;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllToolsRequest$outboundSchema: z.ZodType<
  GetAllToolsRequest$Outbound,
  z.ZodTypeDef,
  GetAllToolsRequest
> = z.object({
  limit: z.number().optional(),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function getAllToolsRequestToJSON(
  getAllToolsRequest: GetAllToolsRequest,
): string {
  return JSON.stringify(
    GetAllToolsRequest$outboundSchema.parse(getAllToolsRequest),
  );
}
export function getAllToolsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsRequest' from JSON`,
  );
}

/** @internal */
export const GetAllToolsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = z.nativeEnum(GetAllToolsObject);
/** @internal */
export const GetAllToolsObject$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = GetAllToolsObject$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> = z.nativeEnum(
    GetAllToolsDataToolsResponse200Status,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> =
    GetAllToolsDataToolsResponse200Status$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200ApplicationJSONType> = z
    .nativeEnum(GetAllToolsDataToolsResponse200ApplicationJSONType);
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200ApplicationJSONType> =
    GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const DataLanguage$inboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  z.nativeEnum(DataLanguage);
/** @internal */
export const DataLanguage$outboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  DataLanguage$inboundSchema;

/** @internal */
export const DataCodeTool$inboundSchema: z.ZodType<
  DataCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DataLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type DataCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const DataCodeTool$outboundSchema: z.ZodType<
  DataCodeTool$Outbound,
  z.ZodTypeDef,
  DataCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DataLanguage$outboundSchema,
  code: z.string(),
});

export function dataCodeToolToJSON(dataCodeTool: DataCodeTool): string {
  return JSON.stringify(DataCodeTool$outboundSchema.parse(dataCodeTool));
}
export function dataCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeTool' from JSON`,
  );
}

/** @internal */
export const Data5$inboundSchema: z.ZodType<Data5, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01KAJRW2SW2Z3XJPV3VX03X2QV"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsResponse200Status$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema,
    code_tool: z.lazy(() => DataCodeTool$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
      "code_tool": "codeTool",
    });
  });
/** @internal */
export type Data5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: DataCodeTool$Outbound;
};

/** @internal */
export const Data5$outboundSchema: z.ZodType<
  Data5$Outbound,
  z.ZodTypeDef,
  Data5
> = z.object({
  id: z.string().default("01KAJRW2SW2Z3XJPV3VX03X2QV"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponse200Status$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => DataCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function data5ToJSON(data5: Data5): string {
  return JSON.stringify(Data5$outboundSchema.parse(data5));
}
export function data5FromJSON(
  jsonString: string,
): SafeParseResult<Data5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data5' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = z.nativeEnum(GetAllToolsDataToolsResponseStatus);
/** @internal */
export const GetAllToolsDataToolsResponseStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = GetAllToolsDataToolsResponseStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200Type$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponse200Type
> = z.nativeEnum(GetAllToolsDataToolsResponse200Type);
/** @internal */
export const GetAllToolsDataToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Type> =
    GetAllToolsDataToolsResponse200Type$inboundSchema;

/** @internal */
export const DataHeaders$inboundSchema: z.ZodType<
  DataHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type DataHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DataHeaders$outboundSchema: z.ZodType<
  DataHeaders$Outbound,
  z.ZodTypeDef,
  DataHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function dataHeadersToJSON(dataHeaders: DataHeaders): string {
  return JSON.stringify(DataHeaders$outboundSchema.parse(dataHeaders));
}
export function dataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHeaders' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const DataInputSchema$inboundSchema: z.ZodType<
  DataInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type DataInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const DataInputSchema$outboundSchema: z.ZodType<
  DataInputSchema$Outbound,
  z.ZodTypeDef,
  DataInputSchema
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function dataInputSchemaToJSON(
  dataInputSchema: DataInputSchema,
): string {
  return JSON.stringify(DataInputSchema$outboundSchema.parse(dataInputSchema));
}
export function dataInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataInputSchema' from JSON`,
  );
}

/** @internal */
export const DataConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = z.nativeEnum(DataConnectionType);
/** @internal */
export const DataConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = DataConnectionType$inboundSchema;

/** @internal */
export const DataMcp$inboundSchema: z.ZodType<DataMcp, z.ZodTypeDef, unknown> =
  z.object({
    server_id: z.string(),
    tool_name: z.string(),
    server_url: z.string(),
    headers: z.record(z.lazy(() => DataHeaders$inboundSchema)).optional(),
    input_schema: z.lazy(() => DataInputSchema$inboundSchema),
    connection_type: DataConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_id": "serverId",
      "tool_name": "toolName",
      "server_url": "serverUrl",
      "input_schema": "inputSchema",
      "connection_type": "connectionType",
    });
  });
/** @internal */
export type DataMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: DataHeaders$Outbound } | undefined;
  input_schema: DataInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const DataMcp$outboundSchema: z.ZodType<
  DataMcp$Outbound,
  z.ZodTypeDef,
  DataMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => DataHeaders$outboundSchema)).optional(),
  inputSchema: z.lazy(() => DataInputSchema$outboundSchema),
  connectionType: DataConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

export function dataMcpToJSON(dataMcp: DataMcp): string {
  return JSON.stringify(DataMcp$outboundSchema.parse(dataMcp));
}
export function dataMcpFromJSON(
  jsonString: string,
): SafeParseResult<DataMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMcp' from JSON`,
  );
}

/** @internal */
export const Data4$inboundSchema: z.ZodType<Data4, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01KAJRW2STG0AV5Q7HBAJTK8PZ"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsResponseStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponse200Type$inboundSchema,
    mcp: z.lazy(() => DataMcp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });
/** @internal */
export type Data4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: DataMcp$Outbound;
};

/** @internal */
export const Data4$outboundSchema: z.ZodType<
  Data4$Outbound,
  z.ZodTypeDef,
  Data4
> = z.object({
  id: z.string().default("01KAJRW2STG0AV5Q7HBAJTK8PZ"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponseStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => DataMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function data4ToJSON(data4: Data4): string {
  return JSON.stringify(Data4$outboundSchema.parse(data4));
}
export function data4FromJSON(
  jsonString: string,
): SafeParseResult<Data4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data4' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = z.nativeEnum(GetAllToolsDataToolsStatus);
/** @internal */
export const GetAllToolsDataToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = GetAllToolsDataToolsStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = z.nativeEnum(GetAllToolsDataToolsResponseType);
/** @internal */
export const GetAllToolsDataToolsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = GetAllToolsDataToolsResponseType$inboundSchema;

/** @internal */
export const GetAllToolsDataMethod$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = z.nativeEnum(GetAllToolsDataMethod);
/** @internal */
export const GetAllToolsDataMethod$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = GetAllToolsDataMethod$inboundSchema;

/** @internal */
export const DataBlueprint$inboundSchema: z.ZodType<
  DataBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type DataBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataBlueprint$outboundSchema: z.ZodType<
  DataBlueprint$Outbound,
  z.ZodTypeDef,
  DataBlueprint
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

export function dataBlueprintToJSON(dataBlueprint: DataBlueprint): string {
  return JSON.stringify(DataBlueprint$outboundSchema.parse(dataBlueprint));
}
export function dataBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DataBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataBlueprint' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema;

/** @internal */
export const DataDefaultValue$inboundSchema: z.ZodType<
  DataDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DataDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DataDefaultValue$outboundSchema: z.ZodType<
  DataDefaultValue$Outbound,
  z.ZodTypeDef,
  DataDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function dataDefaultValueToJSON(
  dataDefaultValue: DataDefaultValue,
): string {
  return JSON.stringify(
    DataDefaultValue$outboundSchema.parse(dataDefaultValue),
  );
}
export function dataDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DataDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataDefaultValue' from JSON`,
  );
}

/** @internal */
export const DataArguments$inboundSchema: z.ZodType<
  DataArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type DataArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DataArguments$outboundSchema: z.ZodType<
  DataArguments$Outbound,
  z.ZodTypeDef,
  DataArguments
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function dataArgumentsToJSON(dataArguments: DataArguments): string {
  return JSON.stringify(DataArguments$outboundSchema.parse(dataArguments));
}
export function dataArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DataArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataArguments' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHttp$inboundSchema: z.ZodType<
  GetAllToolsDataHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$inboundSchema)).optional(),
});
/** @internal */
export type GetAllToolsDataHttp$Outbound = {
  blueprint: DataBlueprint$Outbound;
  arguments?: { [k: string]: DataArguments$Outbound } | undefined;
};

/** @internal */
export const GetAllToolsDataHttp$outboundSchema: z.ZodType<
  GetAllToolsDataHttp$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataHttp
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$outboundSchema)).optional(),
});

export function getAllToolsDataHttpToJSON(
  getAllToolsDataHttp: GetAllToolsDataHttp,
): string {
  return JSON.stringify(
    GetAllToolsDataHttp$outboundSchema.parse(getAllToolsDataHttp),
  );
}
export function getAllToolsDataHttpFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHttp' from JSON`,
  );
}

/** @internal */
export const Data3$inboundSchema: z.ZodType<Data3, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01KAJRW2SQJEA0FRHQQRAA19WV"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponseType$inboundSchema,
    http: z.lazy(() => GetAllToolsDataHttp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });
/** @internal */
export type Data3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: GetAllToolsDataHttp$Outbound;
};

/** @internal */
export const Data3$outboundSchema: z.ZodType<
  Data3$Outbound,
  z.ZodTypeDef,
  Data3
> = z.object({
  id: z.string().default("01KAJRW2SQJEA0FRHQQRAA19WV"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponseType$outboundSchema,
  http: z.lazy(() => GetAllToolsDataHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function data3ToJSON(data3: Data3): string {
  return JSON.stringify(Data3$outboundSchema.parse(data3));
}
export function data3FromJSON(
  jsonString: string,
): SafeParseResult<Data3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data3' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = z.nativeEnum(GetAllToolsDataStatus);
/** @internal */
export const GetAllToolsDataStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = GetAllToolsDataStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = z.nativeEnum(GetAllToolsDataToolsType);
/** @internal */
export const GetAllToolsDataToolsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = GetAllToolsDataToolsType$inboundSchema;

/** @internal */
export const DataJsonSchema$inboundSchema: z.ZodType<
  DataJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});
/** @internal */
export type DataJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict?: boolean | undefined;
};

/** @internal */
export const DataJsonSchema$outboundSchema: z.ZodType<
  DataJsonSchema$Outbound,
  z.ZodTypeDef,
  DataJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});

export function dataJsonSchemaToJSON(dataJsonSchema: DataJsonSchema): string {
  return JSON.stringify(DataJsonSchema$outboundSchema.parse(dataJsonSchema));
}
export function dataJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJsonSchema' from JSON`,
  );
}

/** @internal */
export const Data2$inboundSchema: z.ZodType<Data2, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01KAJRW2SNH9E1HT4GNGYK8JCA"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsType$inboundSchema,
    json_schema: z.lazy(() => DataJsonSchema$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type Data2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: DataJsonSchema$Outbound;
};

/** @internal */
export const Data2$outboundSchema: z.ZodType<
  Data2$Outbound,
  z.ZodTypeDef,
  Data2
> = z.object({
  id: z.string().default("01KAJRW2SNH9E1HT4GNGYK8JCA"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsType$outboundSchema,
  jsonSchema: z.lazy(() => DataJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function data2ToJSON(data2: Data2): string {
  return JSON.stringify(Data2$outboundSchema.parse(data2));
}
export function data2FromJSON(
  jsonString: string,
): SafeParseResult<Data2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data2' from JSON`,
  );
}

/** @internal */
export const DataStatus$inboundSchema: z.ZodNativeEnum<typeof DataStatus> = z
  .nativeEnum(DataStatus);
/** @internal */
export const DataStatus$outboundSchema: z.ZodNativeEnum<typeof DataStatus> =
  DataStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = z.nativeEnum(GetAllToolsDataType);
/** @internal */
export const GetAllToolsDataType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = GetAllToolsDataType$inboundSchema;

/** @internal */
export const GetAllToolsDataFunction$inboundSchema: z.ZodType<
  GetAllToolsDataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type GetAllToolsDataFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const GetAllToolsDataFunction$outboundSchema: z.ZodType<
  GetAllToolsDataFunction$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function getAllToolsDataFunctionToJSON(
  getAllToolsDataFunction: GetAllToolsDataFunction,
): string {
  return JSON.stringify(
    GetAllToolsDataFunction$outboundSchema.parse(getAllToolsDataFunction),
  );
}
export function getAllToolsDataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataFunction' from JSON`,
  );
}

/** @internal */
export const Data1$inboundSchema: z.ZodType<Data1, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01KAJRW2SK288WDF5PXGTCXTQ0"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: DataStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataType$inboundSchema,
    function: z.lazy(() => GetAllToolsDataFunction$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });
/** @internal */
export type Data1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: GetAllToolsDataFunction$Outbound;
};

/** @internal */
export const Data1$outboundSchema: z.ZodType<
  Data1$Outbound,
  z.ZodTypeDef,
  Data1
> = z.object({
  id: z.string().default("01KAJRW2SK288WDF5PXGTCXTQ0"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataType$outboundSchema,
  function: z.lazy(() => GetAllToolsDataFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function data1ToJSON(data1: Data1): string {
  return JSON.stringify(Data1$outboundSchema.parse(data1));
}
export function data1FromJSON(
  jsonString: string,
): SafeParseResult<Data1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data1' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData$inboundSchema: z.ZodType<
  GetAllToolsData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Data1$inboundSchema),
  z.lazy(() => Data2$inboundSchema),
  z.lazy(() => Data3$inboundSchema),
  z.lazy(() => Data4$inboundSchema),
  z.lazy(() => Data5$inboundSchema),
]);
/** @internal */
export type GetAllToolsData$Outbound =
  | Data1$Outbound
  | Data2$Outbound
  | Data3$Outbound
  | Data4$Outbound
  | Data5$Outbound;

/** @internal */
export const GetAllToolsData$outboundSchema: z.ZodType<
  GetAllToolsData$Outbound,
  z.ZodTypeDef,
  GetAllToolsData
> = z.union([
  z.lazy(() => Data1$outboundSchema),
  z.lazy(() => Data2$outboundSchema),
  z.lazy(() => Data3$outboundSchema),
  z.lazy(() => Data4$outboundSchema),
  z.lazy(() => Data5$outboundSchema),
]);

export function getAllToolsDataToJSON(
  getAllToolsData: GetAllToolsData,
): string {
  return JSON.stringify(GetAllToolsData$outboundSchema.parse(getAllToolsData));
}
export function getAllToolsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData' from JSON`,
  );
}

/** @internal */
export const GetAllToolsResponseBody$inboundSchema: z.ZodType<
  GetAllToolsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllToolsObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$inboundSchema),
      z.lazy(() => Data2$inboundSchema),
      z.lazy(() => Data3$inboundSchema),
      z.lazy(() => Data4$inboundSchema),
      z.lazy(() => Data5$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});
/** @internal */
export type GetAllToolsResponseBody$Outbound = {
  object: string;
  data: Array<
    | Data1$Outbound
    | Data2$Outbound
    | Data3$Outbound
    | Data4$Outbound
    | Data5$Outbound
  >;
  has_more: boolean;
};

/** @internal */
export const GetAllToolsResponseBody$outboundSchema: z.ZodType<
  GetAllToolsResponseBody$Outbound,
  z.ZodTypeDef,
  GetAllToolsResponseBody
> = z.object({
  object: GetAllToolsObject$outboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$outboundSchema),
      z.lazy(() => Data2$outboundSchema),
      z.lazy(() => Data3$outboundSchema),
      z.lazy(() => Data4$outboundSchema),
      z.lazy(() => Data5$outboundSchema),
    ]),
  ),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

export function getAllToolsResponseBodyToJSON(
  getAllToolsResponseBody: GetAllToolsResponseBody,
): string {
  return JSON.stringify(
    GetAllToolsResponseBody$outboundSchema.parse(getAllToolsResponseBody),
  );
}
export function getAllToolsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsResponseBody' from JSON`,
  );
}
