/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllToolsRequest = {
  /**
   * Maximum number of tools per page (1-200). Omit to return all tools.
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllToolsObject = {
  List: "list",
} as const;
export type GetAllToolsObject = ClosedEnum<typeof GetAllToolsObject>;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponse200Status = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Status
>;

/**
 * The type must be "object"
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type GetAllToolsDataParameters = {
  /**
   * The type must be "object"
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const DataLanguage = {
  Python: "python",
} as const;
export type DataLanguage = ClosedEnum<typeof DataLanguage>;

export type DataCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: GetAllToolsDataParameters | undefined;
  language: DataLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type DataCodeExecutionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: "code";
  codeTool: DataCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponseStatus = ClosedEnum<
  typeof GetAllToolsDataToolsResponseStatus
>;

export type DataHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type = {
  Object: "object",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type
  >;

export type GetAllToolsDataSchema = {
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type DataTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: GetAllToolsDataSchema;
};

/**
 * The connection type used by the MCP server
 */
export const DataConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DataConnectionType = ClosedEnum<typeof DataConnectionType>;

export type DataMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: DataHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<DataTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DataConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type DataMCPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: DataMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsStatus = ClosedEnum<
  typeof GetAllToolsDataToolsStatus
>;

/**
 * The HTTP method to use.
 */
export const GetAllToolsDataMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type GetAllToolsDataMethod = ClosedEnum<typeof GetAllToolsDataMethod>;

export type GetAllToolsHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type GetAllToolsDataHeaders = GetAllToolsHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DataBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: GetAllToolsDataMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: GetAllToolsHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  >;

/**
 * The default value of the argument.
 */
export type DataDefaultValue = string | number | boolean;

export type DataArguments = {
  /**
   * The type of the argument.
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type GetAllToolsDataHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DataBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DataArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type DataHTTPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsStatus | undefined;
  versionHash?: string | undefined;
  type: "http";
  http: GetAllToolsDataHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataStatus = ClosedEnum<typeof GetAllToolsDataStatus>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DataSchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DataJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: DataSchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type DataJSONSchemaTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataStatus | undefined;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: DataJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DataStatus = ClosedEnum<typeof DataStatus>;

/**
 * The type must be "object"
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DataParameters = {
  /**
   * The type must be "object"
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type GetAllToolsDataFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: DataParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type DataFunctionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DataStatus | undefined;
  versionHash?: string | undefined;
  type: "function";
  function: GetAllToolsDataFunction;
};

export type GetAllToolsData =
  | DataFunctionTool
  | DataJSONSchemaTool
  | DataHTTPTool
  | DataMCPTool
  | DataCodeExecutionTool;

/**
 * Successfully retrieved the list of tools.
 */
export type GetAllToolsResponseBody = {
  object: GetAllToolsObject;
  data: Array<
    | DataFunctionTool
    | DataJSONSchemaTool
    | DataHTTPTool
    | DataMCPTool
    | DataCodeExecutionTool
  >;
  hasMore: boolean;
};

/** @internal */
export const GetAllToolsRequest$inboundSchema: z.ZodType<
  GetAllToolsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().optional(),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type GetAllToolsRequest$Outbound = {
  limit?: number | undefined;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllToolsRequest$outboundSchema: z.ZodType<
  GetAllToolsRequest$Outbound,
  z.ZodTypeDef,
  GetAllToolsRequest
> = z.object({
  limit: z.number().optional(),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function getAllToolsRequestToJSON(
  getAllToolsRequest: GetAllToolsRequest,
): string {
  return JSON.stringify(
    GetAllToolsRequest$outboundSchema.parse(getAllToolsRequest),
  );
}
export function getAllToolsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsRequest' from JSON`,
  );
}

/** @internal */
export const GetAllToolsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = z.nativeEnum(GetAllToolsObject);
/** @internal */
export const GetAllToolsObject$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = GetAllToolsObject$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> = z.nativeEnum(
    GetAllToolsDataToolsResponse200Status,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> =
    GetAllToolsDataToolsResponse200Status$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$inboundSchema;

/** @internal */
export const GetAllToolsDataParameters$inboundSchema: z.ZodType<
  GetAllToolsDataParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type GetAllToolsDataParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const GetAllToolsDataParameters$outboundSchema: z.ZodType<
  GetAllToolsDataParameters$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataParameters
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function getAllToolsDataParametersToJSON(
  getAllToolsDataParameters: GetAllToolsDataParameters,
): string {
  return JSON.stringify(
    GetAllToolsDataParameters$outboundSchema.parse(getAllToolsDataParameters),
  );
}
export function getAllToolsDataParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataParameters' from JSON`,
  );
}

/** @internal */
export const DataLanguage$inboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  z.nativeEnum(DataLanguage);
/** @internal */
export const DataLanguage$outboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  DataLanguage$inboundSchema;

/** @internal */
export const DataCodeTool$inboundSchema: z.ZodType<
  DataCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => GetAllToolsDataParameters$inboundSchema).optional(),
  language: DataLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type DataCodeTool$Outbound = {
  parameters?: GetAllToolsDataParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const DataCodeTool$outboundSchema: z.ZodType<
  DataCodeTool$Outbound,
  z.ZodTypeDef,
  DataCodeTool
> = z.object({
  parameters: z.lazy(() => GetAllToolsDataParameters$outboundSchema).optional(),
  language: DataLanguage$outboundSchema,
  code: z.string(),
});

export function dataCodeToolToJSON(dataCodeTool: DataCodeTool): string {
  return JSON.stringify(DataCodeTool$outboundSchema.parse(dataCodeTool));
}
export function dataCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeTool' from JSON`,
  );
}

/** @internal */
export const DataCodeExecutionTool$inboundSchema: z.ZodType<
  DataCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KCRBKM4687FHAN0REMQRGEKN"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponse200Status$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => DataCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type DataCodeExecutionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "code";
  code_tool: DataCodeTool$Outbound;
};

/** @internal */
export const DataCodeExecutionTool$outboundSchema: z.ZodType<
  DataCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  DataCodeExecutionTool
> = z.object({
  id: z.string().default("tool_01KCRBKM4687FHAN0REMQRGEKN"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponse200Status$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("code"),
  codeTool: z.lazy(() => DataCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function dataCodeExecutionToolToJSON(
  dataCodeExecutionTool: DataCodeExecutionTool,
): string {
  return JSON.stringify(
    DataCodeExecutionTool$outboundSchema.parse(dataCodeExecutionTool),
  );
}
export function dataCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = z.nativeEnum(GetAllToolsDataToolsResponseStatus);
/** @internal */
export const GetAllToolsDataToolsResponseStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = GetAllToolsDataToolsResponseStatus$inboundSchema;

/** @internal */
export const DataHeaders$inboundSchema: z.ZodType<
  DataHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type DataHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DataHeaders$outboundSchema: z.ZodType<
  DataHeaders$Outbound,
  z.ZodTypeDef,
  DataHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function dataHeadersToJSON(dataHeaders: DataHeaders): string {
  return JSON.stringify(DataHeaders$outboundSchema.parse(dataHeaders));
}
export function dataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHeaders' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$inboundSchema;

/** @internal */
export const GetAllToolsDataSchema$inboundSchema: z.ZodType<
  GetAllToolsDataSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type GetAllToolsDataSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const GetAllToolsDataSchema$outboundSchema: z.ZodType<
  GetAllToolsDataSchema$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataSchema
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function getAllToolsDataSchemaToJSON(
  getAllToolsDataSchema: GetAllToolsDataSchema,
): string {
  return JSON.stringify(
    GetAllToolsDataSchema$outboundSchema.parse(getAllToolsDataSchema),
  );
}
export function getAllToolsDataSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataSchema' from JSON`,
  );
}

/** @internal */
export const DataTools$inboundSchema: z.ZodType<
  DataTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KCRBKM45VCNCCVZSY7R5XQNY"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => GetAllToolsDataSchema$inboundSchema),
});
/** @internal */
export type DataTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: GetAllToolsDataSchema$Outbound;
};

/** @internal */
export const DataTools$outboundSchema: z.ZodType<
  DataTools$Outbound,
  z.ZodTypeDef,
  DataTools
> = z.object({
  id: z.string().default("01KCRBKM45VCNCCVZSY7R5XQNY"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => GetAllToolsDataSchema$outboundSchema),
});

export function dataToolsToJSON(dataTools: DataTools): string {
  return JSON.stringify(DataTools$outboundSchema.parse(dataTools));
}
export function dataToolsFromJSON(
  jsonString: string,
): SafeParseResult<DataTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataTools' from JSON`,
  );
}

/** @internal */
export const DataConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = z.nativeEnum(DataConnectionType);
/** @internal */
export const DataConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = DataConnectionType$inboundSchema;

/** @internal */
export const DataMcp$inboundSchema: z.ZodType<DataMcp, z.ZodTypeDef, unknown> =
  z.object({
    server_url: z.string(),
    headers: z.record(z.lazy(() => DataHeaders$inboundSchema)).optional(),
    tools: z.array(z.lazy(() => DataTools$inboundSchema)),
    connection_type: DataConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_url": "serverUrl",
      "connection_type": "connectionType",
    });
  });
/** @internal */
export type DataMcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: DataHeaders$Outbound } | undefined;
  tools: Array<DataTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const DataMcp$outboundSchema: z.ZodType<
  DataMcp$Outbound,
  z.ZodTypeDef,
  DataMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => DataHeaders$outboundSchema)).optional(),
  tools: z.array(z.lazy(() => DataTools$outboundSchema)),
  connectionType: DataConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function dataMcpToJSON(dataMcp: DataMcp): string {
  return JSON.stringify(DataMcp$outboundSchema.parse(dataMcp));
}
export function dataMcpFromJSON(
  jsonString: string,
): SafeParseResult<DataMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMcp' from JSON`,
  );
}

/** @internal */
export const DataMCPTool$inboundSchema: z.ZodType<
  DataMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KCRBKM44Z0AD4GADMZEFF5M0"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponseStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => DataMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DataMCPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "mcp";
  mcp: DataMcp$Outbound;
};

/** @internal */
export const DataMCPTool$outboundSchema: z.ZodType<
  DataMCPTool$Outbound,
  z.ZodTypeDef,
  DataMCPTool
> = z.object({
  id: z.string().default("tool_01KCRBKM44Z0AD4GADMZEFF5M0"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponseStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => DataMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function dataMCPToolToJSON(dataMCPTool: DataMCPTool): string {
  return JSON.stringify(DataMCPTool$outboundSchema.parse(dataMCPTool));
}
export function dataMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<DataMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMCPTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = z.nativeEnum(GetAllToolsDataToolsStatus);
/** @internal */
export const GetAllToolsDataToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = GetAllToolsDataToolsStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataMethod$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = z.nativeEnum(GetAllToolsDataMethod);
/** @internal */
export const GetAllToolsDataMethod$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = GetAllToolsDataMethod$inboundSchema;

/** @internal */
export const GetAllToolsHeaders2$inboundSchema: z.ZodType<
  GetAllToolsHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type GetAllToolsHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const GetAllToolsHeaders2$outboundSchema: z.ZodType<
  GetAllToolsHeaders2$Outbound,
  z.ZodTypeDef,
  GetAllToolsHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function getAllToolsHeaders2ToJSON(
  getAllToolsHeaders2: GetAllToolsHeaders2,
): string {
  return JSON.stringify(
    GetAllToolsHeaders2$outboundSchema.parse(getAllToolsHeaders2),
  );
}
export function getAllToolsHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsHeaders2' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHeaders$inboundSchema: z.ZodType<
  GetAllToolsDataHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => GetAllToolsHeaders2$inboundSchema), z.string()]);
/** @internal */
export type GetAllToolsDataHeaders$Outbound =
  | GetAllToolsHeaders2$Outbound
  | string;

/** @internal */
export const GetAllToolsDataHeaders$outboundSchema: z.ZodType<
  GetAllToolsDataHeaders$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataHeaders
> = z.union([z.lazy(() => GetAllToolsHeaders2$outboundSchema), z.string()]);

export function getAllToolsDataHeadersToJSON(
  getAllToolsDataHeaders: GetAllToolsDataHeaders,
): string {
  return JSON.stringify(
    GetAllToolsDataHeaders$outboundSchema.parse(getAllToolsDataHeaders),
  );
}
export function getAllToolsDataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHeaders' from JSON`,
  );
}

/** @internal */
export const DataBlueprint$inboundSchema: z.ZodType<
  DataBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => GetAllToolsHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type DataBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: GetAllToolsHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataBlueprint$outboundSchema: z.ZodType<
  DataBlueprint$Outbound,
  z.ZodTypeDef,
  DataBlueprint
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => GetAllToolsHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function dataBlueprintToJSON(dataBlueprint: DataBlueprint): string {
  return JSON.stringify(DataBlueprint$outboundSchema.parse(dataBlueprint));
}
export function dataBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DataBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataBlueprint' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema;

/** @internal */
export const DataDefaultValue$inboundSchema: z.ZodType<
  DataDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DataDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DataDefaultValue$outboundSchema: z.ZodType<
  DataDefaultValue$Outbound,
  z.ZodTypeDef,
  DataDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function dataDefaultValueToJSON(
  dataDefaultValue: DataDefaultValue,
): string {
  return JSON.stringify(
    DataDefaultValue$outboundSchema.parse(dataDefaultValue),
  );
}
export function dataDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DataDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataDefaultValue' from JSON`,
  );
}

/** @internal */
export const DataArguments$inboundSchema: z.ZodType<
  DataArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type DataArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DataArguments$outboundSchema: z.ZodType<
  DataArguments$Outbound,
  z.ZodTypeDef,
  DataArguments
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function dataArgumentsToJSON(dataArguments: DataArguments): string {
  return JSON.stringify(DataArguments$outboundSchema.parse(dataArguments));
}
export function dataArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DataArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataArguments' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHttp$inboundSchema: z.ZodType<
  GetAllToolsDataHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$inboundSchema)).optional(),
});
/** @internal */
export type GetAllToolsDataHttp$Outbound = {
  blueprint: DataBlueprint$Outbound;
  arguments?: { [k: string]: DataArguments$Outbound } | undefined;
};

/** @internal */
export const GetAllToolsDataHttp$outboundSchema: z.ZodType<
  GetAllToolsDataHttp$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataHttp
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$outboundSchema)).optional(),
});

export function getAllToolsDataHttpToJSON(
  getAllToolsDataHttp: GetAllToolsDataHttp,
): string {
  return JSON.stringify(
    GetAllToolsDataHttp$outboundSchema.parse(getAllToolsDataHttp),
  );
}
export function getAllToolsDataHttpFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHttp' from JSON`,
  );
}

/** @internal */
export const DataHTTPTool$inboundSchema: z.ZodType<
  DataHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KCRBKM40N2DQTVXQEWP3MA1E"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => GetAllToolsDataHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DataHTTPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "http";
  http: GetAllToolsDataHttp$Outbound;
};

/** @internal */
export const DataHTTPTool$outboundSchema: z.ZodType<
  DataHTTPTool$Outbound,
  z.ZodTypeDef,
  DataHTTPTool
> = z.object({
  id: z.string().default("tool_01KCRBKM40N2DQTVXQEWP3MA1E"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => GetAllToolsDataHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function dataHTTPToolToJSON(dataHTTPTool: DataHTTPTool): string {
  return JSON.stringify(DataHTTPTool$outboundSchema.parse(dataHTTPTool));
}
export function dataHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<DataHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHTTPTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = z.nativeEnum(GetAllToolsDataStatus);
/** @internal */
export const GetAllToolsDataStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = GetAllToolsDataStatus$inboundSchema;

/** @internal */
export const DataSchema$inboundSchema: z.ZodType<
  DataSchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type DataSchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DataSchema$outboundSchema: z.ZodType<
  DataSchema$Outbound,
  z.ZodTypeDef,
  DataSchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function dataSchemaToJSON(dataSchema: DataSchema): string {
  return JSON.stringify(DataSchema$outboundSchema.parse(dataSchema));
}
export function dataSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataSchema' from JSON`,
  );
}

/** @internal */
export const DataJsonSchema$inboundSchema: z.ZodType<
  DataJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => DataSchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type DataJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: DataSchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const DataJsonSchema$outboundSchema: z.ZodType<
  DataJsonSchema$Outbound,
  z.ZodTypeDef,
  DataJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => DataSchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function dataJsonSchemaToJSON(dataJsonSchema: DataJsonSchema): string {
  return JSON.stringify(DataJsonSchema$outboundSchema.parse(dataJsonSchema));
}
export function dataJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJsonSchema' from JSON`,
  );
}

/** @internal */
export const DataJSONSchemaTool$inboundSchema: z.ZodType<
  DataJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KCRBKM3YN2ZYK6V805ZCRJQW"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => DataJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type DataJSONSchemaTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "json_schema";
  json_schema: DataJsonSchema$Outbound;
};

/** @internal */
export const DataJSONSchemaTool$outboundSchema: z.ZodType<
  DataJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  DataJSONSchemaTool
> = z.object({
  id: z.string().default("tool_01KCRBKM3YN2ZYK6V805ZCRJQW"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => DataJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function dataJSONSchemaToolToJSON(
  dataJSONSchemaTool: DataJSONSchemaTool,
): string {
  return JSON.stringify(
    DataJSONSchemaTool$outboundSchema.parse(dataJSONSchemaTool),
  );
}
export function dataJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<DataJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const DataStatus$inboundSchema: z.ZodNativeEnum<typeof DataStatus> = z
  .nativeEnum(DataStatus);
/** @internal */
export const DataStatus$outboundSchema: z.ZodNativeEnum<typeof DataStatus> =
  DataStatus$inboundSchema;

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const DataParameters$inboundSchema: z.ZodType<
  DataParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type DataParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DataParameters$outboundSchema: z.ZodType<
  DataParameters$Outbound,
  z.ZodTypeDef,
  DataParameters
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function dataParametersToJSON(dataParameters: DataParameters): string {
  return JSON.stringify(DataParameters$outboundSchema.parse(dataParameters));
}
export function dataParametersFromJSON(
  jsonString: string,
): SafeParseResult<DataParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataParameters' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataFunction$inboundSchema: z.ZodType<
  GetAllToolsDataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DataParameters$inboundSchema).optional(),
});
/** @internal */
export type GetAllToolsDataFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: DataParameters$Outbound | undefined;
};

/** @internal */
export const GetAllToolsDataFunction$outboundSchema: z.ZodType<
  GetAllToolsDataFunction$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DataParameters$outboundSchema).optional(),
});

export function getAllToolsDataFunctionToJSON(
  getAllToolsDataFunction: GetAllToolsDataFunction,
): string {
  return JSON.stringify(
    GetAllToolsDataFunction$outboundSchema.parse(getAllToolsDataFunction),
  );
}
export function getAllToolsDataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataFunction' from JSON`,
  );
}

/** @internal */
export const DataFunctionTool$inboundSchema: z.ZodType<
  DataFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KCRBKM3VQBW14SCQ45KFMJTG"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => GetAllToolsDataFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DataFunctionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "function";
  function: GetAllToolsDataFunction$Outbound;
};

/** @internal */
export const DataFunctionTool$outboundSchema: z.ZodType<
  DataFunctionTool$Outbound,
  z.ZodTypeDef,
  DataFunctionTool
> = z.object({
  id: z.string().default("tool_01KCRBKM3VQBW14SCQ45KFMJTG"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => GetAllToolsDataFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function dataFunctionToolToJSON(
  dataFunctionTool: DataFunctionTool,
): string {
  return JSON.stringify(
    DataFunctionTool$outboundSchema.parse(dataFunctionTool),
  );
}
export function dataFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<DataFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataFunctionTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData$inboundSchema: z.ZodType<
  GetAllToolsData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DataFunctionTool$inboundSchema),
  z.lazy(() => DataJSONSchemaTool$inboundSchema),
  z.lazy(() => DataHTTPTool$inboundSchema),
  z.lazy(() => DataMCPTool$inboundSchema),
  z.lazy(() => DataCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type GetAllToolsData$Outbound =
  | DataFunctionTool$Outbound
  | DataJSONSchemaTool$Outbound
  | DataHTTPTool$Outbound
  | DataMCPTool$Outbound
  | DataCodeExecutionTool$Outbound;

/** @internal */
export const GetAllToolsData$outboundSchema: z.ZodType<
  GetAllToolsData$Outbound,
  z.ZodTypeDef,
  GetAllToolsData
> = z.union([
  z.lazy(() => DataFunctionTool$outboundSchema),
  z.lazy(() => DataJSONSchemaTool$outboundSchema),
  z.lazy(() => DataHTTPTool$outboundSchema),
  z.lazy(() => DataMCPTool$outboundSchema),
  z.lazy(() => DataCodeExecutionTool$outboundSchema),
]);

export function getAllToolsDataToJSON(
  getAllToolsData: GetAllToolsData,
): string {
  return JSON.stringify(GetAllToolsData$outboundSchema.parse(getAllToolsData));
}
export function getAllToolsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData' from JSON`,
  );
}

/** @internal */
export const GetAllToolsResponseBody$inboundSchema: z.ZodType<
  GetAllToolsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllToolsObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => DataFunctionTool$inboundSchema),
      z.lazy(() => DataJSONSchemaTool$inboundSchema),
      z.lazy(() => DataHTTPTool$inboundSchema),
      z.lazy(() => DataMCPTool$inboundSchema),
      z.lazy(() => DataCodeExecutionTool$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});
/** @internal */
export type GetAllToolsResponseBody$Outbound = {
  object: string;
  data: Array<
    | DataFunctionTool$Outbound
    | DataJSONSchemaTool$Outbound
    | DataHTTPTool$Outbound
    | DataMCPTool$Outbound
    | DataCodeExecutionTool$Outbound
  >;
  has_more: boolean;
};

/** @internal */
export const GetAllToolsResponseBody$outboundSchema: z.ZodType<
  GetAllToolsResponseBody$Outbound,
  z.ZodTypeDef,
  GetAllToolsResponseBody
> = z.object({
  object: GetAllToolsObject$outboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => DataFunctionTool$outboundSchema),
      z.lazy(() => DataJSONSchemaTool$outboundSchema),
      z.lazy(() => DataHTTPTool$outboundSchema),
      z.lazy(() => DataMCPTool$outboundSchema),
      z.lazy(() => DataCodeExecutionTool$outboundSchema),
    ]),
  ),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

export function getAllToolsResponseBodyToJSON(
  getAllToolsResponseBody: GetAllToolsResponseBody,
): string {
  return JSON.stringify(
    GetAllToolsResponseBody$outboundSchema.parse(getAllToolsResponseBody),
  );
}
export function getAllToolsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsResponseBody' from JSON`,
  );
}
