/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllToolsRequest = {
  /**
   * Maximum number of tools per page (1-200). Omit to return all tools.
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllToolsObject = {
  List: "list",
} as const;
export type GetAllToolsObject = ClosedEnum<typeof GetAllToolsObject>;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponse200Status = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Status
>;

/**
 * The type must be "object"
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type GetAllToolsDataParameters = {
  /**
   * The type must be "object"
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const DataLanguage = {
  Python: "python",
} as const;
export type DataLanguage = ClosedEnum<typeof DataLanguage>;

export type DataCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: GetAllToolsDataParameters | undefined;
  language: DataLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type DataCodeExecutionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataToolsResponse200Status;
  versionHash?: string | undefined;
  type: "code";
  codeTool: DataCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponseStatus = ClosedEnum<
  typeof GetAllToolsDataToolsResponseStatus
>;

export type DataHeaders = {
  value: string;
  encrypted: boolean;
};

export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type = {
  Object: "object",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type
  >;

export type GetAllToolsDataSchema = {
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type DataTools = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: GetAllToolsDataSchema;
};

/**
 * The connection type used by the MCP server
 */
export const DataConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DataConnectionType = ClosedEnum<typeof DataConnectionType>;

export type DataMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: DataHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<DataTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DataConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type DataMCPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataToolsResponseStatus;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: DataMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsStatus = ClosedEnum<
  typeof GetAllToolsDataToolsStatus
>;

/**
 * The HTTP method to use.
 */
export const GetAllToolsDataMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type GetAllToolsDataMethod = ClosedEnum<typeof GetAllToolsDataMethod>;

export type GetAllToolsHeaders2 = {
  value: string;
  encrypted: boolean;
};

export type GetAllToolsDataHeaders = GetAllToolsHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DataBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: GetAllToolsDataMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: GetAllToolsHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  >;

/**
 * The default value of the argument.
 */
export type DataDefaultValue = string | number | boolean;

export type DataArguments = {
  /**
   * The type of the argument.
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel: boolean;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type GetAllToolsDataHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DataBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DataArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type DataHTTPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataToolsStatus;
  versionHash?: string | undefined;
  type: "http";
  http: GetAllToolsDataHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataStatus = ClosedEnum<typeof GetAllToolsDataStatus>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DataSchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DataJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: DataSchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type DataJSONSchemaTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataStatus;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: DataJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DataStatus = ClosedEnum<typeof DataStatus>;

/**
 * The type must be "object"
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DataParameters = {
  /**
   * The type must be "object"
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type GetAllToolsDataFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: DataParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type DataFunctionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: DataStatus;
  versionHash?: string | undefined;
  type: "function";
  function: GetAllToolsDataFunction;
};

export type GetAllToolsData =
  | DataFunctionTool
  | DataJSONSchemaTool
  | DataHTTPTool
  | DataMCPTool
  | DataCodeExecutionTool;

/**
 * Successfully retrieved the list of tools.
 */
export type GetAllToolsResponseBody = {
  object: GetAllToolsObject;
  data: Array<
    | DataFunctionTool
    | DataJSONSchemaTool
    | DataHTTPTool
    | DataMCPTool
    | DataCodeExecutionTool
  >;
  hasMore: boolean;
};

/** @internal */
export type GetAllToolsRequest$Outbound = {
  limit?: number | undefined;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllToolsRequest$outboundSchema: z.ZodType<
  GetAllToolsRequest$Outbound,
  z.ZodTypeDef,
  GetAllToolsRequest
> = z.object({
  limit: z.number().optional(),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function getAllToolsRequestToJSON(
  getAllToolsRequest: GetAllToolsRequest,
): string {
  return JSON.stringify(
    GetAllToolsRequest$outboundSchema.parse(getAllToolsRequest),
  );
}

/** @internal */
export const GetAllToolsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = z.nativeEnum(GetAllToolsObject);

/** @internal */
export const GetAllToolsDataToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> = z.nativeEnum(
    GetAllToolsDataToolsResponse200Status,
  );

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type,
  );

/** @internal */
export const GetAllToolsDataParameters$inboundSchema: z.ZodType<
  GetAllToolsDataParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      GetAllToolsDataToolsResponse200ApplicationJSONResponseBody5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function getAllToolsDataParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataParameters' from JSON`,
  );
}

/** @internal */
export const DataLanguage$inboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  z.nativeEnum(DataLanguage);

/** @internal */
export const DataCodeTool$inboundSchema: z.ZodType<
  DataCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => GetAllToolsDataParameters$inboundSchema).optional(),
  language: DataLanguage$inboundSchema,
  code: z.string(),
});

export function dataCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeTool' from JSON`,
  );
}

/** @internal */
export const DataCodeExecutionTool$inboundSchema: z.ZodType<
  DataCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZPGH0M0XCAJ2M2ZEAFZ2VH"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponse200Status$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => DataCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

export function dataCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = z.nativeEnum(GetAllToolsDataToolsResponseStatus);

/** @internal */
export const DataHeaders$inboundSchema: z.ZodType<
  DataHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function dataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHeaders' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type,
  );

/** @internal */
export const GetAllToolsDataSchema$inboundSchema: z.ZodType<
  GetAllToolsDataSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function getAllToolsDataSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataSchema' from JSON`,
  );
}

/** @internal */
export const DataTools$inboundSchema: z.ZodType<
  DataTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KHZPGH0KM69JCCMA6TWFDXTK"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => GetAllToolsDataSchema$inboundSchema),
});

export function dataToolsFromJSON(
  jsonString: string,
): SafeParseResult<DataTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataTools' from JSON`,
  );
}

/** @internal */
export const DataConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = z.nativeEnum(DataConnectionType);

/** @internal */
export const DataMcp$inboundSchema: z.ZodType<DataMcp, z.ZodTypeDef, unknown> =
  z.object({
    server_url: z.string(),
    headers: z.record(z.lazy(() => DataHeaders$inboundSchema)).optional(),
    tools: z.array(z.lazy(() => DataTools$inboundSchema)),
    connection_type: DataConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_url": "serverUrl",
      "connection_type": "connectionType",
    });
  });

export function dataMcpFromJSON(
  jsonString: string,
): SafeParseResult<DataMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMcp' from JSON`,
  );
}

/** @internal */
export const DataMCPTool$inboundSchema: z.ZodType<
  DataMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZPGH0J03QPACK931C2797D"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponseStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => DataMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function dataMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<DataMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMCPTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = z.nativeEnum(GetAllToolsDataToolsStatus);

/** @internal */
export const GetAllToolsDataMethod$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = z.nativeEnum(GetAllToolsDataMethod);

/** @internal */
export const GetAllToolsHeaders2$inboundSchema: z.ZodType<
  GetAllToolsHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function getAllToolsHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsHeaders2' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHeaders$inboundSchema: z.ZodType<
  GetAllToolsDataHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => GetAllToolsHeaders2$inboundSchema), z.string()]);

export function getAllToolsDataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHeaders' from JSON`,
  );
}

/** @internal */
export const DataBlueprint$inboundSchema: z.ZodType<
  DataBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => GetAllToolsHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function dataBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DataBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataBlueprint' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type,
  );

/** @internal */
export const DataDefaultValue$inboundSchema: z.ZodType<
  DataDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

export function dataDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DataDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataDefaultValue' from JSON`,
  );
}

/** @internal */
export const DataArguments$inboundSchema: z.ZodType<
  DataArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

export function dataArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DataArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataArguments' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHttp$inboundSchema: z.ZodType<
  GetAllToolsDataHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$inboundSchema)).optional(),
});

export function getAllToolsDataHttpFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHttp' from JSON`,
  );
}

/** @internal */
export const DataHTTPTool$inboundSchema: z.ZodType<
  DataHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZPGH09C9QR24K3TK73BBJ1"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => GetAllToolsDataHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function dataHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<DataHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHTTPTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = z.nativeEnum(GetAllToolsDataStatus);

/** @internal */
export const DataSchema$inboundSchema: z.ZodType<
  DataSchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function dataSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataSchema' from JSON`,
  );
}

/** @internal */
export const DataJsonSchema$inboundSchema: z.ZodType<
  DataJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => DataSchema$inboundSchema),
  strict: z.boolean().optional(),
});

export function dataJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJsonSchema' from JSON`,
  );
}

/** @internal */
export const DataJSONSchemaTool$inboundSchema: z.ZodType<
  DataJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZPGH07C297X4YCA2CJ6TG4"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => DataJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

export function dataJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<DataJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const DataStatus$inboundSchema: z.ZodNativeEnum<typeof DataStatus> = z
  .nativeEnum(DataStatus);

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const DataParameters$inboundSchema: z.ZodType<
  DataParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function dataParametersFromJSON(
  jsonString: string,
): SafeParseResult<DataParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataParameters' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataFunction$inboundSchema: z.ZodType<
  GetAllToolsDataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DataParameters$inboundSchema).optional(),
});

export function getAllToolsDataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataFunction' from JSON`,
  );
}

/** @internal */
export const DataFunctionTool$inboundSchema: z.ZodType<
  DataFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZPGH05TT5NEFMT2ZKQP7DY"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => GetAllToolsDataFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function dataFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<DataFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataFunctionTool' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData$inboundSchema: z.ZodType<
  GetAllToolsData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DataFunctionTool$inboundSchema),
  z.lazy(() => DataJSONSchemaTool$inboundSchema),
  z.lazy(() => DataHTTPTool$inboundSchema),
  z.lazy(() => DataMCPTool$inboundSchema),
  z.lazy(() => DataCodeExecutionTool$inboundSchema),
]);

export function getAllToolsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData' from JSON`,
  );
}

/** @internal */
export const GetAllToolsResponseBody$inboundSchema: z.ZodType<
  GetAllToolsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllToolsObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => DataFunctionTool$inboundSchema),
      z.lazy(() => DataJSONSchemaTool$inboundSchema),
      z.lazy(() => DataHTTPTool$inboundSchema),
      z.lazy(() => DataMCPTool$inboundSchema),
      z.lazy(() => DataCodeExecutionTool$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function getAllToolsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsResponseBody' from JSON`,
  );
}
