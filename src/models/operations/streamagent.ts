/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const StreamAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type StreamAgentRoleToolMessage = ClosedEnum<
  typeof StreamAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const StreamAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type StreamAgentRoleUserMessage = ClosedEnum<
  typeof StreamAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamAgentRole =
  | StreamAgentRoleUserMessage
  | StreamAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart
  | components.ErrorPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type StreamAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamAgentRoleUserMessage | StreamAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | components.TextPart
    | components.FilePart
    | components.ToolResultPart
    | components.ErrorPart
  >;
};

/**
 * Information about the identity making the request. If the identity does not exist, it will be created automatically.
 */
export type StreamAgentIdentity = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type StreamAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamAgentRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: StreamAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: StreamAgentIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: StreamAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamAgentMemory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

export type StreamAgentRequest = {
  /**
   * The key or ID of the agent to invoke
   */
  key: string;
  requestBody: StreamAgentRequestBody;
};

export type StreamAgentData =
  | components.AgentExecutionStartedStreamingEvent
  | components.AgentStartedStreamingEvent
  | components.AgentThoughtStreamingEvent
  | components.AgentInactiveStreamingEvent
  | components.AgentErroredStreamingEvent
  | components.ActionReviewRequestedStreamingEvent
  | components.ActionReviewedStreamingEvent
  | components.ExecutionReviewRequiredStreamingEvent
  | components.ExecutionReviewedStreamingEvent
  | components.ExecutionNamedStreamingEvent
  | components.AgentHandedOffStreamingEvent
  | components.AgentMessageCreatedStreamingEvent
  | components.ToolExecutionStartedStreamingEvent
  | components.ToolExecutionFinishedStreamingEvent
  | components.ToolExecutionFailedStreamingEvent
  | components.TimeoutStreamingEvent
  | components.ErrorStreamingEvent;

/**
 * Server-Sent Event stream successfully established. Returns real-time events including agent messages, tool calls, status updates, and completion signals. The stream ends with a [DONE] sentinel value.
 */
export type StreamAgentResponseBody = {
  data:
    | components.AgentExecutionStartedStreamingEvent
    | components.AgentStartedStreamingEvent
    | components.AgentThoughtStreamingEvent
    | components.AgentInactiveStreamingEvent
    | components.AgentErroredStreamingEvent
    | components.ActionReviewRequestedStreamingEvent
    | components.ActionReviewedStreamingEvent
    | components.ExecutionReviewRequiredStreamingEvent
    | components.ExecutionReviewedStreamingEvent
    | components.ExecutionNamedStreamingEvent
    | components.AgentHandedOffStreamingEvent
    | components.AgentMessageCreatedStreamingEvent
    | components.ToolExecutionStartedStreamingEvent
    | components.ToolExecutionFinishedStreamingEvent
    | components.ToolExecutionFailedStreamingEvent
    | components.TimeoutStreamingEvent
    | components.ErrorStreamingEvent;
};

/** @internal */
export const StreamAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleToolMessage
> = z.nativeEnum(StreamAgentRoleToolMessage);

/** @internal */
export const StreamAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleUserMessage
> = z.nativeEnum(StreamAgentRoleUserMessage);

/** @internal */
export type StreamAgentRole$Outbound = string | string;

/** @internal */
export const StreamAgentRole$outboundSchema: z.ZodType<
  StreamAgentRole$Outbound,
  z.ZodTypeDef,
  StreamAgentRole
> = z.union([
  StreamAgentRoleUserMessage$outboundSchema,
  StreamAgentRoleToolMessage$outboundSchema,
]);

export function streamAgentRoleToJSON(
  streamAgentRole: StreamAgentRole,
): string {
  return JSON.stringify(StreamAgentRole$outboundSchema.parse(streamAgentRole));
}

/** @internal */
export type StreamAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound
  | components.ErrorPart$Outbound;

/** @internal */
export const StreamAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
  components.ErrorPart$outboundSchema,
]);

export function streamAgentPublicMessagePartToJSON(
  streamAgentPublicMessagePart: StreamAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamAgentPublicMessagePart$outboundSchema.parse(
      streamAgentPublicMessagePart,
    ),
  );
}

/** @internal */
export type StreamAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
    | components.ErrorPart$Outbound
  >;
};

/** @internal */
export const StreamAgentA2AMessage$outboundSchema: z.ZodType<
  StreamAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  StreamAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamAgentRoleUserMessage$outboundSchema,
    StreamAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
      components.ErrorPart$outboundSchema,
    ]),
  ),
});

export function streamAgentA2AMessageToJSON(
  streamAgentA2AMessage: StreamAgentA2AMessage,
): string {
  return JSON.stringify(
    StreamAgentA2AMessage$outboundSchema.parse(streamAgentA2AMessage),
  );
}

/** @internal */
export type StreamAgentIdentity$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamAgentIdentity$outboundSchema: z.ZodType<
  StreamAgentIdentity$Outbound,
  z.ZodTypeDef,
  StreamAgentIdentity
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamAgentIdentityToJSON(
  streamAgentIdentity: StreamAgentIdentity,
): string {
  return JSON.stringify(
    StreamAgentIdentity$outboundSchema.parse(streamAgentIdentity),
  );
}

/** @internal */
export type StreamAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamAgentContact$outboundSchema: z.ZodType<
  StreamAgentContact$Outbound,
  z.ZodTypeDef,
  StreamAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamAgentContactToJSON(
  streamAgentContact: StreamAgentContact,
): string {
  return JSON.stringify(
    StreamAgentContact$outboundSchema.parse(streamAgentContact),
  );
}

/** @internal */
export type StreamAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamAgentThread$outboundSchema: z.ZodType<
  StreamAgentThread$Outbound,
  z.ZodTypeDef,
  StreamAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamAgentThreadToJSON(
  streamAgentThread: StreamAgentThread,
): string {
  return JSON.stringify(
    StreamAgentThread$outboundSchema.parse(streamAgentThread),
  );
}

/** @internal */
export type StreamAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamAgentMemory$outboundSchema: z.ZodType<
  StreamAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamAgentMemoryToJSON(
  streamAgentMemory: StreamAgentMemory,
): string {
  return JSON.stringify(
    StreamAgentMemory$outboundSchema.parse(streamAgentMemory),
  );
}

/** @internal */
export type StreamAgentRequestBody$Outbound = {
  task_id?: string | undefined;
  message: StreamAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  identity?: StreamAgentIdentity$Outbound | undefined;
  contact?: StreamAgentContact$Outbound | undefined;
  thread?: StreamAgentThread$Outbound | undefined;
  memory?: StreamAgentMemory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamAgentRequestBody$outboundSchema: z.ZodType<
  StreamAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamAgentRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => StreamAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => StreamAgentIdentity$outboundSchema).optional(),
  contact: z.lazy(() => StreamAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamAgentMemory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamAgentRequestBodyToJSON(
  streamAgentRequestBody: StreamAgentRequestBody,
): string {
  return JSON.stringify(
    StreamAgentRequestBody$outboundSchema.parse(streamAgentRequestBody),
  );
}

/** @internal */
export type StreamAgentRequest$Outbound = {
  key: string;
  RequestBody: StreamAgentRequestBody$Outbound;
};

/** @internal */
export const StreamAgentRequest$outboundSchema: z.ZodType<
  StreamAgentRequest$Outbound,
  z.ZodTypeDef,
  StreamAgentRequest
> = z.object({
  key: z.string(),
  requestBody: z.lazy(() => StreamAgentRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function streamAgentRequestToJSON(
  streamAgentRequest: StreamAgentRequest,
): string {
  return JSON.stringify(
    StreamAgentRequest$outboundSchema.parse(streamAgentRequest),
  );
}

/** @internal */
export const StreamAgentData$inboundSchema: z.ZodType<
  StreamAgentData,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.AgentExecutionStartedStreamingEvent$inboundSchema,
  components.AgentStartedStreamingEvent$inboundSchema,
  components.AgentThoughtStreamingEvent$inboundSchema,
  components.AgentInactiveStreamingEvent$inboundSchema,
  components.AgentErroredStreamingEvent$inboundSchema,
  components.ActionReviewRequestedStreamingEvent$inboundSchema,
  components.ActionReviewedStreamingEvent$inboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
  components.ExecutionReviewedStreamingEvent$inboundSchema,
  components.ExecutionNamedStreamingEvent$inboundSchema,
  components.AgentHandedOffStreamingEvent$inboundSchema,
  components.AgentMessageCreatedStreamingEvent$inboundSchema,
  components.ToolExecutionStartedStreamingEvent$inboundSchema,
  components.ToolExecutionFinishedStreamingEvent$inboundSchema,
  components.ToolExecutionFailedStreamingEvent$inboundSchema,
  components.TimeoutStreamingEvent$inboundSchema,
  components.ErrorStreamingEvent$inboundSchema,
]);

export function streamAgentDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentData' from JSON`,
  );
}

/** @internal */
export const StreamAgentResponseBody$inboundSchema: z.ZodType<
  StreamAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.AgentExecutionStartedStreamingEvent$inboundSchema,
      components.AgentStartedStreamingEvent$inboundSchema,
      components.AgentThoughtStreamingEvent$inboundSchema,
      components.AgentInactiveStreamingEvent$inboundSchema,
      components.AgentErroredStreamingEvent$inboundSchema,
      components.ActionReviewRequestedStreamingEvent$inboundSchema,
      components.ActionReviewedStreamingEvent$inboundSchema,
      components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
      components.ExecutionReviewedStreamingEvent$inboundSchema,
      components.ExecutionNamedStreamingEvent$inboundSchema,
      components.AgentHandedOffStreamingEvent$inboundSchema,
      components.AgentMessageCreatedStreamingEvent$inboundSchema,
      components.ToolExecutionStartedStreamingEvent$inboundSchema,
      components.ToolExecutionFinishedStreamingEvent$inboundSchema,
      components.ToolExecutionFailedStreamingEvent$inboundSchema,
      components.TimeoutStreamingEvent$inboundSchema,
      components.ErrorStreamingEvent$inboundSchema,
    ]),
  ),
});

export function streamAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentResponseBody' from JSON`,
  );
}
