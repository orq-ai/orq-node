/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const StreamAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type StreamAgentRoleToolMessage = ClosedEnum<
  typeof StreamAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const StreamAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type StreamAgentRoleUserMessage = ClosedEnum<
  typeof StreamAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamAgentRole =
  | StreamAgentRoleUserMessage
  | StreamAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type StreamAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamAgentRoleUserMessage | StreamAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    components.TextPart | components.FilePart | components.ToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type StreamAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamAgentRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: StreamAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: StreamAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamAgentMemory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

export type StreamAgentRequest = {
  /**
   * The key or ID of the agent to invoke
   */
  key: string;
  requestBody: StreamAgentRequestBody;
};

export type StreamAgentData =
  | components.AgentExecutionStartedStreamingEvent
  | components.AgentStartedStreamingEvent
  | components.AgentThoughtStreamingEvent
  | components.AgentInactiveStreamingEvent
  | components.AgentErroredStreamingEvent
  | components.ActionReviewRequestedStreamingEvent
  | components.ActionReviewedStreamingEvent
  | components.ExecutionReviewRequiredStreamingEvent
  | components.ExecutionReviewedStreamingEvent
  | components.ExecutionNamedStreamingEvent
  | components.AgentHandedOffStreamingEvent
  | components.AgentMessageCreatedStreamingEvent
  | components.ToolExecutionStartedStreamingEvent
  | components.ToolExecutionFinishedStreamingEvent
  | components.ToolExecutionFailedStreamingEvent
  | components.TimeoutStreamingEvent
  | components.ErrorStreamingEvent;

/**
 * Server-Sent Event stream successfully established. Returns real-time events including agent messages, tool calls, status updates, and completion signals. The stream ends with a [DONE] sentinel value.
 */
export type StreamAgentResponseBody = {
  data:
    | components.AgentExecutionStartedStreamingEvent
    | components.AgentStartedStreamingEvent
    | components.AgentThoughtStreamingEvent
    | components.AgentInactiveStreamingEvent
    | components.AgentErroredStreamingEvent
    | components.ActionReviewRequestedStreamingEvent
    | components.ActionReviewedStreamingEvent
    | components.ExecutionReviewRequiredStreamingEvent
    | components.ExecutionReviewedStreamingEvent
    | components.ExecutionNamedStreamingEvent
    | components.AgentHandedOffStreamingEvent
    | components.AgentMessageCreatedStreamingEvent
    | components.ToolExecutionStartedStreamingEvent
    | components.ToolExecutionFinishedStreamingEvent
    | components.ToolExecutionFailedStreamingEvent
    | components.TimeoutStreamingEvent
    | components.ErrorStreamingEvent;
};

/** @internal */
export const StreamAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleToolMessage
> = z.nativeEnum(StreamAgentRoleToolMessage);
/** @internal */
export const StreamAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleToolMessage
> = StreamAgentRoleToolMessage$inboundSchema;

/** @internal */
export const StreamAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleUserMessage
> = z.nativeEnum(StreamAgentRoleUserMessage);
/** @internal */
export const StreamAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamAgentRoleUserMessage
> = StreamAgentRoleUserMessage$inboundSchema;

/** @internal */
export const StreamAgentRole$inboundSchema: z.ZodType<
  StreamAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  StreamAgentRoleUserMessage$inboundSchema,
  StreamAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type StreamAgentRole$Outbound = string | string;

/** @internal */
export const StreamAgentRole$outboundSchema: z.ZodType<
  StreamAgentRole$Outbound,
  z.ZodTypeDef,
  StreamAgentRole
> = z.union([
  StreamAgentRoleUserMessage$outboundSchema,
  StreamAgentRoleToolMessage$outboundSchema,
]);

export function streamAgentRoleToJSON(
  streamAgentRole: StreamAgentRole,
): string {
  return JSON.stringify(StreamAgentRole$outboundSchema.parse(streamAgentRole));
}
export function streamAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentRole' from JSON`,
  );
}

/** @internal */
export const StreamAgentPublicMessagePart$inboundSchema: z.ZodType<
  StreamAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolResultPart$inboundSchema,
]);
/** @internal */
export type StreamAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound;

/** @internal */
export const StreamAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
]);

export function streamAgentPublicMessagePartToJSON(
  streamAgentPublicMessagePart: StreamAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamAgentPublicMessagePart$outboundSchema.parse(
      streamAgentPublicMessagePart,
    ),
  );
}
export function streamAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const StreamAgentA2AMessage$inboundSchema: z.ZodType<
  StreamAgentA2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamAgentRoleUserMessage$inboundSchema,
    StreamAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolResultPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type StreamAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
  >;
};

/** @internal */
export const StreamAgentA2AMessage$outboundSchema: z.ZodType<
  StreamAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  StreamAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamAgentRoleUserMessage$outboundSchema,
    StreamAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
    ]),
  ),
});

export function streamAgentA2AMessageToJSON(
  streamAgentA2AMessage: StreamAgentA2AMessage,
): string {
  return JSON.stringify(
    StreamAgentA2AMessage$outboundSchema.parse(streamAgentA2AMessage),
  );
}
export function streamAgentA2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentA2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentA2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentA2AMessage' from JSON`,
  );
}

/** @internal */
export const StreamAgentContact$inboundSchema: z.ZodType<
  StreamAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type StreamAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamAgentContact$outboundSchema: z.ZodType<
  StreamAgentContact$Outbound,
  z.ZodTypeDef,
  StreamAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamAgentContactToJSON(
  streamAgentContact: StreamAgentContact,
): string {
  return JSON.stringify(
    StreamAgentContact$outboundSchema.parse(streamAgentContact),
  );
}
export function streamAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentContact' from JSON`,
  );
}

/** @internal */
export const StreamAgentThread$inboundSchema: z.ZodType<
  StreamAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type StreamAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamAgentThread$outboundSchema: z.ZodType<
  StreamAgentThread$Outbound,
  z.ZodTypeDef,
  StreamAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamAgentThreadToJSON(
  streamAgentThread: StreamAgentThread,
): string {
  return JSON.stringify(
    StreamAgentThread$outboundSchema.parse(streamAgentThread),
  );
}
export function streamAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentThread' from JSON`,
  );
}

/** @internal */
export const StreamAgentMemory$inboundSchema: z.ZodType<
  StreamAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamAgentMemory$outboundSchema: z.ZodType<
  StreamAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamAgentMemoryToJSON(
  streamAgentMemory: StreamAgentMemory,
): string {
  return JSON.stringify(
    StreamAgentMemory$outboundSchema.parse(streamAgentMemory),
  );
}
export function streamAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentMemory' from JSON`,
  );
}

/** @internal */
export const StreamAgentRequestBody$inboundSchema: z.ZodType<
  StreamAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => StreamAgentA2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => StreamAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => StreamAgentMemory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  stream_timeout_seconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
    "stream_timeout_seconds": "streamTimeoutSeconds",
  });
});
/** @internal */
export type StreamAgentRequestBody$Outbound = {
  task_id?: string | undefined;
  message: StreamAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: StreamAgentContact$Outbound | undefined;
  thread?: StreamAgentThread$Outbound | undefined;
  memory?: StreamAgentMemory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamAgentRequestBody$outboundSchema: z.ZodType<
  StreamAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamAgentRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => StreamAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamAgentMemory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamAgentRequestBodyToJSON(
  streamAgentRequestBody: StreamAgentRequestBody,
): string {
  return JSON.stringify(
    StreamAgentRequestBody$outboundSchema.parse(streamAgentRequestBody),
  );
}
export function streamAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const StreamAgentRequest$inboundSchema: z.ZodType<
  StreamAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  RequestBody: z.lazy(() => StreamAgentRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type StreamAgentRequest$Outbound = {
  key: string;
  RequestBody: StreamAgentRequestBody$Outbound;
};

/** @internal */
export const StreamAgentRequest$outboundSchema: z.ZodType<
  StreamAgentRequest$Outbound,
  z.ZodTypeDef,
  StreamAgentRequest
> = z.object({
  key: z.string(),
  requestBody: z.lazy(() => StreamAgentRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function streamAgentRequestToJSON(
  streamAgentRequest: StreamAgentRequest,
): string {
  return JSON.stringify(
    StreamAgentRequest$outboundSchema.parse(streamAgentRequest),
  );
}
export function streamAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentRequest' from JSON`,
  );
}

/** @internal */
export const StreamAgentData$inboundSchema: z.ZodType<
  StreamAgentData,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.AgentExecutionStartedStreamingEvent$inboundSchema,
  components.AgentStartedStreamingEvent$inboundSchema,
  components.AgentThoughtStreamingEvent$inboundSchema,
  components.AgentInactiveStreamingEvent$inboundSchema,
  components.AgentErroredStreamingEvent$inboundSchema,
  components.ActionReviewRequestedStreamingEvent$inboundSchema,
  components.ActionReviewedStreamingEvent$inboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
  components.ExecutionReviewedStreamingEvent$inboundSchema,
  components.ExecutionNamedStreamingEvent$inboundSchema,
  components.AgentHandedOffStreamingEvent$inboundSchema,
  components.AgentMessageCreatedStreamingEvent$inboundSchema,
  components.ToolExecutionStartedStreamingEvent$inboundSchema,
  components.ToolExecutionFinishedStreamingEvent$inboundSchema,
  components.ToolExecutionFailedStreamingEvent$inboundSchema,
  components.TimeoutStreamingEvent$inboundSchema,
  components.ErrorStreamingEvent$inboundSchema,
]);
/** @internal */
export type StreamAgentData$Outbound =
  | components.AgentExecutionStartedStreamingEvent$Outbound
  | components.AgentStartedStreamingEvent$Outbound
  | components.AgentThoughtStreamingEvent$Outbound
  | components.AgentInactiveStreamingEvent$Outbound
  | components.AgentErroredStreamingEvent$Outbound
  | components.ActionReviewRequestedStreamingEvent$Outbound
  | components.ActionReviewedStreamingEvent$Outbound
  | components.ExecutionReviewRequiredStreamingEvent$Outbound
  | components.ExecutionReviewedStreamingEvent$Outbound
  | components.ExecutionNamedStreamingEvent$Outbound
  | components.AgentHandedOffStreamingEvent$Outbound
  | components.AgentMessageCreatedStreamingEvent$Outbound
  | components.ToolExecutionStartedStreamingEvent$Outbound
  | components.ToolExecutionFinishedStreamingEvent$Outbound
  | components.ToolExecutionFailedStreamingEvent$Outbound
  | components.TimeoutStreamingEvent$Outbound
  | components.ErrorStreamingEvent$Outbound;

/** @internal */
export const StreamAgentData$outboundSchema: z.ZodType<
  StreamAgentData$Outbound,
  z.ZodTypeDef,
  StreamAgentData
> = z.union([
  components.AgentExecutionStartedStreamingEvent$outboundSchema,
  components.AgentStartedStreamingEvent$outboundSchema,
  components.AgentThoughtStreamingEvent$outboundSchema,
  components.AgentInactiveStreamingEvent$outboundSchema,
  components.AgentErroredStreamingEvent$outboundSchema,
  components.ActionReviewRequestedStreamingEvent$outboundSchema,
  components.ActionReviewedStreamingEvent$outboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$outboundSchema,
  components.ExecutionReviewedStreamingEvent$outboundSchema,
  components.ExecutionNamedStreamingEvent$outboundSchema,
  components.AgentHandedOffStreamingEvent$outboundSchema,
  components.AgentMessageCreatedStreamingEvent$outboundSchema,
  components.ToolExecutionStartedStreamingEvent$outboundSchema,
  components.ToolExecutionFinishedStreamingEvent$outboundSchema,
  components.ToolExecutionFailedStreamingEvent$outboundSchema,
  components.TimeoutStreamingEvent$outboundSchema,
  components.ErrorStreamingEvent$outboundSchema,
]);

export function streamAgentDataToJSON(
  streamAgentData: StreamAgentData,
): string {
  return JSON.stringify(StreamAgentData$outboundSchema.parse(streamAgentData));
}
export function streamAgentDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentData' from JSON`,
  );
}

/** @internal */
export const StreamAgentResponseBody$inboundSchema: z.ZodType<
  StreamAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.AgentExecutionStartedStreamingEvent$inboundSchema,
      components.AgentStartedStreamingEvent$inboundSchema,
      components.AgentThoughtStreamingEvent$inboundSchema,
      components.AgentInactiveStreamingEvent$inboundSchema,
      components.AgentErroredStreamingEvent$inboundSchema,
      components.ActionReviewRequestedStreamingEvent$inboundSchema,
      components.ActionReviewedStreamingEvent$inboundSchema,
      components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
      components.ExecutionReviewedStreamingEvent$inboundSchema,
      components.ExecutionNamedStreamingEvent$inboundSchema,
      components.AgentHandedOffStreamingEvent$inboundSchema,
      components.AgentMessageCreatedStreamingEvent$inboundSchema,
      components.ToolExecutionStartedStreamingEvent$inboundSchema,
      components.ToolExecutionFinishedStreamingEvent$inboundSchema,
      components.ToolExecutionFailedStreamingEvent$inboundSchema,
      components.TimeoutStreamingEvent$inboundSchema,
      components.ErrorStreamingEvent$inboundSchema,
    ]),
  ),
});
/** @internal */
export type StreamAgentResponseBody$Outbound = {
  data:
    | components.AgentExecutionStartedStreamingEvent$Outbound
    | components.AgentStartedStreamingEvent$Outbound
    | components.AgentThoughtStreamingEvent$Outbound
    | components.AgentInactiveStreamingEvent$Outbound
    | components.AgentErroredStreamingEvent$Outbound
    | components.ActionReviewRequestedStreamingEvent$Outbound
    | components.ActionReviewedStreamingEvent$Outbound
    | components.ExecutionReviewRequiredStreamingEvent$Outbound
    | components.ExecutionReviewedStreamingEvent$Outbound
    | components.ExecutionNamedStreamingEvent$Outbound
    | components.AgentHandedOffStreamingEvent$Outbound
    | components.AgentMessageCreatedStreamingEvent$Outbound
    | components.ToolExecutionStartedStreamingEvent$Outbound
    | components.ToolExecutionFinishedStreamingEvent$Outbound
    | components.ToolExecutionFailedStreamingEvent$Outbound
    | components.TimeoutStreamingEvent$Outbound
    | components.ErrorStreamingEvent$Outbound;
};

/** @internal */
export const StreamAgentResponseBody$outboundSchema: z.ZodType<
  StreamAgentResponseBody$Outbound,
  z.ZodTypeDef,
  StreamAgentResponseBody
> = z.object({
  data: z.union([
    components.AgentExecutionStartedStreamingEvent$outboundSchema,
    components.AgentStartedStreamingEvent$outboundSchema,
    components.AgentThoughtStreamingEvent$outboundSchema,
    components.AgentInactiveStreamingEvent$outboundSchema,
    components.AgentErroredStreamingEvent$outboundSchema,
    components.ActionReviewRequestedStreamingEvent$outboundSchema,
    components.ActionReviewedStreamingEvent$outboundSchema,
    components.ExecutionReviewRequiredStreamingEvent$outboundSchema,
    components.ExecutionReviewedStreamingEvent$outboundSchema,
    components.ExecutionNamedStreamingEvent$outboundSchema,
    components.AgentHandedOffStreamingEvent$outboundSchema,
    components.AgentMessageCreatedStreamingEvent$outboundSchema,
    components.ToolExecutionStartedStreamingEvent$outboundSchema,
    components.ToolExecutionFinishedStreamingEvent$outboundSchema,
    components.ToolExecutionFailedStreamingEvent$outboundSchema,
    components.TimeoutStreamingEvent$outboundSchema,
    components.ErrorStreamingEvent$outboundSchema,
  ]),
});

export function streamAgentResponseBodyToJSON(
  streamAgentResponseBody: StreamAgentResponseBody,
): string {
  return JSON.stringify(
    StreamAgentResponseBody$outboundSchema.parse(streamAgentResponseBody),
  );
}
export function streamAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamAgentResponseBody' from JSON`,
  );
}
