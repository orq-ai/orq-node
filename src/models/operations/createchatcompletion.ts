/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateChatCompletionContentRouterChatCompletionsRequest2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreateChatCompletionMessagesRouterChatCompletionsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreateChatCompletionMessagesRouterChatCompletionsType = ClosedEnum<
  typeof CreateChatCompletionMessagesRouterChatCompletionsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreateChatCompletionMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreateChatCompletionMessagesTtl = ClosedEnum<
  typeof CreateChatCompletionMessagesTtl
>;

export type CreateChatCompletionMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreateChatCompletionMessagesRouterChatCompletionsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreateChatCompletionMessagesTtl | undefined;
};

export type CreateChatCompletionMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: CreateChatCompletionMessagesCacheControl | undefined;
};

export type CreateChatCompletionContentRouterChatCompletions2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type CreateChatCompletionMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const CreateChatCompletionMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type CreateChatCompletionMessagesType = ClosedEnum<
  typeof CreateChatCompletionMessagesType
>;

export type CreateChatCompletionMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: CreateChatCompletionMessagesType;
  function: CreateChatCompletionMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type CreateChatCompletionMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: CreateChatCompletionMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<CreateChatCompletionMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreateChatCompletion2RouterChatCompletionsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreateChatCompletion2RouterChatCompletionsType = ClosedEnum<
  typeof CreateChatCompletion2RouterChatCompletionsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreateChatCompletion2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreateChatCompletion2Ttl = ClosedEnum<
  typeof CreateChatCompletion2Ttl
>;

export type CreateChatCompletion2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreateChatCompletion2RouterChatCompletionsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreateChatCompletion2Ttl | undefined;
};

export type CreateChatCompletion24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: CreateChatCompletion2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type CreateChatCompletionContent2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | CreateChatCompletion24;

/**
 * The contents of the user message.
 */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | CreateChatCompletion24
  >;

export type CreateChatCompletionMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | CreateChatCompletion24
    >;
};

/**
 * The contents of the developer message.
 */
export type CreateChatCompletionMessagesRouterChatCompletionsContent =
  | string
  | Array<components.TextContentPartSchema>;

export type CreateChatCompletionMessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type CreateChatCompletionMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type CreateChatCompletionMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type CreateChatCompletionMessages =
  | CreateChatCompletionMessagesSystemMessage
  | CreateChatCompletionMessagesDeveloperMessage
  | CreateChatCompletionMessagesUserMessage
  | CreateChatCompletionMessagesAssistantMessage
  | CreateChatCompletionMessagesToolMessage;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateChatCompletionVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateChatCompletionVoice = ClosedEnum<
  typeof CreateChatCompletionVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateChatCompletionFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateChatCompletionFormat = ClosedEnum<
  typeof CreateChatCompletionFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateChatCompletionAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateChatCompletionVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateChatCompletionFormat;
};

export type CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict?: boolean | undefined;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateChatCompletionResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateChatCompletionResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateChatCompletionResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateChatCompletionResponseFormat =
  | CreateChatCompletionResponseFormatText
  | CreateChatCompletionResponseFormatJSONObject
  | CreateChatCompletionResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const CreateChatCompletionReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type CreateChatCompletionReasoningEffort = ClosedEnum<
  typeof CreateChatCompletionReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateChatCompletionStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateChatCompletionStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type CreateChatCompletionThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateChatCompletionType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateChatCompletionType = ClosedEnum<
  typeof CreateChatCompletionType
>;

export const CreateChatCompletionRouterChatCompletionsType = {
  Object: "object",
} as const;
export type CreateChatCompletionRouterChatCompletionsType = ClosedEnum<
  typeof CreateChatCompletionRouterChatCompletionsType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object
 */
export type CreateChatCompletionParameters = {
  type: CreateChatCompletionRouterChatCompletionsType;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

export type CreateChatCompletionFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object
   */
  parameters?: CreateChatCompletionParameters | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call.
   */
  strict?: boolean | undefined;
};

export type CreateChatCompletionTools = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateChatCompletionType | undefined;
  function: CreateChatCompletionFunction;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateChatCompletionToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateChatCompletionToolChoiceType = ClosedEnum<
  typeof CreateChatCompletionToolChoiceType
>;

export type CreateChatCompletionToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateChatCompletionToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateChatCompletionToolChoiceType | undefined;
  function: CreateChatCompletionToolChoiceFunction;
};

export const CreateChatCompletionToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateChatCompletionToolChoice1 = ClosedEnum<
  typeof CreateChatCompletionToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateChatCompletionToolChoice =
  | CreateChatCompletionToolChoice2
  | CreateChatCompletionToolChoice1;

export const CreateChatCompletionModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateChatCompletionModalities = ClosedEnum<
  typeof CreateChatCompletionModalities
>;

/**
 * The key of the guardrail.
 */
export const CreateChatCompletionId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type CreateChatCompletionId1 = ClosedEnum<
  typeof CreateChatCompletionId1
>;

export type CreateChatCompletionId = CreateChatCompletionId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const CreateChatCompletionExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type CreateChatCompletionExecuteOn = ClosedEnum<
  typeof CreateChatCompletionExecuteOn
>;

export type CreateChatCompletionGuardrails = {
  id: CreateChatCompletionId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: CreateChatCompletionExecuteOn;
};

export type CreateChatCompletionFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateChatCompletionRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateChatCompletionRouterChatCompletionsRequestType = {
  ExactMatch: "exact_match",
} as const;
export type CreateChatCompletionRouterChatCompletionsRequestType = ClosedEnum<
  typeof CreateChatCompletionRouterChatCompletionsRequestType
>;

/**
 * Cache configuration for the request.
 */
export type CreateChatCompletionCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateChatCompletionRouterChatCompletionsRequestType;
};

export const CreateChatCompletionLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateChatCompletionLoadBalancerType = ClosedEnum<
  typeof CreateChatCompletionLoadBalancerType
>;

export type CreateChatCompletionLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateChatCompletionLoadBalancer1 = {
  type: CreateChatCompletionLoadBalancerType;
  models: Array<CreateChatCompletionLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type CreateChatCompletionLoadBalancer =
  CreateChatCompletionLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateChatCompletionTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Retry configuration for the request
 */
export type CreateChatCompletionRouterChatCompletionsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateChatCompletionRouterChatCompletionsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export const Version = {
  Latest: "latest",
} as const;
/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export type Version = ClosedEnum<typeof Version>;

/**
 * Prompt configuration for the request
 */
export type Prompt = {
  /**
   * Unique identifier of the prompt to use
   */
  id: string;
  /**
   * Version of the prompt to use (currently only "latest" supported)
   */
  version: Version;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateChatCompletionContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type CreateChatCompletionThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

export type Inputs2 = {
  key: string;
  value?: any | undefined;
  isPii?: boolean | undefined;
};

/**
 * Values to replace in the prompt messages using {{variableName}} syntax
 */
export type Inputs = { [k: string]: any } | Array<Inputs2>;

export const CreateChatCompletionRouterChatCompletionsRequestRequestBodyType = {
  ExactMatch: "exact_match",
} as const;
export type CreateChatCompletionRouterChatCompletionsRequestRequestBodyType =
  ClosedEnum<
    typeof CreateChatCompletionRouterChatCompletionsRequestRequestBodyType
  >;

/**
 * Cache configuration for the request.
 */
export type CreateChatCompletionRouterChatCompletionsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateChatCompletionRouterChatCompletionsRequestRequestBodyType;
};

/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export const CreateChatCompletionSearchType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export type CreateChatCompletionSearchType = ClosedEnum<
  typeof CreateChatCompletionSearchType
>;

/**
 * Exists
 */
export type CreateChatCompletionOrExists = {
  exists: boolean;
};

export type CreateChatCompletionOrRouterChatCompletionsNin =
  | string
  | number
  | boolean;

/**
 * Not in
 */
export type CreateChatCompletionOrNin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletionOrRouterChatCompletionsIn =
  | string
  | number
  | boolean;

/**
 * In
 */
export type CreateChatCompletionOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletionOrLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletionOrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletionOrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletionOrGt = {
  gt: number;
};

export type CreateChatCompletionOrRouterChatCompletionsNe =
  | string
  | number
  | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletionOrNe = {
  ne: string | number | boolean;
};

export type CreateChatCompletionOrRouterChatCompletionsEq =
  | string
  | number
  | boolean;

/**
 * Equal to
 */
export type CreateChatCompletionOrEq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterByRouterChatCompletionsOr =
  | CreateChatCompletionOrEq
  | CreateChatCompletionOrNe
  | CreateChatCompletionOrGt
  | CreateChatCompletionOrGte
  | CreateChatCompletionOrLt
  | CreateChatCompletionOrLte
  | CreateChatCompletionOrIn
  | CreateChatCompletionOrNin
  | CreateChatCompletionOrExists;

/**
 * Or
 */
export type CreateChatCompletionFilterByOr = {
  or: Array<
    {
      [k: string]:
        | CreateChatCompletionOrEq
        | CreateChatCompletionOrNe
        | CreateChatCompletionOrGt
        | CreateChatCompletionOrGte
        | CreateChatCompletionOrLt
        | CreateChatCompletionOrLte
        | CreateChatCompletionOrIn
        | CreateChatCompletionOrNin
        | CreateChatCompletionOrExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateChatCompletionAndExists = {
  exists: boolean;
};

export type CreateChatCompletionAndRouterChatCompletionsNin =
  | string
  | number
  | boolean;

/**
 * Not in
 */
export type CreateChatCompletionAndNin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletionAndRouterChatCompletionsIn =
  | string
  | number
  | boolean;

/**
 * In
 */
export type CreateChatCompletionAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletionAndLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletionAndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletionAndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletionAndGt = {
  gt: number;
};

export type CreateChatCompletionAndRouterChatCompletionsNe =
  | string
  | number
  | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletionAndNe = {
  ne: string | number | boolean;
};

export type CreateChatCompletionAndRouterChatCompletionsEq =
  | string
  | number
  | boolean;

/**
 * Equal to
 */
export type CreateChatCompletionAndEq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterByRouterChatCompletionsAnd =
  | CreateChatCompletionAndEq
  | CreateChatCompletionAndNe
  | CreateChatCompletionAndGt
  | CreateChatCompletionAndGte
  | CreateChatCompletionAndLt
  | CreateChatCompletionAndLte
  | CreateChatCompletionAndIn
  | CreateChatCompletionAndNin
  | CreateChatCompletionAndExists;

/**
 * And
 */
export type CreateChatCompletionFilterByAnd = {
  and: Array<
    {
      [k: string]:
        | CreateChatCompletionAndEq
        | CreateChatCompletionAndNe
        | CreateChatCompletionAndGt
        | CreateChatCompletionAndGte
        | CreateChatCompletionAndLt
        | CreateChatCompletionAndLte
        | CreateChatCompletionAndIn
        | CreateChatCompletionAndNin
        | CreateChatCompletionAndExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateChatCompletion1Exists = {
  exists: boolean;
};

export type CreateChatCompletion1RouterChatCompletionsNin =
  | string
  | number
  | boolean;

/**
 * Not in
 */
export type CreateChatCompletion1Nin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletion1RouterChatCompletionsIn =
  | string
  | number
  | boolean;

/**
 * In
 */
export type CreateChatCompletion1In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletion1Lte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletion1Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletion1Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletion1Gt = {
  gt: number;
};

export type CreateChatCompletion1RouterChatCompletionsNe =
  | string
  | number
  | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletion1Ne = {
  ne: string | number | boolean;
};

export type CreateChatCompletion1RouterChatCompletionsEq =
  | string
  | number
  | boolean;

/**
 * Equal to
 */
export type CreateChatCompletion1Eq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterBy1 =
  | CreateChatCompletion1Eq
  | CreateChatCompletion1Ne
  | CreateChatCompletion1Gt
  | CreateChatCompletion1Gte
  | CreateChatCompletion1Lt
  | CreateChatCompletion1Lte
  | CreateChatCompletion1In
  | CreateChatCompletion1Nin
  | CreateChatCompletion1Exists;

/**
 * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
 */
export type CreateChatCompletionFilterBy =
  | CreateChatCompletionFilterByAnd
  | CreateChatCompletionFilterByOr
  | {
    [k: string]:
      | CreateChatCompletion1Eq
      | CreateChatCompletion1Ne
      | CreateChatCompletion1Gt
      | CreateChatCompletion1Gte
      | CreateChatCompletion1Lt
      | CreateChatCompletion1Lte
      | CreateChatCompletion1In
      | CreateChatCompletion1Nin
      | CreateChatCompletion1Exists;
  };

/**
 * Additional search options
 */
export type CreateChatCompletionSearchOptions = {
  /**
   * Whether to include the vector in the chunk
   */
  includeVectors?: boolean | undefined;
  /**
   * Whether to include the metadata in the chunk
   */
  includeMetadata?: boolean | undefined;
  /**
   * Whether to include the scores in the chunk
   */
  includeScores?: boolean | undefined;
};

/**
 * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
 */
export type CreateChatCompletionRerankConfig = {
  /**
   * The name of the rerank model to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/rerank-models).
   */
  model: string;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The number of top results to return after reranking. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
};

/**
 * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
 */
export type CreateChatCompletionAgenticRagConfig = {
  /**
   * The name of the model for the Agent to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/chat-models).
   */
  model: string;
};

export type CreateChatCompletionKnowledgeBases = {
  /**
   * The number of results to return. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
  /**
   * The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`
   */
  threshold?: number | undefined;
  /**
   * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
   */
  searchType?: CreateChatCompletionSearchType | undefined;
  /**
   * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
   */
  filterBy?:
    | CreateChatCompletionFilterByAnd
    | CreateChatCompletionFilterByOr
    | {
      [k: string]:
        | CreateChatCompletion1Eq
        | CreateChatCompletion1Ne
        | CreateChatCompletion1Gt
        | CreateChatCompletion1Gte
        | CreateChatCompletion1Lt
        | CreateChatCompletion1Lte
        | CreateChatCompletion1In
        | CreateChatCompletion1Nin
        | CreateChatCompletion1Exists;
    }
    | undefined;
  /**
   * Additional search options
   */
  searchOptions?: CreateChatCompletionSearchOptions | undefined;
  /**
   * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
   */
  rerankConfig?: CreateChatCompletionRerankConfig | undefined;
  /**
   * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
   */
  agenticRagConfig?: CreateChatCompletionAgenticRagConfig | undefined;
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
  /**
   * The query to use to search the knowledge base. If not provided we will use the last user message from the messages of the requests
   */
  query?: string | undefined;
};

export const CreateChatCompletionLoadBalancerRouterChatCompletionsType = {
  WeightBased: "weight_based",
} as const;
export type CreateChatCompletionLoadBalancerRouterChatCompletionsType =
  ClosedEnum<typeof CreateChatCompletionLoadBalancerRouterChatCompletionsType>;

export type CreateChatCompletionLoadBalancerRouterChatCompletionsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateChatCompletionLoadBalancerRouterChatCompletions1 = {
  type: CreateChatCompletionLoadBalancerRouterChatCompletionsType;
  models: Array<CreateChatCompletionLoadBalancerRouterChatCompletionsModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateChatCompletionRouterChatCompletionsLoadBalancer =
  CreateChatCompletionLoadBalancerRouterChatCompletions1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateChatCompletionRouterChatCompletionsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type Orq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateChatCompletionRouterChatCompletionsRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?:
    | Array<CreateChatCompletionRouterChatCompletionsFallbacks>
    | undefined;
  /**
   * Prompt configuration for the request
   */
  prompt?: Prompt | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateChatCompletionContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateChatCompletionThread | undefined;
  /**
   * Values to replace in the prompt messages using {{variableName}} syntax
   */
  inputs?: { [k: string]: any } | Array<Inputs2> | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateChatCompletionRouterChatCompletionsCache | undefined;
  knowledgeBases?: Array<CreateChatCompletionKnowledgeBases> | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?:
    | CreateChatCompletionLoadBalancerRouterChatCompletions1
    | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateChatCompletionRouterChatCompletionsTimeout | undefined;
};

export type CreateChatCompletionRequestBody = {
  /**
   * A list of messages comprising the conversation so far.
   */
  messages: Array<
    | CreateChatCompletionMessagesSystemMessage
    | CreateChatCompletionMessagesDeveloperMessage
    | CreateChatCompletionMessagesUserMessage
    | CreateChatCompletionMessagesAssistantMessage
    | CreateChatCompletionMessagesToolMessage
  >;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`. The AI Gateway offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the (Supported models)[/docs/proxy/supported-models] to browse available models.
   */
  model: string;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can have a maximum length of 64 characters and values can have a maximum length of 512 characters.
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateChatCompletionAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateChatCompletionResponseFormatText
    | CreateChatCompletionResponseFormatJSONObject
    | CreateChatCompletionResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: CreateChatCompletionReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateChatCompletionStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * A list of tools the model may call.
   */
  tools?: Array<CreateChatCompletionTools> | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateChatCompletionToolChoice2
    | CreateChatCompletionToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateChatCompletionModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<CreateChatCompletionGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateChatCompletionFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateChatCompletionRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateChatCompletionCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: CreateChatCompletionLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateChatCompletionTimeout | undefined;
  /**
   * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  orq?: Orq | undefined;
  stream?: boolean | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const CreateChatCompletionFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type CreateChatCompletionFinishReason = ClosedEnum<
  typeof CreateChatCompletionFinishReason
>;

export type CreateChatCompletionRouterChatCompletionsTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionRouterChatCompletionsContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<CreateChatCompletionRouterChatCompletionsTopLogprobs>;
};

export type CreateChatCompletionRouterChatCompletionsResponseTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionRefusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<
    CreateChatCompletionRouterChatCompletionsResponseTopLogprobs
  >;
};

/**
 * Log probability information for the choice.
 */
export type CreateChatCompletionLogprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<CreateChatCompletionRouterChatCompletionsContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<CreateChatCompletionRefusal> | null;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const CreateChatCompletionRouterChatCompletionsResponse200Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type CreateChatCompletionRouterChatCompletionsResponse200Type =
  ClosedEnum<typeof CreateChatCompletionRouterChatCompletionsResponse200Type>;

export type CreateChatCompletionRouterChatCompletionsResponseFunction = {
  /**
   * The name of the function.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionRouterChatCompletionsToolCalls = {
  /**
   * The index of the tool call.
   */
  index?: number | undefined;
  /**
   * The ID of the tool call.
   */
  id?: string | undefined;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type?: CreateChatCompletionRouterChatCompletionsResponse200Type | undefined;
  function?:
    | CreateChatCompletionRouterChatCompletionsResponseFunction
    | undefined;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models.
   */
  thoughtSignature?: string | undefined;
};

export const CreateChatCompletionRouterChatCompletionsRole = {
  Assistant: "assistant",
} as const;
export type CreateChatCompletionRouterChatCompletionsRole = ClosedEnum<
  typeof CreateChatCompletionRouterChatCompletionsRole
>;

/**
 * Audio response data in streaming mode.
 */
export type CreateChatCompletionRouterChatCompletionsResponseAudio = {
  id?: string | undefined;
  transcript?: string | undefined;
  data?: string | undefined;
  expiresAt?: number | undefined;
};

/**
 * A chat completion delta generated by streamed model responses.
 */
export type Delta = {
  /**
   * The contents of the chunk message.
   */
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?:
    | Array<CreateChatCompletionRouterChatCompletionsToolCalls>
    | undefined;
  role?: CreateChatCompletionRouterChatCompletionsRole | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * Audio response data in streaming mode.
   */
  audio?:
    | CreateChatCompletionRouterChatCompletionsResponseAudio
    | null
    | undefined;
};

export type CreateChatCompletionRouterChatCompletionsChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: CreateChatCompletionFinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index: number;
  /**
   * Log probability information for the choice.
   */
  logprobs?: CreateChatCompletionLogprobs | null | undefined;
  /**
   * A chat completion delta generated by streamed model responses.
   */
  delta: Delta;
};

export type CreateChatCompletionRouterChatCompletionsPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateChatCompletionRouterChatCompletionsCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateChatCompletionRouterChatCompletionsUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | CreateChatCompletionRouterChatCompletionsPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | CreateChatCompletionRouterChatCompletionsCompletionTokensDetails
    | null
    | undefined;
};

export const CreateChatCompletionRouterChatCompletionsObject = {
  ChatCompletionChunk: "chat.completion.chunk",
} as const;
export type CreateChatCompletionRouterChatCompletionsObject = ClosedEnum<
  typeof CreateChatCompletionRouterChatCompletionsObject
>;

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionData = {
  /**
   * A unique identifier for the chat completion.
   */
  id: string;
  /**
   * A list of chat completion choices. Can contain more than one elements if n is greater than 1. Can also be empty for the last chunk if you set stream_options: {"include_usage": true}.
   */
  choices: Array<CreateChatCompletionRouterChatCompletionsChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created: number;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateChatCompletionRouterChatCompletionsUsage | null | undefined;
  object: CreateChatCompletionRouterChatCompletionsObject;
};

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionRouterChatCompletionsResponseBody = {
  /**
   * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
   */
  data?: CreateChatCompletionData | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export const CreateChatCompletionRouterChatCompletionsResponseType = {
  Function: "function",
} as const;
export type CreateChatCompletionRouterChatCompletionsResponseType = ClosedEnum<
  typeof CreateChatCompletionRouterChatCompletionsResponseType
>;

export type CreateChatCompletionRouterChatCompletionsFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionToolCalls = {
  index?: number | undefined;
  id?: string | undefined;
  type?: CreateChatCompletionRouterChatCompletionsResponseType | undefined;
  function?: CreateChatCompletionRouterChatCompletionsFunction | undefined;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export const CreateChatCompletionRole = {
  Assistant: "assistant",
} as const;
export type CreateChatCompletionRole = ClosedEnum<
  typeof CreateChatCompletionRole
>;

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model.
 */
export type CreateChatCompletionRouterChatCompletionsAudio = {
  id: string;
  expiresAt: number;
  data: string;
  transcript: string;
};

/**
 * A chat completion message generated by the model.
 */
export type CreateChatCompletionMessage = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?: Array<CreateChatCompletionToolCalls> | undefined;
  role?: CreateChatCompletionRole | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | null | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | null | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * If the audio output modality is requested, this object contains data about the audio response from the model.
   */
  audio?: CreateChatCompletionRouterChatCompletionsAudio | null | undefined;
};

export type TopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<TopLogprobs>;
};

export type CreateChatCompletionTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type Refusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<CreateChatCompletionTopLogprobs>;
};

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<CreateChatCompletionContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<Refusal> | null;
};

export type CreateChatCompletionChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: FinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index: number;
  /**
   * A chat completion message generated by the model.
   */
  message: CreateChatCompletionMessage;
  /**
   * Log probability information for the choice.
   */
  logprobs?: Logprobs | null | undefined;
};

export type CreateChatCompletionPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateChatCompletionCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateChatCompletionUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | CreateChatCompletionPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | CreateChatCompletionCompletionTokensDetails
    | null
    | undefined;
};

export const CreateChatCompletionObject = {
  ChatCompletion: "chat.completion",
} as const;
export type CreateChatCompletionObject = ClosedEnum<
  typeof CreateChatCompletionObject
>;

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionResponseBody = {
  /**
   * A unique identifier for the chat completion.
   */
  id: string;
  /**
   * A list of chat completion choices. Can be more than one if n is greater than 1.
   */
  choices: Array<CreateChatCompletionChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created: number;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateChatCompletionUsage | null | undefined;
  object: CreateChatCompletionObject;
};

export type CreateChatCompletionResponse =
  | CreateChatCompletionResponseBody
  | EventStream<CreateChatCompletionRouterChatCompletionsResponseBody>;

/** @internal */
export type CreateChatCompletionContentRouterChatCompletionsRequest2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const CreateChatCompletionContentRouterChatCompletionsRequest2$outboundSchema:
  z.ZodType<
    CreateChatCompletionContentRouterChatCompletionsRequest2$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionContentRouterChatCompletionsRequest2
  > = components.TextContentPartSchema$outboundSchema;

export function createChatCompletionContentRouterChatCompletionsRequest2ToJSON(
  createChatCompletionContentRouterChatCompletionsRequest2:
    CreateChatCompletionContentRouterChatCompletionsRequest2,
): string {
  return JSON.stringify(
    CreateChatCompletionContentRouterChatCompletionsRequest2$outboundSchema
      .parse(createChatCompletionContentRouterChatCompletionsRequest2),
  );
}

/** @internal */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function createChatCompletionMessagesRouterChatCompletionsRequestRequestBody5ContentToJSON(
  createChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content:
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content$outboundSchema
      .parse(
        createChatCompletionMessagesRouterChatCompletionsRequestRequestBody5Content,
      ),
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterChatCompletionsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateChatCompletionMessagesRouterChatCompletionsType
  > = z.nativeEnum(CreateChatCompletionMessagesRouterChatCompletionsType);

/** @internal */
export const CreateChatCompletionMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesTtl
> = z.nativeEnum(CreateChatCompletionMessagesTtl);

/** @internal */
export type CreateChatCompletionMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreateChatCompletionMessagesCacheControl$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesCacheControl
> = z.object({
  type: CreateChatCompletionMessagesRouterChatCompletionsType$outboundSchema,
  ttl: CreateChatCompletionMessagesTtl$outboundSchema.default("5m"),
});

export function createChatCompletionMessagesCacheControlToJSON(
  createChatCompletionMessagesCacheControl:
    CreateChatCompletionMessagesCacheControl,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesCacheControl$outboundSchema.parse(
      createChatCompletionMessagesCacheControl,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: CreateChatCompletionMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesToolMessage$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolMessage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() =>
    CreateChatCompletionMessagesCacheControl$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function createChatCompletionMessagesToolMessageToJSON(
  createChatCompletionMessagesToolMessage:
    CreateChatCompletionMessagesToolMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesToolMessage$outboundSchema.parse(
      createChatCompletionMessagesToolMessage,
    ),
  );
}

/** @internal */
export type CreateChatCompletionContentRouterChatCompletions2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const CreateChatCompletionContentRouterChatCompletions2$outboundSchema:
  z.ZodType<
    CreateChatCompletionContentRouterChatCompletions2$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionContentRouterChatCompletions2
  > = z.union([
    components.TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.RefusalPartSchema$outboundSchema,
    components.ReasoningPartSchema$outboundSchema,
    components.RedactedReasoningPartSchema$outboundSchema,
  ]);

export function createChatCompletionContentRouterChatCompletions2ToJSON(
  createChatCompletionContentRouterChatCompletions2:
    CreateChatCompletionContentRouterChatCompletions2,
): string {
  return JSON.stringify(
    CreateChatCompletionContentRouterChatCompletions2$outboundSchema.parse(
      createChatCompletionContentRouterChatCompletions2,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function createChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContentToJSON(
  createChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent:
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent$outboundSchema
      .parse(
        createChatCompletionMessagesRouterChatCompletionsRequestRequestBodyContent,
      ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const CreateChatCompletionMessagesAudio$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesAudio
> = z.object({
  id: z.string(),
});

export function createChatCompletionMessagesAudioToJSON(
  createChatCompletionMessagesAudio: CreateChatCompletionMessagesAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesAudio$outboundSchema.parse(
      createChatCompletionMessagesAudio,
    ),
  );
}

/** @internal */
export const CreateChatCompletionMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesType
> = z.nativeEnum(CreateChatCompletionMessagesType);

/** @internal */
export type CreateChatCompletionMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesFunction$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function createChatCompletionMessagesFunctionToJSON(
  createChatCompletionMessagesFunction: CreateChatCompletionMessagesFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesFunction$outboundSchema.parse(
      createChatCompletionMessagesFunction,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: CreateChatCompletionMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesToolCalls$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesToolCalls
> = z.object({
  id: z.string(),
  type: CreateChatCompletionMessagesType$outboundSchema,
  function: z.lazy(() => CreateChatCompletionMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function createChatCompletionMessagesToolCallsToJSON(
  createChatCompletionMessagesToolCalls: CreateChatCompletionMessagesToolCalls,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesToolCalls$outboundSchema.parse(
      createChatCompletionMessagesToolCalls,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: CreateChatCompletionMessagesAudio$Outbound | null | undefined;
  tool_calls?:
    | Array<CreateChatCompletionMessagesToolCalls$Outbound>
    | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesAssistantMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesAssistantMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesAssistantMessage
  > = z.object({
    content: z.nullable(
      z.union([
        z.string(),
        z.array(
          z.union([
            components.TextContentPartSchema$outboundSchema.and(
              z.object({ type: z.literal("text") }),
            ),
            components.RefusalPartSchema$outboundSchema,
            components.ReasoningPartSchema$outboundSchema,
            components.RedactedReasoningPartSchema$outboundSchema,
          ]),
        ),
      ]),
    ).optional(),
    refusal: z.nullable(z.string()).optional(),
    role: z.literal("assistant"),
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => CreateChatCompletionMessagesAudio$outboundSchema),
    ).optional(),
    toolCalls: z.array(
      z.lazy(() => CreateChatCompletionMessagesToolCalls$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCalls: "tool_calls",
    });
  });

export function createChatCompletionMessagesAssistantMessageToJSON(
  createChatCompletionMessagesAssistantMessage:
    CreateChatCompletionMessagesAssistantMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesAssistantMessage$outboundSchema.parse(
      createChatCompletionMessagesAssistantMessage,
    ),
  );
}

/** @internal */
export const CreateChatCompletion2RouterChatCompletionsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletion2RouterChatCompletionsType> = z
    .nativeEnum(CreateChatCompletion2RouterChatCompletionsType);

/** @internal */
export const CreateChatCompletion2Ttl$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletion2Ttl
> = z.nativeEnum(CreateChatCompletion2Ttl);

/** @internal */
export type CreateChatCompletion2CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreateChatCompletion2CacheControl$outboundSchema: z.ZodType<
  CreateChatCompletion2CacheControl$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion2CacheControl
> = z.object({
  type: CreateChatCompletion2RouterChatCompletionsType$outboundSchema,
  ttl: CreateChatCompletion2Ttl$outboundSchema.default("5m"),
});

export function createChatCompletion2CacheControlToJSON(
  createChatCompletion2CacheControl: CreateChatCompletion2CacheControl,
): string {
  return JSON.stringify(
    CreateChatCompletion2CacheControl$outboundSchema.parse(
      createChatCompletion2CacheControl,
    ),
  );
}

/** @internal */
export type CreateChatCompletion24$Outbound = {
  type: "file";
  cache_control?: CreateChatCompletion2CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const CreateChatCompletion24$outboundSchema: z.ZodType<
  CreateChatCompletion24$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion24
> = z.object({
  type: z.literal("file"),
  cacheControl: z.lazy(() => CreateChatCompletion2CacheControl$outboundSchema)
    .optional(),
  file: components.FileContentPartSchema$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    cacheControl: "cache_control",
  });
});

export function createChatCompletion24ToJSON(
  createChatCompletion24: CreateChatCompletion24,
): string {
  return JSON.stringify(
    CreateChatCompletion24$outboundSchema.parse(createChatCompletion24),
  );
}

/** @internal */
export type CreateChatCompletionContent2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | CreateChatCompletion24$Outbound;

/** @internal */
export const CreateChatCompletionContent2$outboundSchema: z.ZodType<
  CreateChatCompletionContent2$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContent2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => CreateChatCompletion24$outboundSchema),
]);

export function createChatCompletionContent2ToJSON(
  createChatCompletionContent2: CreateChatCompletionContent2,
): string {
  return JSON.stringify(
    CreateChatCompletionContent2$outboundSchema.parse(
      createChatCompletionContent2,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesRouterChatCompletionsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | CreateChatCompletion24$Outbound
  >;

/** @internal */
export const CreateChatCompletionMessagesRouterChatCompletionsRequestContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterChatCompletionsRequestContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterChatCompletionsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => CreateChatCompletion24$outboundSchema),
      ]),
    ),
  ]);

export function createChatCompletionMessagesRouterChatCompletionsRequestContentToJSON(
  createChatCompletionMessagesRouterChatCompletionsRequestContent:
    CreateChatCompletionMessagesRouterChatCompletionsRequestContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterChatCompletionsRequestContent$outboundSchema
      .parse(createChatCompletionMessagesRouterChatCompletionsRequestContent),
  );
}

/** @internal */
export type CreateChatCompletionMessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | CreateChatCompletion24$Outbound
    >;
};

/** @internal */
export const CreateChatCompletionMessagesUserMessage$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesUserMessage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => CreateChatCompletion24$outboundSchema),
      ]),
    ),
  ]),
});

export function createChatCompletionMessagesUserMessageToJSON(
  createChatCompletionMessagesUserMessage:
    CreateChatCompletionMessagesUserMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesUserMessage$outboundSchema.parse(
      createChatCompletionMessagesUserMessage,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesRouterChatCompletionsContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesRouterChatCompletionsContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterChatCompletionsContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterChatCompletionsContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function createChatCompletionMessagesRouterChatCompletionsContentToJSON(
  createChatCompletionMessagesRouterChatCompletionsContent:
    CreateChatCompletionMessagesRouterChatCompletionsContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterChatCompletionsContent$outboundSchema
      .parse(createChatCompletionMessagesRouterChatCompletionsContent),
  );
}

/** @internal */
export type CreateChatCompletionMessagesDeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesDeveloperMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesDeveloperMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesDeveloperMessage
  > = z.object({
    role: z.literal("developer"),
    content: z.union([
      z.string(),
      z.array(components.TextContentPartSchema$outboundSchema),
    ]),
    name: z.string().optional(),
  });

export function createChatCompletionMessagesDeveloperMessageToJSON(
  createChatCompletionMessagesDeveloperMessage:
    CreateChatCompletionMessagesDeveloperMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesDeveloperMessage$outboundSchema.parse(
      createChatCompletionMessagesDeveloperMessage,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesContent$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesContent$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function createChatCompletionMessagesContentToJSON(
  createChatCompletionMessagesContent: CreateChatCompletionMessagesContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesContent$outboundSchema.parse(
      createChatCompletionMessagesContent,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesSystemMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesSystemMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesSystemMessage
  > = z.object({
    role: z.literal("system"),
    content: z.union([
      z.string(),
      z.array(components.TextContentPartSchema$outboundSchema),
    ]),
    name: z.string().optional(),
  });

export function createChatCompletionMessagesSystemMessageToJSON(
  createChatCompletionMessagesSystemMessage:
    CreateChatCompletionMessagesSystemMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesSystemMessage$outboundSchema.parse(
      createChatCompletionMessagesSystemMessage,
    ),
  );
}

/** @internal */
export type CreateChatCompletionMessages$Outbound =
  | CreateChatCompletionMessagesSystemMessage$Outbound
  | CreateChatCompletionMessagesDeveloperMessage$Outbound
  | CreateChatCompletionMessagesUserMessage$Outbound
  | CreateChatCompletionMessagesAssistantMessage$Outbound
  | CreateChatCompletionMessagesToolMessage$Outbound;

/** @internal */
export const CreateChatCompletionMessages$outboundSchema: z.ZodType<
  CreateChatCompletionMessages$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessages
> = z.union([
  z.lazy(() => CreateChatCompletionMessagesSystemMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesDeveloperMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesUserMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesAssistantMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesToolMessage$outboundSchema),
]);

export function createChatCompletionMessagesToJSON(
  createChatCompletionMessages: CreateChatCompletionMessages,
): string {
  return JSON.stringify(
    CreateChatCompletionMessages$outboundSchema.parse(
      createChatCompletionMessages,
    ),
  );
}

/** @internal */
export const CreateChatCompletionVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionVoice
> = z.nativeEnum(CreateChatCompletionVoice);

/** @internal */
export const CreateChatCompletionFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFormat
> = z.nativeEnum(CreateChatCompletionFormat);

/** @internal */
export type CreateChatCompletionAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateChatCompletionAudio$outboundSchema: z.ZodType<
  CreateChatCompletionAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAudio
> = z.object({
  voice: CreateChatCompletionVoice$outboundSchema,
  format: CreateChatCompletionFormat$outboundSchema,
});

export function createChatCompletionAudioToJSON(
  createChatCompletionAudio: CreateChatCompletionAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionAudio$outboundSchema.parse(createChatCompletionAudio),
  );
}

/** @internal */
export type CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createChatCompletionResponseFormatRouterChatCompletionsJsonSchemaToJSON(
  createChatCompletionResponseFormatRouterChatCompletionsJsonSchema:
    CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$outboundSchema
      .parse(createChatCompletionResponseFormatRouterChatCompletionsJsonSchema),
  );
}

/** @internal */
export type CreateChatCompletionResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$Outbound;
};

/** @internal */
export const CreateChatCompletionResponseFormatJSONSchema$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateChatCompletionResponseFormatRouterChatCompletionsJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createChatCompletionResponseFormatJSONSchemaToJSON(
  createChatCompletionResponseFormatJSONSchema:
    CreateChatCompletionResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatJSONSchema$outboundSchema.parse(
      createChatCompletionResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type CreateChatCompletionResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CreateChatCompletionResponseFormatJSONObject$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONObject$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function createChatCompletionResponseFormatJSONObjectToJSON(
  createChatCompletionResponseFormatJSONObject:
    CreateChatCompletionResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatJSONObject$outboundSchema.parse(
      createChatCompletionResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type CreateChatCompletionResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const CreateChatCompletionResponseFormatText$outboundSchema: z.ZodType<
  CreateChatCompletionResponseFormatText$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function createChatCompletionResponseFormatTextToJSON(
  createChatCompletionResponseFormatText:
    CreateChatCompletionResponseFormatText,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatText$outboundSchema.parse(
      createChatCompletionResponseFormatText,
    ),
  );
}

/** @internal */
export type CreateChatCompletionResponseFormat$Outbound =
  | CreateChatCompletionResponseFormatText$Outbound
  | CreateChatCompletionResponseFormatJSONObject$Outbound
  | CreateChatCompletionResponseFormatJSONSchema$Outbound;

/** @internal */
export const CreateChatCompletionResponseFormat$outboundSchema: z.ZodType<
  CreateChatCompletionResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponseFormat
> = z.union([
  z.lazy(() => CreateChatCompletionResponseFormatText$outboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONObject$outboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$outboundSchema),
]);

export function createChatCompletionResponseFormatToJSON(
  createChatCompletionResponseFormat: CreateChatCompletionResponseFormat,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormat$outboundSchema.parse(
      createChatCompletionResponseFormat,
    ),
  );
}

/** @internal */
export const CreateChatCompletionReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionReasoningEffort> = z.nativeEnum(
    CreateChatCompletionReasoningEffort,
  );

/** @internal */
export type CreateChatCompletionStop$Outbound = string | Array<string>;

/** @internal */
export const CreateChatCompletionStop$outboundSchema: z.ZodType<
  CreateChatCompletionStop$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionStop
> = z.union([z.string(), z.array(z.string())]);

export function createChatCompletionStopToJSON(
  createChatCompletionStop: CreateChatCompletionStop,
): string {
  return JSON.stringify(
    CreateChatCompletionStop$outboundSchema.parse(createChatCompletionStop),
  );
}

/** @internal */
export type CreateChatCompletionStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionStreamOptions$outboundSchema: z.ZodType<
  CreateChatCompletionStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createChatCompletionStreamOptionsToJSON(
  createChatCompletionStreamOptions: CreateChatCompletionStreamOptions,
): string {
  return JSON.stringify(
    CreateChatCompletionStreamOptions$outboundSchema.parse(
      createChatCompletionStreamOptions,
    ),
  );
}

/** @internal */
export type CreateChatCompletionThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const CreateChatCompletionThinking$outboundSchema: z.ZodType<
  CreateChatCompletionThinking$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function createChatCompletionThinkingToJSON(
  createChatCompletionThinking: CreateChatCompletionThinking,
): string {
  return JSON.stringify(
    CreateChatCompletionThinking$outboundSchema.parse(
      createChatCompletionThinking,
    ),
  );
}

/** @internal */
export const CreateChatCompletionType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionType
> = z.nativeEnum(CreateChatCompletionType);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterChatCompletionsType> = z
    .nativeEnum(CreateChatCompletionRouterChatCompletionsType);

/** @internal */
export type CreateChatCompletionParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionParameters$outboundSchema: z.ZodType<
  CreateChatCompletionParameters$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionParameters
> = z.object({
  type: CreateChatCompletionRouterChatCompletionsType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});

export function createChatCompletionParametersToJSON(
  createChatCompletionParameters: CreateChatCompletionParameters,
): string {
  return JSON.stringify(
    CreateChatCompletionParameters$outboundSchema.parse(
      createChatCompletionParameters,
    ),
  );
}

/** @internal */
export type CreateChatCompletionFunction$Outbound = {
  name: string;
  description?: string | undefined;
  parameters?: CreateChatCompletionParameters$Outbound | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionFunction$outboundSchema: z.ZodType<
  CreateChatCompletionFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.lazy(() => CreateChatCompletionParameters$outboundSchema)
    .optional(),
  strict: z.boolean().optional(),
});

export function createChatCompletionFunctionToJSON(
  createChatCompletionFunction: CreateChatCompletionFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionFunction$outboundSchema.parse(
      createChatCompletionFunction,
    ),
  );
}

/** @internal */
export type CreateChatCompletionTools$Outbound = {
  type?: string | undefined;
  function: CreateChatCompletionFunction$Outbound;
};

/** @internal */
export const CreateChatCompletionTools$outboundSchema: z.ZodType<
  CreateChatCompletionTools$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionTools
> = z.object({
  type: CreateChatCompletionType$outboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionFunction$outboundSchema),
});

export function createChatCompletionToolsToJSON(
  createChatCompletionTools: CreateChatCompletionTools,
): string {
  return JSON.stringify(
    CreateChatCompletionTools$outboundSchema.parse(createChatCompletionTools),
  );
}

/** @internal */
export const CreateChatCompletionToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoiceType
> = z.nativeEnum(CreateChatCompletionToolChoiceType);

/** @internal */
export type CreateChatCompletionToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateChatCompletionToolChoiceFunction$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function createChatCompletionToolChoiceFunctionToJSON(
  createChatCompletionToolChoiceFunction:
    CreateChatCompletionToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoiceFunction$outboundSchema.parse(
      createChatCompletionToolChoiceFunction,
    ),
  );
}

/** @internal */
export type CreateChatCompletionToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateChatCompletionToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateChatCompletionToolChoice2$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoice2
> = z.object({
  type: CreateChatCompletionToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionToolChoiceFunction$outboundSchema),
});

export function createChatCompletionToolChoice2ToJSON(
  createChatCompletionToolChoice2: CreateChatCompletionToolChoice2,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoice2$outboundSchema.parse(
      createChatCompletionToolChoice2,
    ),
  );
}

/** @internal */
export const CreateChatCompletionToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoice1
> = z.nativeEnum(CreateChatCompletionToolChoice1);

/** @internal */
export type CreateChatCompletionToolChoice$Outbound =
  | CreateChatCompletionToolChoice2$Outbound
  | string;

/** @internal */
export const CreateChatCompletionToolChoice$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoice$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoice
> = z.union([
  z.lazy(() => CreateChatCompletionToolChoice2$outboundSchema),
  CreateChatCompletionToolChoice1$outboundSchema,
]);

export function createChatCompletionToolChoiceToJSON(
  createChatCompletionToolChoice: CreateChatCompletionToolChoice,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoice$outboundSchema.parse(
      createChatCompletionToolChoice,
    ),
  );
}

/** @internal */
export const CreateChatCompletionModalities$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionModalities
> = z.nativeEnum(CreateChatCompletionModalities);

/** @internal */
export const CreateChatCompletionId1$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionId1
> = z.nativeEnum(CreateChatCompletionId1);

/** @internal */
export type CreateChatCompletionId$Outbound = string | string;

/** @internal */
export const CreateChatCompletionId$outboundSchema: z.ZodType<
  CreateChatCompletionId$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionId
> = z.union([CreateChatCompletionId1$outboundSchema, z.string()]);

export function createChatCompletionIdToJSON(
  createChatCompletionId: CreateChatCompletionId,
): string {
  return JSON.stringify(
    CreateChatCompletionId$outboundSchema.parse(createChatCompletionId),
  );
}

/** @internal */
export const CreateChatCompletionExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionExecuteOn
> = z.nativeEnum(CreateChatCompletionExecuteOn);

/** @internal */
export type CreateChatCompletionGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const CreateChatCompletionGuardrails$outboundSchema: z.ZodType<
  CreateChatCompletionGuardrails$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionGuardrails
> = z.object({
  id: z.union([CreateChatCompletionId1$outboundSchema, z.string()]),
  executeOn: CreateChatCompletionExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function createChatCompletionGuardrailsToJSON(
  createChatCompletionGuardrails: CreateChatCompletionGuardrails,
): string {
  return JSON.stringify(
    CreateChatCompletionGuardrails$outboundSchema.parse(
      createChatCompletionGuardrails,
    ),
  );
}

/** @internal */
export type CreateChatCompletionFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateChatCompletionFallbacks$outboundSchema: z.ZodType<
  CreateChatCompletionFallbacks$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFallbacks
> = z.object({
  model: z.string(),
});

export function createChatCompletionFallbacksToJSON(
  createChatCompletionFallbacks: CreateChatCompletionFallbacks,
): string {
  return JSON.stringify(
    CreateChatCompletionFallbacks$outboundSchema.parse(
      createChatCompletionFallbacks,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateChatCompletionRetry$outboundSchema: z.ZodType<
  CreateChatCompletionRetry$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createChatCompletionRetryToJSON(
  createChatCompletionRetry: CreateChatCompletionRetry,
): string {
  return JSON.stringify(
    CreateChatCompletionRetry$outboundSchema.parse(createChatCompletionRetry),
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterChatCompletionsRequestType> =
    z.nativeEnum(CreateChatCompletionRouterChatCompletionsRequestType);

/** @internal */
export type CreateChatCompletionCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateChatCompletionCache$outboundSchema: z.ZodType<
  CreateChatCompletionCache$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateChatCompletionRouterChatCompletionsRequestType$outboundSchema,
});

export function createChatCompletionCacheToJSON(
  createChatCompletionCache: CreateChatCompletionCache,
): string {
  return JSON.stringify(
    CreateChatCompletionCache$outboundSchema.parse(createChatCompletionCache),
  );
}

/** @internal */
export const CreateChatCompletionLoadBalancerType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionLoadBalancerType> = z.nativeEnum(
    CreateChatCompletionLoadBalancerType,
  );

/** @internal */
export type CreateChatCompletionLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateChatCompletionLoadBalancerModels$outboundSchema: z.ZodType<
  CreateChatCompletionLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createChatCompletionLoadBalancerModelsToJSON(
  createChatCompletionLoadBalancerModels:
    CreateChatCompletionLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateChatCompletionLoadBalancerModels$outboundSchema.parse(
      createChatCompletionLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateChatCompletionLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateChatCompletionLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateChatCompletionLoadBalancer1$outboundSchema: z.ZodType<
  CreateChatCompletionLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionLoadBalancer1
> = z.object({
  type: CreateChatCompletionLoadBalancerType$outboundSchema,
  models: z.array(
    z.lazy(() => CreateChatCompletionLoadBalancerModels$outboundSchema),
  ),
});

export function createChatCompletionLoadBalancer1ToJSON(
  createChatCompletionLoadBalancer1: CreateChatCompletionLoadBalancer1,
): string {
  return JSON.stringify(
    CreateChatCompletionLoadBalancer1$outboundSchema.parse(
      createChatCompletionLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateChatCompletionLoadBalancer$Outbound =
  CreateChatCompletionLoadBalancer1$Outbound;

/** @internal */
export const CreateChatCompletionLoadBalancer$outboundSchema: z.ZodType<
  CreateChatCompletionLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionLoadBalancer
> = z.lazy(() => CreateChatCompletionLoadBalancer1$outboundSchema);

export function createChatCompletionLoadBalancerToJSON(
  createChatCompletionLoadBalancer: CreateChatCompletionLoadBalancer,
): string {
  return JSON.stringify(
    CreateChatCompletionLoadBalancer$outboundSchema.parse(
      createChatCompletionLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateChatCompletionTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateChatCompletionTimeout$outboundSchema: z.ZodType<
  CreateChatCompletionTimeout$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createChatCompletionTimeoutToJSON(
  createChatCompletionTimeout: CreateChatCompletionTimeout,
): string {
  return JSON.stringify(
    CreateChatCompletionTimeout$outboundSchema.parse(
      createChatCompletionTimeout,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRouterChatCompletionsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateChatCompletionRouterChatCompletionsRetry$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsRetry$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterChatCompletionsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function createChatCompletionRouterChatCompletionsRetryToJSON(
  createChatCompletionRouterChatCompletionsRetry:
    CreateChatCompletionRouterChatCompletionsRetry,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChatCompletionsRetry$outboundSchema.parse(
      createChatCompletionRouterChatCompletionsRetry,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRouterChatCompletionsFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateChatCompletionRouterChatCompletionsFallbacks$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsFallbacks$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterChatCompletionsFallbacks
  > = z.object({
    model: z.string(),
  });

export function createChatCompletionRouterChatCompletionsFallbacksToJSON(
  createChatCompletionRouterChatCompletionsFallbacks:
    CreateChatCompletionRouterChatCompletionsFallbacks,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChatCompletionsFallbacks$outboundSchema.parse(
      createChatCompletionRouterChatCompletionsFallbacks,
    ),
  );
}

/** @internal */
export const Version$outboundSchema: z.ZodNativeEnum<typeof Version> = z
  .nativeEnum(Version);

/** @internal */
export type Prompt$Outbound = {
  id: string;
  version: string;
};

/** @internal */
export const Prompt$outboundSchema: z.ZodType<
  Prompt$Outbound,
  z.ZodTypeDef,
  Prompt
> = z.object({
  id: z.string(),
  version: Version$outboundSchema,
});

export function promptToJSON(prompt: Prompt): string {
  return JSON.stringify(Prompt$outboundSchema.parse(prompt));
}

/** @internal */
export type CreateChatCompletionContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateChatCompletionContact$outboundSchema: z.ZodType<
  CreateChatCompletionContact$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createChatCompletionContactToJSON(
  createChatCompletionContact: CreateChatCompletionContact,
): string {
  return JSON.stringify(
    CreateChatCompletionContact$outboundSchema.parse(
      createChatCompletionContact,
    ),
  );
}

/** @internal */
export type CreateChatCompletionThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateChatCompletionThread$outboundSchema: z.ZodType<
  CreateChatCompletionThread$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createChatCompletionThreadToJSON(
  createChatCompletionThread: CreateChatCompletionThread,
): string {
  return JSON.stringify(
    CreateChatCompletionThread$outboundSchema.parse(createChatCompletionThread),
  );
}

/** @internal */
export type Inputs2$Outbound = {
  key: string;
  value?: any | undefined;
  is_pii?: boolean | undefined;
};

/** @internal */
export const Inputs2$outboundSchema: z.ZodType<
  Inputs2$Outbound,
  z.ZodTypeDef,
  Inputs2
> = z.object({
  key: z.string(),
  value: z.any().optional(),
  isPii: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    isPii: "is_pii",
  });
});

export function inputs2ToJSON(inputs2: Inputs2): string {
  return JSON.stringify(Inputs2$outboundSchema.parse(inputs2));
}

/** @internal */
export type Inputs$Outbound = { [k: string]: any } | Array<Inputs2$Outbound>;

/** @internal */
export const Inputs$outboundSchema: z.ZodType<
  Inputs$Outbound,
  z.ZodTypeDef,
  Inputs
> = z.union([z.record(z.any()), z.array(z.lazy(() => Inputs2$outboundSchema))]);

export function inputsToJSON(inputs: Inputs): string {
  return JSON.stringify(Inputs$outboundSchema.parse(inputs));
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateChatCompletionRouterChatCompletionsRequestRequestBodyType
  > = z.nativeEnum(
    CreateChatCompletionRouterChatCompletionsRequestRequestBodyType,
  );

/** @internal */
export type CreateChatCompletionRouterChatCompletionsCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateChatCompletionRouterChatCompletionsCache$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsCache$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterChatCompletionsCache
  > = z.object({
    ttl: z.number().default(1800),
    type:
      CreateChatCompletionRouterChatCompletionsRequestRequestBodyType$outboundSchema,
  });

export function createChatCompletionRouterChatCompletionsCacheToJSON(
  createChatCompletionRouterChatCompletionsCache:
    CreateChatCompletionRouterChatCompletionsCache,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChatCompletionsCache$outboundSchema.parse(
      createChatCompletionRouterChatCompletionsCache,
    ),
  );
}

/** @internal */
export const CreateChatCompletionSearchType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionSearchType
> = z.nativeEnum(CreateChatCompletionSearchType);

/** @internal */
export type CreateChatCompletionOrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletionOrExists$outboundSchema: z.ZodType<
  CreateChatCompletionOrExists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrExists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletionOrExistsToJSON(
  createChatCompletionOrExists: CreateChatCompletionOrExists,
): string {
  return JSON.stringify(
    CreateChatCompletionOrExists$outboundSchema.parse(
      createChatCompletionOrExists,
    ),
  );
}

/** @internal */
export type CreateChatCompletionOrRouterChatCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionOrRouterChatCompletionsNin$outboundSchema:
  z.ZodType<
    CreateChatCompletionOrRouterChatCompletionsNin$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionOrRouterChatCompletionsNin
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterChatCompletionsNinToJSON(
  createChatCompletionOrRouterChatCompletionsNin:
    CreateChatCompletionOrRouterChatCompletionsNin,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterChatCompletionsNin$outboundSchema.parse(
      createChatCompletionOrRouterChatCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateChatCompletionOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionOrNin$outboundSchema: z.ZodType<
  CreateChatCompletionOrNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionOrNinToJSON(
  createChatCompletionOrNin: CreateChatCompletionOrNin,
): string {
  return JSON.stringify(
    CreateChatCompletionOrNin$outboundSchema.parse(createChatCompletionOrNin),
  );
}

/** @internal */
export type CreateChatCompletionOrRouterChatCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionOrRouterChatCompletionsIn$outboundSchema:
  z.ZodType<
    CreateChatCompletionOrRouterChatCompletionsIn$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionOrRouterChatCompletionsIn
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterChatCompletionsInToJSON(
  createChatCompletionOrRouterChatCompletionsIn:
    CreateChatCompletionOrRouterChatCompletionsIn,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterChatCompletionsIn$outboundSchema.parse(
      createChatCompletionOrRouterChatCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateChatCompletionOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionOrIn$outboundSchema: z.ZodType<
  CreateChatCompletionOrIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionOrInToJSON(
  createChatCompletionOrIn: CreateChatCompletionOrIn,
): string {
  return JSON.stringify(
    CreateChatCompletionOrIn$outboundSchema.parse(createChatCompletionOrIn),
  );
}

/** @internal */
export type CreateChatCompletionOrLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletionOrLte$outboundSchema: z.ZodType<
  CreateChatCompletionOrLte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrLte
> = z.object({
  lte: z.number(),
});

export function createChatCompletionOrLteToJSON(
  createChatCompletionOrLte: CreateChatCompletionOrLte,
): string {
  return JSON.stringify(
    CreateChatCompletionOrLte$outboundSchema.parse(createChatCompletionOrLte),
  );
}

/** @internal */
export type CreateChatCompletionOrLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletionOrLt$outboundSchema: z.ZodType<
  CreateChatCompletionOrLt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrLt
> = z.object({
  lt: z.number(),
});

export function createChatCompletionOrLtToJSON(
  createChatCompletionOrLt: CreateChatCompletionOrLt,
): string {
  return JSON.stringify(
    CreateChatCompletionOrLt$outboundSchema.parse(createChatCompletionOrLt),
  );
}

/** @internal */
export type CreateChatCompletionOrGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletionOrGte$outboundSchema: z.ZodType<
  CreateChatCompletionOrGte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrGte
> = z.object({
  gte: z.number(),
});

export function createChatCompletionOrGteToJSON(
  createChatCompletionOrGte: CreateChatCompletionOrGte,
): string {
  return JSON.stringify(
    CreateChatCompletionOrGte$outboundSchema.parse(createChatCompletionOrGte),
  );
}

/** @internal */
export type CreateChatCompletionOrGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletionOrGt$outboundSchema: z.ZodType<
  CreateChatCompletionOrGt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrGt
> = z.object({
  gt: z.number(),
});

export function createChatCompletionOrGtToJSON(
  createChatCompletionOrGt: CreateChatCompletionOrGt,
): string {
  return JSON.stringify(
    CreateChatCompletionOrGt$outboundSchema.parse(createChatCompletionOrGt),
  );
}

/** @internal */
export type CreateChatCompletionOrRouterChatCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionOrRouterChatCompletionsNe$outboundSchema:
  z.ZodType<
    CreateChatCompletionOrRouterChatCompletionsNe$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionOrRouterChatCompletionsNe
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterChatCompletionsNeToJSON(
  createChatCompletionOrRouterChatCompletionsNe:
    CreateChatCompletionOrRouterChatCompletionsNe,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterChatCompletionsNe$outboundSchema.parse(
      createChatCompletionOrRouterChatCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateChatCompletionOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionOrNe$outboundSchema: z.ZodType<
  CreateChatCompletionOrNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionOrNeToJSON(
  createChatCompletionOrNe: CreateChatCompletionOrNe,
): string {
  return JSON.stringify(
    CreateChatCompletionOrNe$outboundSchema.parse(createChatCompletionOrNe),
  );
}

/** @internal */
export type CreateChatCompletionOrRouterChatCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionOrRouterChatCompletionsEq$outboundSchema:
  z.ZodType<
    CreateChatCompletionOrRouterChatCompletionsEq$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionOrRouterChatCompletionsEq
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterChatCompletionsEqToJSON(
  createChatCompletionOrRouterChatCompletionsEq:
    CreateChatCompletionOrRouterChatCompletionsEq,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterChatCompletionsEq$outboundSchema.parse(
      createChatCompletionOrRouterChatCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateChatCompletionOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionOrEq$outboundSchema: z.ZodType<
  CreateChatCompletionOrEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionOrEqToJSON(
  createChatCompletionOrEq: CreateChatCompletionOrEq,
): string {
  return JSON.stringify(
    CreateChatCompletionOrEq$outboundSchema.parse(createChatCompletionOrEq),
  );
}

/** @internal */
export type CreateChatCompletionFilterByRouterChatCompletionsOr$Outbound =
  | CreateChatCompletionOrEq$Outbound
  | CreateChatCompletionOrNe$Outbound
  | CreateChatCompletionOrGt$Outbound
  | CreateChatCompletionOrGte$Outbound
  | CreateChatCompletionOrLt$Outbound
  | CreateChatCompletionOrLte$Outbound
  | CreateChatCompletionOrIn$Outbound
  | CreateChatCompletionOrNin$Outbound
  | CreateChatCompletionOrExists$Outbound;

/** @internal */
export const CreateChatCompletionFilterByRouterChatCompletionsOr$outboundSchema:
  z.ZodType<
    CreateChatCompletionFilterByRouterChatCompletionsOr$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionFilterByRouterChatCompletionsOr
  > = z.union([
    z.lazy(() => CreateChatCompletionOrEq$outboundSchema),
    z.lazy(() => CreateChatCompletionOrNe$outboundSchema),
    z.lazy(() => CreateChatCompletionOrGt$outboundSchema),
    z.lazy(() => CreateChatCompletionOrGte$outboundSchema),
    z.lazy(() => CreateChatCompletionOrLt$outboundSchema),
    z.lazy(() => CreateChatCompletionOrLte$outboundSchema),
    z.lazy(() => CreateChatCompletionOrIn$outboundSchema),
    z.lazy(() => CreateChatCompletionOrNin$outboundSchema),
    z.lazy(() => CreateChatCompletionOrExists$outboundSchema),
  ]);

export function createChatCompletionFilterByRouterChatCompletionsOrToJSON(
  createChatCompletionFilterByRouterChatCompletionsOr:
    CreateChatCompletionFilterByRouterChatCompletionsOr,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByRouterChatCompletionsOr$outboundSchema.parse(
      createChatCompletionFilterByRouterChatCompletionsOr,
    ),
  );
}

/** @internal */
export type CreateChatCompletionFilterByOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | CreateChatCompletionOrEq$Outbound
        | CreateChatCompletionOrNe$Outbound
        | CreateChatCompletionOrGt$Outbound
        | CreateChatCompletionOrGte$Outbound
        | CreateChatCompletionOrLt$Outbound
        | CreateChatCompletionOrLte$Outbound
        | CreateChatCompletionOrIn$Outbound
        | CreateChatCompletionOrNin$Outbound
        | CreateChatCompletionOrExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateChatCompletionFilterByOr$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByOr$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionOrEq$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionOrNe$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionOrGt$outboundSchema),
      z.lazy(() => CreateChatCompletionOrGte$outboundSchema),
      z.lazy(() => CreateChatCompletionOrLt$outboundSchema),
      z.lazy(() => CreateChatCompletionOrLte$outboundSchema),
      z.lazy(() => CreateChatCompletionOrIn$outboundSchema),
      z.lazy(() => CreateChatCompletionOrNin$outboundSchema),
      z.lazy(() => CreateChatCompletionOrExists$outboundSchema),
    ])),
  ),
});

export function createChatCompletionFilterByOrToJSON(
  createChatCompletionFilterByOr: CreateChatCompletionFilterByOr,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByOr$outboundSchema.parse(
      createChatCompletionFilterByOr,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletionAndExists$outboundSchema: z.ZodType<
  CreateChatCompletionAndExists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndExists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletionAndExistsToJSON(
  createChatCompletionAndExists: CreateChatCompletionAndExists,
): string {
  return JSON.stringify(
    CreateChatCompletionAndExists$outboundSchema.parse(
      createChatCompletionAndExists,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndRouterChatCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterChatCompletionsNin$outboundSchema:
  z.ZodType<
    CreateChatCompletionAndRouterChatCompletionsNin$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionAndRouterChatCompletionsNin
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterChatCompletionsNinToJSON(
  createChatCompletionAndRouterChatCompletionsNin:
    CreateChatCompletionAndRouterChatCompletionsNin,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterChatCompletionsNin$outboundSchema.parse(
      createChatCompletionAndRouterChatCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionAndNin$outboundSchema: z.ZodType<
  CreateChatCompletionAndNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionAndNinToJSON(
  createChatCompletionAndNin: CreateChatCompletionAndNin,
): string {
  return JSON.stringify(
    CreateChatCompletionAndNin$outboundSchema.parse(createChatCompletionAndNin),
  );
}

/** @internal */
export type CreateChatCompletionAndRouterChatCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterChatCompletionsIn$outboundSchema:
  z.ZodType<
    CreateChatCompletionAndRouterChatCompletionsIn$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionAndRouterChatCompletionsIn
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterChatCompletionsInToJSON(
  createChatCompletionAndRouterChatCompletionsIn:
    CreateChatCompletionAndRouterChatCompletionsIn,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterChatCompletionsIn$outboundSchema.parse(
      createChatCompletionAndRouterChatCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionAndIn$outboundSchema: z.ZodType<
  CreateChatCompletionAndIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionAndInToJSON(
  createChatCompletionAndIn: CreateChatCompletionAndIn,
): string {
  return JSON.stringify(
    CreateChatCompletionAndIn$outboundSchema.parse(createChatCompletionAndIn),
  );
}

/** @internal */
export type CreateChatCompletionAndLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletionAndLte$outboundSchema: z.ZodType<
  CreateChatCompletionAndLte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndLte
> = z.object({
  lte: z.number(),
});

export function createChatCompletionAndLteToJSON(
  createChatCompletionAndLte: CreateChatCompletionAndLte,
): string {
  return JSON.stringify(
    CreateChatCompletionAndLte$outboundSchema.parse(createChatCompletionAndLte),
  );
}

/** @internal */
export type CreateChatCompletionAndLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletionAndLt$outboundSchema: z.ZodType<
  CreateChatCompletionAndLt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndLt
> = z.object({
  lt: z.number(),
});

export function createChatCompletionAndLtToJSON(
  createChatCompletionAndLt: CreateChatCompletionAndLt,
): string {
  return JSON.stringify(
    CreateChatCompletionAndLt$outboundSchema.parse(createChatCompletionAndLt),
  );
}

/** @internal */
export type CreateChatCompletionAndGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletionAndGte$outboundSchema: z.ZodType<
  CreateChatCompletionAndGte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndGte
> = z.object({
  gte: z.number(),
});

export function createChatCompletionAndGteToJSON(
  createChatCompletionAndGte: CreateChatCompletionAndGte,
): string {
  return JSON.stringify(
    CreateChatCompletionAndGte$outboundSchema.parse(createChatCompletionAndGte),
  );
}

/** @internal */
export type CreateChatCompletionAndGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletionAndGt$outboundSchema: z.ZodType<
  CreateChatCompletionAndGt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndGt
> = z.object({
  gt: z.number(),
});

export function createChatCompletionAndGtToJSON(
  createChatCompletionAndGt: CreateChatCompletionAndGt,
): string {
  return JSON.stringify(
    CreateChatCompletionAndGt$outboundSchema.parse(createChatCompletionAndGt),
  );
}

/** @internal */
export type CreateChatCompletionAndRouterChatCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterChatCompletionsNe$outboundSchema:
  z.ZodType<
    CreateChatCompletionAndRouterChatCompletionsNe$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionAndRouterChatCompletionsNe
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterChatCompletionsNeToJSON(
  createChatCompletionAndRouterChatCompletionsNe:
    CreateChatCompletionAndRouterChatCompletionsNe,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterChatCompletionsNe$outboundSchema.parse(
      createChatCompletionAndRouterChatCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionAndNe$outboundSchema: z.ZodType<
  CreateChatCompletionAndNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionAndNeToJSON(
  createChatCompletionAndNe: CreateChatCompletionAndNe,
): string {
  return JSON.stringify(
    CreateChatCompletionAndNe$outboundSchema.parse(createChatCompletionAndNe),
  );
}

/** @internal */
export type CreateChatCompletionAndRouterChatCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterChatCompletionsEq$outboundSchema:
  z.ZodType<
    CreateChatCompletionAndRouterChatCompletionsEq$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionAndRouterChatCompletionsEq
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterChatCompletionsEqToJSON(
  createChatCompletionAndRouterChatCompletionsEq:
    CreateChatCompletionAndRouterChatCompletionsEq,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterChatCompletionsEq$outboundSchema.parse(
      createChatCompletionAndRouterChatCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionAndEq$outboundSchema: z.ZodType<
  CreateChatCompletionAndEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionAndEqToJSON(
  createChatCompletionAndEq: CreateChatCompletionAndEq,
): string {
  return JSON.stringify(
    CreateChatCompletionAndEq$outboundSchema.parse(createChatCompletionAndEq),
  );
}

/** @internal */
export type CreateChatCompletionFilterByRouterChatCompletionsAnd$Outbound =
  | CreateChatCompletionAndEq$Outbound
  | CreateChatCompletionAndNe$Outbound
  | CreateChatCompletionAndGt$Outbound
  | CreateChatCompletionAndGte$Outbound
  | CreateChatCompletionAndLt$Outbound
  | CreateChatCompletionAndLte$Outbound
  | CreateChatCompletionAndIn$Outbound
  | CreateChatCompletionAndNin$Outbound
  | CreateChatCompletionAndExists$Outbound;

/** @internal */
export const CreateChatCompletionFilterByRouterChatCompletionsAnd$outboundSchema:
  z.ZodType<
    CreateChatCompletionFilterByRouterChatCompletionsAnd$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionFilterByRouterChatCompletionsAnd
  > = z.union([
    z.lazy(() => CreateChatCompletionAndEq$outboundSchema),
    z.lazy(() => CreateChatCompletionAndNe$outboundSchema),
    z.lazy(() => CreateChatCompletionAndGt$outboundSchema),
    z.lazy(() => CreateChatCompletionAndGte$outboundSchema),
    z.lazy(() => CreateChatCompletionAndLt$outboundSchema),
    z.lazy(() => CreateChatCompletionAndLte$outboundSchema),
    z.lazy(() => CreateChatCompletionAndIn$outboundSchema),
    z.lazy(() => CreateChatCompletionAndNin$outboundSchema),
    z.lazy(() => CreateChatCompletionAndExists$outboundSchema),
  ]);

export function createChatCompletionFilterByRouterChatCompletionsAndToJSON(
  createChatCompletionFilterByRouterChatCompletionsAnd:
    CreateChatCompletionFilterByRouterChatCompletionsAnd,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByRouterChatCompletionsAnd$outboundSchema.parse(
      createChatCompletionFilterByRouterChatCompletionsAnd,
    ),
  );
}

/** @internal */
export type CreateChatCompletionFilterByAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | CreateChatCompletionAndEq$Outbound
        | CreateChatCompletionAndNe$Outbound
        | CreateChatCompletionAndGt$Outbound
        | CreateChatCompletionAndGte$Outbound
        | CreateChatCompletionAndLt$Outbound
        | CreateChatCompletionAndLte$Outbound
        | CreateChatCompletionAndIn$Outbound
        | CreateChatCompletionAndNin$Outbound
        | CreateChatCompletionAndExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateChatCompletionFilterByAnd$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByAnd$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionAndEq$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionAndNe$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionAndGt$outboundSchema),
      z.lazy(() => CreateChatCompletionAndGte$outboundSchema),
      z.lazy(() => CreateChatCompletionAndLt$outboundSchema),
      z.lazy(() => CreateChatCompletionAndLte$outboundSchema),
      z.lazy(() => CreateChatCompletionAndIn$outboundSchema),
      z.lazy(() => CreateChatCompletionAndNin$outboundSchema),
      z.lazy(() => CreateChatCompletionAndExists$outboundSchema),
    ])),
  ),
});

export function createChatCompletionFilterByAndToJSON(
  createChatCompletionFilterByAnd: CreateChatCompletionFilterByAnd,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByAnd$outboundSchema.parse(
      createChatCompletionFilterByAnd,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletion1Exists$outboundSchema: z.ZodType<
  CreateChatCompletion1Exists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Exists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletion1ExistsToJSON(
  createChatCompletion1Exists: CreateChatCompletion1Exists,
): string {
  return JSON.stringify(
    CreateChatCompletion1Exists$outboundSchema.parse(
      createChatCompletion1Exists,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1RouterChatCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletion1RouterChatCompletionsNin$outboundSchema:
  z.ZodType<
    CreateChatCompletion1RouterChatCompletionsNin$Outbound,
    z.ZodTypeDef,
    CreateChatCompletion1RouterChatCompletionsNin
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterChatCompletionsNinToJSON(
  createChatCompletion1RouterChatCompletionsNin:
    CreateChatCompletion1RouterChatCompletionsNin,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterChatCompletionsNin$outboundSchema.parse(
      createChatCompletion1RouterChatCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletion1Nin$outboundSchema: z.ZodType<
  CreateChatCompletion1Nin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Nin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletion1NinToJSON(
  createChatCompletion1Nin: CreateChatCompletion1Nin,
): string {
  return JSON.stringify(
    CreateChatCompletion1Nin$outboundSchema.parse(createChatCompletion1Nin),
  );
}

/** @internal */
export type CreateChatCompletion1RouterChatCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletion1RouterChatCompletionsIn$outboundSchema:
  z.ZodType<
    CreateChatCompletion1RouterChatCompletionsIn$Outbound,
    z.ZodTypeDef,
    CreateChatCompletion1RouterChatCompletionsIn
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterChatCompletionsInToJSON(
  createChatCompletion1RouterChatCompletionsIn:
    CreateChatCompletion1RouterChatCompletionsIn,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterChatCompletionsIn$outboundSchema.parse(
      createChatCompletion1RouterChatCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletion1In$outboundSchema: z.ZodType<
  CreateChatCompletion1In$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1In
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletion1InToJSON(
  createChatCompletion1In: CreateChatCompletion1In,
): string {
  return JSON.stringify(
    CreateChatCompletion1In$outboundSchema.parse(createChatCompletion1In),
  );
}

/** @internal */
export type CreateChatCompletion1Lte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletion1Lte$outboundSchema: z.ZodType<
  CreateChatCompletion1Lte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Lte
> = z.object({
  lte: z.number(),
});

export function createChatCompletion1LteToJSON(
  createChatCompletion1Lte: CreateChatCompletion1Lte,
): string {
  return JSON.stringify(
    CreateChatCompletion1Lte$outboundSchema.parse(createChatCompletion1Lte),
  );
}

/** @internal */
export type CreateChatCompletion1Lt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletion1Lt$outboundSchema: z.ZodType<
  CreateChatCompletion1Lt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Lt
> = z.object({
  lt: z.number(),
});

export function createChatCompletion1LtToJSON(
  createChatCompletion1Lt: CreateChatCompletion1Lt,
): string {
  return JSON.stringify(
    CreateChatCompletion1Lt$outboundSchema.parse(createChatCompletion1Lt),
  );
}

/** @internal */
export type CreateChatCompletion1Gte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletion1Gte$outboundSchema: z.ZodType<
  CreateChatCompletion1Gte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Gte
> = z.object({
  gte: z.number(),
});

export function createChatCompletion1GteToJSON(
  createChatCompletion1Gte: CreateChatCompletion1Gte,
): string {
  return JSON.stringify(
    CreateChatCompletion1Gte$outboundSchema.parse(createChatCompletion1Gte),
  );
}

/** @internal */
export type CreateChatCompletion1Gt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletion1Gt$outboundSchema: z.ZodType<
  CreateChatCompletion1Gt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Gt
> = z.object({
  gt: z.number(),
});

export function createChatCompletion1GtToJSON(
  createChatCompletion1Gt: CreateChatCompletion1Gt,
): string {
  return JSON.stringify(
    CreateChatCompletion1Gt$outboundSchema.parse(createChatCompletion1Gt),
  );
}

/** @internal */
export type CreateChatCompletion1RouterChatCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletion1RouterChatCompletionsNe$outboundSchema:
  z.ZodType<
    CreateChatCompletion1RouterChatCompletionsNe$Outbound,
    z.ZodTypeDef,
    CreateChatCompletion1RouterChatCompletionsNe
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterChatCompletionsNeToJSON(
  createChatCompletion1RouterChatCompletionsNe:
    CreateChatCompletion1RouterChatCompletionsNe,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterChatCompletionsNe$outboundSchema.parse(
      createChatCompletion1RouterChatCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletion1Ne$outboundSchema: z.ZodType<
  CreateChatCompletion1Ne$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Ne
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletion1NeToJSON(
  createChatCompletion1Ne: CreateChatCompletion1Ne,
): string {
  return JSON.stringify(
    CreateChatCompletion1Ne$outboundSchema.parse(createChatCompletion1Ne),
  );
}

/** @internal */
export type CreateChatCompletion1RouterChatCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletion1RouterChatCompletionsEq$outboundSchema:
  z.ZodType<
    CreateChatCompletion1RouterChatCompletionsEq$Outbound,
    z.ZodTypeDef,
    CreateChatCompletion1RouterChatCompletionsEq
  > = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterChatCompletionsEqToJSON(
  createChatCompletion1RouterChatCompletionsEq:
    CreateChatCompletion1RouterChatCompletionsEq,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterChatCompletionsEq$outboundSchema.parse(
      createChatCompletion1RouterChatCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateChatCompletion1Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletion1Eq$outboundSchema: z.ZodType<
  CreateChatCompletion1Eq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Eq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletion1EqToJSON(
  createChatCompletion1Eq: CreateChatCompletion1Eq,
): string {
  return JSON.stringify(
    CreateChatCompletion1Eq$outboundSchema.parse(createChatCompletion1Eq),
  );
}

/** @internal */
export type CreateChatCompletionFilterBy1$Outbound =
  | CreateChatCompletion1Eq$Outbound
  | CreateChatCompletion1Ne$Outbound
  | CreateChatCompletion1Gt$Outbound
  | CreateChatCompletion1Gte$Outbound
  | CreateChatCompletion1Lt$Outbound
  | CreateChatCompletion1Lte$Outbound
  | CreateChatCompletion1In$Outbound
  | CreateChatCompletion1Nin$Outbound
  | CreateChatCompletion1Exists$Outbound;

/** @internal */
export const CreateChatCompletionFilterBy1$outboundSchema: z.ZodType<
  CreateChatCompletionFilterBy1$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterBy1
> = z.union([
  z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
  z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
  z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
  z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
  z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
  z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
  z.lazy(() => CreateChatCompletion1In$outboundSchema),
  z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
  z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
]);

export function createChatCompletionFilterBy1ToJSON(
  createChatCompletionFilterBy1: CreateChatCompletionFilterBy1,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterBy1$outboundSchema.parse(
      createChatCompletionFilterBy1,
    ),
  );
}

/** @internal */
export type CreateChatCompletionFilterBy$Outbound =
  | CreateChatCompletionFilterByAnd$Outbound
  | CreateChatCompletionFilterByOr$Outbound
  | {
    [k: string]:
      | CreateChatCompletion1Eq$Outbound
      | CreateChatCompletion1Ne$Outbound
      | CreateChatCompletion1Gt$Outbound
      | CreateChatCompletion1Gte$Outbound
      | CreateChatCompletion1Lt$Outbound
      | CreateChatCompletion1Lte$Outbound
      | CreateChatCompletion1In$Outbound
      | CreateChatCompletion1Nin$Outbound
      | CreateChatCompletion1Exists$Outbound;
  };

/** @internal */
export const CreateChatCompletionFilterBy$outboundSchema: z.ZodType<
  CreateChatCompletionFilterBy$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterBy
> = z.union([
  z.lazy(() => CreateChatCompletionFilterByAnd$outboundSchema),
  z.lazy(() => CreateChatCompletionFilterByOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
    z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
    z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
    z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
    z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
    z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
    z.lazy(() => CreateChatCompletion1In$outboundSchema),
    z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
    z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
  ])),
]);

export function createChatCompletionFilterByToJSON(
  createChatCompletionFilterBy: CreateChatCompletionFilterBy,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterBy$outboundSchema.parse(
      createChatCompletionFilterBy,
    ),
  );
}

/** @internal */
export type CreateChatCompletionSearchOptions$Outbound = {
  include_vectors?: boolean | undefined;
  include_metadata?: boolean | undefined;
  include_scores?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionSearchOptions$outboundSchema: z.ZodType<
  CreateChatCompletionSearchOptions$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionSearchOptions
> = z.object({
  includeVectors: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeScores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeVectors: "include_vectors",
    includeMetadata: "include_metadata",
    includeScores: "include_scores",
  });
});

export function createChatCompletionSearchOptionsToJSON(
  createChatCompletionSearchOptions: CreateChatCompletionSearchOptions,
): string {
  return JSON.stringify(
    CreateChatCompletionSearchOptions$outboundSchema.parse(
      createChatCompletionSearchOptions,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRerankConfig$Outbound = {
  model: string;
  threshold: number;
  top_k: number;
};

/** @internal */
export const CreateChatCompletionRerankConfig$outboundSchema: z.ZodType<
  CreateChatCompletionRerankConfig$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRerankConfig
> = z.object({
  model: z.string(),
  threshold: z.number().default(0),
  topK: z.number().int().default(10),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
  });
});

export function createChatCompletionRerankConfigToJSON(
  createChatCompletionRerankConfig: CreateChatCompletionRerankConfig,
): string {
  return JSON.stringify(
    CreateChatCompletionRerankConfig$outboundSchema.parse(
      createChatCompletionRerankConfig,
    ),
  );
}

/** @internal */
export type CreateChatCompletionAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const CreateChatCompletionAgenticRagConfig$outboundSchema: z.ZodType<
  CreateChatCompletionAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function createChatCompletionAgenticRagConfigToJSON(
  createChatCompletionAgenticRagConfig: CreateChatCompletionAgenticRagConfig,
): string {
  return JSON.stringify(
    CreateChatCompletionAgenticRagConfig$outboundSchema.parse(
      createChatCompletionAgenticRagConfig,
    ),
  );
}

/** @internal */
export type CreateChatCompletionKnowledgeBases$Outbound = {
  top_k?: number | undefined;
  threshold?: number | undefined;
  search_type: string;
  filter_by?:
    | CreateChatCompletionFilterByAnd$Outbound
    | CreateChatCompletionFilterByOr$Outbound
    | {
      [k: string]:
        | CreateChatCompletion1Eq$Outbound
        | CreateChatCompletion1Ne$Outbound
        | CreateChatCompletion1Gt$Outbound
        | CreateChatCompletion1Gte$Outbound
        | CreateChatCompletion1Lt$Outbound
        | CreateChatCompletion1Lte$Outbound
        | CreateChatCompletion1In$Outbound
        | CreateChatCompletion1Nin$Outbound
        | CreateChatCompletion1Exists$Outbound;
    }
    | undefined;
  search_options?: CreateChatCompletionSearchOptions$Outbound | undefined;
  rerank_config?: CreateChatCompletionRerankConfig$Outbound | undefined;
  agentic_rag_config?:
    | CreateChatCompletionAgenticRagConfig$Outbound
    | undefined;
  knowledge_id: string;
  query?: string | undefined;
};

/** @internal */
export const CreateChatCompletionKnowledgeBases$outboundSchema: z.ZodType<
  CreateChatCompletionKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionKnowledgeBases
> = z.object({
  topK: z.number().int().optional(),
  threshold: z.number().optional(),
  searchType: CreateChatCompletionSearchType$outboundSchema.default(
    "hybrid_search",
  ),
  filterBy: z.union([
    z.lazy(() => CreateChatCompletionFilterByAnd$outboundSchema),
    z.lazy(() => CreateChatCompletionFilterByOr$outboundSchema),
    z.record(
      z.union([
        z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
        z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
        z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
        z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
        z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
        z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
        z.lazy(() => CreateChatCompletion1In$outboundSchema),
        z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
        z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
      ]),
    ),
  ]).optional(),
  searchOptions: z.lazy(() => CreateChatCompletionSearchOptions$outboundSchema)
    .optional(),
  rerankConfig: z.lazy(() => CreateChatCompletionRerankConfig$outboundSchema)
    .optional(),
  agenticRagConfig: z.lazy(() =>
    CreateChatCompletionAgenticRagConfig$outboundSchema
  ).optional(),
  knowledgeId: z.string(),
  query: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    searchType: "search_type",
    filterBy: "filter_by",
    searchOptions: "search_options",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
    knowledgeId: "knowledge_id",
  });
});

export function createChatCompletionKnowledgeBasesToJSON(
  createChatCompletionKnowledgeBases: CreateChatCompletionKnowledgeBases,
): string {
  return JSON.stringify(
    CreateChatCompletionKnowledgeBases$outboundSchema.parse(
      createChatCompletionKnowledgeBases,
    ),
  );
}

/** @internal */
export const CreateChatCompletionLoadBalancerRouterChatCompletionsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateChatCompletionLoadBalancerRouterChatCompletionsType
  > = z.nativeEnum(CreateChatCompletionLoadBalancerRouterChatCompletionsType);

/** @internal */
export type CreateChatCompletionLoadBalancerRouterChatCompletionsModels$Outbound =
  {
    model: string;
    weight: number;
  };

/** @internal */
export const CreateChatCompletionLoadBalancerRouterChatCompletionsModels$outboundSchema:
  z.ZodType<
    CreateChatCompletionLoadBalancerRouterChatCompletionsModels$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionLoadBalancerRouterChatCompletionsModels
  > = z.object({
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function createChatCompletionLoadBalancerRouterChatCompletionsModelsToJSON(
  createChatCompletionLoadBalancerRouterChatCompletionsModels:
    CreateChatCompletionLoadBalancerRouterChatCompletionsModels,
): string {
  return JSON.stringify(
    CreateChatCompletionLoadBalancerRouterChatCompletionsModels$outboundSchema
      .parse(createChatCompletionLoadBalancerRouterChatCompletionsModels),
  );
}

/** @internal */
export type CreateChatCompletionLoadBalancerRouterChatCompletions1$Outbound = {
  type: string;
  models: Array<
    CreateChatCompletionLoadBalancerRouterChatCompletionsModels$Outbound
  >;
};

/** @internal */
export const CreateChatCompletionLoadBalancerRouterChatCompletions1$outboundSchema:
  z.ZodType<
    CreateChatCompletionLoadBalancerRouterChatCompletions1$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionLoadBalancerRouterChatCompletions1
  > = z.object({
    type:
      CreateChatCompletionLoadBalancerRouterChatCompletionsType$outboundSchema,
    models: z.array(
      z.lazy(() =>
        CreateChatCompletionLoadBalancerRouterChatCompletionsModels$outboundSchema
      ),
    ),
  });

export function createChatCompletionLoadBalancerRouterChatCompletions1ToJSON(
  createChatCompletionLoadBalancerRouterChatCompletions1:
    CreateChatCompletionLoadBalancerRouterChatCompletions1,
): string {
  return JSON.stringify(
    CreateChatCompletionLoadBalancerRouterChatCompletions1$outboundSchema.parse(
      createChatCompletionLoadBalancerRouterChatCompletions1,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRouterChatCompletionsLoadBalancer$Outbound =
  CreateChatCompletionLoadBalancerRouterChatCompletions1$Outbound;

/** @internal */
export const CreateChatCompletionRouterChatCompletionsLoadBalancer$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsLoadBalancer$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterChatCompletionsLoadBalancer
  > = z.lazy(() =>
    CreateChatCompletionLoadBalancerRouterChatCompletions1$outboundSchema
  );

export function createChatCompletionRouterChatCompletionsLoadBalancerToJSON(
  createChatCompletionRouterChatCompletionsLoadBalancer:
    CreateChatCompletionRouterChatCompletionsLoadBalancer,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChatCompletionsLoadBalancer$outboundSchema.parse(
      createChatCompletionRouterChatCompletionsLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateChatCompletionRouterChatCompletionsTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateChatCompletionRouterChatCompletionsTimeout$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsTimeout$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterChatCompletionsTimeout
  > = z.object({
    callTimeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      callTimeout: "call_timeout",
    });
  });

export function createChatCompletionRouterChatCompletionsTimeoutToJSON(
  createChatCompletionRouterChatCompletionsTimeout:
    CreateChatCompletionRouterChatCompletionsTimeout,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChatCompletionsTimeout$outboundSchema.parse(
      createChatCompletionRouterChatCompletionsTimeout,
    ),
  );
}

/** @internal */
export type Orq$Outbound = {
  name?: string | undefined;
  retry?: CreateChatCompletionRouterChatCompletionsRetry$Outbound | undefined;
  fallbacks?:
    | Array<CreateChatCompletionRouterChatCompletionsFallbacks$Outbound>
    | undefined;
  prompt?: Prompt$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateChatCompletionContact$Outbound | undefined;
  thread?: CreateChatCompletionThread$Outbound | undefined;
  inputs?: { [k: string]: any } | Array<Inputs2$Outbound> | undefined;
  cache?: CreateChatCompletionRouterChatCompletionsCache$Outbound | undefined;
  knowledge_bases?:
    | Array<CreateChatCompletionKnowledgeBases$Outbound>
    | undefined;
  load_balancer?:
    | CreateChatCompletionLoadBalancerRouterChatCompletions1$Outbound
    | undefined;
  timeout?:
    | CreateChatCompletionRouterChatCompletionsTimeout$Outbound
    | undefined;
};

/** @internal */
export const Orq$outboundSchema: z.ZodType<Orq$Outbound, z.ZodTypeDef, Orq> = z
  .object({
    name: z.string().optional(),
    retry: z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsRetry$outboundSchema
    ).optional(),
    fallbacks: z.array(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsFallbacks$outboundSchema
      ),
    ).optional(),
    prompt: z.lazy(() => Prompt$outboundSchema).optional(),
    identity: components.PublicContact$outboundSchema.optional(),
    contact: z.lazy(() => CreateChatCompletionContact$outboundSchema)
      .optional(),
    thread: z.lazy(() => CreateChatCompletionThread$outboundSchema).optional(),
    inputs: z.union([
      z.record(z.any()),
      z.array(z.lazy(() => Inputs2$outboundSchema)),
    ]).optional(),
    cache: z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsCache$outboundSchema
    ).optional(),
    knowledgeBases: z.array(
      z.lazy(() => CreateChatCompletionKnowledgeBases$outboundSchema),
    ).optional(),
    loadBalancer: z.lazy(() =>
      CreateChatCompletionLoadBalancerRouterChatCompletions1$outboundSchema
    ).optional(),
    timeout: z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsTimeout$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      knowledgeBases: "knowledge_bases",
      loadBalancer: "load_balancer",
    });
  });

export function orqToJSON(orq: Orq): string {
  return JSON.stringify(Orq$outboundSchema.parse(orq));
}

/** @internal */
export type CreateChatCompletionRequestBody$Outbound = {
  messages: Array<
    | CreateChatCompletionMessagesSystemMessage$Outbound
    | CreateChatCompletionMessagesDeveloperMessage$Outbound
    | CreateChatCompletionMessagesUserMessage$Outbound
    | CreateChatCompletionMessagesAssistantMessage$Outbound
    | CreateChatCompletionMessagesToolMessage$Outbound
  >;
  model: string;
  metadata?: { [k: string]: string } | undefined;
  audio?: CreateChatCompletionAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateChatCompletionResponseFormatText$Outbound
    | CreateChatCompletionResponseFormatJSONObject$Outbound
    | CreateChatCompletionResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | CreateChatCompletionStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tools?: Array<CreateChatCompletionTools$Outbound> | undefined;
  tool_choice?: CreateChatCompletionToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<CreateChatCompletionGuardrails$Outbound> | undefined;
  fallbacks?: Array<CreateChatCompletionFallbacks$Outbound> | undefined;
  retry?: CreateChatCompletionRetry$Outbound | undefined;
  cache?: CreateChatCompletionCache$Outbound | undefined;
  load_balancer?: CreateChatCompletionLoadBalancer1$Outbound | undefined;
  timeout?: CreateChatCompletionTimeout$Outbound | undefined;
  orq?: Orq$Outbound | undefined;
  stream: boolean;
};

/** @internal */
export const CreateChatCompletionRequestBody$outboundSchema: z.ZodType<
  CreateChatCompletionRequestBody$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRequestBody
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => CreateChatCompletionMessagesSystemMessage$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionMessagesDeveloperMessage$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionMessagesUserMessage$outboundSchema),
      z.lazy(() => CreateChatCompletionMessagesAssistantMessage$outboundSchema),
      z.lazy(() => CreateChatCompletionMessagesToolMessage$outboundSchema),
    ]),
  ),
  model: z.string(),
  metadata: z.record(z.string()).optional(),
  audio: z.nullable(z.lazy(() => CreateChatCompletionAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateChatCompletionResponseFormatText$outboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: CreateChatCompletionReasoningEffort$outboundSchema
    .optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateChatCompletionStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  tools: z.array(z.lazy(() => CreateChatCompletionTools$outboundSchema))
    .optional(),
  toolChoice: z.union([
    z.lazy(() => CreateChatCompletionToolChoice2$outboundSchema),
    CreateChatCompletionToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateChatCompletionModalities$outboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => CreateChatCompletionGuardrails$outboundSchema),
  ).optional(),
  fallbacks: z.array(z.lazy(() => CreateChatCompletionFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => CreateChatCompletionRetry$outboundSchema).optional(),
  cache: z.lazy(() => CreateChatCompletionCache$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateChatCompletionLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateChatCompletionTimeout$outboundSchema).optional(),
  orq: z.lazy(() => Orq$outboundSchema).optional(),
  stream: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function createChatCompletionRequestBodyToJSON(
  createChatCompletionRequestBody: CreateChatCompletionRequestBody,
): string {
  return JSON.stringify(
    CreateChatCompletionRequestBody$outboundSchema.parse(
      createChatCompletionRequestBody,
    ),
  );
}

/** @internal */
export const CreateChatCompletionFinishReason$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFinishReason
> = z.nativeEnum(CreateChatCompletionFinishReason);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsTopLogprobs$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsTopLogprobs,
    z.ZodTypeDef,
    unknown
  > = z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
  });

export function createChatCompletionRouterChatCompletionsTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsTopLogprobs,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsTopLogprobs$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsTopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsContent$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsContent,
    z.ZodTypeDef,
    unknown
  > = z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
    top_logprobs: z.array(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsTopLogprobs$inboundSchema
      ),
    ),
  }).transform((v) => {
    return remap$(v, {
      "top_logprobs": "topLogprobs",
    });
  });

export function createChatCompletionRouterChatCompletionsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponseTopLogprobs$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsResponseTopLogprobs,
    z.ZodTypeDef,
    unknown
  > = z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
  });

export function createChatCompletionRouterChatCompletionsResponseTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsResponseTopLogprobs,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsResponseTopLogprobs$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsResponseTopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRefusal$inboundSchema: z.ZodType<
  CreateChatCompletionRefusal,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(
    z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsResponseTopLogprobs$inboundSchema
    ),
  ),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});

export function createChatCompletionRefusalFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRefusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRefusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRefusal' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionLogprobs$inboundSchema: z.ZodType<
  CreateChatCompletionLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsContent$inboundSchema
    )),
  ),
  refusal: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionRefusal$inboundSchema)),
  ),
});

export function createChatCompletionLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponse200Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateChatCompletionRouterChatCompletionsResponse200Type
  > = z.nativeEnum(CreateChatCompletionRouterChatCompletionsResponse200Type);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponseFunction$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
    arguments: z.string().optional(),
  });

export function createChatCompletionRouterChatCompletionsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsResponseFunction$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsToolCalls$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsToolCalls,
    z.ZodTypeDef,
    unknown
  > = z.object({
    index: z.number().optional(),
    id: z.string().optional(),
    type: CreateChatCompletionRouterChatCompletionsResponse200Type$inboundSchema
      .optional(),
    function: z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsResponseFunction$inboundSchema
    ).optional(),
    thought_signature: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "thought_signature": "thoughtSignature",
    });
  });

export function createChatCompletionRouterChatCompletionsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsToolCalls,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsToolCalls$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsRole$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterChatCompletionsRole> = z
    .nativeEnum(CreateChatCompletionRouterChatCompletionsRole);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponseAudio$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsResponseAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string().optional(),
    transcript: z.string().optional(),
    data: z.string().optional(),
    expires_at: z.number().int().optional(),
  }).transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  });

export function createChatCompletionRouterChatCompletionsResponseAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsResponseAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsResponseAudio$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsResponseAudio' from JSON`,
  );
}

/** @internal */
export const Delta$inboundSchema: z.ZodType<Delta, z.ZodTypeDef, unknown> = z
  .object({
    content: z.nullable(z.string()).optional(),
    refusal: z.nullable(z.string()).optional(),
    tool_calls: z.array(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsToolCalls$inboundSchema
      ),
    ).optional(),
    role: CreateChatCompletionRouterChatCompletionsRole$inboundSchema
      .optional(),
    reasoning: z.string().optional(),
    reasoning_signature: z.string().optional(),
    redacted_reasoning: z.string().optional(),
    audio: z.nullable(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsResponseAudio$inboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_calls": "toolCalls",
      "reasoning_signature": "reasoningSignature",
      "redacted_reasoning": "redactedReasoning",
    });
  });

export function deltaFromJSON(
  jsonString: string,
): SafeParseResult<Delta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delta' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsChoices$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsChoices,
    z.ZodTypeDef,
    unknown
  > = z.object({
    finish_reason: z.nullable(CreateChatCompletionFinishReason$inboundSchema),
    index: z.number().default(0),
    logprobs: z.nullable(
      z.lazy(() => CreateChatCompletionLogprobs$inboundSchema),
    ).optional(),
    delta: z.lazy(() => Delta$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "finish_reason": "finishReason",
    });
  });

export function createChatCompletionRouterChatCompletionsChoicesFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsChoices,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsChoices$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsChoices' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsPromptTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsPromptTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    cached_tokens: z.nullable(z.number().int()).optional(),
    cache_creation_tokens: z.nullable(z.number().int()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "cache_creation_tokens": "cacheCreationTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function createChatCompletionRouterChatCompletionsPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsPromptTokensDetails$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsCompletionTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function createChatCompletionRouterChatCompletionsCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsCompletionTokensDetails$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsUsage$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsUsage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    completion_tokens: z.number().optional(),
    prompt_tokens: z.number().optional(),
    total_tokens: z.number().optional(),
    prompt_tokens_details: z.nullable(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsPromptTokensDetails$inboundSchema
      ),
    ).optional(),
    completion_tokens_details: z.nullable(
      z.lazy(() =>
        CreateChatCompletionRouterChatCompletionsCompletionTokensDetails$inboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "completion_tokens": "completionTokens",
      "prompt_tokens": "promptTokens",
      "total_tokens": "totalTokens",
      "prompt_tokens_details": "promptTokensDetails",
      "completion_tokens_details": "completionTokensDetails",
    });
  });

export function createChatCompletionRouterChatCompletionsUsageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsUsage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsUsage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsUsage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsObject$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterChatCompletionsObject> = z
    .nativeEnum(CreateChatCompletionRouterChatCompletionsObject);

/** @internal */
export const CreateChatCompletionData$inboundSchema: z.ZodType<
  CreateChatCompletionData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(
    z.lazy(() =>
      CreateChatCompletionRouterChatCompletionsChoices$inboundSchema
    ),
  ),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(
    z.lazy(() => CreateChatCompletionRouterChatCompletionsUsage$inboundSchema),
  ).optional(),
  object: CreateChatCompletionRouterChatCompletionsObject$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});

export function createChatCompletionDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionData' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponseBody$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    data: z.string().optional().transform((v, ctx) => {
      if (v === undefined) return undefined;
      try {
        return JSON.parse(v);
      } catch (err) {
        ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
        return z.NEVER;
      }
    }).pipe(z.lazy(() => CreateChatCompletionData$inboundSchema).optional()),
  });

export function createChatCompletionRouterChatCompletionsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsResponseBody' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsResponseType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateChatCompletionRouterChatCompletionsResponseType
  > = z.nativeEnum(CreateChatCompletionRouterChatCompletionsResponseType);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsFunction$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
    arguments: z.string().optional(),
  });

export function createChatCompletionRouterChatCompletionsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionToolCalls$inboundSchema: z.ZodType<
  CreateChatCompletionToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number().optional(),
  id: z.string().optional(),
  type: CreateChatCompletionRouterChatCompletionsResponseType$inboundSchema
    .optional(),
  function: z.lazy(() =>
    CreateChatCompletionRouterChatCompletionsFunction$inboundSchema
  ).optional(),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});

export function createChatCompletionToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRole$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRole
> = z.nativeEnum(CreateChatCompletionRole);

/** @internal */
export const CreateChatCompletionRouterChatCompletionsAudio$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterChatCompletionsAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    expires_at: z.number().int(),
    data: z.string(),
    transcript: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "expires_at": "expiresAt",
    });
  });

export function createChatCompletionRouterChatCompletionsAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterChatCompletionsAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterChatCompletionsAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterChatCompletionsAudio' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessage$inboundSchema: z.ZodType<
  CreateChatCompletionMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  tool_calls: z.array(z.lazy(() => CreateChatCompletionToolCalls$inboundSchema))
    .optional(),
  role: CreateChatCompletionRole$inboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoning_signature: z.nullable(z.string()).optional(),
  redacted_reasoning: z.string().optional(),
  audio: z.nullable(
    z.lazy(() => CreateChatCompletionRouterChatCompletionsAudio$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});

export function createChatCompletionMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessage' from JSON`,
  );
}

/** @internal */
export const TopLogprobs$inboundSchema: z.ZodType<
  TopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function topLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<TopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionContent$inboundSchema: z.ZodType<
  CreateChatCompletionContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(z.lazy(() => TopLogprobs$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});

export function createChatCompletionContentFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionTopLogprobs$inboundSchema: z.ZodType<
  CreateChatCompletionTopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function createChatCompletionTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionTopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionTopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionTopLogprobs' from JSON`,
  );
}

/** @internal */
export const Refusal$inboundSchema: z.ZodType<Refusal, z.ZodTypeDef, unknown> =
  z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
    top_logprobs: z.array(
      z.lazy(() => CreateChatCompletionTopLogprobs$inboundSchema),
    ),
  }).transform((v) => {
    return remap$(v, {
      "top_logprobs": "topLogprobs",
    });
  });

export function refusalFromJSON(
  jsonString: string,
): SafeParseResult<Refusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refusal' from JSON`,
  );
}

/** @internal */
export const Logprobs$inboundSchema: z.ZodType<
  Logprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionContent$inboundSchema)),
  ),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$inboundSchema))),
});

export function logprobsFromJSON(
  jsonString: string,
): SafeParseResult<Logprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Logprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Logprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionChoices$inboundSchema: z.ZodType<
  CreateChatCompletionChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: z.nullable(FinishReason$inboundSchema),
  index: z.number().default(0),
  message: z.lazy(() => CreateChatCompletionMessage$inboundSchema),
  logprobs: z.nullable(z.lazy(() => Logprobs$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});

export function createChatCompletionChoicesFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionChoices' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionPromptTokensDetails$inboundSchema: z.ZodType<
  CreateChatCompletionPromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  cache_creation_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "cache_creation_tokens": "cacheCreationTokens",
    "audio_tokens": "audioTokens",
  });
});

export function createChatCompletionPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionCompletionTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function createChatCompletionCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionUsage$inboundSchema: z.ZodType<
  CreateChatCompletionUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => CreateChatCompletionPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CreateChatCompletionCompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});

export function createChatCompletionUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionUsage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionObject
> = z.nativeEnum(CreateChatCompletionObject);

/** @internal */
export const CreateChatCompletionResponseBody$inboundSchema: z.ZodType<
  CreateChatCompletionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => CreateChatCompletionChoices$inboundSchema)),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(z.lazy(() => CreateChatCompletionUsage$inboundSchema))
    .optional(),
  object: CreateChatCompletionObject$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});

export function createChatCompletionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponse$inboundSchema: z.ZodType<
  CreateChatCompletionResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() =>
            CreateChatCompletionRouterChatCompletionsResponseBody$inboundSchema
          ).parse(rawEvent),
        };
      });
    }),
]);

export function createChatCompletionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponse' from JSON`,
  );
}
