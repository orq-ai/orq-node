/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentModelConfigurationFormat;
};

export const StreamRunAgentResponseFormatAgentsRequestType = {
  JsonSchema: "json_schema",
} as const;
export type StreamRunAgentResponseFormatAgentsRequestType = ClosedEnum<
  typeof StreamRunAgentResponseFormatAgentsRequestType
>;

export type StreamRunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatJSONSchema = {
  type: StreamRunAgentResponseFormatAgentsRequestType;
  jsonSchema: StreamRunAgentResponseFormatAgentsJsonSchema;
};

export const StreamRunAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type StreamRunAgentResponseFormatAgentsType = ClosedEnum<
  typeof StreamRunAgentResponseFormatAgentsType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatJSONObject = {
  type: StreamRunAgentResponseFormatAgentsType;
};

export const StreamRunAgentResponseFormatType = {
  Text: "text",
} as const;
export type StreamRunAgentResponseFormatType = ClosedEnum<
  typeof StreamRunAgentResponseFormatType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatText = {
  type: StreamRunAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatJSONSchema
  | StreamRunAgentResponseFormatText
  | StreamRunAgentResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const StreamRunAgentModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type StreamRunAgentModelConfigurationType = ClosedEnum<
  typeof StreamRunAgentModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const StreamRunAgentModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type StreamRunAgentModelConfigurationThinkingLevel = ClosedEnum<
  typeof StreamRunAgentModelConfigurationThinkingLevel
>;

export type StreamRunAgentModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: StreamRunAgentModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: StreamRunAgentModelConfigurationThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceType = ClosedEnum<
  typeof StreamRunAgentToolChoiceType
>;

export type StreamRunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type StreamRunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceType | undefined;
  function: StreamRunAgentToolChoiceFunction;
};

export const StreamRunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoice1 = ClosedEnum<
  typeof StreamRunAgentToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentModelConfigurationToolChoice =
  | StreamRunAgentToolChoice2
  | StreamRunAgentToolChoice1;

export const StreamRunAgentModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentModelConfigurationModalities
>;

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type StreamRunAgentModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatJSONSchema
    | StreamRunAgentResponseFormatText
    | StreamRunAgentResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: StreamRunAgentModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoice2
    | StreamRunAgentToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type StreamRunAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type StreamRunAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: StreamRunAgentModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: StreamRunAgentModelConfigurationRetry | undefined;
};

/**
 * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
 */
export type StreamRunAgentModelConfiguration =
  | StreamRunAgentModelConfiguration2
  | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentFallbackModelConfigurationFormat;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType =
  {
    JsonSchema: "json_schema",
  } as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType =
  ClosedEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  >;

export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema = {
  type:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType;
  jsonSchema: StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  {
    JsonObject: "json_object",
  } as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  ClosedEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  >;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatAgentsJSONObject = {
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType = {
  Text: "text",
} as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyType =
  ClosedEnum<typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatAgentsText = {
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType;
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentFallbackModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema
  | StreamRunAgentResponseFormatAgentsText
  | StreamRunAgentResponseFormatAgentsJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const StreamRunAgentFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type StreamRunAgentFallbackModelConfigurationType = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const StreamRunAgentFallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type StreamRunAgentFallbackModelConfigurationThinkingLevel = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationThinkingLevel
>;

export type StreamRunAgentFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: StreamRunAgentFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?:
    | StreamRunAgentFallbackModelConfigurationThinkingLevel
    | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceAgentsType = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgentsType
>;

export type StreamRunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type StreamRunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceAgentsType | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction;
};

export const StreamRunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoiceAgents1 = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentFallbackModelConfigurationToolChoice =
  | StreamRunAgentToolChoiceAgents2
  | StreamRunAgentToolChoiceAgents1;

export const StreamRunAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type StreamRunAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema
    | StreamRunAgentResponseFormatAgentsText
    | StreamRunAgentResponseFormatAgentsJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: StreamRunAgentFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoiceAgents2
    | StreamRunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type StreamRunAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: StreamRunAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type StreamRunAgentFallbackModelConfiguration =
  | StreamRunAgentFallbackModelConfiguration2
  | string;

/**
 * Message containing tool execution results
 */
export const StreamRunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type StreamRunAgentRoleToolMessage = ClosedEnum<
  typeof StreamRunAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const StreamRunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type StreamRunAgentRoleUserMessage = ClosedEnum<
  typeof StreamRunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamRunAgentRole =
  | StreamRunAgentRoleUserMessage
  | StreamRunAgentRoleToolMessage;

export const StreamRunAgentPublicMessagePartAgentsRequestKind = {
  ToolResult: "tool_result",
} as const;
export type StreamRunAgentPublicMessagePartAgentsRequestKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartAgentsRequestKind
>;

/**
 * Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request.
 */
export type StreamRunAgentPublicMessagePartToolResultPart = {
  kind: StreamRunAgentPublicMessagePartAgentsRequestKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPublicMessagePartAgentsKind = {
  File: "file",
} as const;
export type StreamRunAgentPublicMessagePartAgentsKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPublicMessagePartFile =
  | StreamRunAgentFileBinaryFormat
  | StreamRunAgentFileFileInURIFormat;

/**
 * File attachment part. Use this to send files (images, documents, etc.) to the agent for processing.
 */
export type StreamRunAgentPublicMessagePartFilePart = {
  kind: StreamRunAgentPublicMessagePartAgentsKind;
  file: StreamRunAgentFileBinaryFormat | StreamRunAgentFileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPublicMessagePartKind = {
  Text: "text",
} as const;
export type StreamRunAgentPublicMessagePartKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartKind
>;

/**
 * Text content part. Use this to send text messages to the agent.
 */
export type StreamRunAgentPublicMessagePartTextPart = {
  kind: StreamRunAgentPublicMessagePartKind;
  text: string;
};

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamRunAgentPublicMessagePart =
  | StreamRunAgentPublicMessagePartTextPart
  | StreamRunAgentPublicMessagePartFilePart
  | StreamRunAgentPublicMessagePartToolResultPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type StreamRunAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamRunAgentRoleUserMessage | StreamRunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | StreamRunAgentPublicMessagePartTextPart
    | StreamRunAgentPublicMessagePartFilePart
    | StreamRunAgentPublicMessagePartToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type StreamRunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamRunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamRunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamRunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type StreamRunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type =
  {
    Mcp: "mcp",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  >;

export type StreamRunAgentAgentToolInputRunAgentsHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType =
  {
    Object: "object",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  >;

export type AgentToolInputRunSchema = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type AgentToolInputRunTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: AgentToolInputRunSchema;
};

/**
 * The connection type used by the MCP server
 */
export const AgentToolInputRunConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type AgentToolInputRunConnectionType = ClosedEnum<
  typeof AgentToolInputRunConnectionType
>;

export type AgentToolInputRunMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?:
    | { [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders }
    | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<AgentToolInputRunTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: AgentToolInputRunConnectionType;
};

/**
 * MCP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunMCPToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  mcp: AgentToolInputRunMcp;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunAgentsParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type StreamRunAgentAgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunAgentsParameters | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunFunctionToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const AgentToolInputRunLanguage = {
  Python: "python",
} as const;
export type AgentToolInputRunLanguage = ClosedEnum<
  typeof AgentToolInputRunLanguage
>;

export type AgentToolInputRunCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunParameters | undefined;
  language: AgentToolInputRunLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunCodeToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: AgentToolInputRunCodeTool;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * The HTTP method to use.
 */
export const AgentToolInputRunMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type AgentToolInputRunMethod = ClosedEnum<
  typeof AgentToolInputRunMethod
>;

export type StreamRunAgentHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type StreamRunAgentAgentToolInputRunHeaders =
  | StreamRunAgentHeaders2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type AgentToolInputRunBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: AgentToolInputRunMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: StreamRunAgentHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type AgentToolInputRunDefaultValue = string | number | boolean;

export type AgentToolInputRunArguments = {
  /**
   * The type of the argument.
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type AgentToolInputRunHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: AgentToolInputRunBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: AgentToolInputRunArguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunHTTPToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: AgentToolInputRunHttp;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type StreamRunAgentAgentToolInputRunCurrentDateTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  >;

/**
 * Lists available memory stores
 */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Writes information to agent memory stores
 */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType =
  {
    QueryMemoryStore: "query_memory_store",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  >;

/**
 * Queries agent memory stores for context
 */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  >;

/**
 * Retrieves available agents in the system
 */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunAgentsRequestType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsType = {
  WebScraper: "web_scraper",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunAgentsType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type StreamRunAgentAgentToolInputRunWebScraperTool = {
  type: StreamRunAgentAgentToolInputRunAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunType = {
  GoogleSearch: "google_search",
} as const;
export type StreamRunAgentAgentToolInputRunType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunType
>;

/**
 * Performs Google searches to retrieve web content
 */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool = {
  type: StreamRunAgentAgentToolInputRunType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function, MCP) support full inline definitions for on-the-fly creation.
 */
export type StreamRunAgentAgentToolInputRun =
  | AgentToolInputRunHTTPToolRun
  | AgentToolInputRunCodeToolRun
  | AgentToolInputRunMCPToolRun
  | AgentToolInputRunFunctionToolRun
  | StreamRunAgentAgentToolInputRunGoogleSearchTool
  | StreamRunAgentAgentToolInputRunWebScraperTool
  | StreamRunAgentAgentToolInputRunCallSubAgentTool
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  | StreamRunAgentAgentToolInputRunCurrentDateTool;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const StreamRunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type StreamRunAgentToolApprovalRequired = ClosedEnum<
  typeof StreamRunAgentToolApprovalRequired
>;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentExecuteOn = ClosedEnum<
  typeof StreamRunAgentExecuteOn
>;

export type StreamRunAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentAgentsExecuteOn = ClosedEnum<
  typeof StreamRunAgentAgentsExecuteOn
>;

export type StreamRunAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentAgentsExecuteOn;
};

export type StreamRunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | AgentToolInputRunHTTPToolRun
      | AgentToolInputRunCodeToolRun
      | AgentToolInputRunMCPToolRun
      | AgentToolInputRunFunctionToolRun
      | StreamRunAgentAgentToolInputRunGoogleSearchTool
      | StreamRunAgentAgentToolInputRunWebScraperTool
      | StreamRunAgentAgentToolInputRunCallSubAgentTool
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
      | StreamRunAgentAgentToolInputRunCurrentDateTool
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: StreamRunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<StreamRunAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<StreamRunAgentGuardrails> | undefined;
};

export type StreamRunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
   */
  model: StreamRunAgentModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<StreamRunAgentFallbackModelConfiguration2 | string>
    | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: StreamRunAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: StreamRunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamRunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamRunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<StreamRunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<StreamRunAgentTeamOfAgents> | undefined;
  settings: StreamRunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type =
  {
    AgentsError: "agents.error",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data =
  {
    error: string;
    code: string;
  };

export type Seventeen = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type =
  {
    AgentsTimeout: "agents.timeout",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data =
  {
    message: string;
  };

export type Sixteen = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type =
  {
    EventWorkflowEventsToolExecutionFailed:
      "event.workflow_events.tool_execution_failed",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type
  >;

export type ErrorT = {
  message: string;
  stack?: string | undefined;
};

/**
 * Orquesta product
 */
export const StreamRunAgentDataProduct = {
  Remoteconfigs: "remoteconfigs",
  Deployments: "deployments",
  Experiments: "experiments",
  Playgrounds: "playgrounds",
  Spreadsheets: "spreadsheets",
  SpreadsheetRun: "spreadsheet_run",
  LlmEvaluator: "llm_evaluator",
  Knowledge: "knowledge",
  Router: "router",
  Workflows: "workflows",
  ExternalEvents: "external_events",
  Agents: "agents",
  MemoryStores: "memory-stores",
  Generic: "generic",
  Evaluators: "evaluators",
  Otel: "otel",
} as const;
/**
 * Orquesta product
 */
export type StreamRunAgentDataProduct = ClosedEnum<
  typeof StreamRunAgentDataProduct
>;

export type StreamRunAgentDataAgentsMemory = {
  entityId: string;
};

export type StreamRunAgentDataToolExecutionContext = {
  actionId: string;
  agentToolCallId: string;
  workspaceId: string;
  agentManifestId: string;
  agentExecutionId: string;
  /**
   * Orquesta product
   */
  product: StreamRunAgentDataProduct;
  memory?: StreamRunAgentDataAgentsMemory | undefined;
  parentId?: string | undefined;
};

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data =
  {
    error: ErrorT;
    actionType: string;
    toolExecutionContext: StreamRunAgentDataToolExecutionContext;
    responseId?: string | undefined;
  };

export type Fifteen = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type =
  {
    EventWorkflowEventsToolExecutionFinished:
      "event.workflow_events.tool_execution_finished",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type
  >;

/**
 * Orquesta product
 */
export const DataProduct = {
  Remoteconfigs: "remoteconfigs",
  Deployments: "deployments",
  Experiments: "experiments",
  Playgrounds: "playgrounds",
  Spreadsheets: "spreadsheets",
  SpreadsheetRun: "spreadsheet_run",
  LlmEvaluator: "llm_evaluator",
  Knowledge: "knowledge",
  Router: "router",
  Workflows: "workflows",
  ExternalEvents: "external_events",
  Agents: "agents",
  MemoryStores: "memory-stores",
  Generic: "generic",
  Evaluators: "evaluators",
  Otel: "otel",
} as const;
/**
 * Orquesta product
 */
export type DataProduct = ClosedEnum<typeof DataProduct>;

export type StreamRunAgentDataMemory = {
  entityId: string;
};

export type DataToolExecutionContext = {
  actionId: string;
  agentToolCallId: string;
  workspaceId: string;
  agentManifestId: string;
  agentExecutionId: string;
  /**
   * Orquesta product
   */
  product: DataProduct;
  memory?: StreamRunAgentDataMemory | undefined;
  parentId?: string | undefined;
};

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data =
  {
    result?: any | undefined;
    actionType: string;
    toolExecutionContext: DataToolExecutionContext;
    responseId?: string | undefined;
  };

export type Fourteen = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type =
  {
    EventWorkflowEventsToolExecutionStarted:
      "event.workflow_events.tool_execution_started",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type
  >;

/**
 * Orquesta product
 */
export const Product = {
  Remoteconfigs: "remoteconfigs",
  Deployments: "deployments",
  Experiments: "experiments",
  Playgrounds: "playgrounds",
  Spreadsheets: "spreadsheets",
  SpreadsheetRun: "spreadsheet_run",
  LlmEvaluator: "llm_evaluator",
  Knowledge: "knowledge",
  Router: "router",
  Workflows: "workflows",
  ExternalEvents: "external_events",
  Agents: "agents",
  MemoryStores: "memory-stores",
  Generic: "generic",
  Evaluators: "evaluators",
  Otel: "otel",
} as const;
/**
 * Orquesta product
 */
export type Product = ClosedEnum<typeof Product>;

export type DataMemory = {
  entityId: string;
};

export type ToolExecutionContext = {
  actionId: string;
  agentToolCallId: string;
  workspaceId: string;
  agentManifestId: string;
  agentExecutionId: string;
  /**
   * Orquesta product
   */
  product: Product;
  memory?: DataMemory | undefined;
  parentId?: string | undefined;
};

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data =
  {
    toolId: string;
    toolKey?: string | undefined;
    toolDisplayName?: string | undefined;
    actionType: string;
    toolArguments: { [k: string]: any };
    toolExecutionContext: ToolExecutionContext;
    responseId?: string | undefined;
  };

export type Thirteen = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type =
  {
    EventAgentsMessageCreated: "event.agents.message-created",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type
  >;

export const StreamRunAgentDataAgentsResponseRole = {
  User: "user",
  Tool: "tool",
} as const;
export type StreamRunAgentDataAgentsResponseRole = ClosedEnum<
  typeof StreamRunAgentDataAgentsResponseRole
>;

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind =
  {
    ToolResult: "tool_result",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind
  >;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type StreamRunAgentPartsAgentsResponse200ToolResultPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind =
  {
    ToolCall: "tool_call",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind
  >;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type StreamRunAgentPartsAgentsResponse200ToolCallPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind =
  {
    File: "file",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind
  >;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat =
  {
    /**
     * URL for the File content
     */
    uri: string;
    /**
     * Optional mimeType for the file
     */
    mimeType?: string | undefined;
    /**
     * Optional name for the file
     */
    name?: string | undefined;
  };

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPartsAgentsResponse200File =
  | StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat
  | StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type StreamRunAgentPartsAgentsResponse200FilePart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind;
  file:
    | StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat
    | StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind =
  {
    Data: "data",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind
  >;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type StreamRunAgentPartsAgentsResponse200DataPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind =
  {
    Text: "text",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind
  >;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type StreamRunAgentPartsAgentsResponse200TextPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind;
  text: string;
};

export type StreamRunAgentDataAgentsResponseParts =
  | StreamRunAgentPartsAgentsResponse200ToolCallPart
  | StreamRunAgentPartsAgentsResponse200TextPart
  | StreamRunAgentPartsAgentsResponse200DataPart
  | StreamRunAgentPartsAgentsResponse200FilePart
  | StreamRunAgentPartsAgentsResponse200ToolResultPart;

export type DataMessage = {
  messageId?: string | undefined;
  role: StreamRunAgentDataAgentsResponseRole;
  parts: Array<
    | StreamRunAgentPartsAgentsResponse200ToolCallPart
    | StreamRunAgentPartsAgentsResponse200TextPart
    | StreamRunAgentPartsAgentsResponse200DataPart
    | StreamRunAgentPartsAgentsResponse200FilePart
    | StreamRunAgentPartsAgentsResponse200ToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
};

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data =
  {
    workflowRunId: string;
    spanId: string;
    parentId: string;
    message: Array<DataMessage>;
  };

export type Twelve = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type =
  {
    EventAgentsHandedOff: "event.agents.handed_off",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data =
  {
    agentId: string;
    input: string;
  };

export type Eleven = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type =
  {
    EventAgentsExecutionNamed: "event.agents.execution_named",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data =
  {
    name: string;
    agentManifestId: string;
  };

export type Ten = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type =
  {
    EventAgentsExecutionReviewed: "event.agents.execution_reviewed",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data =
  {};

export type Nine = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type =
  {
    EventAgentsExecutionReviewRequired:
      "event.agents.execution_review_required",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type
  >;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data =
  {};

export type Eight = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type =
  {
    EventAgentsActionReviewed: "event.agents.action_reviewed",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type
  >;

export const Review = {
  Approved: "approved",
  Rejected: "rejected",
} as const;
export type Review = ClosedEnum<typeof Review>;

export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData =
  {
    agentId: string;
    actionId: string;
    agentToolCallId: string;
    review: Review;
    mockOutput?: { [k: string]: any } | undefined;
    reviewSource?: string | undefined;
    reviewedById?: string | undefined;
  };

export type Seven = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType =
  {
    EventAgentsActionReviewRequested: "event.agents.action_review_requested",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType
  >;

export type DataConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type Tool = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<DataConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type StreamRunAgentDataAgentsResponse200TextEventStreamData = {
  agentId: string;
  actionId: string;
  requiresApproval: boolean;
  tool: Tool;
  input: { [k: string]: any };
  agentToolCallId: string;
  responseId?: string | undefined;
};

export type StreamRunAgentData6 = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamData;
};

export const StreamRunAgentDataAgentsResponse200TextEventStreamType = {
  EventAgentsErrored: "event.agents.errored",
} as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamType = ClosedEnum<
  typeof StreamRunAgentDataAgentsResponse200TextEventStreamType
>;

export type StreamRunAgentDataAgentsResponse200Data = {
  error: string;
  code: number;
  /**
   * ID of the response tracking this execution
   */
  responseId?: string | undefined;
};

export type StreamRunAgentData5 = {
  type: StreamRunAgentDataAgentsResponse200TextEventStreamType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200Data;
};

export const StreamRunAgentDataAgentsResponse200Type = {
  EventAgentsInactive: "event.agents.inactive",
} as const;
export type StreamRunAgentDataAgentsResponse200Type = ClosedEnum<
  typeof StreamRunAgentDataAgentsResponse200Type
>;

/**
 * Extended A2A message role
 */
export const StreamRunAgentDataAgentsRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type StreamRunAgentDataAgentsRole = ClosedEnum<
  typeof StreamRunAgentDataAgentsRole
>;

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind =
  {
    ToolResult: "tool_result",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind
  >;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type StreamRunAgentPartsAgentsResponseToolResultPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind =
  {
    ToolCall: "tool_call",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind
  >;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type StreamRunAgentPartsAgentsResponseToolCallPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind =
  {
    File: "file",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind
  >;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileAgentsResponse200FileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileAgentsResponse200BinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPartsAgentsResponseFile =
  | StreamRunAgentFileAgentsResponse200BinaryFormat
  | StreamRunAgentFileAgentsResponse200FileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type StreamRunAgentPartsAgentsResponseFilePart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind;
  file:
    | StreamRunAgentFileAgentsResponse200BinaryFormat
    | StreamRunAgentFileAgentsResponse200FileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind =
  {
    Data: "data",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind
  >;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type StreamRunAgentPartsAgentsResponseDataPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind =
  {
    Text: "text",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind
  >;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type StreamRunAgentPartsAgentsResponseTextPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind;
  text: string;
};

export type StreamRunAgentDataAgentsParts =
  | StreamRunAgentPartsAgentsResponseToolCallPart
  | StreamRunAgentPartsAgentsResponseTextPart
  | StreamRunAgentPartsAgentsResponseDataPart
  | StreamRunAgentPartsAgentsResponseFilePart
  | StreamRunAgentPartsAgentsResponseToolResultPart;

/**
 * Full last message in A2A format (for backwards compatibility)
 */
export type LastMessageFull = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: StreamRunAgentDataAgentsRole;
  parts: Array<
    | StreamRunAgentPartsAgentsResponseToolCallPart
    | StreamRunAgentPartsAgentsResponseTextPart
    | StreamRunAgentPartsAgentsResponseDataPart
    | StreamRunAgentPartsAgentsResponseFilePart
    | StreamRunAgentPartsAgentsResponseToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * The reason why the agent execution became inactive
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
  MaxIterations: "max_iterations",
  MaxTime: "max_time",
} as const;
/**
 * The reason why the agent execution became inactive
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type =
  {
    Function: "function",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type
  >;

export type StreamRunAgentDataFunction = {
  name?: string | undefined;
  arguments?: string | undefined;
};

export type PendingToolCalls = {
  id: string;
  type: StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type;
  function: StreamRunAgentDataFunction;
};

export type StreamRunAgentDataPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type StreamRunAgentDataCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the last agent message
 */
export type StreamRunAgentDataUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | StreamRunAgentDataPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | StreamRunAgentDataCompletionTokensDetails
    | null
    | undefined;
};

export type StreamRunAgentDataAgentsResponseData = {
  lastMessage: string;
  /**
   * Full last message in A2A format (for backwards compatibility)
   */
  lastMessageFull?: LastMessageFull | undefined;
  /**
   * The reason why the agent execution became inactive
   */
  finishReason: FinishReason;
  /**
   * Tool calls that are pending user response (for function_call finish reason)
   */
  pendingToolCalls?: Array<PendingToolCalls> | undefined;
  /**
   * Token usage from the last agent message
   */
  usage?: StreamRunAgentDataUsage | undefined;
  /**
   * ID of the response tracking this execution
   */
  responseId?: string | undefined;
};

export type Data4 = {
  type: StreamRunAgentDataAgentsResponse200Type;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsResponseData;
};

export const StreamRunAgentDataAgentsResponseType = {
  EventAgentsThought: "event.agents.thought",
} as const;
export type StreamRunAgentDataAgentsResponseType = ClosedEnum<
  typeof StreamRunAgentDataAgentsResponseType
>;

export const StreamRunAgentDataRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
export type StreamRunAgentDataRole = ClosedEnum<typeof StreamRunAgentDataRole>;

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind =
  {
    ToolResult: "tool_result",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind
  >;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type StreamRunAgentPartsAgentsToolResultPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind =
  {
    ToolCall: "tool_call",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind
  >;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type StreamRunAgentPartsAgentsToolCallPart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind =
  {
    File: "file",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind
  >;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileAgentsResponseFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileAgentsResponseBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPartsAgentsFile =
  | StreamRunAgentFileAgentsResponseBinaryFormat
  | StreamRunAgentFileAgentsResponseFileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type StreamRunAgentPartsAgentsFilePart = {
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind;
  file:
    | StreamRunAgentFileAgentsResponseBinaryFormat
    | StreamRunAgentFileAgentsResponseFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind =
  {
    Data: "data",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind
  >;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type StreamRunAgentPartsAgentsDataPart = {
  kind: StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind =
  {
    Text: "text",
  } as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind =
  ClosedEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind
  >;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type StreamRunAgentPartsAgentsTextPart = {
  kind: StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind;
  text: string;
};

export type StreamRunAgentDataParts =
  | StreamRunAgentPartsAgentsToolCallPart
  | StreamRunAgentPartsAgentsTextPart
  | StreamRunAgentPartsAgentsDataPart
  | StreamRunAgentPartsAgentsFilePart
  | StreamRunAgentPartsAgentsToolResultPart;

export type MessageDifference = {
  messageId: string;
  role: StreamRunAgentDataRole;
  parts: Array<
    | StreamRunAgentPartsAgentsToolCallPart
    | StreamRunAgentPartsAgentsTextPart
    | StreamRunAgentPartsAgentsDataPart
    | StreamRunAgentPartsAgentsFilePart
    | StreamRunAgentPartsAgentsToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
  agentId: string;
  agentExecutionId: string;
  workspaceId: string;
};

/**
 * The reason the model stopped generating tokens.
 */
export const StreamRunAgentDataFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type StreamRunAgentDataFinishReason = ClosedEnum<
  typeof StreamRunAgentDataFinishReason
>;

export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type =
  {
    Function: "function",
  } as const;
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type =
  ClosedEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type
  >;

export type StreamRunAgentDataAgentsFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type DataToolCalls = {
  id?: string | undefined;
  type?:
    | StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type
    | undefined;
  function?: StreamRunAgentDataAgentsFunction | undefined;
};

export const StreamRunAgentDataAgentsResponse200Role = {
  Assistant: "assistant",
} as const;
export type StreamRunAgentDataAgentsResponse200Role = ClosedEnum<
  typeof StreamRunAgentDataAgentsResponse200Role
>;

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model.
 */
export type DataAudio = {
  id: string;
  expiresAt: number;
  data: string;
  transcript: string;
};

/**
 * A chat completion message generated by the model.
 */
export type StreamRunAgentDataMessage = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?: Array<DataToolCalls> | undefined;
  role?: StreamRunAgentDataAgentsResponse200Role | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | null | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | null | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * If the audio output modality is requested, this object contains data about the audio response from the model.
   */
  audio?: DataAudio | null | undefined;
};

export type TopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type DataContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<TopLogprobs>;
};

export type DataTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type Refusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<DataTopLogprobs>;
};

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<DataContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<Refusal> | null;
};

export type Choice = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: StreamRunAgentDataFinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index?: number | undefined;
  /**
   * A chat completion message generated by the model.
   */
  message: StreamRunAgentDataMessage;
  /**
   * Log probability information for the choice.
   */
  logprobs?: Logprobs | null | undefined;
};

export type DataPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type DataCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type DataUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: DataPromptTokensDetails | null | undefined;
  completionTokensDetails?: DataCompletionTokensDetails | null | undefined;
};

export type StreamRunAgentDataAgentsData = {
  agentId: string;
  messageDifference: { [k: string]: MessageDifference };
  choice?: Choice | undefined;
  choiceIndex?: number | undefined;
  iteration: number;
  accumulatedExecutionTime: number;
  responseId?: string | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: DataUsage | undefined;
};

export type Data3 = {
  type: StreamRunAgentDataAgentsResponseType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataAgentsData;
};

export const StreamRunAgentDataAgentsType = {
  EventAgentsStarted: "event.agents.started",
} as const;
export type StreamRunAgentDataAgentsType = ClosedEnum<
  typeof StreamRunAgentDataAgentsType
>;

/**
 * Extended A2A message role
 */
export const DataRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type DataRole = ClosedEnum<typeof DataRole>;

export const StreamRunAgentPartsAgentsResponse200TextEventStreamKind = {
  ToolResult: "tool_result",
} as const;
export type StreamRunAgentPartsAgentsResponse200TextEventStreamKind =
  ClosedEnum<typeof StreamRunAgentPartsAgentsResponse200TextEventStreamKind>;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type StreamRunAgentPartsToolResultPart = {
  kind: StreamRunAgentPartsAgentsResponse200TextEventStreamKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponse200Kind = {
  ToolCall: "tool_call",
} as const;
export type StreamRunAgentPartsAgentsResponse200Kind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsResponse200Kind
>;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type StreamRunAgentPartsToolCallPart = {
  kind: StreamRunAgentPartsAgentsResponse200Kind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsResponseKind = {
  File: "file",
} as const;
export type StreamRunAgentPartsAgentsResponseKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsResponseKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileAgentsFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileAgentsBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPartsFile =
  | StreamRunAgentFileAgentsBinaryFormat
  | StreamRunAgentFileAgentsFileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type StreamRunAgentPartsFilePart = {
  kind: StreamRunAgentPartsAgentsResponseKind;
  file:
    | StreamRunAgentFileAgentsBinaryFormat
    | StreamRunAgentFileAgentsFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsKind = {
  Data: "data",
} as const;
export type StreamRunAgentPartsAgentsKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsKind
>;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type StreamRunAgentPartsDataPart = {
  kind: StreamRunAgentPartsAgentsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsKind = {
  Text: "text",
} as const;
export type StreamRunAgentPartsKind = ClosedEnum<
  typeof StreamRunAgentPartsKind
>;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type StreamRunAgentPartsTextPart = {
  kind: StreamRunAgentPartsKind;
  text: string;
};

export type DataParts =
  | StreamRunAgentPartsToolCallPart
  | StreamRunAgentPartsTextPart
  | StreamRunAgentPartsDataPart
  | StreamRunAgentPartsFilePart
  | StreamRunAgentPartsToolResultPart;

export type InputMessage = {
  messageId?: string | undefined;
  /**
   * Extended A2A message role
   */
  role: DataRole;
  parts: Array<
    | StreamRunAgentPartsToolCallPart
    | StreamRunAgentPartsTextPart
    | StreamRunAgentPartsDataPart
    | StreamRunAgentPartsFilePart
    | StreamRunAgentPartsToolResultPart
  >;
  metadata?: { [k: string]: any } | undefined;
};

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const DataToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type DataToolApprovalRequired = ClosedEnum<
  typeof DataToolApprovalRequired
>;

export type StreamRunAgentDataConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type StreamRunAgentDataTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<StreamRunAgentDataConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const DataExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type DataExecuteOn = ClosedEnum<typeof DataExecuteOn>;

export type DataEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: DataExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentDataExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentDataExecuteOn = ClosedEnum<
  typeof StreamRunAgentDataExecuteOn
>;

export type DataGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentDataExecuteOn;
};

export type DataSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: DataToolApprovalRequired | undefined;
  tools?: Array<StreamRunAgentDataTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<DataEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<DataGuardrails> | undefined;
};

export type StreamRunAgentDataData = {
  integrationId?: string | undefined;
  inputMessage: InputMessage;
  modelId: string;
  instructions: string;
  systemPrompt: string;
  settings?: DataSettings | undefined;
  agentManifestId: string;
  agentKey: string;
  variables?: { [k: string]: any } | undefined;
  toolExecutionId?: string | undefined;
  isContinuation?: boolean | undefined;
  stream?: boolean | undefined;
  responseId?: string | undefined;
};

export type Data2 = {
  type: StreamRunAgentDataAgentsType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: StreamRunAgentDataData;
};

export const StreamRunAgentDataType = {
  AgentsExecutionStarted: "agents.execution_started",
} as const;
export type StreamRunAgentDataType = ClosedEnum<typeof StreamRunAgentDataType>;

export type DataData = {
  /**
   * Agent execution task ID (ULID)
   */
  agentTaskId: string;
  /**
   * Workspace ID
   */
  workspaceId: string;
  /**
   * Trace ID for the workflow run
   */
  traceId: string;
};

export type Data1 = {
  type: StreamRunAgentDataType;
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: DataData;
};

export type StreamRunAgentData =
  | Data1
  | Data2
  | Data3
  | Data4
  | StreamRunAgentData5
  | StreamRunAgentData6
  | Seven
  | Eight
  | Nine
  | Ten
  | Eleven
  | Twelve
  | Thirteen
  | Fourteen
  | Fifteen
  | Sixteen
  | Seventeen;

/**
 * Server-Sent Event stream successfully established. Delivers real-time agent execution events including message fragments, tool invocations, intermediate results, and completion status. Stream terminates with [DONE] sentinel upon completion.
 */
export type StreamRunAgentResponseBody = {
  data:
    | Data1
    | Data2
    | Data3
    | Data4
    | StreamRunAgentData5
    | StreamRunAgentData6
    | Seven
    | Eight
    | Nine
    | Ten
    | Eleven
    | Twelve
    | Thirteen
    | Fourteen
    | Fifteen
    | Sixteen
    | Seventeen;
};

/** @internal */
export const StreamRunAgentModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationVoice> = z.nativeEnum(
    StreamRunAgentModelConfigurationVoice,
  );
/** @internal */
export const StreamRunAgentModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationVoice> =
    StreamRunAgentModelConfigurationVoice$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationFormat> = z.nativeEnum(
    StreamRunAgentModelConfigurationFormat,
  );
/** @internal */
export const StreamRunAgentModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationFormat> =
    StreamRunAgentModelConfigurationFormat$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationAudio$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: StreamRunAgentModelConfigurationVoice$inboundSchema,
  format: StreamRunAgentModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type StreamRunAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationAudio
> = z.object({
  voice: StreamRunAgentModelConfigurationVoice$outboundSchema,
  format: StreamRunAgentModelConfigurationFormat$outboundSchema,
});

export function streamRunAgentModelConfigurationAudioToJSON(
  streamRunAgentModelConfigurationAudio: StreamRunAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentModelConfigurationAudio,
    ),
  );
}
export function streamRunAgentModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsRequestType> = z
    .nativeEnum(StreamRunAgentResponseFormatAgentsRequestType);
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsRequestType> =
    StreamRunAgentResponseFormatAgentsRequestType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsJsonSchema:
    StreamRunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatJSONSchema$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestType$inboundSchema,
  json_schema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type StreamRunAgentResponseFormatJSONSchema$Outbound = {
  type: string;
  json_schema: StreamRunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONSchema
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestType$outboundSchema,
  jsonSchema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function streamRunAgentResponseFormatJSONSchemaToJSON(
  streamRunAgentResponseFormatJSONSchema:
    StreamRunAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatJSONSchema,
    ),
  );
}
export function streamRunAgentResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsType> = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsType,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsType> =
    StreamRunAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONObject
> = z.object({
  type: StreamRunAgentResponseFormatAgentsType$outboundSchema,
});

export function streamRunAgentResponseFormatJSONObjectToJSON(
  streamRunAgentResponseFormatJSONObject:
    StreamRunAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatJSONObject,
    ),
  );
}
export function streamRunAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentResponseFormatType
> = z.nativeEnum(StreamRunAgentResponseFormatType);
/** @internal */
export const StreamRunAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentResponseFormatType
> = StreamRunAgentResponseFormatType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatText$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatText
> = z.object({
  type: StreamRunAgentResponseFormatType$outboundSchema,
});

export function streamRunAgentResponseFormatTextToJSON(
  streamRunAgentResponseFormatText: StreamRunAgentResponseFormatText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatText$outboundSchema.parse(
      streamRunAgentResponseFormatText,
    ),
  );
}
export function streamRunAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatJSONSchema$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatText$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONObject$inboundSchema),
  ]);
/** @internal */
export type StreamRunAgentModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatJSONSchema$Outbound
  | StreamRunAgentResponseFormatText$Outbound
  | StreamRunAgentResponseFormatJSONObject$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
  ]);

export function streamRunAgentModelConfigurationResponseFormatToJSON(
  streamRunAgentModelConfigurationResponseFormat:
    StreamRunAgentModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentModelConfigurationResponseFormat,
    ),
  );
}
export function streamRunAgentModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationStop$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentModelConfigurationStop$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentModelConfigurationStopToJSON(
  streamRunAgentModelConfigurationStop: StreamRunAgentModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStop$outboundSchema.parse(
      streamRunAgentModelConfigurationStop,
    ),
  );
}
export function streamRunAgentModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type StreamRunAgentModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentModelConfigurationStreamOptionsToJSON(
  streamRunAgentModelConfigurationStreamOptions:
    StreamRunAgentModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentModelConfigurationStreamOptions,
    ),
  );
}
export function streamRunAgentModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationType> = z.nativeEnum(
    StreamRunAgentModelConfigurationType,
  );
/** @internal */
export const StreamRunAgentModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationType> =
    StreamRunAgentModelConfigurationType$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationThinkingLevel> = z
    .nativeEnum(StreamRunAgentModelConfigurationThinkingLevel);
/** @internal */
export const StreamRunAgentModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationThinkingLevel> =
    StreamRunAgentModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationThinking$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: StreamRunAgentModelConfigurationThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type StreamRunAgentModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationThinking$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationThinking
> = z.object({
  type: StreamRunAgentModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: StreamRunAgentModelConfigurationThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function streamRunAgentModelConfigurationThinkingToJSON(
  streamRunAgentModelConfigurationThinking:
    StreamRunAgentModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentModelConfigurationThinking,
    ),
  );
}
export function streamRunAgentModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = z.nativeEnum(StreamRunAgentToolChoiceType);
/** @internal */
export const StreamRunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = StreamRunAgentToolChoiceType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function streamRunAgentToolChoiceFunctionToJSON(
  streamRunAgentToolChoiceFunction: StreamRunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceFunction$outboundSchema.parse(
      streamRunAgentToolChoiceFunction,
    ),
  );
}
export function streamRunAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoice2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoice2
> = z.object({
  type: StreamRunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$outboundSchema),
});

export function streamRunAgentToolChoice2ToJSON(
  streamRunAgentToolChoice2: StreamRunAgentToolChoice2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoice2$outboundSchema.parse(streamRunAgentToolChoice2),
  );
}
export function streamRunAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = z.nativeEnum(StreamRunAgentToolChoice1);
/** @internal */
export const StreamRunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = StreamRunAgentToolChoice1$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationToolChoice$inboundSchema:
  z.ZodType<StreamRunAgentModelConfigurationToolChoice, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
      StreamRunAgentToolChoice1$inboundSchema,
    ]);
/** @internal */
export type StreamRunAgentModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
    StreamRunAgentToolChoice1$outboundSchema,
  ]);

export function streamRunAgentModelConfigurationToolChoiceToJSON(
  streamRunAgentModelConfigurationToolChoice:
    StreamRunAgentModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentModelConfigurationToolChoice,
    ),
  );
}
export function streamRunAgentModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentModelConfigurationModalities);
/** @internal */
export const StreamRunAgentModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationModalities> =
    StreamRunAgentModelConfigurationModalities$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationParameters$inboundSchema:
  z.ZodType<StreamRunAgentModelConfigurationParameters, z.ZodTypeDef, unknown> =
    z.object({
      audio: z.nullable(
        z.lazy(() => StreamRunAgentModelConfigurationAudio$inboundSchema),
      ).optional(),
      frequency_penalty: z.nullable(z.number()).optional(),
      max_tokens: z.nullable(z.number().int()).optional(),
      max_completion_tokens: z.nullable(z.number().int()).optional(),
      logprobs: z.nullable(z.boolean()).optional(),
      top_logprobs: z.nullable(z.number().int()).optional(),
      n: z.nullable(z.number().int()).optional(),
      presence_penalty: z.nullable(z.number()).optional(),
      response_format: z.union([
        z.lazy(() => StreamRunAgentResponseFormatJSONSchema$inboundSchema),
        z.lazy(() => StreamRunAgentResponseFormatText$inboundSchema),
        z.lazy(() => StreamRunAgentResponseFormatJSONObject$inboundSchema),
      ]).optional(),
      reasoning_effort: z.string().optional(),
      verbosity: z.string().optional(),
      seed: z.nullable(z.number()).optional(),
      stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
      stream_options: z.nullable(
        z.lazy(() =>
          StreamRunAgentModelConfigurationStreamOptions$inboundSchema
        ),
      ).optional(),
      thinking: z.lazy(() =>
        StreamRunAgentModelConfigurationThinking$inboundSchema
      ).optional(),
      temperature: z.nullable(z.number()).optional(),
      top_p: z.nullable(z.number()).optional(),
      top_k: z.nullable(z.number()).optional(),
      tool_choice: z.union([
        z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
        StreamRunAgentToolChoice1$inboundSchema,
      ]).optional(),
      parallel_tool_calls: z.boolean().optional(),
      modalities: z.nullable(
        z.array(StreamRunAgentModelConfigurationModalities$inboundSchema),
      ).optional(),
    }).transform((v) => {
      return remap$(v, {
        "frequency_penalty": "frequencyPenalty",
        "max_tokens": "maxTokens",
        "max_completion_tokens": "maxCompletionTokens",
        "top_logprobs": "topLogprobs",
        "presence_penalty": "presencePenalty",
        "response_format": "responseFormat",
        "reasoning_effort": "reasoningEffort",
        "stream_options": "streamOptions",
        "top_p": "topP",
        "top_k": "topK",
        "tool_choice": "toolChoice",
        "parallel_tool_calls": "parallelToolCalls",
      });
    });
/** @internal */
export type StreamRunAgentModelConfigurationParameters$Outbound = {
  audio?: StreamRunAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatJSONSchema$Outbound
    | StreamRunAgentResponseFormatText$Outbound
    | StreamRunAgentResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: StreamRunAgentModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => StreamRunAgentModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      StreamRunAgentModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
      StreamRunAgentToolChoice1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(StreamRunAgentModelConfigurationModalities$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function streamRunAgentModelConfigurationParametersToJSON(
  streamRunAgentModelConfigurationParameters:
    StreamRunAgentModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentModelConfigurationParameters,
    ),
  );
}
export function streamRunAgentModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationRetry$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type StreamRunAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function streamRunAgentModelConfigurationRetryToJSON(
  streamRunAgentModelConfigurationRetry: StreamRunAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationRetry$outboundSchema.parse(
      streamRunAgentModelConfigurationRetry,
    ),
  );
}
export function streamRunAgentModelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfiguration2$inboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentModelConfigurationParameters$inboundSchema
  ).optional(),
  retry: z.lazy(() => StreamRunAgentModelConfigurationRetry$inboundSchema)
    .optional(),
});
/** @internal */
export type StreamRunAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: StreamRunAgentModelConfigurationParameters$Outbound | undefined;
  retry?: StreamRunAgentModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModelConfiguration2$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentModelConfigurationParameters$outboundSchema
  ).optional(),
  retry: z.lazy(() => StreamRunAgentModelConfigurationRetry$outboundSchema)
    .optional(),
});

export function streamRunAgentModelConfiguration2ToJSON(
  streamRunAgentModelConfiguration2: StreamRunAgentModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration2$outboundSchema.parse(
      streamRunAgentModelConfiguration2,
    ),
  );
}
export function streamRunAgentModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfiguration$inboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type StreamRunAgentModelConfiguration$Outbound =
  | StreamRunAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentModelConfigurationToJSON(
  streamRunAgentModelConfiguration: StreamRunAgentModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration$outboundSchema.parse(
      streamRunAgentModelConfiguration,
    ),
  );
}
export function streamRunAgentModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfiguration' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationVoice);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationVoice> =
    StreamRunAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationFormat);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationFormat> =
    StreamRunAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: StreamRunAgentFallbackModelConfigurationVoice$inboundSchema,
    format: StreamRunAgentFallbackModelConfigurationFormat$inboundSchema,
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: StreamRunAgentFallbackModelConfigurationVoice$outboundSchema,
    format: StreamRunAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function streamRunAgentFallbackModelConfigurationAudioToJSON(
  streamRunAgentFallbackModelConfigurationAudio:
    StreamRunAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  > = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  > =
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}
export function streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema,
    json_schema: z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: string;
  json_schema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type:
      StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$outboundSchema,
    jsonSchema: z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function streamRunAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestJSONSchema:
    StreamRunAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsRequestJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsRequestJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsRequestJSONSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > =
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema,
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJSONObject
  > = z.object({
    type:
      StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema,
  });

export function streamRunAgentResponseFormatAgentsJSONObjectToJSON(
  streamRunAgentResponseFormatAgentsJSONObject:
    StreamRunAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType
  > = z.nativeEnum(StreamRunAgentResponseFormatAgentsRequestRequestBodyType);
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType
  > = StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormatAgentsText$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgentsText
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema,
});

export function streamRunAgentResponseFormatAgentsTextToJSON(
  streamRunAgentResponseFormatAgentsText:
    StreamRunAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsText$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsText,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
    ),
    z.lazy(() => StreamRunAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema),
  ]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound
  | StreamRunAgentResponseFormatAgentsText$Outbound
  | StreamRunAgentResponseFormatAgentsJSONObject$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
    ),
    z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
  ]);

export function streamRunAgentFallbackModelConfigurationResponseFormatToJSON(
  streamRunAgentFallbackModelConfigurationResponseFormat:
    StreamRunAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentFallbackModelConfigurationStopToJSON(
  streamRunAgentFallbackModelConfigurationStop:
    StreamRunAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStop$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStop,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentFallbackModelConfigurationStreamOptionsToJSON(
  streamRunAgentFallbackModelConfigurationStreamOptions:
    StreamRunAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationType> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationType);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationType> =
    StreamRunAgentFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentFallbackModelConfigurationThinkingLevel
  > = z.nativeEnum(StreamRunAgentFallbackModelConfigurationThinkingLevel);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentFallbackModelConfigurationThinkingLevel
  > = StreamRunAgentFallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentFallbackModelConfigurationType$inboundSchema,
    budget_tokens: z.number(),
    thinking_level:
      StreamRunAgentFallbackModelConfigurationThinkingLevel$inboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      "budget_tokens": "budgetTokens",
      "thinking_level": "thinkingLevel",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationThinking
  > = z.object({
    type: StreamRunAgentFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
    thinkingLevel:
      StreamRunAgentFallbackModelConfigurationThinkingLevel$outboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
      thinkingLevel: "thinking_level",
    });
  });

export function streamRunAgentFallbackModelConfigurationThinkingToJSON(
  streamRunAgentFallbackModelConfigurationThinking:
    StreamRunAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = z.nativeEnum(StreamRunAgentToolChoiceAgentsType);
/** @internal */
export const StreamRunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = StreamRunAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function streamRunAgentToolChoiceAgentsFunctionToJSON(
  streamRunAgentToolChoiceAgentsFunction:
    StreamRunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      streamRunAgentToolChoiceAgentsFunction,
    ),
  );
}
export function streamRunAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgents2
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function streamRunAgentToolChoiceAgents2ToJSON(
  streamRunAgentToolChoiceAgents2: StreamRunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgents2$outboundSchema.parse(
      streamRunAgentToolChoiceAgents2,
    ),
  );
}
export function streamRunAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = z.nativeEnum(StreamRunAgentToolChoiceAgents1);
/** @internal */
export const StreamRunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = StreamRunAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
    StreamRunAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
    StreamRunAgentToolChoiceAgents1$outboundSchema,
  ]);

export function streamRunAgentFallbackModelConfigurationToolChoiceToJSON(
  streamRunAgentFallbackModelConfigurationToolChoice:
    StreamRunAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationModalities);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationModalities> =
    StreamRunAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => StreamRunAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
      ),
      z.lazy(() => StreamRunAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
      StreamRunAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(StreamRunAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | StreamRunAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | StreamRunAgentResponseFormatAgentsText$Outbound
    | StreamRunAgentResponseFormatAgentsJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | StreamRunAgentFallbackModelConfigurationThinking$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
      z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
      StreamRunAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        StreamRunAgentFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function streamRunAgentFallbackModelConfigurationParametersToJSON(
  streamRunAgentFallbackModelConfigurationParameters:
    StreamRunAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type StreamRunAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | StreamRunAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
  });

export function streamRunAgentFallbackModelConfiguration2ToJSON(
  streamRunAgentFallbackModelConfiguration2:
    StreamRunAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration2$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration2,
    ),
  );
}
export function streamRunAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type StreamRunAgentFallbackModelConfiguration$Outbound =
  | StreamRunAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentFallbackModelConfigurationToJSON(
  streamRunAgentFallbackModelConfiguration:
    StreamRunAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = z.nativeEnum(StreamRunAgentRoleToolMessage);
/** @internal */
export const StreamRunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = StreamRunAgentRoleToolMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = z.nativeEnum(StreamRunAgentRoleUserMessage);
/** @internal */
export const StreamRunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = StreamRunAgentRoleUserMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRole$inboundSchema: z.ZodType<
  StreamRunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  StreamRunAgentRoleUserMessage$inboundSchema,
  StreamRunAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type StreamRunAgentRole$Outbound = string | string;

/** @internal */
export const StreamRunAgentRole$outboundSchema: z.ZodType<
  StreamRunAgentRole$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRole
> = z.union([
  StreamRunAgentRoleUserMessage$outboundSchema,
  StreamRunAgentRoleToolMessage$outboundSchema,
]);

export function streamRunAgentRoleToJSON(
  streamRunAgentRole: StreamRunAgentRole,
): string {
  return JSON.stringify(
    StreamRunAgentRole$outboundSchema.parse(streamRunAgentRole),
  );
}
export function streamRunAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRole' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsRequestKind> = z
    .nativeEnum(StreamRunAgentPublicMessagePartAgentsRequestKind);
/** @internal */
export const StreamRunAgentPublicMessagePartAgentsRequestKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsRequestKind> =
    StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema;

/** @internal */
export const StreamRunAgentPublicMessagePartToolResultPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPublicMessagePartToolResultPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind: StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPublicMessagePartToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPublicMessagePartToolResultPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPublicMessagePartToolResultPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPublicMessagePartToolResultPart
  > = z.object({
    kind: StreamRunAgentPublicMessagePartAgentsRequestKind$outboundSchema,
    toolCallId: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPublicMessagePartToolResultPartToJSON(
  streamRunAgentPublicMessagePartToolResultPart:
    StreamRunAgentPublicMessagePartToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartToolResultPart$outboundSchema.parse(
      streamRunAgentPublicMessagePartToolResultPart,
    ),
  );
}
export function streamRunAgentPublicMessagePartToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartToolResultPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartToolResultPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartAgentsKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsKind> = z
    .nativeEnum(StreamRunAgentPublicMessagePartAgentsKind);
/** @internal */
export const StreamRunAgentPublicMessagePartAgentsKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsKind> =
    StreamRunAgentPublicMessagePartAgentsKind$inboundSchema;

/** @internal */
export const StreamRunAgentFileFileInURIFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileFileInURIFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileFileInURIFormatToJSON(
  streamRunAgentFileFileInURIFormat: StreamRunAgentFileFileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileFileInURIFormat$outboundSchema.parse(
      streamRunAgentFileFileInURIFormat,
    ),
  );
}
export function streamRunAgentFileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileBinaryFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileBinaryFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileBinaryFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileBinaryFormatToJSON(
  streamRunAgentFileBinaryFormat: StreamRunAgentFileBinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileBinaryFormat$outboundSchema.parse(
      streamRunAgentFileBinaryFormat,
    ),
  );
}
export function streamRunAgentFileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartFile$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFileBinaryFormat$inboundSchema),
  z.lazy(() => StreamRunAgentFileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPublicMessagePartFile$Outbound =
  | StreamRunAgentFileBinaryFormat$Outbound
  | StreamRunAgentFileFileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePartFile$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartFile
> = z.union([
  z.lazy(() => StreamRunAgentFileBinaryFormat$outboundSchema),
  z.lazy(() => StreamRunAgentFileFileInURIFormat$outboundSchema),
]);

export function streamRunAgentPublicMessagePartFileToJSON(
  streamRunAgentPublicMessagePartFile: StreamRunAgentPublicMessagePartFile,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartFile$outboundSchema.parse(
      streamRunAgentPublicMessagePartFile,
    ),
  );
}
export function streamRunAgentPublicMessagePartFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPublicMessagePartFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPublicMessagePartFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartFilePart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPublicMessagePartAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileBinaryFormat$inboundSchema),
    z.lazy(() => StreamRunAgentFileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPublicMessagePartFilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileBinaryFormat$Outbound
    | StreamRunAgentFileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPublicMessagePartFilePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFilePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartFilePart
> = z.object({
  kind: StreamRunAgentPublicMessagePartAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileBinaryFormat$outboundSchema),
    z.lazy(() => StreamRunAgentFileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPublicMessagePartFilePartToJSON(
  streamRunAgentPublicMessagePartFilePart:
    StreamRunAgentPublicMessagePartFilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartFilePart$outboundSchema.parse(
      streamRunAgentPublicMessagePartFilePart,
    ),
  );
}
export function streamRunAgentPublicMessagePartFilePartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartFilePart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartFilePart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartFilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPublicMessagePartKind
> = z.nativeEnum(StreamRunAgentPublicMessagePartKind);
/** @internal */
export const StreamRunAgentPublicMessagePartKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartKind> =
    StreamRunAgentPublicMessagePartKind$inboundSchema;

/** @internal */
export const StreamRunAgentPublicMessagePartTextPart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPublicMessagePartKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type StreamRunAgentPublicMessagePartTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPublicMessagePartTextPart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartTextPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartTextPart
> = z.object({
  kind: StreamRunAgentPublicMessagePartKind$outboundSchema,
  text: z.string(),
});

export function streamRunAgentPublicMessagePartTextPartToJSON(
  streamRunAgentPublicMessagePartTextPart:
    StreamRunAgentPublicMessagePartTextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartTextPart$outboundSchema.parse(
      streamRunAgentPublicMessagePartTextPart,
    ),
  );
}
export function streamRunAgentPublicMessagePartTextPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartTextPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartTextPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartTextPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPublicMessagePartTextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartFilePart$inboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPublicMessagePart$Outbound =
  | StreamRunAgentPublicMessagePartTextPart$Outbound
  | StreamRunAgentPublicMessagePartFilePart$Outbound
  | StreamRunAgentPublicMessagePartToolResultPart$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePart
> = z.union([
  z.lazy(() => StreamRunAgentPublicMessagePartTextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartFilePart$outboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$outboundSchema),
]);

export function streamRunAgentPublicMessagePartToJSON(
  streamRunAgentPublicMessagePart: StreamRunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePart$outboundSchema.parse(
      streamRunAgentPublicMessagePart,
    ),
  );
}
export function streamRunAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentA2AMessage$inboundSchema: z.ZodType<
  StreamRunAgentA2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$inboundSchema,
    StreamRunAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPublicMessagePartTextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartFilePart$inboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type StreamRunAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | StreamRunAgentPublicMessagePartTextPart$Outbound
    | StreamRunAgentPublicMessagePartFilePart$Outbound
    | StreamRunAgentPublicMessagePartToolResultPart$Outbound
  >;
};

/** @internal */
export const StreamRunAgentA2AMessage$outboundSchema: z.ZodType<
  StreamRunAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$outboundSchema,
    StreamRunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPublicMessagePartTextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartFilePart$outboundSchema),
      z.lazy(() =>
        StreamRunAgentPublicMessagePartToolResultPart$outboundSchema
      ),
    ]),
  ),
});

export function streamRunAgentA2AMessageToJSON(
  streamRunAgentA2AMessage: StreamRunAgentA2AMessage,
): string {
  return JSON.stringify(
    StreamRunAgentA2AMessage$outboundSchema.parse(streamRunAgentA2AMessage),
  );
}
export function streamRunAgentA2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentA2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentA2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentA2AMessage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentContact$inboundSchema: z.ZodType<
  StreamRunAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type StreamRunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentContact$outboundSchema: z.ZodType<
  StreamRunAgentContact$Outbound,
  z.ZodTypeDef,
  StreamRunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentContactToJSON(
  streamRunAgentContact: StreamRunAgentContact,
): string {
  return JSON.stringify(
    StreamRunAgentContact$outboundSchema.parse(streamRunAgentContact),
  );
}
export function streamRunAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentContact' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentThread$inboundSchema: z.ZodType<
  StreamRunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type StreamRunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentThread$outboundSchema: z.ZodType<
  StreamRunAgentThread$Outbound,
  z.ZodTypeDef,
  StreamRunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamRunAgentThreadToJSON(
  streamRunAgentThread: StreamRunAgentThread,
): string {
  return JSON.stringify(
    StreamRunAgentThread$outboundSchema.parse(streamRunAgentThread),
  );
}
export function streamRunAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentThread' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMemory$inboundSchema: z.ZodType<
  StreamRunAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamRunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentMemory$outboundSchema: z.ZodType<
  StreamRunAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentMemoryToJSON(
  streamRunAgentMemory: StreamRunAgentMemory,
): string {
  return JSON.stringify(
    StreamRunAgentMemory$outboundSchema.parse(streamRunAgentMemory),
  );
}
export function streamRunAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMemory' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentKnowledgeBases$inboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type StreamRunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const StreamRunAgentKnowledgeBases$outboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  StreamRunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function streamRunAgentKnowledgeBasesToJSON(
  streamRunAgentKnowledgeBases: StreamRunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    StreamRunAgentKnowledgeBases$outboundSchema.parse(
      streamRunAgentKnowledgeBases,
    ),
  );
}
export function streamRunAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentTeamOfAgents$inboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type StreamRunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const StreamRunAgentTeamOfAgents$outboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function streamRunAgentTeamOfAgentsToJSON(
  streamRunAgentTeamOfAgents: StreamRunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    StreamRunAgentTeamOfAgents$outboundSchema.parse(streamRunAgentTeamOfAgents),
  );
}
export function streamRunAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsHeaders,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsHeaders
  > = z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });

export function streamRunAgentAgentToolInputRunAgentsHeadersToJSON(
  streamRunAgentAgentToolInputRunAgentsHeaders:
    StreamRunAgentAgentToolInputRunAgentsHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsHeaders,
    ),
  );
}
export function streamRunAgentAgentToolInputRunAgentsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunAgentsHeaders,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunAgentsHeaders' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema;

/** @internal */
export const AgentToolInputRunSchema$inboundSchema: z.ZodType<
  AgentToolInputRunSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type AgentToolInputRunSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const AgentToolInputRunSchema$outboundSchema: z.ZodType<
  AgentToolInputRunSchema$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunSchema
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function agentToolInputRunSchemaToJSON(
  agentToolInputRunSchema: AgentToolInputRunSchema,
): string {
  return JSON.stringify(
    AgentToolInputRunSchema$outboundSchema.parse(agentToolInputRunSchema),
  );
}
export function agentToolInputRunSchemaFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunSchema' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunTools$inboundSchema: z.ZodType<
  AgentToolInputRunTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KARZ2EHKMKDXF7W6S51R9N4G"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => AgentToolInputRunSchema$inboundSchema),
});
/** @internal */
export type AgentToolInputRunTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: AgentToolInputRunSchema$Outbound;
};

/** @internal */
export const AgentToolInputRunTools$outboundSchema: z.ZodType<
  AgentToolInputRunTools$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunTools
> = z.object({
  id: z.string().default("01KARZ2EHKMKDXF7W6S51R9N4G"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => AgentToolInputRunSchema$outboundSchema),
});

export function agentToolInputRunToolsToJSON(
  agentToolInputRunTools: AgentToolInputRunTools,
): string {
  return JSON.stringify(
    AgentToolInputRunTools$outboundSchema.parse(agentToolInputRunTools),
  );
}
export function agentToolInputRunToolsFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunTools' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunConnectionType
> = z.nativeEnum(AgentToolInputRunConnectionType);
/** @internal */
export const AgentToolInputRunConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunConnectionType
> = AgentToolInputRunConnectionType$inboundSchema;

/** @internal */
export const AgentToolInputRunMcp$inboundSchema: z.ZodType<
  AgentToolInputRunMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(
    z.lazy(() => StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => AgentToolInputRunTools$inboundSchema)),
  connection_type: AgentToolInputRunConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type AgentToolInputRunMcp$Outbound = {
  server_url: string;
  headers?: {
    [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound;
  } | undefined;
  tools: Array<AgentToolInputRunTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const AgentToolInputRunMcp$outboundSchema: z.ZodType<
  AgentToolInputRunMcp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(
    z.lazy(() => StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => AgentToolInputRunTools$outboundSchema)),
  connectionType: AgentToolInputRunConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function agentToolInputRunMcpToJSON(
  agentToolInputRunMcp: AgentToolInputRunMcp,
): string {
  return JSON.stringify(
    AgentToolInputRunMcp$outboundSchema.parse(agentToolInputRunMcp),
  );
}
export function agentToolInputRunMcpFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunMcp' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunMCPToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunMCPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => AgentToolInputRunMcp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunMCPToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  mcp: AgentToolInputRunMcp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunMCPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunMCPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMCPToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => AgentToolInputRunMcp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunMCPToolRunToJSON(
  agentToolInputRunMCPToolRun: AgentToolInputRunMCPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunMCPToolRun$outboundSchema.parse(
      agentToolInputRunMCPToolRun,
    ),
  );
}
export function agentToolInputRunMCPToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunMCPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunMCPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunMCPToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsParameters,
    z.ZodTypeDef,
    unknown
  > = collectExtraKeys$(
    z.object({
      type:
        StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema,
      properties: z.record(z.any()),
      required: z.array(z.string()),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  );
/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunAgentsParametersToJSON(
  streamRunAgentAgentToolInputRunAgentsParameters:
    StreamRunAgentAgentToolInputRunAgentsParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsParameters,
    ),
  );
}
export function streamRunAgentAgentToolInputRunAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunAgentsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunAgentsParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type StreamRunAgentAgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?:
    | StreamRunAgentAgentToolInputRunAgentsParameters$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema
  ).optional(),
});

export function streamRunAgentAgentToolInputRunFunctionToJSON(
  streamRunAgentAgentToolInputRunFunction:
    StreamRunAgentAgentToolInputRunFunction,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunFunction$outboundSchema.parse(
      streamRunAgentAgentToolInputRunFunction,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunFunction' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunFunctionToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => StreamRunAgentAgentToolInputRunFunction$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunFunctionToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunFunctionToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunctionToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() =>
    StreamRunAgentAgentToolInputRunFunction$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunFunctionToolRunToJSON(
  agentToolInputRunFunctionToolRun: AgentToolInputRunFunctionToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunFunctionToolRun$outboundSchema.parse(
      agentToolInputRunFunctionToolRun,
    ),
  );
}
export function agentToolInputRunFunctionToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunFunctionToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunFunctionToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunFunctionToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunParameters$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type StreamRunAgentAgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunParametersToJSON(
  streamRunAgentAgentToolInputRunParameters:
    StreamRunAgentAgentToolInputRunParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunParameters,
    ),
  );
}
export function streamRunAgentAgentToolInputRunParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunParameters' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunLanguage$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = z.nativeEnum(AgentToolInputRunLanguage);
/** @internal */
export const AgentToolInputRunLanguage$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = AgentToolInputRunLanguage$inboundSchema;

/** @internal */
export const AgentToolInputRunCodeTool$inboundSchema: z.ZodType<
  AgentToolInputRunCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunParameters$inboundSchema
  ).optional(),
  language: AgentToolInputRunLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type AgentToolInputRunCodeTool$Outbound = {
  parameters?: StreamRunAgentAgentToolInputRunParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const AgentToolInputRunCodeTool$outboundSchema: z.ZodType<
  AgentToolInputRunCodeTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeTool
> = z.object({
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunParameters$outboundSchema
  ).optional(),
  language: AgentToolInputRunLanguage$outboundSchema,
  code: z.string(),
});

export function agentToolInputRunCodeToolToJSON(
  agentToolInputRunCodeTool: AgentToolInputRunCodeTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeTool$outboundSchema.parse(agentToolInputRunCodeTool),
  );
}
export function agentToolInputRunCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunCodeToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  code_tool: z.lazy(() => AgentToolInputRunCodeTool$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "code_tool": "codeTool",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunCodeToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: AgentToolInputRunCodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunCodeToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => AgentToolInputRunCodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCodeToolRunToJSON(
  agentToolInputRunCodeToolRun: AgentToolInputRunCodeToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeToolRun$outboundSchema.parse(
      agentToolInputRunCodeToolRun,
    ),
  );
}
export function agentToolInputRunCodeToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema;

/** @internal */
export const AgentToolInputRunMethod$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = z.nativeEnum(AgentToolInputRunMethod);
/** @internal */
export const AgentToolInputRunMethod$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = AgentToolInputRunMethod$inboundSchema;

/** @internal */
export const StreamRunAgentHeaders2$inboundSchema: z.ZodType<
  StreamRunAgentHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type StreamRunAgentHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentHeaders2$outboundSchema: z.ZodType<
  StreamRunAgentHeaders2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function streamRunAgentHeaders2ToJSON(
  streamRunAgentHeaders2: StreamRunAgentHeaders2,
): string {
  return JSON.stringify(
    StreamRunAgentHeaders2$outboundSchema.parse(streamRunAgentHeaders2),
  );
}
export function streamRunAgentHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentHeaders2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunHeaders$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => StreamRunAgentHeaders2$inboundSchema), z.string()]);
/** @internal */
export type StreamRunAgentAgentToolInputRunHeaders$Outbound =
  | StreamRunAgentHeaders2$Outbound
  | string;

/** @internal */
export const StreamRunAgentAgentToolInputRunHeaders$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunHeaders$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunHeaders
> = z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]);

export function streamRunAgentAgentToolInputRunHeadersToJSON(
  streamRunAgentAgentToolInputRunHeaders:
    StreamRunAgentAgentToolInputRunHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunHeaders,
    ),
  );
}
export function streamRunAgentAgentToolInputRunHeadersFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRunHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunHeaders' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunBlueprint$inboundSchema: z.ZodType<
  AgentToolInputRunBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => StreamRunAgentHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type AgentToolInputRunBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: StreamRunAgentHeaders2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const AgentToolInputRunBlueprint$outboundSchema: z.ZodType<
  AgentToolInputRunBlueprint$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunBlueprint
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function agentToolInputRunBlueprintToJSON(
  agentToolInputRunBlueprint: AgentToolInputRunBlueprint,
): string {
  return JSON.stringify(
    AgentToolInputRunBlueprint$outboundSchema.parse(agentToolInputRunBlueprint),
  );
}
export function agentToolInputRunBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunBlueprint' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema;

/** @internal */
export const AgentToolInputRunDefaultValue$inboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AgentToolInputRunDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const AgentToolInputRunDefaultValue$outboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function agentToolInputRunDefaultValueToJSON(
  agentToolInputRunDefaultValue: AgentToolInputRunDefaultValue,
): string {
  return JSON.stringify(
    AgentToolInputRunDefaultValue$outboundSchema.parse(
      agentToolInputRunDefaultValue,
    ),
  );
}
export function agentToolInputRunDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunDefaultValue' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunArguments$inboundSchema: z.ZodType<
  AgentToolInputRunArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type AgentToolInputRunArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const AgentToolInputRunArguments$outboundSchema: z.ZodType<
  AgentToolInputRunArguments$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunArguments
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function agentToolInputRunArgumentsToJSON(
  agentToolInputRunArguments: AgentToolInputRunArguments,
): string {
  return JSON.stringify(
    AgentToolInputRunArguments$outboundSchema.parse(agentToolInputRunArguments),
  );
}
export function agentToolInputRunArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunArguments' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHttp$inboundSchema: z.ZodType<
  AgentToolInputRunHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type AgentToolInputRunHttp$Outbound = {
  blueprint: AgentToolInputRunBlueprint$Outbound;
  arguments?: { [k: string]: AgentToolInputRunArguments$Outbound } | undefined;
};

/** @internal */
export const AgentToolInputRunHttp$outboundSchema: z.ZodType<
  AgentToolInputRunHttp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHttp
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$outboundSchema))
    .optional(),
});

export function agentToolInputRunHttpToJSON(
  agentToolInputRunHttp: AgentToolInputRunHttp,
): string {
  return JSON.stringify(
    AgentToolInputRunHttp$outboundSchema.parse(agentToolInputRunHttp),
  );
}
export function agentToolInputRunHttpFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHttp' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHTTPToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunHTTPToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: AgentToolInputRunHttp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunHTTPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHTTPToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunHTTPToolRunToJSON(
  agentToolInputRunHTTPToolRun: AgentToolInputRunHTTPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunHTTPToolRun$outboundSchema.parse(
      agentToolInputRunHTTPToolRun,
    ),
  );
}
export function agentToolInputRunHTTPToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHTTPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHTTPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHTTPToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCurrentDateTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCurrentDateToolToJSON(
  streamRunAgentAgentToolInputRunCurrentDateTool:
    StreamRunAgentAgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCurrentDateTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCurrentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCurrentDateTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCurrentDateTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolToJSON(
  streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool:
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound =
  {
    type: string;
    requires_approval?: boolean | undefined;
  };

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool:
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolToJSON(
  streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool:
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool),
  );
}
export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool:
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunWriteMemoryStoreTool:
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunQueryMemoryStoreTool:
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = z.nativeEnum(StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveAgentsToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveAgentsTool:
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunRetrieveAgentsTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsRequestType> = z
    .nativeEnum(StreamRunAgentAgentToolInputRunAgentsRequestType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsRequestType> =
    StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCallSubAgentTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsRequestType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCallSubAgentToolToJSON(
  streamRunAgentAgentToolInputRunCallSubAgentTool:
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCallSubAgentTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCallSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCallSubAgentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsType> = z
    .nativeEnum(StreamRunAgentAgentToolInputRunAgentsType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsType> =
    StreamRunAgentAgentToolInputRunAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWebScraperTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWebScraperToolToJSON(
  streamRunAgentAgentToolInputRunWebScraperTool:
    StreamRunAgentAgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWebScraperTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWebScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWebScraperTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWebScraperTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentToolInputRunType
> = z.nativeEnum(StreamRunAgentAgentToolInputRunType);
/** @internal */
export const StreamRunAgentAgentToolInputRunType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunType> =
    StreamRunAgentAgentToolInputRunType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunGoogleSearchTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunGoogleSearchToolToJSON(
  streamRunAgentAgentToolInputRunGoogleSearchTool:
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunGoogleSearchTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunGoogleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunGoogleSearchTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunGoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRun$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunMCPToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema),
]);
/** @internal */
export type StreamRunAgentAgentToolInputRun$Outbound =
  | AgentToolInputRunHTTPToolRun$Outbound
  | AgentToolInputRunCodeToolRun$Outbound
  | AgentToolInputRunMCPToolRun$Outbound
  | AgentToolInputRunFunctionToolRun$Outbound
  | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
  | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
  | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound;

/** @internal */
export const StreamRunAgentAgentToolInputRun$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRun
> = z.union([
  z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema),
]);

export function streamRunAgentAgentToolInputRunToJSON(
  streamRunAgentAgentToolInputRun: StreamRunAgentAgentToolInputRun,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRun$outboundSchema.parse(
      streamRunAgentAgentToolInputRun,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentAgentToolInputRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = z.nativeEnum(StreamRunAgentToolApprovalRequired);
/** @internal */
export const StreamRunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = StreamRunAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const StreamRunAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentExecuteOn
> = z.nativeEnum(StreamRunAgentExecuteOn);
/** @internal */
export const StreamRunAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentExecuteOn
> = StreamRunAgentExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentEvaluators$inboundSchema: z.ZodType<
  StreamRunAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: StreamRunAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type StreamRunAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentEvaluators$outboundSchema: z.ZodType<
  StreamRunAgentEvaluators$Outbound,
  z.ZodTypeDef,
  StreamRunAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentEvaluatorsToJSON(
  streamRunAgentEvaluators: StreamRunAgentEvaluators,
): string {
  return JSON.stringify(
    StreamRunAgentEvaluators$outboundSchema.parse(streamRunAgentEvaluators),
  );
}
export function streamRunAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentsExecuteOn
> = z.nativeEnum(StreamRunAgentAgentsExecuteOn);
/** @internal */
export const StreamRunAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentsExecuteOn
> = StreamRunAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentGuardrails$inboundSchema: z.ZodType<
  StreamRunAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: StreamRunAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type StreamRunAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentGuardrails$outboundSchema: z.ZodType<
  StreamRunAgentGuardrails$Outbound,
  z.ZodTypeDef,
  StreamRunAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentGuardrailsToJSON(
  streamRunAgentGuardrails: StreamRunAgentGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentGuardrails$outboundSchema.parse(streamRunAgentGuardrails),
  );
}
export function streamRunAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentSettings$inboundSchema: z.ZodType<
  StreamRunAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunMCPToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema
      ),
      z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema
      ),
    ]),
  ).optional(),
  tool_approval_required: StreamRunAgentToolApprovalRequired$inboundSchema
    .default("none"),
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(300),
  evaluators: z.array(z.lazy(() => StreamRunAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => StreamRunAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});
/** @internal */
export type StreamRunAgentSettings$Outbound = {
  tools?:
    | Array<
      | AgentToolInputRunHTTPToolRun$Outbound
      | AgentToolInputRunCodeToolRun$Outbound
      | AgentToolInputRunMCPToolRun$Outbound
      | AgentToolInputRunFunctionToolRun$Outbound
      | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
      | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
      | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
  evaluators?: Array<StreamRunAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<StreamRunAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const StreamRunAgentSettings$outboundSchema: z.ZodType<
  StreamRunAgentSettings$Outbound,
  z.ZodTypeDef,
  StreamRunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema
      ),
    ]),
  ).optional(),
  toolApprovalRequired: StreamRunAgentToolApprovalRequired$outboundSchema
    .default("none"),
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(300),
  evaluators: z.array(z.lazy(() => StreamRunAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => StreamRunAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

export function streamRunAgentSettingsToJSON(
  streamRunAgentSettings: StreamRunAgentSettings,
): string {
  return JSON.stringify(
    StreamRunAgentSettings$outboundSchema.parse(streamRunAgentSettings),
  );
}
export function streamRunAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentSettings' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRequestBody$inboundSchema: z.ZodType<
  StreamRunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  task_id: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModelConfiguration2$inboundSchema),
    z.string(),
  ]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentA2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$inboundSchema),
  ).optional(),
  team_of_agents: z.array(
    z.lazy(() => StreamRunAgentTeamOfAgents$inboundSchema),
  ).optional(),
  settings: z.lazy(() => StreamRunAgentSettings$inboundSchema),
  metadata: z.record(z.any()).optional(),
  stream_timeout_seconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
    "stream_timeout_seconds": "streamTimeoutSeconds",
  });
});
/** @internal */
export type StreamRunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: StreamRunAgentModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<StreamRunAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: StreamRunAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: StreamRunAgentContact$Outbound | undefined;
  thread?: StreamRunAgentThread$Outbound | undefined;
  memory?: StreamRunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<StreamRunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<StreamRunAgentTeamOfAgents$Outbound> | undefined;
  settings: StreamRunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamRunAgentRequestBody$outboundSchema: z.ZodType<
  StreamRunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => StreamRunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => StreamRunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamRunAgentRequestBodyToJSON(
  streamRunAgentRequestBody: StreamRunAgentRequestBody,
): string {
  return JSON.stringify(
    StreamRunAgentRequestBody$outboundSchema.parse(streamRunAgentRequestBody),
  );
}
export function streamRunAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    error: z.string(),
    code: z.string(),
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$Outbound =
  {
    error: string;
    code: string;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data
  > = z.object({
    error: z.string(),
    code: z.string(),
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody17DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody17DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data' from JSON`,
  );
}

/** @internal */
export const Seventeen$inboundSchema: z.ZodType<
  Seventeen,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$inboundSchema
  ),
});
/** @internal */
export type Seventeen$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$Outbound;
};

/** @internal */
export const Seventeen$outboundSchema: z.ZodType<
  Seventeen$Outbound,
  z.ZodTypeDef,
  Seventeen
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody17Data$outboundSchema
  ),
});

export function seventeenToJSON(seventeen: Seventeen): string {
  return JSON.stringify(Seventeen$outboundSchema.parse(seventeen));
}
export function seventeenFromJSON(
  jsonString: string,
): SafeParseResult<Seventeen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Seventeen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Seventeen' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    message: z.string(),
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$Outbound =
  {
    message: string;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data
  > = z.object({
    message: z.string(),
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody16DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody16DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data' from JSON`,
  );
}

/** @internal */
export const Sixteen$inboundSchema: z.ZodType<Sixteen, z.ZodTypeDef, unknown> =
  z.object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$inboundSchema
    ),
  });
/** @internal */
export type Sixteen$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$Outbound;
};

/** @internal */
export const Sixteen$outboundSchema: z.ZodType<
  Sixteen$Outbound,
  z.ZodTypeDef,
  Sixteen
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody16Data$outboundSchema
  ),
});

export function sixteenToJSON(sixteen: Sixteen): string {
  return JSON.stringify(Sixteen$outboundSchema.parse(sixteen));
}
export function sixteenFromJSON(
  jsonString: string,
): SafeParseResult<Sixteen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Sixteen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Sixteen' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type$inboundSchema;

/** @internal */
export const ErrorT$inboundSchema: z.ZodType<ErrorT, z.ZodTypeDef, unknown> = z
  .object({
    message: z.string(),
    stack: z.string().optional(),
  });
/** @internal */
export type ErrorT$Outbound = {
  message: string;
  stack?: string | undefined;
};

/** @internal */
export const ErrorT$outboundSchema: z.ZodType<
  ErrorT$Outbound,
  z.ZodTypeDef,
  ErrorT
> = z.object({
  message: z.string(),
  stack: z.string().optional(),
});

export function errorToJSON(errorT: ErrorT): string {
  return JSON.stringify(ErrorT$outboundSchema.parse(errorT));
}
export function errorFromJSON(
  jsonString: string,
): SafeParseResult<ErrorT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ErrorT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorT' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataProduct$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataProduct
> = z.nativeEnum(StreamRunAgentDataProduct);
/** @internal */
export const StreamRunAgentDataProduct$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataProduct
> = StreamRunAgentDataProduct$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsMemory$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamRunAgentDataAgentsMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentDataAgentsMemory$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentDataAgentsMemoryToJSON(
  streamRunAgentDataAgentsMemory: StreamRunAgentDataAgentsMemory,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsMemory$outboundSchema.parse(
      streamRunAgentDataAgentsMemory,
    ),
  );
}
export function streamRunAgentDataAgentsMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataAgentsMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsMemory' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataToolExecutionContext$inboundSchema: z.ZodType<
  StreamRunAgentDataToolExecutionContext,
  z.ZodTypeDef,
  unknown
> = z.object({
  action_id: z.string(),
  agent_tool_call_id: z.string(),
  workspace_id: z.string(),
  agent_manifest_id: z.string(),
  agent_execution_id: z.string(),
  product: StreamRunAgentDataProduct$inboundSchema,
  memory: z.lazy(() => StreamRunAgentDataAgentsMemory$inboundSchema).optional(),
  parent_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "action_id": "actionId",
    "agent_tool_call_id": "agentToolCallId",
    "workspace_id": "workspaceId",
    "agent_manifest_id": "agentManifestId",
    "agent_execution_id": "agentExecutionId",
    "parent_id": "parentId",
  });
});
/** @internal */
export type StreamRunAgentDataToolExecutionContext$Outbound = {
  action_id: string;
  agent_tool_call_id: string;
  workspace_id: string;
  agent_manifest_id: string;
  agent_execution_id: string;
  product: string;
  memory?: StreamRunAgentDataAgentsMemory$Outbound | undefined;
  parent_id?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataToolExecutionContext$outboundSchema: z.ZodType<
  StreamRunAgentDataToolExecutionContext$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataToolExecutionContext
> = z.object({
  actionId: z.string(),
  agentToolCallId: z.string(),
  workspaceId: z.string(),
  agentManifestId: z.string(),
  agentExecutionId: z.string(),
  product: StreamRunAgentDataProduct$outboundSchema,
  memory: z.lazy(() => StreamRunAgentDataAgentsMemory$outboundSchema)
    .optional(),
  parentId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    actionId: "action_id",
    agentToolCallId: "agent_tool_call_id",
    workspaceId: "workspace_id",
    agentManifestId: "agent_manifest_id",
    agentExecutionId: "agent_execution_id",
    parentId: "parent_id",
  });
});

export function streamRunAgentDataToolExecutionContextToJSON(
  streamRunAgentDataToolExecutionContext:
    StreamRunAgentDataToolExecutionContext,
): string {
  return JSON.stringify(
    StreamRunAgentDataToolExecutionContext$outboundSchema.parse(
      streamRunAgentDataToolExecutionContext,
    ),
  );
}
export function streamRunAgentDataToolExecutionContextFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataToolExecutionContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataToolExecutionContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataToolExecutionContext' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    error: z.lazy(() => ErrorT$inboundSchema),
    action_type: z.string(),
    tool_execution_context: z.lazy(() =>
      StreamRunAgentDataToolExecutionContext$inboundSchema
    ),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "tool_execution_context": "toolExecutionContext",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$Outbound =
  {
    error: ErrorT$Outbound;
    action_type: string;
    tool_execution_context: StreamRunAgentDataToolExecutionContext$Outbound;
    responseId?: string | undefined;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data
  > = z.object({
    error: z.lazy(() => ErrorT$outboundSchema),
    actionType: z.string(),
    toolExecutionContext: z.lazy(() =>
      StreamRunAgentDataToolExecutionContext$outboundSchema
    ),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      actionType: "action_type",
      toolExecutionContext: "tool_execution_context",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody15DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody15DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data' from JSON`,
  );
}

/** @internal */
export const Fifteen$inboundSchema: z.ZodType<Fifteen, z.ZodTypeDef, unknown> =
  z.object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$inboundSchema
    ),
  });
/** @internal */
export type Fifteen$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$Outbound;
};

/** @internal */
export const Fifteen$outboundSchema: z.ZodType<
  Fifteen$Outbound,
  z.ZodTypeDef,
  Fifteen
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody15Data$outboundSchema
  ),
});

export function fifteenToJSON(fifteen: Fifteen): string {
  return JSON.stringify(Fifteen$outboundSchema.parse(fifteen));
}
export function fifteenFromJSON(
  jsonString: string,
): SafeParseResult<Fifteen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fifteen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fifteen' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type$inboundSchema;

/** @internal */
export const DataProduct$inboundSchema: z.ZodNativeEnum<typeof DataProduct> = z
  .nativeEnum(DataProduct);
/** @internal */
export const DataProduct$outboundSchema: z.ZodNativeEnum<typeof DataProduct> =
  DataProduct$inboundSchema;

/** @internal */
export const StreamRunAgentDataMemory$inboundSchema: z.ZodType<
  StreamRunAgentDataMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamRunAgentDataMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentDataMemory$outboundSchema: z.ZodType<
  StreamRunAgentDataMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentDataMemoryToJSON(
  streamRunAgentDataMemory: StreamRunAgentDataMemory,
): string {
  return JSON.stringify(
    StreamRunAgentDataMemory$outboundSchema.parse(streamRunAgentDataMemory),
  );
}
export function streamRunAgentDataMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataMemory' from JSON`,
  );
}

/** @internal */
export const DataToolExecutionContext$inboundSchema: z.ZodType<
  DataToolExecutionContext,
  z.ZodTypeDef,
  unknown
> = z.object({
  action_id: z.string(),
  agent_tool_call_id: z.string(),
  workspace_id: z.string(),
  agent_manifest_id: z.string(),
  agent_execution_id: z.string(),
  product: DataProduct$inboundSchema,
  memory: z.lazy(() => StreamRunAgentDataMemory$inboundSchema).optional(),
  parent_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "action_id": "actionId",
    "agent_tool_call_id": "agentToolCallId",
    "workspace_id": "workspaceId",
    "agent_manifest_id": "agentManifestId",
    "agent_execution_id": "agentExecutionId",
    "parent_id": "parentId",
  });
});
/** @internal */
export type DataToolExecutionContext$Outbound = {
  action_id: string;
  agent_tool_call_id: string;
  workspace_id: string;
  agent_manifest_id: string;
  agent_execution_id: string;
  product: string;
  memory?: StreamRunAgentDataMemory$Outbound | undefined;
  parent_id?: string | undefined;
};

/** @internal */
export const DataToolExecutionContext$outboundSchema: z.ZodType<
  DataToolExecutionContext$Outbound,
  z.ZodTypeDef,
  DataToolExecutionContext
> = z.object({
  actionId: z.string(),
  agentToolCallId: z.string(),
  workspaceId: z.string(),
  agentManifestId: z.string(),
  agentExecutionId: z.string(),
  product: DataProduct$outboundSchema,
  memory: z.lazy(() => StreamRunAgentDataMemory$outboundSchema).optional(),
  parentId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    actionId: "action_id",
    agentToolCallId: "agent_tool_call_id",
    workspaceId: "workspace_id",
    agentManifestId: "agent_manifest_id",
    agentExecutionId: "agent_execution_id",
    parentId: "parent_id",
  });
});

export function dataToolExecutionContextToJSON(
  dataToolExecutionContext: DataToolExecutionContext,
): string {
  return JSON.stringify(
    DataToolExecutionContext$outboundSchema.parse(dataToolExecutionContext),
  );
}
export function dataToolExecutionContextFromJSON(
  jsonString: string,
): SafeParseResult<DataToolExecutionContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataToolExecutionContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataToolExecutionContext' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    result: z.any().optional(),
    action_type: z.string(),
    tool_execution_context: z.lazy(() =>
      DataToolExecutionContext$inboundSchema
    ),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "tool_execution_context": "toolExecutionContext",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$Outbound =
  {
    result?: any | undefined;
    action_type: string;
    tool_execution_context: DataToolExecutionContext$Outbound;
    responseId?: string | undefined;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data
  > = z.object({
    result: z.any().optional(),
    actionType: z.string(),
    toolExecutionContext: z.lazy(() => DataToolExecutionContext$outboundSchema),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      actionType: "action_type",
      toolExecutionContext: "tool_execution_context",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody14DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody14DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data' from JSON`,
  );
}

/** @internal */
export const Fourteen$inboundSchema: z.ZodType<
  Fourteen,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$inboundSchema
  ),
});
/** @internal */
export type Fourteen$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$Outbound;
};

/** @internal */
export const Fourteen$outboundSchema: z.ZodType<
  Fourteen$Outbound,
  z.ZodTypeDef,
  Fourteen
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody14Data$outboundSchema
  ),
});

export function fourteenToJSON(fourteen: Fourteen): string {
  return JSON.stringify(Fourteen$outboundSchema.parse(fourteen));
}
export function fourteenFromJSON(
  jsonString: string,
): SafeParseResult<Fourteen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fourteen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fourteen' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type$inboundSchema;

/** @internal */
export const Product$inboundSchema: z.ZodNativeEnum<typeof Product> = z
  .nativeEnum(Product);
/** @internal */
export const Product$outboundSchema: z.ZodNativeEnum<typeof Product> =
  Product$inboundSchema;

/** @internal */
export const DataMemory$inboundSchema: z.ZodType<
  DataMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type DataMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const DataMemory$outboundSchema: z.ZodType<
  DataMemory$Outbound,
  z.ZodTypeDef,
  DataMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function dataMemoryToJSON(dataMemory: DataMemory): string {
  return JSON.stringify(DataMemory$outboundSchema.parse(dataMemory));
}
export function dataMemoryFromJSON(
  jsonString: string,
): SafeParseResult<DataMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMemory' from JSON`,
  );
}

/** @internal */
export const ToolExecutionContext$inboundSchema: z.ZodType<
  ToolExecutionContext,
  z.ZodTypeDef,
  unknown
> = z.object({
  action_id: z.string(),
  agent_tool_call_id: z.string(),
  workspace_id: z.string(),
  agent_manifest_id: z.string(),
  agent_execution_id: z.string(),
  product: Product$inboundSchema,
  memory: z.lazy(() => DataMemory$inboundSchema).optional(),
  parent_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "action_id": "actionId",
    "agent_tool_call_id": "agentToolCallId",
    "workspace_id": "workspaceId",
    "agent_manifest_id": "agentManifestId",
    "agent_execution_id": "agentExecutionId",
    "parent_id": "parentId",
  });
});
/** @internal */
export type ToolExecutionContext$Outbound = {
  action_id: string;
  agent_tool_call_id: string;
  workspace_id: string;
  agent_manifest_id: string;
  agent_execution_id: string;
  product: string;
  memory?: DataMemory$Outbound | undefined;
  parent_id?: string | undefined;
};

/** @internal */
export const ToolExecutionContext$outboundSchema: z.ZodType<
  ToolExecutionContext$Outbound,
  z.ZodTypeDef,
  ToolExecutionContext
> = z.object({
  actionId: z.string(),
  agentToolCallId: z.string(),
  workspaceId: z.string(),
  agentManifestId: z.string(),
  agentExecutionId: z.string(),
  product: Product$outboundSchema,
  memory: z.lazy(() => DataMemory$outboundSchema).optional(),
  parentId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    actionId: "action_id",
    agentToolCallId: "agent_tool_call_id",
    workspaceId: "workspace_id",
    agentManifestId: "agent_manifest_id",
    agentExecutionId: "agent_execution_id",
    parentId: "parent_id",
  });
});

export function toolExecutionContextToJSON(
  toolExecutionContext: ToolExecutionContext,
): string {
  return JSON.stringify(
    ToolExecutionContext$outboundSchema.parse(toolExecutionContext),
  );
}
export function toolExecutionContextFromJSON(
  jsonString: string,
): SafeParseResult<ToolExecutionContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolExecutionContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolExecutionContext' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    tool_id: z.string(),
    tool_key: z.string().optional(),
    tool_display_name: z.string().optional(),
    action_type: z.string(),
    tool_arguments: z.record(z.any()),
    tool_execution_context: z.lazy(() => ToolExecutionContext$inboundSchema),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_id": "toolId",
      "tool_key": "toolKey",
      "tool_display_name": "toolDisplayName",
      "action_type": "actionType",
      "tool_arguments": "toolArguments",
      "tool_execution_context": "toolExecutionContext",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$Outbound =
  {
    tool_id: string;
    tool_key?: string | undefined;
    tool_display_name?: string | undefined;
    action_type: string;
    tool_arguments: { [k: string]: any };
    tool_execution_context: ToolExecutionContext$Outbound;
    responseId?: string | undefined;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data
  > = z.object({
    toolId: z.string(),
    toolKey: z.string().optional(),
    toolDisplayName: z.string().optional(),
    actionType: z.string(),
    toolArguments: z.record(z.any()),
    toolExecutionContext: z.lazy(() => ToolExecutionContext$outboundSchema),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      toolId: "tool_id",
      toolKey: "tool_key",
      toolDisplayName: "tool_display_name",
      actionType: "action_type",
      toolArguments: "tool_arguments",
      toolExecutionContext: "tool_execution_context",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody13DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody13DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data' from JSON`,
  );
}

/** @internal */
export const Thirteen$inboundSchema: z.ZodType<
  Thirteen,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$inboundSchema
  ),
});
/** @internal */
export type Thirteen$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$Outbound;
};

/** @internal */
export const Thirteen$outboundSchema: z.ZodType<
  Thirteen$Outbound,
  z.ZodTypeDef,
  Thirteen
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody13Data$outboundSchema
  ),
});

export function thirteenToJSON(thirteen: Thirteen): string {
  return JSON.stringify(Thirteen$outboundSchema.parse(thirteen));
}
export function thirteenFromJSON(
  jsonString: string,
): SafeParseResult<Thirteen, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thirteen$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thirteen' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponseRole$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponseRole> = z.nativeEnum(
    StreamRunAgentDataAgentsResponseRole,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponseRole$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponseRole> =
    StreamRunAgentDataAgentsResponseRole$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200ToolResultPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200ToolResultPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponse200ToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponse200ToolResultPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200ToolResultPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponse200ToolResultPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage5Kind$outboundSchema,
    toolCallId: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPartsAgentsResponse200ToolResultPartToJSON(
  streamRunAgentPartsAgentsResponse200ToolResultPart:
    StreamRunAgentPartsAgentsResponse200ToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200ToolResultPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200ToolResultPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200ToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200ToolResultPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200ToolResultPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200ToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200ToolCallPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200ToolCallPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind$inboundSchema,
    tool_name: z.string(),
    tool_call_id: z.string(),
    arguments: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_name": "toolName",
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponse200ToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponse200ToolCallPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200ToolCallPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponse200ToolCallPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessage4Kind$outboundSchema,
    toolName: z.string(),
    toolCallId: z.string(),
    arguments: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolName: "tool_name",
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPartsAgentsResponse200ToolCallPartToJSON(
  streamRunAgentPartsAgentsResponse200ToolCallPart:
    StreamRunAgentPartsAgentsResponse200ToolCallPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200ToolCallPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200ToolCallPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200ToolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200ToolCallPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200ToolCallPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200ToolCallPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind$inboundSchema;

/** @internal */
export const StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$Outbound =
  {
    uri: string;
    mimeType?: string | undefined;
    name?: string | undefined;
  };

/** @internal */
export const StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormatToJSON(
  streamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat:
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$outboundSchema
      .parse(streamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat),
  );
}
export function streamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$Outbound =
  {
    bytes: string;
    mimeType?: string | undefined;
    name?: string | undefined;
  };

/** @internal */
export const StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponse200TextEventStreamBinaryFormatToJSON(
  streamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat:
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$outboundSchema
      .parse(streamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat),
  );
}
export function streamRunAgentFileAgentsResponse200TextEventStreamBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200File$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponse200File,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$inboundSchema
  ),
]);
/** @internal */
export type StreamRunAgentPartsAgentsResponse200File$Outbound =
  | StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$Outbound
  | StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200File$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponse200File$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsResponse200File
> = z.union([
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$outboundSchema
  ),
]);

export function streamRunAgentPartsAgentsResponse200FileToJSON(
  streamRunAgentPartsAgentsResponse200File:
    StreamRunAgentPartsAgentsResponse200File,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200File$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200File,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200FileFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200File,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200File$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200File' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200FilePart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200FilePart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind$inboundSchema,
    file: z.union([
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$inboundSchema
      ),
    ]),
    metadata: z.record(z.any()).optional(),
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponse200FilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$Outbound
    | StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponse200FilePart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200FilePart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponse200FilePart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataMessageKind$outboundSchema,
    file: z.union([
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200TextEventStreamBinaryFormat$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200TextEventStreamFileInURIFormat$outboundSchema
      ),
    ]),
    metadata: z.record(z.any()).optional(),
  });

export function streamRunAgentPartsAgentsResponse200FilePartToJSON(
  streamRunAgentPartsAgentsResponse200FilePart:
    StreamRunAgentPartsAgentsResponse200FilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200FilePart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200FilePart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200FilePartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200FilePart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200FilePart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200FilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200DataPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200DataPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind$inboundSchema,
    data: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponse200DataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponse200DataPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200DataPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponse200DataPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12DataKind$outboundSchema,
    data: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  });

export function streamRunAgentPartsAgentsResponse200DataPartToJSON(
  streamRunAgentPartsAgentsResponse200DataPart:
    StreamRunAgentPartsAgentsResponse200DataPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200DataPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200DataPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200DataPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200DataPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200DataPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200DataPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200TextPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind$inboundSchema,
    text: z.string(),
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponse200TextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponse200TextPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponse200TextPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData12Kind$outboundSchema,
    text: z.string(),
  });

export function streamRunAgentPartsAgentsResponse200TextPartToJSON(
  streamRunAgentPartsAgentsResponse200TextPart:
    StreamRunAgentPartsAgentsResponse200TextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponse200TextPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponse200TextPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponse200TextPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponse200TextPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponse200TextPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponse200TextPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponseParts$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponseParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsResponse200ToolCallPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200TextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200DataPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200FilePart$inboundSchema),
  z.lazy(() =>
    StreamRunAgentPartsAgentsResponse200ToolResultPart$inboundSchema
  ),
]);
/** @internal */
export type StreamRunAgentDataAgentsResponseParts$Outbound =
  | StreamRunAgentPartsAgentsResponse200ToolCallPart$Outbound
  | StreamRunAgentPartsAgentsResponse200TextPart$Outbound
  | StreamRunAgentPartsAgentsResponse200DataPart$Outbound
  | StreamRunAgentPartsAgentsResponse200FilePart$Outbound
  | StreamRunAgentPartsAgentsResponse200ToolResultPart$Outbound;

/** @internal */
export const StreamRunAgentDataAgentsResponseParts$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponseParts$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsResponseParts
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsResponse200ToolCallPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200TextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200DataPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponse200FilePart$outboundSchema),
  z.lazy(() =>
    StreamRunAgentPartsAgentsResponse200ToolResultPart$outboundSchema
  ),
]);

export function streamRunAgentDataAgentsResponsePartsToJSON(
  streamRunAgentDataAgentsResponseParts: StreamRunAgentDataAgentsResponseParts,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponseParts$outboundSchema.parse(
      streamRunAgentDataAgentsResponseParts,
    ),
  );
}
export function streamRunAgentDataAgentsResponsePartsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsResponseParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponseParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponseParts' from JSON`,
  );
}

/** @internal */
export const DataMessage$inboundSchema: z.ZodType<
  DataMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: StreamRunAgentDataAgentsResponseRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponse200ToolCallPart$inboundSchema
      ),
      z.lazy(() => StreamRunAgentPartsAgentsResponse200TextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponse200DataPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponse200FilePart$inboundSchema),
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponse200ToolResultPart$inboundSchema
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type DataMessage$Outbound = {
  messageId?: string | undefined;
  role: string;
  parts: Array<
    | StreamRunAgentPartsAgentsResponse200ToolCallPart$Outbound
    | StreamRunAgentPartsAgentsResponse200TextPart$Outbound
    | StreamRunAgentPartsAgentsResponse200DataPart$Outbound
    | StreamRunAgentPartsAgentsResponse200FilePart$Outbound
    | StreamRunAgentPartsAgentsResponse200ToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataMessage$outboundSchema: z.ZodType<
  DataMessage$Outbound,
  z.ZodTypeDef,
  DataMessage
> = z.object({
  messageId: z.string().optional(),
  role: StreamRunAgentDataAgentsResponseRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponse200ToolCallPart$outboundSchema
      ),
      z.lazy(() => StreamRunAgentPartsAgentsResponse200TextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponse200DataPart$outboundSchema),
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponse200FilePart$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponse200ToolResultPart$outboundSchema
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function dataMessageToJSON(dataMessage: DataMessage): string {
  return JSON.stringify(DataMessage$outboundSchema.parse(dataMessage));
}
export function dataMessageFromJSON(
  jsonString: string,
): SafeParseResult<DataMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMessage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    workflowRunId: z.string(),
    spanId: z.string(),
    parentId: z.string(),
    message: z.array(z.lazy(() => DataMessage$inboundSchema)),
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$Outbound =
  {
    workflowRunId: string;
    spanId: string;
    parentId: string;
    message: Array<DataMessage$Outbound>;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data
  > = z.object({
    workflowRunId: z.string(),
    spanId: z.string(),
    parentId: z.string(),
    message: z.array(z.lazy(() => DataMessage$outboundSchema)),
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody12DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody12DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data' from JSON`,
  );
}

/** @internal */
export const Twelve$inboundSchema: z.ZodType<Twelve, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$inboundSchema
    ),
  });
/** @internal */
export type Twelve$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$Outbound;
};

/** @internal */
export const Twelve$outboundSchema: z.ZodType<
  Twelve$Outbound,
  z.ZodTypeDef,
  Twelve
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody12Data$outboundSchema
  ),
});

export function twelveToJSON(twelve: Twelve): string {
  return JSON.stringify(Twelve$outboundSchema.parse(twelve));
}
export function twelveFromJSON(
  jsonString: string,
): SafeParseResult<Twelve, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Twelve$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Twelve' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    agent_id: z.string(),
    input: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "agent_id": "agentId",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$Outbound =
  {
    agent_id: string;
    input: string;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data
  > = z.object({
    agentId: z.string(),
    input: z.string(),
  }).transform((v) => {
    return remap$(v, {
      agentId: "agent_id",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody11DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody11DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data' from JSON`,
  );
}

/** @internal */
export const Eleven$inboundSchema: z.ZodType<Eleven, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$inboundSchema
    ),
  });
/** @internal */
export type Eleven$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$Outbound;
};

/** @internal */
export const Eleven$outboundSchema: z.ZodType<
  Eleven$Outbound,
  z.ZodTypeDef,
  Eleven
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody11Data$outboundSchema
  ),
});

export function elevenToJSON(eleven: Eleven): string {
  return JSON.stringify(Eleven$outboundSchema.parse(eleven));
}
export function elevenFromJSON(
  jsonString: string,
): SafeParseResult<Eleven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Eleven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Eleven' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    agent_manifest_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "agent_manifest_id": "agentManifestId",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$Outbound =
  {
    name: string;
    agent_manifest_id: string;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data
  > = z.object({
    name: z.string(),
    agentManifestId: z.string(),
  }).transform((v) => {
    return remap$(v, {
      agentManifestId: "agent_manifest_id",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody10DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody10DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data' from JSON`,
  );
}

/** @internal */
export const Ten$inboundSchema: z.ZodType<Ten, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$inboundSchema
    ),
  });
/** @internal */
export type Ten$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$Outbound;
};

/** @internal */
export const Ten$outboundSchema: z.ZodType<Ten$Outbound, z.ZodTypeDef, Ten> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Type$outboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody10Data$outboundSchema
    ),
  });

export function tenToJSON(ten: Ten): string {
  return JSON.stringify(Ten$outboundSchema.parse(ten));
}
export function tenFromJSON(
  jsonString: string,
): SafeParseResult<Ten, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ten$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ten' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data,
    z.ZodTypeDef,
    unknown
  > = z.object({});
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$Outbound =
  {};

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data
  > = z.object({});

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody9DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody9DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data' from JSON`,
  );
}

/** @internal */
export const Nine$inboundSchema: z.ZodType<Nine, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$inboundSchema
    ),
  });
/** @internal */
export type Nine$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$Outbound;
};

/** @internal */
export const Nine$outboundSchema: z.ZodType<Nine$Outbound, z.ZodTypeDef, Nine> =
  z.object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Type$outboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody9Data$outboundSchema
    ),
  });

export function nineToJSON(nine: Nine): string {
  return JSON.stringify(Nine$outboundSchema.parse(nine));
}
export function nineFromJSON(
  jsonString: string,
): SafeParseResult<Nine, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Nine$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Nine' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data,
    z.ZodTypeDef,
    unknown
  > = z.object({});
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$Outbound =
  {};

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data
  > = z.object({});

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody8DataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBody8DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data' from JSON`,
  );
}

/** @internal */
export const Eight$inboundSchema: z.ZodType<Eight, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$inboundSchema
    ),
  });
/** @internal */
export type Eight$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$Outbound;
};

/** @internal */
export const Eight$outboundSchema: z.ZodType<
  Eight$Outbound,
  z.ZodTypeDef,
  Eight
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody8Data$outboundSchema
  ),
});

export function eightToJSON(eight: Eight): string {
  return JSON.stringify(Eight$outboundSchema.parse(eight));
}
export function eightFromJSON(
  jsonString: string,
): SafeParseResult<Eight, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Eight$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Eight' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type$inboundSchema;

/** @internal */
export const Review$inboundSchema: z.ZodNativeEnum<typeof Review> = z
  .nativeEnum(Review);
/** @internal */
export const Review$outboundSchema: z.ZodNativeEnum<typeof Review> =
  Review$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    agent_id: z.string(),
    action_id: z.string(),
    agent_tool_call_id: z.string(),
    review: Review$inboundSchema,
    mock_output: z.record(z.any()).optional(),
    review_source: z.string().optional(),
    reviewed_by_id: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "agent_id": "agentId",
      "action_id": "actionId",
      "agent_tool_call_id": "agentToolCallId",
      "mock_output": "mockOutput",
      "review_source": "reviewSource",
      "reviewed_by_id": "reviewedById",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$Outbound =
  {
    agent_id: string;
    action_id: string;
    agent_tool_call_id: string;
    review: string;
    mock_output?: { [k: string]: any } | undefined;
    review_source?: string | undefined;
    reviewed_by_id?: string | undefined;
  };

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData
  > = z.object({
    agentId: z.string(),
    actionId: z.string(),
    agentToolCallId: z.string(),
    review: Review$outboundSchema,
    mockOutput: z.record(z.any()).optional(),
    reviewSource: z.string().optional(),
    reviewedById: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      agentId: "agent_id",
      actionId: "action_id",
      agentToolCallId: "agent_tool_call_id",
      mockOutput: "mock_output",
      reviewSource: "review_source",
      reviewedById: "reviewed_by_id",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBodyDataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$outboundSchema
      .parse(
        streamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData,
      ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamResponseBodyDataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData' from JSON`,
  );
}

/** @internal */
export const Seven$inboundSchema: z.ZodType<Seven, z.ZodTypeDef, unknown> = z
  .object({
    type:
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() =>
      StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$inboundSchema
    ),
  });
/** @internal */
export type Seven$Outbound = {
  type: string;
  timestamp: string;
  data:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$Outbound;
};

/** @internal */
export const Seven$outboundSchema: z.ZodType<
  Seven$Outbound,
  z.ZodTypeDef,
  Seven
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody7Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyData$outboundSchema
  ),
});

export function sevenToJSON(seven: Seven): string {
  return JSON.stringify(Seven$outboundSchema.parse(seven));
}
export function sevenFromJSON(
  jsonString: string,
): SafeParseResult<Seven, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Seven$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Seven' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType$inboundSchema;

/** @internal */
export const DataConditions$inboundSchema: z.ZodType<
  DataConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type DataConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const DataConditions$outboundSchema: z.ZodType<
  DataConditions$Outbound,
  z.ZodTypeDef,
  DataConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function dataConditionsToJSON(dataConditions: DataConditions): string {
  return JSON.stringify(DataConditions$outboundSchema.parse(dataConditions));
}
export function dataConditionsFromJSON(
  jsonString: string,
): SafeParseResult<DataConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataConditions' from JSON`,
  );
}

/** @internal */
export const Tool$inboundSchema: z.ZodType<Tool, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    key: z.string().optional(),
    action_type: z.string(),
    display_name: z.string().optional(),
    description: z.string().optional(),
    requires_approval: z.boolean().default(false),
    tool_id: z.string().optional(),
    conditions: z.array(z.lazy(() => DataConditions$inboundSchema)).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      "action_type": "actionType",
      "display_name": "displayName",
      "requires_approval": "requiresApproval",
      "tool_id": "toolId",
    });
  });
/** @internal */
export type Tool$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<DataConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const Tool$outboundSchema: z.ZodType<Tool$Outbound, z.ZodTypeDef, Tool> =
  z.object({
    id: z.string(),
    key: z.string().optional(),
    actionType: z.string(),
    displayName: z.string().optional(),
    description: z.string().optional(),
    requiresApproval: z.boolean().default(false),
    toolId: z.string().optional(),
    conditions: z.array(z.lazy(() => DataConditions$outboundSchema)).optional(),
    timeout: z.number().default(120),
  }).transform((v) => {
    return remap$(v, {
      actionType: "action_type",
      displayName: "display_name",
      requiresApproval: "requires_approval",
      toolId: "tool_id",
    });
  });

export function toolToJSON(tool: Tool): string {
  return JSON.stringify(Tool$outboundSchema.parse(tool));
}
export function toolFromJSON(
  jsonString: string,
): SafeParseResult<Tool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamData$inboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    agent_id: z.string(),
    action_id: z.string(),
    requires_approval: z.boolean(),
    tool: z.lazy(() => Tool$inboundSchema),
    input: z.record(z.any()),
    agent_tool_call_id: z.string(),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "agent_id": "agentId",
      "action_id": "actionId",
      "requires_approval": "requiresApproval",
      "agent_tool_call_id": "agentToolCallId",
    });
  });
/** @internal */
export type StreamRunAgentDataAgentsResponse200TextEventStreamData$Outbound = {
  agent_id: string;
  action_id: string;
  requires_approval: boolean;
  tool: Tool$Outbound;
  input: { [k: string]: any };
  agent_tool_call_id: string;
  responseId?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamData$outboundSchema:
  z.ZodType<
    StreamRunAgentDataAgentsResponse200TextEventStreamData$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataAgentsResponse200TextEventStreamData
  > = z.object({
    agentId: z.string(),
    actionId: z.string(),
    requiresApproval: z.boolean(),
    tool: z.lazy(() => Tool$outboundSchema),
    input: z.record(z.any()),
    agentToolCallId: z.string(),
    responseId: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      agentId: "agent_id",
      actionId: "action_id",
      requiresApproval: "requires_approval",
      agentToolCallId: "agent_tool_call_id",
    });
  });

export function streamRunAgentDataAgentsResponse200TextEventStreamDataToJSON(
  streamRunAgentDataAgentsResponse200TextEventStreamData:
    StreamRunAgentDataAgentsResponse200TextEventStreamData,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200TextEventStreamData$outboundSchema.parse(
      streamRunAgentDataAgentsResponse200TextEventStreamData,
    ),
  );
}
export function streamRunAgentDataAgentsResponse200TextEventStreamDataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200TextEventStreamData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200TextEventStreamData$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200TextEventStreamData' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentData6$inboundSchema: z.ZodType<
  StreamRunAgentData6,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamData$inboundSchema
  ),
});
/** @internal */
export type StreamRunAgentData6$Outbound = {
  type: string;
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200TextEventStreamData$Outbound;
};

/** @internal */
export const StreamRunAgentData6$outboundSchema: z.ZodType<
  StreamRunAgentData6$Outbound,
  z.ZodTypeDef,
  StreamRunAgentData6
> = z.object({
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBodyType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    StreamRunAgentDataAgentsResponse200TextEventStreamData$outboundSchema
  ),
});

export function streamRunAgentData6ToJSON(
  streamRunAgentData6: StreamRunAgentData6,
): string {
  return JSON.stringify(
    StreamRunAgentData6$outboundSchema.parse(streamRunAgentData6),
  );
}
export function streamRunAgentData6FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentData6, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentData6$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentData6' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamType
  > = z.nativeEnum(StreamRunAgentDataAgentsResponse200TextEventStreamType);
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamType
  > = StreamRunAgentDataAgentsResponse200TextEventStreamType$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200Data$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponse200Data,
  z.ZodTypeDef,
  unknown
> = z.object({
  error: z.string(),
  code: z.number(),
  responseId: z.string().optional(),
});
/** @internal */
export type StreamRunAgentDataAgentsResponse200Data$Outbound = {
  error: string;
  code: number;
  responseId?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataAgentsResponse200Data$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponse200Data$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsResponse200Data
> = z.object({
  error: z.string(),
  code: z.number(),
  responseId: z.string().optional(),
});

export function streamRunAgentDataAgentsResponse200DataToJSON(
  streamRunAgentDataAgentsResponse200Data:
    StreamRunAgentDataAgentsResponse200Data,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponse200Data$outboundSchema.parse(
      streamRunAgentDataAgentsResponse200Data,
    ),
  );
}
export function streamRunAgentDataAgentsResponse200DataFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataAgentsResponse200Data,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponse200Data$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentDataAgentsResponse200Data' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentData5$inboundSchema: z.ZodType<
  StreamRunAgentData5,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentDataAgentsResponse200TextEventStreamType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => StreamRunAgentDataAgentsResponse200Data$inboundSchema),
});
/** @internal */
export type StreamRunAgentData5$Outbound = {
  type: string;
  timestamp: string;
  data: StreamRunAgentDataAgentsResponse200Data$Outbound;
};

/** @internal */
export const StreamRunAgentData5$outboundSchema: z.ZodType<
  StreamRunAgentData5$Outbound,
  z.ZodTypeDef,
  StreamRunAgentData5
> = z.object({
  type: StreamRunAgentDataAgentsResponse200TextEventStreamType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => StreamRunAgentDataAgentsResponse200Data$outboundSchema),
});

export function streamRunAgentData5ToJSON(
  streamRunAgentData5: StreamRunAgentData5,
): string {
  return JSON.stringify(
    StreamRunAgentData5$outboundSchema.parse(streamRunAgentData5),
  );
}
export function streamRunAgentData5FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentData5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentData5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentData5' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponse200Type> = z
    .nativeEnum(StreamRunAgentDataAgentsResponse200Type);
/** @internal */
export const StreamRunAgentDataAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponse200Type> =
    StreamRunAgentDataAgentsResponse200Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsRole$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataAgentsRole
> = z.nativeEnum(StreamRunAgentDataAgentsRole);
/** @internal */
export const StreamRunAgentDataAgentsRole$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataAgentsRole
> = StreamRunAgentDataAgentsRole$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponseToolResultPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseToolResultPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponseToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponseToolResultPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseToolResultPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponseToolResultPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull5Kind$outboundSchema,
    toolCallId: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPartsAgentsResponseToolResultPartToJSON(
  streamRunAgentPartsAgentsResponseToolResultPart:
    StreamRunAgentPartsAgentsResponseToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseToolResultPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseToolResultPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponseToolResultPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseToolResultPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponseToolCallPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseToolCallPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind$inboundSchema,
    tool_name: z.string(),
    tool_call_id: z.string(),
    arguments: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_name": "toolName",
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPartsAgentsResponseToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponseToolCallPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseToolCallPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponseToolCallPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFull4Kind$outboundSchema,
    toolName: z.string(),
    toolCallId: z.string(),
    arguments: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolName: "tool_name",
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPartsAgentsResponseToolCallPartToJSON(
  streamRunAgentPartsAgentsResponseToolCallPart:
    StreamRunAgentPartsAgentsResponseToolCallPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseToolCallPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseToolCallPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseToolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponseToolCallPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseToolCallPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseToolCallPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind$inboundSchema;

/** @internal */
export const StreamRunAgentFileAgentsResponse200FileInURIFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200FileInURIFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponse200FileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsResponse200FileInURIFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200FileInURIFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponse200FileInURIFormat
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponse200FileInURIFormatToJSON(
  streamRunAgentFileAgentsResponse200FileInURIFormat:
    StreamRunAgentFileAgentsResponse200FileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponse200FileInURIFormat$outboundSchema.parse(
      streamRunAgentFileAgentsResponse200FileInURIFormat,
    ),
  );
}
export function streamRunAgentFileAgentsResponse200FileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponse200FileInURIFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponse200FileInURIFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFileAgentsResponse200FileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileAgentsResponse200BinaryFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200BinaryFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponse200BinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsResponse200BinaryFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponse200BinaryFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponse200BinaryFormat
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponse200BinaryFormatToJSON(
  streamRunAgentFileAgentsResponse200BinaryFormat:
    StreamRunAgentFileAgentsResponse200BinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponse200BinaryFormat$outboundSchema.parse(
      streamRunAgentFileAgentsResponse200BinaryFormat,
    ),
  );
}
export function streamRunAgentFileAgentsResponse200BinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponse200BinaryFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponse200BinaryFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFileAgentsResponse200BinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponseFile$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponseFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsResponse200BinaryFormat$inboundSchema),
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200FileInURIFormat$inboundSchema
  ),
]);
/** @internal */
export type StreamRunAgentPartsAgentsResponseFile$Outbound =
  | StreamRunAgentFileAgentsResponse200BinaryFormat$Outbound
  | StreamRunAgentFileAgentsResponse200FileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPartsAgentsResponseFile$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponseFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsResponseFile
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsResponse200BinaryFormat$outboundSchema),
  z.lazy(() =>
    StreamRunAgentFileAgentsResponse200FileInURIFormat$outboundSchema
  ),
]);

export function streamRunAgentPartsAgentsResponseFileToJSON(
  streamRunAgentPartsAgentsResponseFile: StreamRunAgentPartsAgentsResponseFile,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseFile$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseFile,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsResponseFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponseFilePart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponseFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileAgentsResponse200BinaryFormat$inboundSchema),
    z.lazy(() =>
      StreamRunAgentFileAgentsResponse200FileInURIFormat$inboundSchema
    ),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsAgentsResponseFilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileAgentsResponse200BinaryFormat$Outbound
    | StreamRunAgentFileAgentsResponse200FileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponseFilePart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseFilePart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponseFilePart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataLastMessageFullKind$outboundSchema,
    file: z.union([
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200BinaryFormat$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentFileAgentsResponse200FileInURIFormat$outboundSchema
      ),
    ]),
    metadata: z.record(z.any()).optional(),
  });

export function streamRunAgentPartsAgentsResponseFilePartToJSON(
  streamRunAgentPartsAgentsResponseFilePart:
    StreamRunAgentPartsAgentsResponseFilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseFilePart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseFilePart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseFilePartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponseFilePart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseFilePart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseFilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponseDataPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponseDataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsAgentsResponseDataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponseDataPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseDataPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponseDataPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4DataKind$outboundSchema,
    data: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  });

export function streamRunAgentPartsAgentsResponseDataPartToJSON(
  streamRunAgentPartsAgentsResponseDataPart:
    StreamRunAgentPartsAgentsResponseDataPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseDataPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseDataPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseDataPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponseDataPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseDataPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseDataPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponseTextPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsResponseTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type StreamRunAgentPartsAgentsResponseTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPartsAgentsResponseTextPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPartsAgentsResponseTextPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPartsAgentsResponseTextPart
  > = z.object({
    kind:
      StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData4Kind$outboundSchema,
    text: z.string(),
  });

export function streamRunAgentPartsAgentsResponseTextPartToJSON(
  streamRunAgentPartsAgentsResponseTextPart:
    StreamRunAgentPartsAgentsResponseTextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsResponseTextPart$outboundSchema.parse(
      streamRunAgentPartsAgentsResponseTextPart,
    ),
  );
}
export function streamRunAgentPartsAgentsResponseTextPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsResponseTextPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsResponseTextPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsResponseTextPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsParts$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsResponseToolCallPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseTextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseDataPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseFilePart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseToolResultPart$inboundSchema),
]);
/** @internal */
export type StreamRunAgentDataAgentsParts$Outbound =
  | StreamRunAgentPartsAgentsResponseToolCallPart$Outbound
  | StreamRunAgentPartsAgentsResponseTextPart$Outbound
  | StreamRunAgentPartsAgentsResponseDataPart$Outbound
  | StreamRunAgentPartsAgentsResponseFilePart$Outbound
  | StreamRunAgentPartsAgentsResponseToolResultPart$Outbound;

/** @internal */
export const StreamRunAgentDataAgentsParts$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsParts$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsParts
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsResponseToolCallPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseTextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseDataPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseFilePart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsResponseToolResultPart$outboundSchema),
]);

export function streamRunAgentDataAgentsPartsToJSON(
  streamRunAgentDataAgentsParts: StreamRunAgentDataAgentsParts,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsParts$outboundSchema.parse(
      streamRunAgentDataAgentsParts,
    ),
  );
}
export function streamRunAgentDataAgentsPartsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataAgentsParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsParts' from JSON`,
  );
}

/** @internal */
export const LastMessageFull$inboundSchema: z.ZodType<
  LastMessageFull,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: StreamRunAgentDataAgentsRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPartsAgentsResponseToolCallPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponseTextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponseDataPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponseFilePart$inboundSchema),
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponseToolResultPart$inboundSchema
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type LastMessageFull$Outbound = {
  messageId?: string | undefined;
  role: string;
  parts: Array<
    | StreamRunAgentPartsAgentsResponseToolCallPart$Outbound
    | StreamRunAgentPartsAgentsResponseTextPart$Outbound
    | StreamRunAgentPartsAgentsResponseDataPart$Outbound
    | StreamRunAgentPartsAgentsResponseFilePart$Outbound
    | StreamRunAgentPartsAgentsResponseToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const LastMessageFull$outboundSchema: z.ZodType<
  LastMessageFull$Outbound,
  z.ZodTypeDef,
  LastMessageFull
> = z.object({
  messageId: z.string().optional(),
  role: StreamRunAgentDataAgentsRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponseToolCallPart$outboundSchema
      ),
      z.lazy(() => StreamRunAgentPartsAgentsResponseTextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponseDataPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsResponseFilePart$outboundSchema),
      z.lazy(() =>
        StreamRunAgentPartsAgentsResponseToolResultPart$outboundSchema
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function lastMessageFullToJSON(
  lastMessageFull: LastMessageFull,
): string {
  return JSON.stringify(LastMessageFull$outboundSchema.parse(lastMessageFull));
}
export function lastMessageFullFromJSON(
  jsonString: string,
): SafeParseResult<LastMessageFull, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LastMessageFull$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LastMessageFull' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);
/** @internal */
export const FinishReason$outboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  FinishReason$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataFunction$inboundSchema: z.ZodType<
  StreamRunAgentDataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type StreamRunAgentDataFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataFunction$outboundSchema: z.ZodType<
  StreamRunAgentDataFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function streamRunAgentDataFunctionToJSON(
  streamRunAgentDataFunction: StreamRunAgentDataFunction,
): string {
  return JSON.stringify(
    StreamRunAgentDataFunction$outboundSchema.parse(streamRunAgentDataFunction),
  );
}
export function streamRunAgentDataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataFunction' from JSON`,
  );
}

/** @internal */
export const PendingToolCalls$inboundSchema: z.ZodType<
  PendingToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type$inboundSchema,
  function: z.lazy(() => StreamRunAgentDataFunction$inboundSchema),
});
/** @internal */
export type PendingToolCalls$Outbound = {
  id: string;
  type: string;
  function: StreamRunAgentDataFunction$Outbound;
};

/** @internal */
export const PendingToolCalls$outboundSchema: z.ZodType<
  PendingToolCalls$Outbound,
  z.ZodTypeDef,
  PendingToolCalls
> = z.object({
  id: z.string(),
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody4Type$outboundSchema,
  function: z.lazy(() => StreamRunAgentDataFunction$outboundSchema),
});

export function pendingToolCallsToJSON(
  pendingToolCalls: PendingToolCalls,
): string {
  return JSON.stringify(
    PendingToolCalls$outboundSchema.parse(pendingToolCalls),
  );
}
export function pendingToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<PendingToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingToolCalls' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataPromptTokensDetails$inboundSchema: z.ZodType<
  StreamRunAgentDataPromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type StreamRunAgentDataPromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const StreamRunAgentDataPromptTokensDetails$outboundSchema: z.ZodType<
  StreamRunAgentDataPromptTokensDetails$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataPromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    audioTokens: "audio_tokens",
  });
});

export function streamRunAgentDataPromptTokensDetailsToJSON(
  streamRunAgentDataPromptTokensDetails: StreamRunAgentDataPromptTokensDetails,
): string {
  return JSON.stringify(
    StreamRunAgentDataPromptTokensDetails$outboundSchema.parse(
      streamRunAgentDataPromptTokensDetails,
    ),
  );
}
export function streamRunAgentDataPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataPromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataPromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataCompletionTokensDetails$inboundSchema: z.ZodType<
  StreamRunAgentDataCompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type StreamRunAgentDataCompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const StreamRunAgentDataCompletionTokensDetails$outboundSchema:
  z.ZodType<
    StreamRunAgentDataCompletionTokensDetails$Outbound,
    z.ZodTypeDef,
    StreamRunAgentDataCompletionTokensDetails
  > = z.object({
    reasoningTokens: z.nullable(z.number()).optional(),
    acceptedPredictionTokens: z.nullable(z.number()).optional(),
    rejectedPredictionTokens: z.nullable(z.number()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      reasoningTokens: "reasoning_tokens",
      acceptedPredictionTokens: "accepted_prediction_tokens",
      rejectedPredictionTokens: "rejected_prediction_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function streamRunAgentDataCompletionTokensDetailsToJSON(
  streamRunAgentDataCompletionTokensDetails:
    StreamRunAgentDataCompletionTokensDetails,
): string {
  return JSON.stringify(
    StreamRunAgentDataCompletionTokensDetails$outboundSchema.parse(
      streamRunAgentDataCompletionTokensDetails,
    ),
  );
}
export function streamRunAgentDataCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentDataCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentDataCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataUsage$inboundSchema: z.ZodType<
  StreamRunAgentDataUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => StreamRunAgentDataPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => StreamRunAgentDataCompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type StreamRunAgentDataUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?:
    | StreamRunAgentDataPromptTokensDetails$Outbound
    | null
    | undefined;
  completion_tokens_details?:
    | StreamRunAgentDataCompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const StreamRunAgentDataUsage$outboundSchema: z.ZodType<
  StreamRunAgentDataUsage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => StreamRunAgentDataPromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => StreamRunAgentDataCompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function streamRunAgentDataUsageToJSON(
  streamRunAgentDataUsage: StreamRunAgentDataUsage,
): string {
  return JSON.stringify(
    StreamRunAgentDataUsage$outboundSchema.parse(streamRunAgentDataUsage),
  );
}
export function streamRunAgentDataUsageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataUsage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponseData$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponseData,
  z.ZodTypeDef,
  unknown
> = z.object({
  last_message: z.string(),
  last_message_full: z.lazy(() => LastMessageFull$inboundSchema).optional(),
  finish_reason: FinishReason$inboundSchema,
  pending_tool_calls: z.array(z.lazy(() => PendingToolCalls$inboundSchema))
    .optional(),
  usage: z.lazy(() => StreamRunAgentDataUsage$inboundSchema).optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "last_message": "lastMessage",
    "last_message_full": "lastMessageFull",
    "finish_reason": "finishReason",
    "pending_tool_calls": "pendingToolCalls",
  });
});
/** @internal */
export type StreamRunAgentDataAgentsResponseData$Outbound = {
  last_message: string;
  last_message_full?: LastMessageFull$Outbound | undefined;
  finish_reason: string;
  pending_tool_calls?: Array<PendingToolCalls$Outbound> | undefined;
  usage?: StreamRunAgentDataUsage$Outbound | undefined;
  responseId?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataAgentsResponseData$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsResponseData$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsResponseData
> = z.object({
  lastMessage: z.string(),
  lastMessageFull: z.lazy(() => LastMessageFull$outboundSchema).optional(),
  finishReason: FinishReason$outboundSchema,
  pendingToolCalls: z.array(z.lazy(() => PendingToolCalls$outboundSchema))
    .optional(),
  usage: z.lazy(() => StreamRunAgentDataUsage$outboundSchema).optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    lastMessage: "last_message",
    lastMessageFull: "last_message_full",
    finishReason: "finish_reason",
    pendingToolCalls: "pending_tool_calls",
  });
});

export function streamRunAgentDataAgentsResponseDataToJSON(
  streamRunAgentDataAgentsResponseData: StreamRunAgentDataAgentsResponseData,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsResponseData$outboundSchema.parse(
      streamRunAgentDataAgentsResponseData,
    ),
  );
}
export function streamRunAgentDataAgentsResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentDataAgentsResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsResponseData' from JSON`,
  );
}

/** @internal */
export const Data4$inboundSchema: z.ZodType<Data4, z.ZodTypeDef, unknown> = z
  .object({
    type: StreamRunAgentDataAgentsResponse200Type$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() => StreamRunAgentDataAgentsResponseData$inboundSchema),
  });
/** @internal */
export type Data4$Outbound = {
  type: string;
  timestamp: string;
  data: StreamRunAgentDataAgentsResponseData$Outbound;
};

/** @internal */
export const Data4$outboundSchema: z.ZodType<
  Data4$Outbound,
  z.ZodTypeDef,
  Data4
> = z.object({
  type: StreamRunAgentDataAgentsResponse200Type$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => StreamRunAgentDataAgentsResponseData$outboundSchema),
});

export function data4ToJSON(data4: Data4): string {
  return JSON.stringify(Data4$outboundSchema.parse(data4));
}
export function data4FromJSON(
  jsonString: string,
): SafeParseResult<Data4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data4' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponseType> = z.nativeEnum(
    StreamRunAgentDataAgentsResponseType,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponseType> =
    StreamRunAgentDataAgentsResponseType$inboundSchema;

/** @internal */
export const StreamRunAgentDataRole$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataRole
> = z.nativeEnum(StreamRunAgentDataRole);
/** @internal */
export const StreamRunAgentDataRole$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataRole
> = StreamRunAgentDataRole$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsToolResultPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type StreamRunAgentPartsAgentsToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsToolResultPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsToolResultPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsToolResultPart
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataMessageDifferenceKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function streamRunAgentPartsAgentsToolResultPartToJSON(
  streamRunAgentPartsAgentsToolResultPart:
    StreamRunAgentPartsAgentsToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsToolResultPart$outboundSchema.parse(
      streamRunAgentPartsAgentsToolResultPart,
    ),
  );
}
export function streamRunAgentPartsAgentsToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPartsAgentsToolResultPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsToolResultPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPartsAgentsToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsToolCallPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsToolCallPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type StreamRunAgentPartsAgentsToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsToolCallPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsToolCallPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsToolCallPart
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3DataKind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

export function streamRunAgentPartsAgentsToolCallPartToJSON(
  streamRunAgentPartsAgentsToolCallPart: StreamRunAgentPartsAgentsToolCallPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsToolCallPart$outboundSchema.parse(
      streamRunAgentPartsAgentsToolCallPart,
    ),
  );
}
export function streamRunAgentPartsAgentsToolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsToolCallPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPartsAgentsToolCallPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsToolCallPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind$inboundSchema;

/** @internal */
export const StreamRunAgentFileAgentsResponseFileInURIFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponseFileInURIFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponseFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsResponseFileInURIFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponseFileInURIFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponseFileInURIFormat
  > = z.object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponseFileInURIFormatToJSON(
  streamRunAgentFileAgentsResponseFileInURIFormat:
    StreamRunAgentFileAgentsResponseFileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponseFileInURIFormat$outboundSchema.parse(
      streamRunAgentFileAgentsResponseFileInURIFormat,
    ),
  );
}
export function streamRunAgentFileAgentsResponseFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponseFileInURIFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponseFileInURIFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFileAgentsResponseFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileAgentsResponseBinaryFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponseBinaryFormat,
    z.ZodTypeDef,
    unknown
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });
/** @internal */
export type StreamRunAgentFileAgentsResponseBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsResponseBinaryFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFileAgentsResponseBinaryFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFileAgentsResponseBinaryFormat
  > = z.object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

export function streamRunAgentFileAgentsResponseBinaryFormatToJSON(
  streamRunAgentFileAgentsResponseBinaryFormat:
    StreamRunAgentFileAgentsResponseBinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsResponseBinaryFormat$outboundSchema.parse(
      streamRunAgentFileAgentsResponseBinaryFormat,
    ),
  );
}
export function streamRunAgentFileAgentsResponseBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsResponseBinaryFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsResponseBinaryFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFileAgentsResponseBinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsFile$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsResponseBinaryFormat$inboundSchema),
  z.lazy(() => StreamRunAgentFileAgentsResponseFileInURIFormat$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPartsAgentsFile$Outbound =
  | StreamRunAgentFileAgentsResponseBinaryFormat$Outbound
  | StreamRunAgentFileAgentsResponseFileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPartsAgentsFile$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsFile
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsResponseBinaryFormat$outboundSchema),
  z.lazy(() => StreamRunAgentFileAgentsResponseFileInURIFormat$outboundSchema),
]);

export function streamRunAgentPartsAgentsFileToJSON(
  streamRunAgentPartsAgentsFile: StreamRunAgentPartsAgentsFile,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsFile$outboundSchema.parse(
      streamRunAgentPartsAgentsFile,
    ),
  );
}
export function streamRunAgentPartsAgentsFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsAgentsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsFilePart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileAgentsResponseBinaryFormat$inboundSchema),
    z.lazy(() => StreamRunAgentFileAgentsResponseFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsAgentsFilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileAgentsResponseBinaryFormat$Outbound
    | StreamRunAgentFileAgentsResponseFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsFilePart$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsFilePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsFilePart
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyData3Kind$outboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileAgentsResponseBinaryFormat$outboundSchema),
    z.lazy(() =>
      StreamRunAgentFileAgentsResponseFileInURIFormat$outboundSchema
    ),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPartsAgentsFilePartToJSON(
  streamRunAgentPartsAgentsFilePart: StreamRunAgentPartsAgentsFilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsFilePart$outboundSchema.parse(
      streamRunAgentPartsAgentsFilePart,
    ),
  );
}
export function streamRunAgentPartsAgentsFilePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsAgentsFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsFilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsDataPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsDataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsAgentsDataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsAgentsDataPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsDataPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsDataPart
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyDataKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPartsAgentsDataPartToJSON(
  streamRunAgentPartsAgentsDataPart: StreamRunAgentPartsAgentsDataPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsDataPart$outboundSchema.parse(
      streamRunAgentPartsAgentsDataPart,
    ),
  );
}
export function streamRunAgentPartsAgentsDataPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsDataPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsAgentsDataPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsDataPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind
  > = z.nativeEnum(
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind
  > =
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsTextPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type StreamRunAgentPartsAgentsTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPartsAgentsTextPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsAgentsTextPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsAgentsTextPart
> = z.object({
  kind:
    StreamRunAgentPartsAgentsResponse200TextEventStreamResponseBodyKind$outboundSchema,
  text: z.string(),
});

export function streamRunAgentPartsAgentsTextPartToJSON(
  streamRunAgentPartsAgentsTextPart: StreamRunAgentPartsAgentsTextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsAgentsTextPart$outboundSchema.parse(
      streamRunAgentPartsAgentsTextPart,
    ),
  );
}
export function streamRunAgentPartsAgentsTextPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsAgentsTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsAgentsTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsAgentsTextPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataParts$inboundSchema: z.ZodType<
  StreamRunAgentDataParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsToolCallPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsTextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsDataPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsFilePart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsToolResultPart$inboundSchema),
]);
/** @internal */
export type StreamRunAgentDataParts$Outbound =
  | StreamRunAgentPartsAgentsToolCallPart$Outbound
  | StreamRunAgentPartsAgentsTextPart$Outbound
  | StreamRunAgentPartsAgentsDataPart$Outbound
  | StreamRunAgentPartsAgentsFilePart$Outbound
  | StreamRunAgentPartsAgentsToolResultPart$Outbound;

/** @internal */
export const StreamRunAgentDataParts$outboundSchema: z.ZodType<
  StreamRunAgentDataParts$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataParts
> = z.union([
  z.lazy(() => StreamRunAgentPartsAgentsToolCallPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsTextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsDataPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsFilePart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsAgentsToolResultPart$outboundSchema),
]);

export function streamRunAgentDataPartsToJSON(
  streamRunAgentDataParts: StreamRunAgentDataParts,
): string {
  return JSON.stringify(
    StreamRunAgentDataParts$outboundSchema.parse(streamRunAgentDataParts),
  );
}
export function streamRunAgentDataPartsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataParts' from JSON`,
  );
}

/** @internal */
export const MessageDifference$inboundSchema: z.ZodType<
  MessageDifference,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string(),
  role: StreamRunAgentDataRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPartsAgentsToolCallPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsTextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsDataPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsFilePart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsToolResultPart$inboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
  agent_id: z.string(),
  agent_execution_id: z.string(),
  workspace_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_id": "agentId",
    "agent_execution_id": "agentExecutionId",
    "workspace_id": "workspaceId",
  });
});
/** @internal */
export type MessageDifference$Outbound = {
  messageId: string;
  role: string;
  parts: Array<
    | StreamRunAgentPartsAgentsToolCallPart$Outbound
    | StreamRunAgentPartsAgentsTextPart$Outbound
    | StreamRunAgentPartsAgentsDataPart$Outbound
    | StreamRunAgentPartsAgentsFilePart$Outbound
    | StreamRunAgentPartsAgentsToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
  agent_id: string;
  agent_execution_id: string;
  workspace_id: string;
};

/** @internal */
export const MessageDifference$outboundSchema: z.ZodType<
  MessageDifference$Outbound,
  z.ZodTypeDef,
  MessageDifference
> = z.object({
  messageId: z.string(),
  role: StreamRunAgentDataRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPartsAgentsToolCallPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsTextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsDataPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsFilePart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsAgentsToolResultPart$outboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
  agentId: z.string(),
  agentExecutionId: z.string(),
  workspaceId: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentId: "agent_id",
    agentExecutionId: "agent_execution_id",
    workspaceId: "workspace_id",
  });
});

export function messageDifferenceToJSON(
  messageDifference: MessageDifference,
): string {
  return JSON.stringify(
    MessageDifference$outboundSchema.parse(messageDifference),
  );
}
export function messageDifferenceFromJSON(
  jsonString: string,
): SafeParseResult<MessageDifference, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessageDifference$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessageDifference' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataFinishReason$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataFinishReason
> = z.nativeEnum(StreamRunAgentDataFinishReason);
/** @internal */
export const StreamRunAgentDataFinishReason$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataFinishReason
> = StreamRunAgentDataFinishReason$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type
  > = z.nativeEnum(
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type,
  );
/** @internal */
export const StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type
  > =
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type$inboundSchema;

/** @internal */
export const StreamRunAgentDataAgentsFunction$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type StreamRunAgentDataAgentsFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataAgentsFunction$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function streamRunAgentDataAgentsFunctionToJSON(
  streamRunAgentDataAgentsFunction: StreamRunAgentDataAgentsFunction,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsFunction$outboundSchema.parse(
      streamRunAgentDataAgentsFunction,
    ),
  );
}
export function streamRunAgentDataAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsFunction' from JSON`,
  );
}

/** @internal */
export const DataToolCalls$inboundSchema: z.ZodType<
  DataToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type$inboundSchema
      .optional(),
  function: z.lazy(() => StreamRunAgentDataAgentsFunction$inboundSchema)
    .optional(),
});
/** @internal */
export type DataToolCalls$Outbound = {
  id?: string | undefined;
  type?: string | undefined;
  function?: StreamRunAgentDataAgentsFunction$Outbound | undefined;
};

/** @internal */
export const DataToolCalls$outboundSchema: z.ZodType<
  DataToolCalls$Outbound,
  z.ZodTypeDef,
  DataToolCalls
> = z.object({
  id: z.string().optional(),
  type:
    StreamRunAgentDataAgentsResponse200TextEventStreamResponseBody3Type$outboundSchema
      .optional(),
  function: z.lazy(() => StreamRunAgentDataAgentsFunction$outboundSchema)
    .optional(),
});

export function dataToolCallsToJSON(dataToolCalls: DataToolCalls): string {
  return JSON.stringify(DataToolCalls$outboundSchema.parse(dataToolCalls));
}
export function dataToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<DataToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataToolCalls' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsResponse200Role$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponse200Role> = z
    .nativeEnum(StreamRunAgentDataAgentsResponse200Role);
/** @internal */
export const StreamRunAgentDataAgentsResponse200Role$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentDataAgentsResponse200Role> =
    StreamRunAgentDataAgentsResponse200Role$inboundSchema;

/** @internal */
export const DataAudio$inboundSchema: z.ZodType<
  DataAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  expires_at: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    "expires_at": "expiresAt",
  });
});
/** @internal */
export type DataAudio$Outbound = {
  id: string;
  expires_at: number;
  data: string;
  transcript: string;
};

/** @internal */
export const DataAudio$outboundSchema: z.ZodType<
  DataAudio$Outbound,
  z.ZodTypeDef,
  DataAudio
> = z.object({
  id: z.string(),
  expiresAt: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    expiresAt: "expires_at",
  });
});

export function dataAudioToJSON(dataAudio: DataAudio): string {
  return JSON.stringify(DataAudio$outboundSchema.parse(dataAudio));
}
export function dataAudioFromJSON(
  jsonString: string,
): SafeParseResult<DataAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataMessage$inboundSchema: z.ZodType<
  StreamRunAgentDataMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  tool_calls: z.array(z.lazy(() => DataToolCalls$inboundSchema)).optional(),
  role: StreamRunAgentDataAgentsResponse200Role$inboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoning_signature: z.nullable(z.string()).optional(),
  redacted_reasoning: z.string().optional(),
  audio: z.nullable(z.lazy(() => DataAudio$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type StreamRunAgentDataMessage$Outbound = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  tool_calls?: Array<DataToolCalls$Outbound> | undefined;
  role?: string | undefined;
  reasoning?: string | null | undefined;
  reasoning_signature?: string | null | undefined;
  redacted_reasoning?: string | undefined;
  audio?: DataAudio$Outbound | null | undefined;
};

/** @internal */
export const StreamRunAgentDataMessage$outboundSchema: z.ZodType<
  StreamRunAgentDataMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataMessage
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  toolCalls: z.array(z.lazy(() => DataToolCalls$outboundSchema)).optional(),
  role: StreamRunAgentDataAgentsResponse200Role$outboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoningSignature: z.nullable(z.string()).optional(),
  redactedReasoning: z.string().optional(),
  audio: z.nullable(z.lazy(() => DataAudio$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function streamRunAgentDataMessageToJSON(
  streamRunAgentDataMessage: StreamRunAgentDataMessage,
): string {
  return JSON.stringify(
    StreamRunAgentDataMessage$outboundSchema.parse(streamRunAgentDataMessage),
  );
}
export function streamRunAgentDataMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataMessage' from JSON`,
  );
}

/** @internal */
export const TopLogprobs$inboundSchema: z.ZodType<
  TopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type TopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const TopLogprobs$outboundSchema: z.ZodType<
  TopLogprobs$Outbound,
  z.ZodTypeDef,
  TopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function topLogprobsToJSON(topLogprobs: TopLogprobs): string {
  return JSON.stringify(TopLogprobs$outboundSchema.parse(topLogprobs));
}
export function topLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<TopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopLogprobs' from JSON`,
  );
}

/** @internal */
export const DataContent$inboundSchema: z.ZodType<
  DataContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(z.lazy(() => TopLogprobs$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});
/** @internal */
export type DataContent$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<TopLogprobs$Outbound>;
};

/** @internal */
export const DataContent$outboundSchema: z.ZodType<
  DataContent$Outbound,
  z.ZodTypeDef,
  DataContent
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(z.lazy(() => TopLogprobs$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function dataContentToJSON(dataContent: DataContent): string {
  return JSON.stringify(DataContent$outboundSchema.parse(dataContent));
}
export function dataContentFromJSON(
  jsonString: string,
): SafeParseResult<DataContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataContent' from JSON`,
  );
}

/** @internal */
export const DataTopLogprobs$inboundSchema: z.ZodType<
  DataTopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type DataTopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const DataTopLogprobs$outboundSchema: z.ZodType<
  DataTopLogprobs$Outbound,
  z.ZodTypeDef,
  DataTopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function dataTopLogprobsToJSON(
  dataTopLogprobs: DataTopLogprobs,
): string {
  return JSON.stringify(DataTopLogprobs$outboundSchema.parse(dataTopLogprobs));
}
export function dataTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<DataTopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataTopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataTopLogprobs' from JSON`,
  );
}

/** @internal */
export const Refusal$inboundSchema: z.ZodType<Refusal, z.ZodTypeDef, unknown> =
  z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
    top_logprobs: z.array(z.lazy(() => DataTopLogprobs$inboundSchema)),
  }).transform((v) => {
    return remap$(v, {
      "top_logprobs": "topLogprobs",
    });
  });
/** @internal */
export type Refusal$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<DataTopLogprobs$Outbound>;
};

/** @internal */
export const Refusal$outboundSchema: z.ZodType<
  Refusal$Outbound,
  z.ZodTypeDef,
  Refusal
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(z.lazy(() => DataTopLogprobs$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function refusalToJSON(refusal: Refusal): string {
  return JSON.stringify(Refusal$outboundSchema.parse(refusal));
}
export function refusalFromJSON(
  jsonString: string,
): SafeParseResult<Refusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refusal' from JSON`,
  );
}

/** @internal */
export const Logprobs$inboundSchema: z.ZodType<
  Logprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(z.array(z.lazy(() => DataContent$inboundSchema))),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$inboundSchema))),
});
/** @internal */
export type Logprobs$Outbound = {
  content: Array<DataContent$Outbound> | null;
  refusal: Array<Refusal$Outbound> | null;
};

/** @internal */
export const Logprobs$outboundSchema: z.ZodType<
  Logprobs$Outbound,
  z.ZodTypeDef,
  Logprobs
> = z.object({
  content: z.nullable(z.array(z.lazy(() => DataContent$outboundSchema))),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$outboundSchema))),
});

export function logprobsToJSON(logprobs: Logprobs): string {
  return JSON.stringify(Logprobs$outboundSchema.parse(logprobs));
}
export function logprobsFromJSON(
  jsonString: string,
): SafeParseResult<Logprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Logprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Logprobs' from JSON`,
  );
}

/** @internal */
export const Choice$inboundSchema: z.ZodType<Choice, z.ZodTypeDef, unknown> = z
  .object({
    finish_reason: z.nullable(StreamRunAgentDataFinishReason$inboundSchema),
    index: z.number().default(0),
    message: z.lazy(() => StreamRunAgentDataMessage$inboundSchema),
    logprobs: z.nullable(z.lazy(() => Logprobs$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "finish_reason": "finishReason",
    });
  });
/** @internal */
export type Choice$Outbound = {
  finish_reason: string | null;
  index: number;
  message: StreamRunAgentDataMessage$Outbound;
  logprobs?: Logprobs$Outbound | null | undefined;
};

/** @internal */
export const Choice$outboundSchema: z.ZodType<
  Choice$Outbound,
  z.ZodTypeDef,
  Choice
> = z.object({
  finishReason: z.nullable(StreamRunAgentDataFinishReason$outboundSchema),
  index: z.number().default(0),
  message: z.lazy(() => StreamRunAgentDataMessage$outboundSchema),
  logprobs: z.nullable(z.lazy(() => Logprobs$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

export function choiceToJSON(choice: Choice): string {
  return JSON.stringify(Choice$outboundSchema.parse(choice));
}
export function choiceFromJSON(
  jsonString: string,
): SafeParseResult<Choice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Choice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Choice' from JSON`,
  );
}

/** @internal */
export const DataPromptTokensDetails$inboundSchema: z.ZodType<
  DataPromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type DataPromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const DataPromptTokensDetails$outboundSchema: z.ZodType<
  DataPromptTokensDetails$Outbound,
  z.ZodTypeDef,
  DataPromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    audioTokens: "audio_tokens",
  });
});

export function dataPromptTokensDetailsToJSON(
  dataPromptTokensDetails: DataPromptTokensDetails,
): string {
  return JSON.stringify(
    DataPromptTokensDetails$outboundSchema.parse(dataPromptTokensDetails),
  );
}
export function dataPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<DataPromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataPromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const DataCompletionTokensDetails$inboundSchema: z.ZodType<
  DataCompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type DataCompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const DataCompletionTokensDetails$outboundSchema: z.ZodType<
  DataCompletionTokensDetails$Outbound,
  z.ZodTypeDef,
  DataCompletionTokensDetails
> = z.object({
  reasoningTokens: z.nullable(z.number()).optional(),
  acceptedPredictionTokens: z.nullable(z.number()).optional(),
  rejectedPredictionTokens: z.nullable(z.number()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningTokens: "reasoning_tokens",
    acceptedPredictionTokens: "accepted_prediction_tokens",
    rejectedPredictionTokens: "rejected_prediction_tokens",
    audioTokens: "audio_tokens",
  });
});

export function dataCompletionTokensDetailsToJSON(
  dataCompletionTokensDetails: DataCompletionTokensDetails,
): string {
  return JSON.stringify(
    DataCompletionTokensDetails$outboundSchema.parse(
      dataCompletionTokensDetails,
    ),
  );
}
export function dataCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<DataCompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const DataUsage$inboundSchema: z.ZodType<
  DataUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => DataPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => DataCompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type DataUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?: DataPromptTokensDetails$Outbound | null | undefined;
  completion_tokens_details?:
    | DataCompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const DataUsage$outboundSchema: z.ZodType<
  DataUsage$Outbound,
  z.ZodTypeDef,
  DataUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => DataPromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => DataCompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function dataUsageToJSON(dataUsage: DataUsage): string {
  return JSON.stringify(DataUsage$outboundSchema.parse(dataUsage));
}
export function dataUsageFromJSON(
  jsonString: string,
): SafeParseResult<DataUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataUsage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsData$inboundSchema: z.ZodType<
  StreamRunAgentDataAgentsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_id: z.string(),
  message_difference: z.record(z.lazy(() => MessageDifference$inboundSchema)),
  choice: z.lazy(() => Choice$inboundSchema).optional(),
  choiceIndex: z.number().optional(),
  iteration: z.number(),
  accumulated_execution_time: z.number(),
  responseId: z.string().optional(),
  usage: z.lazy(() => DataUsage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "agent_id": "agentId",
    "message_difference": "messageDifference",
    "accumulated_execution_time": "accumulatedExecutionTime",
  });
});
/** @internal */
export type StreamRunAgentDataAgentsData$Outbound = {
  agent_id: string;
  message_difference: { [k: string]: MessageDifference$Outbound };
  choice?: Choice$Outbound | undefined;
  choiceIndex?: number | undefined;
  iteration: number;
  accumulated_execution_time: number;
  responseId?: string | undefined;
  usage?: DataUsage$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentDataAgentsData$outboundSchema: z.ZodType<
  StreamRunAgentDataAgentsData$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataAgentsData
> = z.object({
  agentId: z.string(),
  messageDifference: z.record(z.lazy(() => MessageDifference$outboundSchema)),
  choice: z.lazy(() => Choice$outboundSchema).optional(),
  choiceIndex: z.number().optional(),
  iteration: z.number(),
  accumulatedExecutionTime: z.number(),
  responseId: z.string().optional(),
  usage: z.lazy(() => DataUsage$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    agentId: "agent_id",
    messageDifference: "message_difference",
    accumulatedExecutionTime: "accumulated_execution_time",
  });
});

export function streamRunAgentDataAgentsDataToJSON(
  streamRunAgentDataAgentsData: StreamRunAgentDataAgentsData,
): string {
  return JSON.stringify(
    StreamRunAgentDataAgentsData$outboundSchema.parse(
      streamRunAgentDataAgentsData,
    ),
  );
}
export function streamRunAgentDataAgentsDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataAgentsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataAgentsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataAgentsData' from JSON`,
  );
}

/** @internal */
export const Data3$inboundSchema: z.ZodType<Data3, z.ZodTypeDef, unknown> = z
  .object({
    type: StreamRunAgentDataAgentsResponseType$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() => StreamRunAgentDataAgentsData$inboundSchema),
  });
/** @internal */
export type Data3$Outbound = {
  type: string;
  timestamp: string;
  data: StreamRunAgentDataAgentsData$Outbound;
};

/** @internal */
export const Data3$outboundSchema: z.ZodType<
  Data3$Outbound,
  z.ZodTypeDef,
  Data3
> = z.object({
  type: StreamRunAgentDataAgentsResponseType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => StreamRunAgentDataAgentsData$outboundSchema),
});

export function data3ToJSON(data3: Data3): string {
  return JSON.stringify(Data3$outboundSchema.parse(data3));
}
export function data3FromJSON(
  jsonString: string,
): SafeParseResult<Data3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data3' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataAgentsType
> = z.nativeEnum(StreamRunAgentDataAgentsType);
/** @internal */
export const StreamRunAgentDataAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataAgentsType
> = StreamRunAgentDataAgentsType$inboundSchema;

/** @internal */
export const DataRole$inboundSchema: z.ZodNativeEnum<typeof DataRole> = z
  .nativeEnum(DataRole);
/** @internal */
export const DataRole$outboundSchema: z.ZodNativeEnum<typeof DataRole> =
  DataRole$inboundSchema;

/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamKind
  > = z.nativeEnum(StreamRunAgentPartsAgentsResponse200TextEventStreamKind);
/** @internal */
export const StreamRunAgentPartsAgentsResponse200TextEventStreamKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsResponse200TextEventStreamKind
  > = StreamRunAgentPartsAgentsResponse200TextEventStreamKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsToolResultPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsResponse200TextEventStreamKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type StreamRunAgentPartsToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsToolResultPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsToolResultPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsToolResultPart
> = z.object({
  kind: StreamRunAgentPartsAgentsResponse200TextEventStreamKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function streamRunAgentPartsToolResultPartToJSON(
  streamRunAgentPartsToolResultPart: StreamRunAgentPartsToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsToolResultPart$outboundSchema.parse(
      streamRunAgentPartsToolResultPart,
    ),
  );
}
export function streamRunAgentPartsToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponse200Kind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsResponse200Kind> = z
    .nativeEnum(StreamRunAgentPartsAgentsResponse200Kind);
/** @internal */
export const StreamRunAgentPartsAgentsResponse200Kind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsResponse200Kind> =
    StreamRunAgentPartsAgentsResponse200Kind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsToolCallPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsToolCallPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsResponse200Kind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type StreamRunAgentPartsToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsToolCallPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsToolCallPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsToolCallPart
> = z.object({
  kind: StreamRunAgentPartsAgentsResponse200Kind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

export function streamRunAgentPartsToolCallPartToJSON(
  streamRunAgentPartsToolCallPart: StreamRunAgentPartsToolCallPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsToolCallPart$outboundSchema.parse(
      streamRunAgentPartsToolCallPart,
    ),
  );
}
export function streamRunAgentPartsToolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsToolCallPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsToolCallPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsToolCallPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsResponseKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsResponseKind> = z.nativeEnum(
    StreamRunAgentPartsAgentsResponseKind,
  );
/** @internal */
export const StreamRunAgentPartsAgentsResponseKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsResponseKind> =
    StreamRunAgentPartsAgentsResponseKind$inboundSchema;

/** @internal */
export const StreamRunAgentFileAgentsFileInURIFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileAgentsFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileAgentsFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsFileInURIFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileAgentsFileInURIFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileAgentsFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileAgentsFileInURIFormatToJSON(
  streamRunAgentFileAgentsFileInURIFormat:
    StreamRunAgentFileAgentsFileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsFileInURIFormat$outboundSchema.parse(
      streamRunAgentFileAgentsFileInURIFormat,
    ),
  );
}
export function streamRunAgentFileAgentsFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFileAgentsFileInURIFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsFileInURIFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFileAgentsFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileAgentsBinaryFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileAgentsBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileAgentsBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileAgentsBinaryFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileAgentsBinaryFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileAgentsBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileAgentsBinaryFormatToJSON(
  streamRunAgentFileAgentsBinaryFormat: StreamRunAgentFileAgentsBinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileAgentsBinaryFormat$outboundSchema.parse(
      streamRunAgentFileAgentsBinaryFormat,
    ),
  );
}
export function streamRunAgentFileAgentsBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFileAgentsBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFileAgentsBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileAgentsBinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsFile$inboundSchema: z.ZodType<
  StreamRunAgentPartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsBinaryFormat$inboundSchema),
  z.lazy(() => StreamRunAgentFileAgentsFileInURIFormat$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPartsFile$Outbound =
  | StreamRunAgentFileAgentsBinaryFormat$Outbound
  | StreamRunAgentFileAgentsFileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPartsFile$outboundSchema: z.ZodType<
  StreamRunAgentPartsFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsFile
> = z.union([
  z.lazy(() => StreamRunAgentFileAgentsBinaryFormat$outboundSchema),
  z.lazy(() => StreamRunAgentFileAgentsFileInURIFormat$outboundSchema),
]);

export function streamRunAgentPartsFileToJSON(
  streamRunAgentPartsFile: StreamRunAgentPartsFile,
): string {
  return JSON.stringify(
    StreamRunAgentPartsFile$outboundSchema.parse(streamRunAgentPartsFile),
  );
}
export function streamRunAgentPartsFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsFilePart$inboundSchema: z.ZodType<
  StreamRunAgentPartsFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsResponseKind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileAgentsBinaryFormat$inboundSchema),
    z.lazy(() => StreamRunAgentFileAgentsFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsFilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileAgentsBinaryFormat$Outbound
    | StreamRunAgentFileAgentsFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsFilePart$outboundSchema: z.ZodType<
  StreamRunAgentPartsFilePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsFilePart
> = z.object({
  kind: StreamRunAgentPartsAgentsResponseKind$outboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileAgentsBinaryFormat$outboundSchema),
    z.lazy(() => StreamRunAgentFileAgentsFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPartsFilePartToJSON(
  streamRunAgentPartsFilePart: StreamRunAgentPartsFilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsFilePart$outboundSchema.parse(
      streamRunAgentPartsFilePart,
    ),
  );
}
export function streamRunAgentPartsFilePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsFilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsAgentsKind
> = z.nativeEnum(StreamRunAgentPartsAgentsKind);
/** @internal */
export const StreamRunAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsAgentsKind
> = StreamRunAgentPartsAgentsKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsDataPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsDataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPartsDataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPartsDataPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsDataPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsDataPart
> = z.object({
  kind: StreamRunAgentPartsAgentsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPartsDataPartToJSON(
  streamRunAgentPartsDataPart: StreamRunAgentPartsDataPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsDataPart$outboundSchema.parse(
      streamRunAgentPartsDataPart,
    ),
  );
}
export function streamRunAgentPartsDataPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsDataPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsDataPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsDataPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsKind
> = z.nativeEnum(StreamRunAgentPartsKind);
/** @internal */
export const StreamRunAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsKind
> = StreamRunAgentPartsKind$inboundSchema;

/** @internal */
export const StreamRunAgentPartsTextPart$inboundSchema: z.ZodType<
  StreamRunAgentPartsTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type StreamRunAgentPartsTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPartsTextPart$outboundSchema: z.ZodType<
  StreamRunAgentPartsTextPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsTextPart
> = z.object({
  kind: StreamRunAgentPartsKind$outboundSchema,
  text: z.string(),
});

export function streamRunAgentPartsTextPartToJSON(
  streamRunAgentPartsTextPart: StreamRunAgentPartsTextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPartsTextPart$outboundSchema.parse(
      streamRunAgentPartsTextPart,
    ),
  );
}
export function streamRunAgentPartsTextPartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsTextPart' from JSON`,
  );
}

/** @internal */
export const DataParts$inboundSchema: z.ZodType<
  DataParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPartsToolCallPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsTextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsDataPart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsFilePart$inboundSchema),
  z.lazy(() => StreamRunAgentPartsToolResultPart$inboundSchema),
]);
/** @internal */
export type DataParts$Outbound =
  | StreamRunAgentPartsToolCallPart$Outbound
  | StreamRunAgentPartsTextPart$Outbound
  | StreamRunAgentPartsDataPart$Outbound
  | StreamRunAgentPartsFilePart$Outbound
  | StreamRunAgentPartsToolResultPart$Outbound;

/** @internal */
export const DataParts$outboundSchema: z.ZodType<
  DataParts$Outbound,
  z.ZodTypeDef,
  DataParts
> = z.union([
  z.lazy(() => StreamRunAgentPartsToolCallPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsTextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsDataPart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsFilePart$outboundSchema),
  z.lazy(() => StreamRunAgentPartsToolResultPart$outboundSchema),
]);

export function dataPartsToJSON(dataParts: DataParts): string {
  return JSON.stringify(DataParts$outboundSchema.parse(dataParts));
}
export function dataPartsFromJSON(
  jsonString: string,
): SafeParseResult<DataParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataParts' from JSON`,
  );
}

/** @internal */
export const InputMessage$inboundSchema: z.ZodType<
  InputMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: DataRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPartsToolCallPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsTextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsDataPart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsFilePart$inboundSchema),
      z.lazy(() => StreamRunAgentPartsToolResultPart$inboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InputMessage$Outbound = {
  messageId?: string | undefined;
  role: string;
  parts: Array<
    | StreamRunAgentPartsToolCallPart$Outbound
    | StreamRunAgentPartsTextPart$Outbound
    | StreamRunAgentPartsDataPart$Outbound
    | StreamRunAgentPartsFilePart$Outbound
    | StreamRunAgentPartsToolResultPart$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InputMessage$outboundSchema: z.ZodType<
  InputMessage$Outbound,
  z.ZodTypeDef,
  InputMessage
> = z.object({
  messageId: z.string().optional(),
  role: DataRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPartsToolCallPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsTextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsDataPart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsFilePart$outboundSchema),
      z.lazy(() => StreamRunAgentPartsToolResultPart$outboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function inputMessageToJSON(inputMessage: InputMessage): string {
  return JSON.stringify(InputMessage$outboundSchema.parse(inputMessage));
}
export function inputMessageFromJSON(
  jsonString: string,
): SafeParseResult<InputMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputMessage' from JSON`,
  );
}

/** @internal */
export const DataToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof DataToolApprovalRequired
> = z.nativeEnum(DataToolApprovalRequired);
/** @internal */
export const DataToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof DataToolApprovalRequired
> = DataToolApprovalRequired$inboundSchema;

/** @internal */
export const StreamRunAgentDataConditions$inboundSchema: z.ZodType<
  StreamRunAgentDataConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type StreamRunAgentDataConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const StreamRunAgentDataConditions$outboundSchema: z.ZodType<
  StreamRunAgentDataConditions$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function streamRunAgentDataConditionsToJSON(
  streamRunAgentDataConditions: StreamRunAgentDataConditions,
): string {
  return JSON.stringify(
    StreamRunAgentDataConditions$outboundSchema.parse(
      streamRunAgentDataConditions,
    ),
  );
}
export function streamRunAgentDataConditionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataConditions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataTools$inboundSchema: z.ZodType<
  StreamRunAgentDataTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => StreamRunAgentDataConditions$inboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});
/** @internal */
export type StreamRunAgentDataTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<StreamRunAgentDataConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const StreamRunAgentDataTools$outboundSchema: z.ZodType<
  StreamRunAgentDataTools$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  toolId: z.string().optional(),
  conditions: z.array(z.lazy(() => StreamRunAgentDataConditions$outboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
    toolId: "tool_id",
  });
});

export function streamRunAgentDataToolsToJSON(
  streamRunAgentDataTools: StreamRunAgentDataTools,
): string {
  return JSON.stringify(
    StreamRunAgentDataTools$outboundSchema.parse(streamRunAgentDataTools),
  );
}
export function streamRunAgentDataToolsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataTools' from JSON`,
  );
}

/** @internal */
export const DataExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof DataExecuteOn
> = z.nativeEnum(DataExecuteOn);
/** @internal */
export const DataExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof DataExecuteOn
> = DataExecuteOn$inboundSchema;

/** @internal */
export const DataEvaluators$inboundSchema: z.ZodType<
  DataEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: DataExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type DataEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const DataEvaluators$outboundSchema: z.ZodType<
  DataEvaluators$Outbound,
  z.ZodTypeDef,
  DataEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: DataExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function dataEvaluatorsToJSON(dataEvaluators: DataEvaluators): string {
  return JSON.stringify(DataEvaluators$outboundSchema.parse(dataEvaluators));
}
export function dataEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<DataEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataEvaluators' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataExecuteOn
> = z.nativeEnum(StreamRunAgentDataExecuteOn);
/** @internal */
export const StreamRunAgentDataExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataExecuteOn
> = StreamRunAgentDataExecuteOn$inboundSchema;

/** @internal */
export const DataGuardrails$inboundSchema: z.ZodType<
  DataGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: StreamRunAgentDataExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type DataGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const DataGuardrails$outboundSchema: z.ZodType<
  DataGuardrails$Outbound,
  z.ZodTypeDef,
  DataGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentDataExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function dataGuardrailsToJSON(dataGuardrails: DataGuardrails): string {
  return JSON.stringify(DataGuardrails$outboundSchema.parse(dataGuardrails));
}
export function dataGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<DataGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataGuardrails' from JSON`,
  );
}

/** @internal */
export const DataSettings$inboundSchema: z.ZodType<
  DataSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: DataToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => StreamRunAgentDataTools$inboundSchema))
    .optional(),
  evaluators: z.array(z.lazy(() => DataEvaluators$inboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => DataGuardrails$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type DataSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<StreamRunAgentDataTools$Outbound> | undefined;
  evaluators?: Array<DataEvaluators$Outbound> | undefined;
  guardrails?: Array<DataGuardrails$Outbound> | undefined;
};

/** @internal */
export const DataSettings$outboundSchema: z.ZodType<
  DataSettings$Outbound,
  z.ZodTypeDef,
  DataSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: DataToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => StreamRunAgentDataTools$outboundSchema))
    .optional(),
  evaluators: z.array(z.lazy(() => DataEvaluators$outboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => DataGuardrails$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function dataSettingsToJSON(dataSettings: DataSettings): string {
  return JSON.stringify(DataSettings$outboundSchema.parse(dataSettings));
}
export function dataSettingsFromJSON(
  jsonString: string,
): SafeParseResult<DataSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataSettings' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataData$inboundSchema: z.ZodType<
  StreamRunAgentDataData,
  z.ZodTypeDef,
  unknown
> = z.object({
  integration_id: z.string().optional(),
  inputMessage: z.lazy(() => InputMessage$inboundSchema),
  modelId: z.string(),
  instructions: z.string(),
  system_prompt: z.string(),
  settings: z.lazy(() => DataSettings$inboundSchema).optional(),
  agent_manifest_id: z.string(),
  agent_key: z.string(),
  variables: z.record(z.any()).optional(),
  tool_execution_id: z.string().optional(),
  is_continuation: z.boolean().optional(),
  stream: z.boolean().optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "system_prompt": "systemPrompt",
    "agent_manifest_id": "agentManifestId",
    "agent_key": "agentKey",
    "tool_execution_id": "toolExecutionId",
    "is_continuation": "isContinuation",
  });
});
/** @internal */
export type StreamRunAgentDataData$Outbound = {
  integration_id?: string | undefined;
  inputMessage: InputMessage$Outbound;
  modelId: string;
  instructions: string;
  system_prompt: string;
  settings?: DataSettings$Outbound | undefined;
  agent_manifest_id: string;
  agent_key: string;
  variables?: { [k: string]: any } | undefined;
  tool_execution_id?: string | undefined;
  is_continuation?: boolean | undefined;
  stream?: boolean | undefined;
  responseId?: string | undefined;
};

/** @internal */
export const StreamRunAgentDataData$outboundSchema: z.ZodType<
  StreamRunAgentDataData$Outbound,
  z.ZodTypeDef,
  StreamRunAgentDataData
> = z.object({
  integrationId: z.string().optional(),
  inputMessage: z.lazy(() => InputMessage$outboundSchema),
  modelId: z.string(),
  instructions: z.string(),
  systemPrompt: z.string(),
  settings: z.lazy(() => DataSettings$outboundSchema).optional(),
  agentManifestId: z.string(),
  agentKey: z.string(),
  variables: z.record(z.any()).optional(),
  toolExecutionId: z.string().optional(),
  isContinuation: z.boolean().optional(),
  stream: z.boolean().optional(),
  responseId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    systemPrompt: "system_prompt",
    agentManifestId: "agent_manifest_id",
    agentKey: "agent_key",
    toolExecutionId: "tool_execution_id",
    isContinuation: "is_continuation",
  });
});

export function streamRunAgentDataDataToJSON(
  streamRunAgentDataData: StreamRunAgentDataData,
): string {
  return JSON.stringify(
    StreamRunAgentDataData$outboundSchema.parse(streamRunAgentDataData),
  );
}
export function streamRunAgentDataDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentDataData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentDataData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentDataData' from JSON`,
  );
}

/** @internal */
export const Data2$inboundSchema: z.ZodType<Data2, z.ZodTypeDef, unknown> = z
  .object({
    type: StreamRunAgentDataAgentsType$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() => StreamRunAgentDataData$inboundSchema),
  });
/** @internal */
export type Data2$Outbound = {
  type: string;
  timestamp: string;
  data: StreamRunAgentDataData$Outbound;
};

/** @internal */
export const Data2$outboundSchema: z.ZodType<
  Data2$Outbound,
  z.ZodTypeDef,
  Data2
> = z.object({
  type: StreamRunAgentDataAgentsType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => StreamRunAgentDataData$outboundSchema),
});

export function data2ToJSON(data2: Data2): string {
  return JSON.stringify(Data2$outboundSchema.parse(data2));
}
export function data2FromJSON(
  jsonString: string,
): SafeParseResult<Data2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentDataType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataType
> = z.nativeEnum(StreamRunAgentDataType);
/** @internal */
export const StreamRunAgentDataType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentDataType
> = StreamRunAgentDataType$inboundSchema;

/** @internal */
export const DataData$inboundSchema: z.ZodType<
  DataData,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_task_id: z.string(),
  workspace_id: z.string(),
  trace_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_task_id": "agentTaskId",
    "workspace_id": "workspaceId",
    "trace_id": "traceId",
  });
});
/** @internal */
export type DataData$Outbound = {
  agent_task_id: string;
  workspace_id: string;
  trace_id: string;
};

/** @internal */
export const DataData$outboundSchema: z.ZodType<
  DataData$Outbound,
  z.ZodTypeDef,
  DataData
> = z.object({
  agentTaskId: z.string(),
  workspaceId: z.string(),
  traceId: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentTaskId: "agent_task_id",
    workspaceId: "workspace_id",
    traceId: "trace_id",
  });
});

export function dataDataToJSON(dataData: DataData): string {
  return JSON.stringify(DataData$outboundSchema.parse(dataData));
}
export function dataDataFromJSON(
  jsonString: string,
): SafeParseResult<DataData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataData' from JSON`,
  );
}

/** @internal */
export const Data1$inboundSchema: z.ZodType<Data1, z.ZodTypeDef, unknown> = z
  .object({
    type: StreamRunAgentDataType$inboundSchema,
    timestamp: z.string(),
    data: z.lazy(() => DataData$inboundSchema),
  });
/** @internal */
export type Data1$Outbound = {
  type: string;
  timestamp: string;
  data: DataData$Outbound;
};

/** @internal */
export const Data1$outboundSchema: z.ZodType<
  Data1$Outbound,
  z.ZodTypeDef,
  Data1
> = z.object({
  type: StreamRunAgentDataType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => DataData$outboundSchema),
});

export function data1ToJSON(data1: Data1): string {
  return JSON.stringify(Data1$outboundSchema.parse(data1));
}
export function data1FromJSON(
  jsonString: string,
): SafeParseResult<Data1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentData$inboundSchema: z.ZodType<
  StreamRunAgentData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Data1$inboundSchema),
  z.lazy(() => Data2$inboundSchema),
  z.lazy(() => Data3$inboundSchema),
  z.lazy(() => Data4$inboundSchema),
  z.lazy(() => StreamRunAgentData5$inboundSchema),
  z.lazy(() => StreamRunAgentData6$inboundSchema),
  z.lazy(() => Seven$inboundSchema),
  z.lazy(() => Eight$inboundSchema),
  z.lazy(() => Nine$inboundSchema),
  z.lazy(() => Ten$inboundSchema),
  z.lazy(() => Eleven$inboundSchema),
  z.lazy(() => Twelve$inboundSchema),
  z.lazy(() => Thirteen$inboundSchema),
  z.lazy(() => Fourteen$inboundSchema),
  z.lazy(() => Fifteen$inboundSchema),
  z.lazy(() => Sixteen$inboundSchema),
  z.lazy(() => Seventeen$inboundSchema),
]);
/** @internal */
export type StreamRunAgentData$Outbound =
  | Data1$Outbound
  | Data2$Outbound
  | Data3$Outbound
  | Data4$Outbound
  | StreamRunAgentData5$Outbound
  | StreamRunAgentData6$Outbound
  | Seven$Outbound
  | Eight$Outbound
  | Nine$Outbound
  | Ten$Outbound
  | Eleven$Outbound
  | Twelve$Outbound
  | Thirteen$Outbound
  | Fourteen$Outbound
  | Fifteen$Outbound
  | Sixteen$Outbound
  | Seventeen$Outbound;

/** @internal */
export const StreamRunAgentData$outboundSchema: z.ZodType<
  StreamRunAgentData$Outbound,
  z.ZodTypeDef,
  StreamRunAgentData
> = z.union([
  z.lazy(() => Data1$outboundSchema),
  z.lazy(() => Data2$outboundSchema),
  z.lazy(() => Data3$outboundSchema),
  z.lazy(() => Data4$outboundSchema),
  z.lazy(() => StreamRunAgentData5$outboundSchema),
  z.lazy(() => StreamRunAgentData6$outboundSchema),
  z.lazy(() => Seven$outboundSchema),
  z.lazy(() => Eight$outboundSchema),
  z.lazy(() => Nine$outboundSchema),
  z.lazy(() => Ten$outboundSchema),
  z.lazy(() => Eleven$outboundSchema),
  z.lazy(() => Twelve$outboundSchema),
  z.lazy(() => Thirteen$outboundSchema),
  z.lazy(() => Fourteen$outboundSchema),
  z.lazy(() => Fifteen$outboundSchema),
  z.lazy(() => Sixteen$outboundSchema),
  z.lazy(() => Seventeen$outboundSchema),
]);

export function streamRunAgentDataToJSON(
  streamRunAgentData: StreamRunAgentData,
): string {
  return JSON.stringify(
    StreamRunAgentData$outboundSchema.parse(streamRunAgentData),
  );
}
export function streamRunAgentDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentData' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseBody$inboundSchema: z.ZodType<
  StreamRunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      z.lazy(() => Data1$inboundSchema),
      z.lazy(() => Data2$inboundSchema),
      z.lazy(() => Data3$inboundSchema),
      z.lazy(() => Data4$inboundSchema),
      z.lazy(() => StreamRunAgentData5$inboundSchema),
      z.lazy(() => StreamRunAgentData6$inboundSchema),
      z.lazy(() => Seven$inboundSchema),
      z.lazy(() => Eight$inboundSchema),
      z.lazy(() => Nine$inboundSchema),
      z.lazy(() => Ten$inboundSchema),
      z.lazy(() => Eleven$inboundSchema),
      z.lazy(() => Twelve$inboundSchema),
      z.lazy(() => Thirteen$inboundSchema),
      z.lazy(() => Fourteen$inboundSchema),
      z.lazy(() => Fifteen$inboundSchema),
      z.lazy(() => Sixteen$inboundSchema),
      z.lazy(() => Seventeen$inboundSchema),
    ]),
  ),
});
/** @internal */
export type StreamRunAgentResponseBody$Outbound = {
  data:
    | Data1$Outbound
    | Data2$Outbound
    | Data3$Outbound
    | Data4$Outbound
    | StreamRunAgentData5$Outbound
    | StreamRunAgentData6$Outbound
    | Seven$Outbound
    | Eight$Outbound
    | Nine$Outbound
    | Ten$Outbound
    | Eleven$Outbound
    | Twelve$Outbound
    | Thirteen$Outbound
    | Fourteen$Outbound
    | Fifteen$Outbound
    | Sixteen$Outbound
    | Seventeen$Outbound;
};

/** @internal */
export const StreamRunAgentResponseBody$outboundSchema: z.ZodType<
  StreamRunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseBody
> = z.object({
  data: z.union([
    z.lazy(() => Data1$outboundSchema),
    z.lazy(() => Data2$outboundSchema),
    z.lazy(() => Data3$outboundSchema),
    z.lazy(() => Data4$outboundSchema),
    z.lazy(() => StreamRunAgentData5$outboundSchema),
    z.lazy(() => StreamRunAgentData6$outboundSchema),
    z.lazy(() => Seven$outboundSchema),
    z.lazy(() => Eight$outboundSchema),
    z.lazy(() => Nine$outboundSchema),
    z.lazy(() => Ten$outboundSchema),
    z.lazy(() => Eleven$outboundSchema),
    z.lazy(() => Twelve$outboundSchema),
    z.lazy(() => Thirteen$outboundSchema),
    z.lazy(() => Fourteen$outboundSchema),
    z.lazy(() => Fifteen$outboundSchema),
    z.lazy(() => Sixteen$outboundSchema),
    z.lazy(() => Seventeen$outboundSchema),
  ]),
});

export function streamRunAgentResponseBodyToJSON(
  streamRunAgentResponseBody: StreamRunAgentResponseBody,
): string {
  return JSON.stringify(
    StreamRunAgentResponseBody$outboundSchema.parse(streamRunAgentResponseBody),
  );
}
export function streamRunAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseBody' from JSON`,
  );
}
