/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentModelConfigurationFormat;
};

export type StreamRunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: StreamRunAgentResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatText
  | StreamRunAgentResponseFormatJSONObject
  | StreamRunAgentResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const StreamRunAgentModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type StreamRunAgentModelConfigurationReasoningEffort = ClosedEnum<
  typeof StreamRunAgentModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type StreamRunAgentModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceType = ClosedEnum<
  typeof StreamRunAgentToolChoiceType
>;

export type StreamRunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type StreamRunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceType | undefined;
  function: StreamRunAgentToolChoiceFunction;
};

export const StreamRunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoice1 = ClosedEnum<
  typeof StreamRunAgentToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentModelConfigurationToolChoice =
  | StreamRunAgentToolChoice2
  | StreamRunAgentToolChoice1;

export const StreamRunAgentModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const StreamRunAgentId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type StreamRunAgentId1 = ClosedEnum<typeof StreamRunAgentId1>;

export type StreamRunAgentModelConfigurationId = StreamRunAgentId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const StreamRunAgentModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type StreamRunAgentModelConfigurationExecuteOn = ClosedEnum<
  typeof StreamRunAgentModelConfigurationExecuteOn
>;

export type StreamRunAgentModelConfigurationGuardrails = {
  id: StreamRunAgentId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: StreamRunAgentModelConfigurationExecuteOn;
};

export type StreamRunAgentModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type StreamRunAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const StreamRunAgentModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type StreamRunAgentModelConfigurationType = ClosedEnum<
  typeof StreamRunAgentModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type StreamRunAgentModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: StreamRunAgentModelConfigurationType;
};

export const StreamRunAgentLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type StreamRunAgentLoadBalancerType = ClosedEnum<
  typeof StreamRunAgentLoadBalancerType
>;

export type StreamRunAgentLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type StreamRunAgentLoadBalancer1 = {
  type: StreamRunAgentLoadBalancerType;
  models: Array<StreamRunAgentLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type StreamRunAgentModelConfigurationLoadBalancer =
  StreamRunAgentLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type StreamRunAgentModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type StreamRunAgentModelConfigurationParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatText
    | StreamRunAgentResponseFormatJSONObject
    | StreamRunAgentResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: StreamRunAgentModelConfigurationReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoice2
    | StreamRunAgentToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<StreamRunAgentModelConfigurationGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<StreamRunAgentModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: StreamRunAgentModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: StreamRunAgentModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: StreamRunAgentLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: StreamRunAgentModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type StreamRunAgentModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type StreamRunAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: StreamRunAgentModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: StreamRunAgentModelConfigurationAgentsRetry | undefined;
};

/**
 * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
 */
export type StreamRunAgentModelConfiguration =
  | StreamRunAgentModelConfiguration2
  | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentFallbackModelConfigurationFormat;
};

export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema = {
  type: "json_schema";
  jsonSchema: StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentFallbackModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatAgentsText
  | StreamRunAgentResponseFormatAgentsJSONObject
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const StreamRunAgentFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type StreamRunAgentFallbackModelConfigurationReasoningEffort =
  ClosedEnum<typeof StreamRunAgentFallbackModelConfigurationReasoningEffort>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type StreamRunAgentFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceAgentsType = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgentsType
>;

export type StreamRunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type StreamRunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceAgentsType | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction;
};

export const StreamRunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoiceAgents1 = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentFallbackModelConfigurationToolChoice =
  | StreamRunAgentToolChoiceAgents2
  | StreamRunAgentToolChoiceAgents1;

export const StreamRunAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const StreamRunAgentIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type StreamRunAgentIdAgents1 = ClosedEnum<
  typeof StreamRunAgentIdAgents1
>;

export type StreamRunAgentFallbackModelConfigurationId =
  | StreamRunAgentIdAgents1
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const StreamRunAgentFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type StreamRunAgentFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationExecuteOn
>;

export type StreamRunAgentFallbackModelConfigurationGuardrails = {
  id: StreamRunAgentIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: StreamRunAgentFallbackModelConfigurationExecuteOn;
};

export type StreamRunAgentFallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type StreamRunAgentFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const StreamRunAgentFallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type StreamRunAgentFallbackModelConfigurationType = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type StreamRunAgentFallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: StreamRunAgentFallbackModelConfigurationType;
};

export const StreamRunAgentLoadBalancerAgentsType = {
  WeightBased: "weight_based",
} as const;
export type StreamRunAgentLoadBalancerAgentsType = ClosedEnum<
  typeof StreamRunAgentLoadBalancerAgentsType
>;

export type StreamRunAgentLoadBalancerAgentsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type StreamRunAgentLoadBalancerAgents1 = {
  type: StreamRunAgentLoadBalancerAgentsType;
  models: Array<StreamRunAgentLoadBalancerAgentsModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type StreamRunAgentFallbackModelConfigurationLoadBalancer =
  StreamRunAgentLoadBalancerAgents1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type StreamRunAgentFallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type StreamRunAgentFallbackModelConfigurationParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatAgentsText
    | StreamRunAgentResponseFormatAgentsJSONObject
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | StreamRunAgentFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoiceAgents2
    | StreamRunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<StreamRunAgentFallbackModelConfigurationGuardrails>
    | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?:
    | Array<StreamRunAgentFallbackModelConfigurationFallbacks>
    | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: StreamRunAgentFallbackModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: StreamRunAgentFallbackModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: StreamRunAgentLoadBalancerAgents1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: StreamRunAgentFallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type StreamRunAgentFallbackModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type StreamRunAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: StreamRunAgentFallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: StreamRunAgentFallbackModelConfigurationAgentsRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type StreamRunAgentFallbackModelConfiguration =
  | StreamRunAgentFallbackModelConfiguration2
  | string;

/**
 * Message containing tool execution results
 */
export const StreamRunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type StreamRunAgentRoleToolMessage = ClosedEnum<
  typeof StreamRunAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const StreamRunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type StreamRunAgentRoleUserMessage = ClosedEnum<
  typeof StreamRunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamRunAgentRole =
  | StreamRunAgentRoleUserMessage
  | StreamRunAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamRunAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart
  | components.ErrorPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type StreamRunAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamRunAgentRoleUserMessage | StreamRunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | components.TextPart
    | components.FilePart
    | components.ToolResultPart
    | components.ErrorPart
  >;
};

/**
 * Information about the identity making the request. If the identity does not exist, it will be created automatically.
 */
export type StreamRunAgentIdentity = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type StreamRunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamRunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamRunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamRunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type StreamRunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type StreamRunAgentAgentToolInputRunAgentsHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  {
    Object: "object",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  >;

export type StreamRunAgentAgentToolInputRunAgentsSchema = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type AgentToolInputRunTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: StreamRunAgentAgentToolInputRunAgentsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const AgentToolInputRunConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type AgentToolInputRunConnectionType = ClosedEnum<
  typeof AgentToolInputRunConnectionType
>;

export type AgentToolInputRunMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?:
    | { [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders }
    | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<AgentToolInputRunTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: AgentToolInputRunConnectionType;
};

/**
 * MCP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunMCPToolRun = {
  type: "mcp";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  mcp: AgentToolInputRunMcp;
  requiresApproval?: boolean | undefined;
};

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunSchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type StreamRunAgentAgentToolInputRunJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: StreamRunAgentAgentToolInputRunSchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * JSON Schema tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunJSONSchemaToolRun = {
  type: "json_schema";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  jsonSchema: StreamRunAgentAgentToolInputRunJsonSchema;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunAgentsParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type StreamRunAgentAgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunAgentsParameters | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunFunctionToolRun = {
  type: "function";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const AgentToolInputRunLanguage = {
  Python: "python",
} as const;
export type AgentToolInputRunLanguage = ClosedEnum<
  typeof AgentToolInputRunLanguage
>;

export type AgentToolInputRunCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunParameters | undefined;
  language: AgentToolInputRunLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunCodeToolRun = {
  type: "code";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: AgentToolInputRunCodeTool;
  requiresApproval?: boolean | undefined;
};

/**
 * The HTTP method to use.
 */
export const AgentToolInputRunMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type AgentToolInputRunMethod = ClosedEnum<
  typeof AgentToolInputRunMethod
>;

export type StreamRunAgentHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type StreamRunAgentAgentToolInputRunHeaders =
  | StreamRunAgentHeaders2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type AgentToolInputRunBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: AgentToolInputRunMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: StreamRunAgentHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type AgentToolInputRunDefaultValue = string | number | boolean;

export type AgentToolInputRunArguments = {
  /**
   * The type of the argument.
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type AgentToolInputRunHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: AgentToolInputRunBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: AgentToolInputRunArguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunHTTPToolRun = {
  type: "http";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: AgentToolInputRunHttp;
  requiresApproval?: boolean | undefined;
};

/**
 * Returns the current date and time
 */
export type StreamRunAgentAgentToolInputRunCurrentDateTool = {
  type: "current_date";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries knowledge bases for information
 */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool = {
  type: "query_knowledge_base";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available knowledge bases
 */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool = {
  type: "retrieve_knowledge_bases";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Deletes documents from memory stores
 */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool = {
  type: "delete_memory_document";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available memory stores
 */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool = {
  type: "retrieve_memory_stores";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Writes information to agent memory stores
 */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool = {
  type: "write_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries agent memory stores for context
 */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool = {
  type: "query_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Retrieves available agents in the system
 */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool = {
  type: "retrieve_agents";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Delegates tasks to specialized sub-agents
 */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool = {
  type: "call_sub_agent";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Scrapes and extracts content from web pages
 */
export type StreamRunAgentAgentToolInputRunWebScraperTool = {
  type: "web_scraper";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Performs Google searches to retrieve web content
 */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool = {
  type: "google_search";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function, JSON Schema, MCP) support full inline definitions for on-the-fly creation.
 */
export type StreamRunAgentAgentToolInputRun =
  | StreamRunAgentAgentToolInputRunGoogleSearchTool
  | StreamRunAgentAgentToolInputRunWebScraperTool
  | StreamRunAgentAgentToolInputRunCallSubAgentTool
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  | StreamRunAgentAgentToolInputRunCurrentDateTool
  | AgentToolInputRunHTTPToolRun
  | AgentToolInputRunCodeToolRun
  | AgentToolInputRunFunctionToolRun
  | AgentToolInputRunJSONSchemaToolRun
  | AgentToolInputRunMCPToolRun;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const StreamRunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type StreamRunAgentToolApprovalRequired = ClosedEnum<
  typeof StreamRunAgentToolApprovalRequired
>;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentExecuteOn = ClosedEnum<
  typeof StreamRunAgentExecuteOn
>;

export type StreamRunAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentAgentsExecuteOn = ClosedEnum<
  typeof StreamRunAgentAgentsExecuteOn
>;

export type StreamRunAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentAgentsExecuteOn;
};

export type StreamRunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | StreamRunAgentAgentToolInputRunGoogleSearchTool
      | StreamRunAgentAgentToolInputRunWebScraperTool
      | StreamRunAgentAgentToolInputRunCallSubAgentTool
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
      | StreamRunAgentAgentToolInputRunCurrentDateTool
      | AgentToolInputRunHTTPToolRun
      | AgentToolInputRunCodeToolRun
      | AgentToolInputRunFunctionToolRun
      | AgentToolInputRunJSONSchemaToolRun
      | AgentToolInputRunMCPToolRun
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: StreamRunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * Maximum cost in USD for the agent execution. When the accumulated cost exceeds this limit, the agent will stop executing. Set to 0 for unlimited. Only supported in v3 responses
   */
  maxCost?: number | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<StreamRunAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<StreamRunAgentGuardrails> | undefined;
};

export type StreamRunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
   */
  model: StreamRunAgentModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<StreamRunAgentFallbackModelConfiguration2 | string>
    | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: StreamRunAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: StreamRunAgentIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: StreamRunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamRunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamRunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<StreamRunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<StreamRunAgentTeamOfAgents> | undefined;
  settings: StreamRunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

export type StreamRunAgentData =
  | components.AgentExecutionStartedStreamingEvent
  | components.AgentStartedStreamingEvent
  | components.AgentThoughtStreamingEvent
  | components.AgentInactiveStreamingEvent
  | components.AgentErroredStreamingEvent
  | components.ActionReviewRequestedStreamingEvent
  | components.ActionReviewedStreamingEvent
  | components.ExecutionReviewRequiredStreamingEvent
  | components.ExecutionReviewedStreamingEvent
  | components.ExecutionNamedStreamingEvent
  | components.AgentHandedOffStreamingEvent
  | components.AgentMessageCreatedStreamingEvent
  | components.ToolExecutionStartedStreamingEvent
  | components.ToolExecutionFinishedStreamingEvent
  | components.ToolExecutionFailedStreamingEvent
  | components.TimeoutStreamingEvent
  | components.ErrorStreamingEvent;

/**
 * Server-Sent Event stream successfully established. Delivers real-time agent execution events including message fragments, tool invocations, intermediate results, and completion status. Stream terminates with [DONE] sentinel upon completion.
 */
export type StreamRunAgentResponseBody = {
  data:
    | components.AgentExecutionStartedStreamingEvent
    | components.AgentStartedStreamingEvent
    | components.AgentThoughtStreamingEvent
    | components.AgentInactiveStreamingEvent
    | components.AgentErroredStreamingEvent
    | components.ActionReviewRequestedStreamingEvent
    | components.ActionReviewedStreamingEvent
    | components.ExecutionReviewRequiredStreamingEvent
    | components.ExecutionReviewedStreamingEvent
    | components.ExecutionNamedStreamingEvent
    | components.AgentHandedOffStreamingEvent
    | components.AgentMessageCreatedStreamingEvent
    | components.ToolExecutionStartedStreamingEvent
    | components.ToolExecutionFinishedStreamingEvent
    | components.ToolExecutionFailedStreamingEvent
    | components.TimeoutStreamingEvent
    | components.ErrorStreamingEvent;
};

/** @internal */
export const StreamRunAgentModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationVoice> = z.nativeEnum(
    StreamRunAgentModelConfigurationVoice,
  );

/** @internal */
export const StreamRunAgentModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationFormat> = z.nativeEnum(
    StreamRunAgentModelConfigurationFormat,
  );

/** @internal */
export type StreamRunAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationAudio
> = z.object({
  voice: StreamRunAgentModelConfigurationVoice$outboundSchema,
  format: StreamRunAgentModelConfigurationFormat$outboundSchema,
});

export function streamRunAgentModelConfigurationAudioToJSON(
  streamRunAgentModelConfigurationAudio: StreamRunAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsJsonSchema:
    StreamRunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJsonSchema,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: StreamRunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function streamRunAgentResponseFormatJSONSchemaToJSON(
  streamRunAgentResponseFormatJSONSchema:
    StreamRunAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const StreamRunAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function streamRunAgentResponseFormatJSONObjectToJSON(
  streamRunAgentResponseFormatJSONObject:
    StreamRunAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const StreamRunAgentResponseFormatText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function streamRunAgentResponseFormatTextToJSON(
  streamRunAgentResponseFormatText: StreamRunAgentResponseFormatText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatText$outboundSchema.parse(
      streamRunAgentResponseFormatText,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatText$Outbound
  | StreamRunAgentResponseFormatJSONObject$Outbound
  | StreamRunAgentResponseFormatJSONSchema$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
  ]);

export function streamRunAgentModelConfigurationResponseFormatToJSON(
  streamRunAgentModelConfigurationResponseFormat:
    StreamRunAgentModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationReasoningEffort> = z
    .nativeEnum(StreamRunAgentModelConfigurationReasoningEffort);

/** @internal */
export type StreamRunAgentModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentModelConfigurationStop$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentModelConfigurationStopToJSON(
  streamRunAgentModelConfigurationStop: StreamRunAgentModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStop$outboundSchema.parse(
      streamRunAgentModelConfigurationStop,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentModelConfigurationStreamOptionsToJSON(
  streamRunAgentModelConfigurationStreamOptions:
    StreamRunAgentModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationThinking$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function streamRunAgentModelConfigurationThinkingToJSON(
  streamRunAgentModelConfigurationThinking:
    StreamRunAgentModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const StreamRunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = z.nativeEnum(StreamRunAgentToolChoiceType);

/** @internal */
export type StreamRunAgentToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const StreamRunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function streamRunAgentToolChoiceFunctionToJSON(
  streamRunAgentToolChoiceFunction: StreamRunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceFunction$outboundSchema.parse(
      streamRunAgentToolChoiceFunction,
    ),
  );
}

/** @internal */
export type StreamRunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoice2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoice2
> = z.object({
  type: StreamRunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$outboundSchema),
});

export function streamRunAgentToolChoice2ToJSON(
  streamRunAgentToolChoice2: StreamRunAgentToolChoice2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoice2$outboundSchema.parse(streamRunAgentToolChoice2),
  );
}

/** @internal */
export const StreamRunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = z.nativeEnum(StreamRunAgentToolChoice1);

/** @internal */
export type StreamRunAgentModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
    StreamRunAgentToolChoice1$outboundSchema,
  ]);

export function streamRunAgentModelConfigurationToolChoiceToJSON(
  streamRunAgentModelConfigurationToolChoice:
    StreamRunAgentModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentModelConfigurationModalities);

/** @internal */
export const StreamRunAgentId1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentId1
> = z.nativeEnum(StreamRunAgentId1);

/** @internal */
export type StreamRunAgentModelConfigurationId$Outbound = string | string;

/** @internal */
export const StreamRunAgentModelConfigurationId$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationId$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationId
> = z.union([StreamRunAgentId1$outboundSchema, z.string()]);

export function streamRunAgentModelConfigurationIdToJSON(
  streamRunAgentModelConfigurationId: StreamRunAgentModelConfigurationId,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationId$outboundSchema.parse(
      streamRunAgentModelConfigurationId,
    ),
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationExecuteOn> = z
    .nativeEnum(StreamRunAgentModelConfigurationExecuteOn);

/** @internal */
export type StreamRunAgentModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationGuardrails
  > = z.object({
    id: z.union([StreamRunAgentId1$outboundSchema, z.string()]),
    executeOn: StreamRunAgentModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function streamRunAgentModelConfigurationGuardrailsToJSON(
  streamRunAgentModelConfigurationGuardrails:
    StreamRunAgentModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationGuardrails$outboundSchema.parse(
      streamRunAgentModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationFallbacks$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationFallbacks$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationFallbacks
  > = z.object({
    model: z.string(),
  });

export function streamRunAgentModelConfigurationFallbacksToJSON(
  streamRunAgentModelConfigurationFallbacks:
    StreamRunAgentModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationFallbacks$outboundSchema.parse(
      streamRunAgentModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function streamRunAgentModelConfigurationRetryToJSON(
  streamRunAgentModelConfigurationRetry: StreamRunAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationRetry$outboundSchema.parse(
      streamRunAgentModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationType> = z.nativeEnum(
    StreamRunAgentModelConfigurationType,
  );

/** @internal */
export type StreamRunAgentModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationCache$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationCache$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationCache
> = z.object({
  ttl: z.number().default(1800),
  type: StreamRunAgentModelConfigurationType$outboundSchema,
});

export function streamRunAgentModelConfigurationCacheToJSON(
  streamRunAgentModelConfigurationCache: StreamRunAgentModelConfigurationCache,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationCache$outboundSchema.parse(
      streamRunAgentModelConfigurationCache,
    ),
  );
}

/** @internal */
export const StreamRunAgentLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentLoadBalancerType
> = z.nativeEnum(StreamRunAgentLoadBalancerType);

/** @internal */
export type StreamRunAgentLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const StreamRunAgentLoadBalancerModels$outboundSchema: z.ZodType<
  StreamRunAgentLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  StreamRunAgentLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function streamRunAgentLoadBalancerModelsToJSON(
  streamRunAgentLoadBalancerModels: StreamRunAgentLoadBalancerModels,
): string {
  return JSON.stringify(
    StreamRunAgentLoadBalancerModels$outboundSchema.parse(
      streamRunAgentLoadBalancerModels,
    ),
  );
}

/** @internal */
export type StreamRunAgentLoadBalancer1$Outbound = {
  type: string;
  models: Array<StreamRunAgentLoadBalancerModels$Outbound>;
};

/** @internal */
export const StreamRunAgentLoadBalancer1$outboundSchema: z.ZodType<
  StreamRunAgentLoadBalancer1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentLoadBalancer1
> = z.object({
  type: StreamRunAgentLoadBalancerType$outboundSchema,
  models: z.array(
    z.lazy(() => StreamRunAgentLoadBalancerModels$outboundSchema),
  ),
});

export function streamRunAgentLoadBalancer1ToJSON(
  streamRunAgentLoadBalancer1: StreamRunAgentLoadBalancer1,
): string {
  return JSON.stringify(
    StreamRunAgentLoadBalancer1$outboundSchema.parse(
      streamRunAgentLoadBalancer1,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationLoadBalancer$Outbound =
  StreamRunAgentLoadBalancer1$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationLoadBalancer$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationLoadBalancer$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationLoadBalancer
  > = z.lazy(() => StreamRunAgentLoadBalancer1$outboundSchema);

export function streamRunAgentModelConfigurationLoadBalancerToJSON(
  streamRunAgentModelConfigurationLoadBalancer:
    StreamRunAgentModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationLoadBalancer$outboundSchema.parse(
      streamRunAgentModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const StreamRunAgentModelConfigurationTimeout$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationTimeout$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function streamRunAgentModelConfigurationTimeoutToJSON(
  streamRunAgentModelConfigurationTimeout:
    StreamRunAgentModelConfigurationTimeout,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationTimeout$outboundSchema.parse(
      streamRunAgentModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationParameters$Outbound = {
  name?: string | undefined;
  audio?: StreamRunAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatText$Outbound
    | StreamRunAgentResponseFormatJSONObject$Outbound
    | StreamRunAgentResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<StreamRunAgentModelConfigurationGuardrails$Outbound>
    | undefined;
  fallbacks?:
    | Array<StreamRunAgentModelConfigurationFallbacks$Outbound>
    | undefined;
  retry?: StreamRunAgentModelConfigurationRetry$Outbound | undefined;
  cache?: StreamRunAgentModelConfigurationCache$Outbound | undefined;
  load_balancer?: StreamRunAgentLoadBalancer1$Outbound | undefined;
  timeout?: StreamRunAgentModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationParameters
  > = z.object({
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => StreamRunAgentModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
    ]).optional(),
    reasoningEffort:
      StreamRunAgentModelConfigurationReasoningEffort$outboundSchema.optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
      StreamRunAgentToolChoice1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(StreamRunAgentModelConfigurationModalities$outboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() => StreamRunAgentModelConfigurationGuardrails$outboundSchema),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() => StreamRunAgentModelConfigurationFallbacks$outboundSchema),
    ).optional(),
    retry: z.lazy(() => StreamRunAgentModelConfigurationRetry$outboundSchema)
      .optional(),
    cache: z.lazy(() => StreamRunAgentModelConfigurationCache$outboundSchema)
      .optional(),
    loadBalancer: z.lazy(() => StreamRunAgentLoadBalancer1$outboundSchema)
      .optional(),
    timeout: z.lazy(() =>
      StreamRunAgentModelConfigurationTimeout$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
      loadBalancer: "load_balancer",
    });
  });

export function streamRunAgentModelConfigurationParametersToJSON(
  streamRunAgentModelConfigurationParameters:
    StreamRunAgentModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationAgentsRetry$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationAgentsRetry$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationAgentsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function streamRunAgentModelConfigurationAgentsRetryToJSON(
  streamRunAgentModelConfigurationAgentsRetry:
    StreamRunAgentModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationAgentsRetry$outboundSchema.parse(
      streamRunAgentModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: StreamRunAgentModelConfigurationParameters$Outbound | undefined;
  retry?: StreamRunAgentModelConfigurationAgentsRetry$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModelConfiguration2$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentModelConfigurationParameters$outboundSchema
  ).optional(),
  retry: z.lazy(() =>
    StreamRunAgentModelConfigurationAgentsRetry$outboundSchema
  ).optional(),
});

export function streamRunAgentModelConfiguration2ToJSON(
  streamRunAgentModelConfiguration2: StreamRunAgentModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration2$outboundSchema.parse(
      streamRunAgentModelConfiguration2,
    ),
  );
}

/** @internal */
export type StreamRunAgentModelConfiguration$Outbound =
  | StreamRunAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentModelConfigurationToJSON(
  streamRunAgentModelConfiguration: StreamRunAgentModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration$outboundSchema.parse(
      streamRunAgentModelConfiguration,
    ),
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationVoice);

/** @internal */
export const StreamRunAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationFormat);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: StreamRunAgentFallbackModelConfigurationVoice$outboundSchema,
    format: StreamRunAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function streamRunAgentFallbackModelConfigurationAudioToJSON(
  streamRunAgentFallbackModelConfigurationAudio:
    StreamRunAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function streamRunAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestJSONSchema:
    StreamRunAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function streamRunAgentResponseFormatAgentsJSONObjectToJSON(
  streamRunAgentResponseFormatAgentsJSONObject:
    StreamRunAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJSONObject,
    ),
  );
}

/** @internal */
export type StreamRunAgentResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgentsText
> = z.object({
  type: z.literal("text"),
});

export function streamRunAgentResponseFormatAgentsTextToJSON(
  streamRunAgentResponseFormatAgentsText:
    StreamRunAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsText$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsText,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatAgentsText$Outbound
  | StreamRunAgentResponseFormatAgentsJSONObject$Outbound
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
    z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
    ),
  ]);

export function streamRunAgentFallbackModelConfigurationResponseFormatToJSON(
  streamRunAgentFallbackModelConfigurationResponseFormat:
    StreamRunAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentFallbackModelConfigurationReasoningEffort
  > = z.nativeEnum(StreamRunAgentFallbackModelConfigurationReasoningEffort);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentFallbackModelConfigurationStopToJSON(
  streamRunAgentFallbackModelConfigurationStop:
    StreamRunAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStop$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStop,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentFallbackModelConfigurationStreamOptionsToJSON(
  streamRunAgentFallbackModelConfigurationStreamOptions:
    StreamRunAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function streamRunAgentFallbackModelConfigurationThinkingToJSON(
  streamRunAgentFallbackModelConfigurationThinking:
    StreamRunAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = z.nativeEnum(StreamRunAgentToolChoiceAgentsType);

/** @internal */
export type StreamRunAgentToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string(),
});

export function streamRunAgentToolChoiceAgentsFunctionToJSON(
  streamRunAgentToolChoiceAgentsFunction:
    StreamRunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      streamRunAgentToolChoiceAgentsFunction,
    ),
  );
}

/** @internal */
export type StreamRunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgents2
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function streamRunAgentToolChoiceAgents2ToJSON(
  streamRunAgentToolChoiceAgents2: StreamRunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgents2$outboundSchema.parse(
      streamRunAgentToolChoiceAgents2,
    ),
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = z.nativeEnum(StreamRunAgentToolChoiceAgents1);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
    StreamRunAgentToolChoiceAgents1$outboundSchema,
  ]);

export function streamRunAgentFallbackModelConfigurationToolChoiceToJSON(
  streamRunAgentFallbackModelConfigurationToolChoice:
    StreamRunAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationModalities);

/** @internal */
export const StreamRunAgentIdAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentIdAgents1
> = z.nativeEnum(StreamRunAgentIdAgents1);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationId$Outbound =
  | string
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationId$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationId$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationId
  > = z.union([StreamRunAgentIdAgents1$outboundSchema, z.string()]);

export function streamRunAgentFallbackModelConfigurationIdToJSON(
  streamRunAgentFallbackModelConfigurationId:
    StreamRunAgentFallbackModelConfigurationId,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationId$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationId,
    ),
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationExecuteOn> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationExecuteOn);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationGuardrails
  > = z.object({
    id: z.union([StreamRunAgentIdAgents1$outboundSchema, z.string()]),
    executeOn: StreamRunAgentFallbackModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function streamRunAgentFallbackModelConfigurationGuardrailsToJSON(
  streamRunAgentFallbackModelConfigurationGuardrails:
    StreamRunAgentFallbackModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationFallbacks$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationFallbacks$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationFallbacks
  > = z.object({
    model: z.string(),
  });

export function streamRunAgentFallbackModelConfigurationFallbacksToJSON(
  streamRunAgentFallbackModelConfigurationFallbacks:
    StreamRunAgentFallbackModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationFallbacks$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationRetry$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationRetry$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function streamRunAgentFallbackModelConfigurationRetryToJSON(
  streamRunAgentFallbackModelConfigurationRetry:
    StreamRunAgentFallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationRetry$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationType> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationType);

/** @internal */
export type StreamRunAgentFallbackModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationCache$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationCache$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationCache
  > = z.object({
    ttl: z.number().default(1800),
    type: StreamRunAgentFallbackModelConfigurationType$outboundSchema,
  });

export function streamRunAgentFallbackModelConfigurationCacheToJSON(
  streamRunAgentFallbackModelConfigurationCache:
    StreamRunAgentFallbackModelConfigurationCache,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationCache$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationCache,
    ),
  );
}

/** @internal */
export const StreamRunAgentLoadBalancerAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentLoadBalancerAgentsType> = z.nativeEnum(
    StreamRunAgentLoadBalancerAgentsType,
  );

/** @internal */
export type StreamRunAgentLoadBalancerAgentsModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const StreamRunAgentLoadBalancerAgentsModels$outboundSchema: z.ZodType<
  StreamRunAgentLoadBalancerAgentsModels$Outbound,
  z.ZodTypeDef,
  StreamRunAgentLoadBalancerAgentsModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function streamRunAgentLoadBalancerAgentsModelsToJSON(
  streamRunAgentLoadBalancerAgentsModels:
    StreamRunAgentLoadBalancerAgentsModels,
): string {
  return JSON.stringify(
    StreamRunAgentLoadBalancerAgentsModels$outboundSchema.parse(
      streamRunAgentLoadBalancerAgentsModels,
    ),
  );
}

/** @internal */
export type StreamRunAgentLoadBalancerAgents1$Outbound = {
  type: string;
  models: Array<StreamRunAgentLoadBalancerAgentsModels$Outbound>;
};

/** @internal */
export const StreamRunAgentLoadBalancerAgents1$outboundSchema: z.ZodType<
  StreamRunAgentLoadBalancerAgents1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentLoadBalancerAgents1
> = z.object({
  type: StreamRunAgentLoadBalancerAgentsType$outboundSchema,
  models: z.array(
    z.lazy(() => StreamRunAgentLoadBalancerAgentsModels$outboundSchema),
  ),
});

export function streamRunAgentLoadBalancerAgents1ToJSON(
  streamRunAgentLoadBalancerAgents1: StreamRunAgentLoadBalancerAgents1,
): string {
  return JSON.stringify(
    StreamRunAgentLoadBalancerAgents1$outboundSchema.parse(
      streamRunAgentLoadBalancerAgents1,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationLoadBalancer$Outbound =
  StreamRunAgentLoadBalancerAgents1$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationLoadBalancer$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationLoadBalancer$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationLoadBalancer
  > = z.lazy(() => StreamRunAgentLoadBalancerAgents1$outboundSchema);

export function streamRunAgentFallbackModelConfigurationLoadBalancerToJSON(
  streamRunAgentFallbackModelConfigurationLoadBalancer:
    StreamRunAgentFallbackModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationLoadBalancer$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationTimeout$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationTimeout$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationTimeout
  > = z.object({
    callTimeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      callTimeout: "call_timeout",
    });
  });

export function streamRunAgentFallbackModelConfigurationTimeoutToJSON(
  streamRunAgentFallbackModelConfigurationTimeout:
    StreamRunAgentFallbackModelConfigurationTimeout,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationTimeout$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationParameters$Outbound = {
  name?: string | undefined;
  audio?:
    | StreamRunAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatAgentsText$Outbound
    | StreamRunAgentResponseFormatAgentsJSONObject$Outbound
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<StreamRunAgentFallbackModelConfigurationGuardrails$Outbound>
    | undefined;
  fallbacks?:
    | Array<StreamRunAgentFallbackModelConfigurationFallbacks$Outbound>
    | undefined;
  retry?: StreamRunAgentFallbackModelConfigurationRetry$Outbound | undefined;
  cache?: StreamRunAgentFallbackModelConfigurationCache$Outbound | undefined;
  load_balancer?: StreamRunAgentLoadBalancerAgents1$Outbound | undefined;
  timeout?:
    | StreamRunAgentFallbackModelConfigurationTimeout$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationParameters
  > = z.object({
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
      z.lazy(() =>
        StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort:
      StreamRunAgentFallbackModelConfigurationReasoningEffort$outboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
      StreamRunAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        StreamRunAgentFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema
      ),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationFallbacks$outboundSchema
      ),
    ).optional(),
    retry: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationRetry$outboundSchema
    ).optional(),
    cache: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationCache$outboundSchema
    ).optional(),
    loadBalancer: z.lazy(() => StreamRunAgentLoadBalancerAgents1$outboundSchema)
      .optional(),
    timeout: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationTimeout$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
      loadBalancer: "load_balancer",
    });
  });

export function streamRunAgentFallbackModelConfigurationParametersToJSON(
  streamRunAgentFallbackModelConfigurationParameters:
    StreamRunAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAgentsRetry$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAgentsRetry$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationAgentsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function streamRunAgentFallbackModelConfigurationAgentsRetryToJSON(
  streamRunAgentFallbackModelConfigurationAgentsRetry:
    StreamRunAgentFallbackModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationAgentsRetry$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | StreamRunAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
  retry?:
    | StreamRunAgentFallbackModelConfigurationAgentsRetry$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
    retry: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationAgentsRetry$outboundSchema
    ).optional(),
  });

export function streamRunAgentFallbackModelConfiguration2ToJSON(
  streamRunAgentFallbackModelConfiguration2:
    StreamRunAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration2$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration2,
    ),
  );
}

/** @internal */
export type StreamRunAgentFallbackModelConfiguration$Outbound =
  | StreamRunAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentFallbackModelConfigurationToJSON(
  streamRunAgentFallbackModelConfiguration:
    StreamRunAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration,
    ),
  );
}

/** @internal */
export const StreamRunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = z.nativeEnum(StreamRunAgentRoleToolMessage);

/** @internal */
export const StreamRunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = z.nativeEnum(StreamRunAgentRoleUserMessage);

/** @internal */
export type StreamRunAgentRole$Outbound = string | string;

/** @internal */
export const StreamRunAgentRole$outboundSchema: z.ZodType<
  StreamRunAgentRole$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRole
> = z.union([
  StreamRunAgentRoleUserMessage$outboundSchema,
  StreamRunAgentRoleToolMessage$outboundSchema,
]);

export function streamRunAgentRoleToJSON(
  streamRunAgentRole: StreamRunAgentRole,
): string {
  return JSON.stringify(
    StreamRunAgentRole$outboundSchema.parse(streamRunAgentRole),
  );
}

/** @internal */
export type StreamRunAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound
  | components.ErrorPart$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
  components.ErrorPart$outboundSchema,
]);

export function streamRunAgentPublicMessagePartToJSON(
  streamRunAgentPublicMessagePart: StreamRunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePart$outboundSchema.parse(
      streamRunAgentPublicMessagePart,
    ),
  );
}

/** @internal */
export type StreamRunAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
    | components.ErrorPart$Outbound
  >;
};

/** @internal */
export const StreamRunAgentA2AMessage$outboundSchema: z.ZodType<
  StreamRunAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$outboundSchema,
    StreamRunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
      components.ErrorPart$outboundSchema,
    ]),
  ),
});

export function streamRunAgentA2AMessageToJSON(
  streamRunAgentA2AMessage: StreamRunAgentA2AMessage,
): string {
  return JSON.stringify(
    StreamRunAgentA2AMessage$outboundSchema.parse(streamRunAgentA2AMessage),
  );
}

/** @internal */
export type StreamRunAgentIdentity$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentIdentity$outboundSchema: z.ZodType<
  StreamRunAgentIdentity$Outbound,
  z.ZodTypeDef,
  StreamRunAgentIdentity
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentIdentityToJSON(
  streamRunAgentIdentity: StreamRunAgentIdentity,
): string {
  return JSON.stringify(
    StreamRunAgentIdentity$outboundSchema.parse(streamRunAgentIdentity),
  );
}

/** @internal */
export type StreamRunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentContact$outboundSchema: z.ZodType<
  StreamRunAgentContact$Outbound,
  z.ZodTypeDef,
  StreamRunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentContactToJSON(
  streamRunAgentContact: StreamRunAgentContact,
): string {
  return JSON.stringify(
    StreamRunAgentContact$outboundSchema.parse(streamRunAgentContact),
  );
}

/** @internal */
export type StreamRunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentThread$outboundSchema: z.ZodType<
  StreamRunAgentThread$Outbound,
  z.ZodTypeDef,
  StreamRunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamRunAgentThreadToJSON(
  streamRunAgentThread: StreamRunAgentThread,
): string {
  return JSON.stringify(
    StreamRunAgentThread$outboundSchema.parse(streamRunAgentThread),
  );
}

/** @internal */
export type StreamRunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentMemory$outboundSchema: z.ZodType<
  StreamRunAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentMemoryToJSON(
  streamRunAgentMemory: StreamRunAgentMemory,
): string {
  return JSON.stringify(
    StreamRunAgentMemory$outboundSchema.parse(streamRunAgentMemory),
  );
}

/** @internal */
export type StreamRunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const StreamRunAgentKnowledgeBases$outboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  StreamRunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function streamRunAgentKnowledgeBasesToJSON(
  streamRunAgentKnowledgeBases: StreamRunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    StreamRunAgentKnowledgeBases$outboundSchema.parse(
      streamRunAgentKnowledgeBases,
    ),
  );
}

/** @internal */
export type StreamRunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const StreamRunAgentTeamOfAgents$outboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function streamRunAgentTeamOfAgentsToJSON(
  streamRunAgentTeamOfAgents: StreamRunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    StreamRunAgentTeamOfAgents$outboundSchema.parse(streamRunAgentTeamOfAgents),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsHeaders
  > = z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });

export function streamRunAgentAgentToolInputRunAgentsHeadersToJSON(
  streamRunAgentAgentToolInputRunAgentsHeaders:
    StreamRunAgentAgentToolInputRunAgentsHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsHeaders,
    ),
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType,
  );

/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsSchema
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema,
    properties: z.record(z.any()).optional(),
    required: z.array(z.string()).optional(),
  });

export function streamRunAgentAgentToolInputRunAgentsSchemaToJSON(
  streamRunAgentAgentToolInputRunAgentsSchema:
    StreamRunAgentAgentToolInputRunAgentsSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsSchema,
    ),
  );
}

/** @internal */
export type AgentToolInputRunTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: StreamRunAgentAgentToolInputRunAgentsSchema$Outbound;
};

/** @internal */
export const AgentToolInputRunTools$outboundSchema: z.ZodType<
  AgentToolInputRunTools$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunTools
> = z.object({
  id: z.string().default("01KHY5SDED02EB50VKMNSFBPEE"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema
  ),
});

export function agentToolInputRunToolsToJSON(
  agentToolInputRunTools: AgentToolInputRunTools,
): string {
  return JSON.stringify(
    AgentToolInputRunTools$outboundSchema.parse(agentToolInputRunTools),
  );
}

/** @internal */
export const AgentToolInputRunConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunConnectionType
> = z.nativeEnum(AgentToolInputRunConnectionType);

/** @internal */
export type AgentToolInputRunMcp$Outbound = {
  server_url: string;
  headers?: {
    [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound;
  } | undefined;
  tools: Array<AgentToolInputRunTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const AgentToolInputRunMcp$outboundSchema: z.ZodType<
  AgentToolInputRunMcp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(
    z.lazy(() => StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => AgentToolInputRunTools$outboundSchema)),
  connectionType: AgentToolInputRunConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function agentToolInputRunMcpToJSON(
  agentToolInputRunMcp: AgentToolInputRunMcp,
): string {
  return JSON.stringify(
    AgentToolInputRunMcp$outboundSchema.parse(agentToolInputRunMcp),
  );
}

/** @internal */
export type AgentToolInputRunMCPToolRun$Outbound = {
  type: "mcp";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  mcp: AgentToolInputRunMcp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunMCPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunMCPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMCPToolRun
> = z.object({
  type: z.literal("mcp"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => AgentToolInputRunMcp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunMCPToolRunToJSON(
  agentToolInputRunMCPToolRun: AgentToolInputRunMCPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunMCPToolRun$outboundSchema.parse(
      agentToolInputRunMCPToolRun,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunSchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunSchema$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunSchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function streamRunAgentAgentToolInputRunSchemaToJSON(
  streamRunAgentAgentToolInputRunSchema: StreamRunAgentAgentToolInputRunSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunSchema,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: StreamRunAgentAgentToolInputRunSchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunJsonSchema
  > = z.object({
    name: z.string(),
    description: z.string(),
    schema: z.lazy(() => StreamRunAgentAgentToolInputRunSchema$outboundSchema),
    strict: z.boolean().optional(),
  });

export function streamRunAgentAgentToolInputRunJsonSchemaToJSON(
  streamRunAgentAgentToolInputRunJsonSchema:
    StreamRunAgentAgentToolInputRunJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunJsonSchema,
    ),
  );
}

/** @internal */
export type AgentToolInputRunJSONSchemaToolRun$Outbound = {
  type: "json_schema";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  json_schema: StreamRunAgentAgentToolInputRunJsonSchema$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunJSONSchemaToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunJSONSchemaToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunJSONSchemaToolRun
> = z.object({
  type: z.literal("json_schema"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  jsonSchema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    jsonSchema: "json_schema",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunJSONSchemaToolRunToJSON(
  agentToolInputRunJSONSchemaToolRun: AgentToolInputRunJSONSchemaToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunJSONSchemaToolRun$outboundSchema.parse(
      agentToolInputRunJSONSchemaToolRun,
    ),
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType,
  );

/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunAgentsParametersToJSON(
  streamRunAgentAgentToolInputRunAgentsParameters:
    StreamRunAgentAgentToolInputRunAgentsParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsParameters,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?:
    | StreamRunAgentAgentToolInputRunAgentsParameters$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema
  ).optional(),
});

export function streamRunAgentAgentToolInputRunFunctionToJSON(
  streamRunAgentAgentToolInputRunFunction:
    StreamRunAgentAgentToolInputRunFunction,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunFunction$outboundSchema.parse(
      streamRunAgentAgentToolInputRunFunction,
    ),
  );
}

/** @internal */
export type AgentToolInputRunFunctionToolRun$Outbound = {
  type: "function";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunFunctionToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunctionToolRun
> = z.object({
  type: z.literal("function"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() =>
    StreamRunAgentAgentToolInputRunFunction$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunFunctionToolRunToJSON(
  agentToolInputRunFunctionToolRun: AgentToolInputRunFunctionToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunFunctionToolRun$outboundSchema.parse(
      agentToolInputRunFunctionToolRun,
    ),
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType,
  );

/** @internal */
export type StreamRunAgentAgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunParametersToJSON(
  streamRunAgentAgentToolInputRunParameters:
    StreamRunAgentAgentToolInputRunParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunParameters,
    ),
  );
}

/** @internal */
export const AgentToolInputRunLanguage$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = z.nativeEnum(AgentToolInputRunLanguage);

/** @internal */
export type AgentToolInputRunCodeTool$Outbound = {
  parameters?: StreamRunAgentAgentToolInputRunParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const AgentToolInputRunCodeTool$outboundSchema: z.ZodType<
  AgentToolInputRunCodeTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeTool
> = z.object({
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunParameters$outboundSchema
  ).optional(),
  language: AgentToolInputRunLanguage$outboundSchema,
  code: z.string(),
});

export function agentToolInputRunCodeToolToJSON(
  agentToolInputRunCodeTool: AgentToolInputRunCodeTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeTool$outboundSchema.parse(agentToolInputRunCodeTool),
  );
}

/** @internal */
export type AgentToolInputRunCodeToolRun$Outbound = {
  type: "code";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: AgentToolInputRunCodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunCodeToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeToolRun
> = z.object({
  type: z.literal("code"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => AgentToolInputRunCodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCodeToolRunToJSON(
  agentToolInputRunCodeToolRun: AgentToolInputRunCodeToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeToolRun$outboundSchema.parse(
      agentToolInputRunCodeToolRun,
    ),
  );
}

/** @internal */
export const AgentToolInputRunMethod$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = z.nativeEnum(AgentToolInputRunMethod);

/** @internal */
export type StreamRunAgentHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentHeaders2$outboundSchema: z.ZodType<
  StreamRunAgentHeaders2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function streamRunAgentHeaders2ToJSON(
  streamRunAgentHeaders2: StreamRunAgentHeaders2,
): string {
  return JSON.stringify(
    StreamRunAgentHeaders2$outboundSchema.parse(streamRunAgentHeaders2),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunHeaders$Outbound =
  | StreamRunAgentHeaders2$Outbound
  | string;

/** @internal */
export const StreamRunAgentAgentToolInputRunHeaders$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunHeaders$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunHeaders
> = z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]);

export function streamRunAgentAgentToolInputRunHeadersToJSON(
  streamRunAgentAgentToolInputRunHeaders:
    StreamRunAgentAgentToolInputRunHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunHeaders,
    ),
  );
}

/** @internal */
export type AgentToolInputRunBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: StreamRunAgentHeaders2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const AgentToolInputRunBlueprint$outboundSchema: z.ZodType<
  AgentToolInputRunBlueprint$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunBlueprint
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function agentToolInputRunBlueprintToJSON(
  agentToolInputRunBlueprint: AgentToolInputRunBlueprint,
): string {
  return JSON.stringify(
    AgentToolInputRunBlueprint$outboundSchema.parse(agentToolInputRunBlueprint),
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );

/** @internal */
export type AgentToolInputRunDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const AgentToolInputRunDefaultValue$outboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function agentToolInputRunDefaultValueToJSON(
  agentToolInputRunDefaultValue: AgentToolInputRunDefaultValue,
): string {
  return JSON.stringify(
    AgentToolInputRunDefaultValue$outboundSchema.parse(
      agentToolInputRunDefaultValue,
    ),
  );
}

/** @internal */
export type AgentToolInputRunArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const AgentToolInputRunArguments$outboundSchema: z.ZodType<
  AgentToolInputRunArguments$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunArguments
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function agentToolInputRunArgumentsToJSON(
  agentToolInputRunArguments: AgentToolInputRunArguments,
): string {
  return JSON.stringify(
    AgentToolInputRunArguments$outboundSchema.parse(agentToolInputRunArguments),
  );
}

/** @internal */
export type AgentToolInputRunHttp$Outbound = {
  blueprint: AgentToolInputRunBlueprint$Outbound;
  arguments?: { [k: string]: AgentToolInputRunArguments$Outbound } | undefined;
};

/** @internal */
export const AgentToolInputRunHttp$outboundSchema: z.ZodType<
  AgentToolInputRunHttp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHttp
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$outboundSchema))
    .optional(),
});

export function agentToolInputRunHttpToJSON(
  agentToolInputRunHttp: AgentToolInputRunHttp,
): string {
  return JSON.stringify(
    AgentToolInputRunHttp$outboundSchema.parse(agentToolInputRunHttp),
  );
}

/** @internal */
export type AgentToolInputRunHTTPToolRun$Outbound = {
  type: "http";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: AgentToolInputRunHttp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunHTTPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHTTPToolRun
> = z.object({
  type: z.literal("http"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunHTTPToolRunToJSON(
  agentToolInputRunHTTPToolRun: AgentToolInputRunHTTPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunHTTPToolRun$outboundSchema.parse(
      agentToolInputRunHTTPToolRun,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound = {
  type: "current_date";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCurrentDateTool
  > = z.object({
    type: z.literal("current_date"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCurrentDateToolToJSON(
  streamRunAgentAgentToolInputRunCurrentDateTool:
    StreamRunAgentAgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCurrentDateTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: "query_knowledge_base";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  > = z.object({
    type: z.literal("query_knowledge_base"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolToJSON(
  streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool:
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound =
  {
    type: "retrieve_knowledge_bases";
    requires_approval?: boolean | undefined;
  };

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool:
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: "delete_memory_document";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type: z.literal("delete_memory_document"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolToJSON(
  streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool:
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: "retrieve_memory_stores";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type: z.literal("retrieve_memory_stores"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool:
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: "write_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  > = z.object({
    type: z.literal("write_memory_store"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunWriteMemoryStoreTool:
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: "query_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  > = z.object({
    type: z.literal("query_memory_store"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunQueryMemoryStoreTool:
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: "retrieve_agents";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  > = z.object({
    type: z.literal("retrieve_agents"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveAgentsToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveAgentsTool:
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunRetrieveAgentsTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound = {
  type: "call_sub_agent";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCallSubAgentTool
  > = z.object({
    type: z.literal("call_sub_agent"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCallSubAgentToolToJSON(
  streamRunAgentAgentToolInputRunCallSubAgentTool:
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCallSubAgentTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunWebScraperTool$Outbound = {
  type: "web_scraper";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWebScraperTool
  > = z.object({
    type: z.literal("web_scraper"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWebScraperToolToJSON(
  streamRunAgentAgentToolInputRunWebScraperTool:
    StreamRunAgentAgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWebScraperTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound = {
  type: "google_search";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunGoogleSearchTool
  > = z.object({
    type: z.literal("google_search"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunGoogleSearchToolToJSON(
  streamRunAgentAgentToolInputRunGoogleSearchTool:
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunGoogleSearchTool,
    ),
  );
}

/** @internal */
export type StreamRunAgentAgentToolInputRun$Outbound =
  | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
  | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
  | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
  | AgentToolInputRunHTTPToolRun$Outbound
  | AgentToolInputRunCodeToolRun$Outbound
  | AgentToolInputRunFunctionToolRun$Outbound
  | AgentToolInputRunJSONSchemaToolRun$Outbound
  | AgentToolInputRunMCPToolRun$Outbound;

/** @internal */
export const StreamRunAgentAgentToolInputRun$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRun
> = z.union([
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema),
  z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunJSONSchemaToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
]);

export function streamRunAgentAgentToolInputRunToJSON(
  streamRunAgentAgentToolInputRun: StreamRunAgentAgentToolInputRun,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRun$outboundSchema.parse(
      streamRunAgentAgentToolInputRun,
    ),
  );
}

/** @internal */
export const StreamRunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = z.nativeEnum(StreamRunAgentToolApprovalRequired);

/** @internal */
export const StreamRunAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentExecuteOn
> = z.nativeEnum(StreamRunAgentExecuteOn);

/** @internal */
export type StreamRunAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentEvaluators$outboundSchema: z.ZodType<
  StreamRunAgentEvaluators$Outbound,
  z.ZodTypeDef,
  StreamRunAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentEvaluatorsToJSON(
  streamRunAgentEvaluators: StreamRunAgentEvaluators,
): string {
  return JSON.stringify(
    StreamRunAgentEvaluators$outboundSchema.parse(streamRunAgentEvaluators),
  );
}

/** @internal */
export const StreamRunAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentsExecuteOn
> = z.nativeEnum(StreamRunAgentAgentsExecuteOn);

/** @internal */
export type StreamRunAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentGuardrails$outboundSchema: z.ZodType<
  StreamRunAgentGuardrails$Outbound,
  z.ZodTypeDef,
  StreamRunAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentGuardrailsToJSON(
  streamRunAgentGuardrails: StreamRunAgentGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentGuardrails$outboundSchema.parse(streamRunAgentGuardrails),
  );
}

/** @internal */
export type StreamRunAgentSettings$Outbound = {
  tools?:
    | Array<
      | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
      | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
      | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
      | AgentToolInputRunHTTPToolRun$Outbound
      | AgentToolInputRunCodeToolRun$Outbound
      | AgentToolInputRunFunctionToolRun$Outbound
      | AgentToolInputRunJSONSchemaToolRun$Outbound
      | AgentToolInputRunMCPToolRun$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
  max_cost: number;
  evaluators?: Array<StreamRunAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<StreamRunAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const StreamRunAgentSettings$outboundSchema: z.ZodType<
  StreamRunAgentSettings$Outbound,
  z.ZodTypeDef,
  StreamRunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema
      ),
      z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunJSONSchemaToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
    ]),
  ).optional(),
  toolApprovalRequired: StreamRunAgentToolApprovalRequired$outboundSchema
    .default("none"),
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  maxCost: z.number().default(0),
  evaluators: z.array(z.lazy(() => StreamRunAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => StreamRunAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    maxCost: "max_cost",
  });
});

export function streamRunAgentSettingsToJSON(
  streamRunAgentSettings: StreamRunAgentSettings,
): string {
  return JSON.stringify(
    StreamRunAgentSettings$outboundSchema.parse(streamRunAgentSettings),
  );
}

/** @internal */
export type StreamRunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: StreamRunAgentModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<StreamRunAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: StreamRunAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  identity?: StreamRunAgentIdentity$Outbound | undefined;
  contact?: StreamRunAgentContact$Outbound | undefined;
  thread?: StreamRunAgentThread$Outbound | undefined;
  memory?: StreamRunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<StreamRunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<StreamRunAgentTeamOfAgents$Outbound> | undefined;
  settings: StreamRunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamRunAgentRequestBody$outboundSchema: z.ZodType<
  StreamRunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => StreamRunAgentIdentity$outboundSchema).optional(),
  contact: z.lazy(() => StreamRunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => StreamRunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => StreamRunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamRunAgentRequestBodyToJSON(
  streamRunAgentRequestBody: StreamRunAgentRequestBody,
): string {
  return JSON.stringify(
    StreamRunAgentRequestBody$outboundSchema.parse(streamRunAgentRequestBody),
  );
}

/** @internal */
export const StreamRunAgentData$inboundSchema: z.ZodType<
  StreamRunAgentData,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.AgentExecutionStartedStreamingEvent$inboundSchema,
  components.AgentStartedStreamingEvent$inboundSchema,
  components.AgentThoughtStreamingEvent$inboundSchema,
  components.AgentInactiveStreamingEvent$inboundSchema,
  components.AgentErroredStreamingEvent$inboundSchema,
  components.ActionReviewRequestedStreamingEvent$inboundSchema,
  components.ActionReviewedStreamingEvent$inboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
  components.ExecutionReviewedStreamingEvent$inboundSchema,
  components.ExecutionNamedStreamingEvent$inboundSchema,
  components.AgentHandedOffStreamingEvent$inboundSchema,
  components.AgentMessageCreatedStreamingEvent$inboundSchema,
  components.ToolExecutionStartedStreamingEvent$inboundSchema,
  components.ToolExecutionFinishedStreamingEvent$inboundSchema,
  components.ToolExecutionFailedStreamingEvent$inboundSchema,
  components.TimeoutStreamingEvent$inboundSchema,
  components.ErrorStreamingEvent$inboundSchema,
]);

export function streamRunAgentDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentData' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseBody$inboundSchema: z.ZodType<
  StreamRunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.AgentExecutionStartedStreamingEvent$inboundSchema,
      components.AgentStartedStreamingEvent$inboundSchema,
      components.AgentThoughtStreamingEvent$inboundSchema,
      components.AgentInactiveStreamingEvent$inboundSchema,
      components.AgentErroredStreamingEvent$inboundSchema,
      components.ActionReviewRequestedStreamingEvent$inboundSchema,
      components.ActionReviewedStreamingEvent$inboundSchema,
      components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
      components.ExecutionReviewedStreamingEvent$inboundSchema,
      components.ExecutionNamedStreamingEvent$inboundSchema,
      components.AgentHandedOffStreamingEvent$inboundSchema,
      components.AgentMessageCreatedStreamingEvent$inboundSchema,
      components.ToolExecutionStartedStreamingEvent$inboundSchema,
      components.ToolExecutionFinishedStreamingEvent$inboundSchema,
      components.ToolExecutionFailedStreamingEvent$inboundSchema,
      components.TimeoutStreamingEvent$inboundSchema,
      components.ErrorStreamingEvent$inboundSchema,
    ]),
  ),
});

export function streamRunAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseBody' from JSON`,
  );
}
