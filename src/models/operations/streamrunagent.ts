/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentModelVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentModelVoice = ClosedEnum<
  typeof StreamRunAgentModelVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentModelFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentModelFormat = ClosedEnum<
  typeof StreamRunAgentModelFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentModelAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentModelVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentModelFormat;
};

export const StreamRunAgentResponseFormatAgentsRequestType = {
  JsonSchema: "json_schema",
} as const;
export type StreamRunAgentResponseFormatAgentsRequestType = ClosedEnum<
  typeof StreamRunAgentResponseFormatAgentsRequestType
>;

export type StreamRunAgentResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type StreamRunAgentResponseFormat3 = {
  type: StreamRunAgentResponseFormatAgentsRequestType;
  jsonSchema: StreamRunAgentResponseFormatJsonSchema;
};

export const StreamRunAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type StreamRunAgentResponseFormatAgentsType = ClosedEnum<
  typeof StreamRunAgentResponseFormatAgentsType
>;

export type StreamRunAgentResponseFormat2 = {
  type: StreamRunAgentResponseFormatAgentsType;
};

export const StreamRunAgentResponseFormatType = {
  Text: "text",
} as const;
export type StreamRunAgentResponseFormatType = ClosedEnum<
  typeof StreamRunAgentResponseFormatType
>;

export type StreamRunAgentResponseFormat1 = {
  type: StreamRunAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentModelResponseFormat =
  | StreamRunAgentResponseFormat3
  | StreamRunAgentResponseFormat1
  | StreamRunAgentResponseFormat2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentModelStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentModelStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const StreamRunAgentModelType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type StreamRunAgentModelType = ClosedEnum<
  typeof StreamRunAgentModelType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const StreamRunAgentModelThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type StreamRunAgentModelThinkingLevel = ClosedEnum<
  typeof StreamRunAgentModelThinkingLevel
>;

export type StreamRunAgentModelThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: StreamRunAgentModelType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: StreamRunAgentModelThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceType = ClosedEnum<
  typeof StreamRunAgentToolChoiceType
>;

export type StreamRunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type StreamRunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceType | undefined;
  function: StreamRunAgentToolChoiceFunction;
};

export const StreamRunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoice1 = ClosedEnum<
  typeof StreamRunAgentToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentModelToolChoice =
  | StreamRunAgentToolChoice2
  | StreamRunAgentToolChoice1;

export const StreamRunAgentModelModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentModelModalities = ClosedEnum<
  typeof StreamRunAgentModelModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type StreamRunAgentModelWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

/**
 * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p (nucleus sampling), frequency_penalty, presence_penalty, response_format, reasoning_effort. Not all parameters work with all models.
 */
export type StreamRunAgentModelParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentModelAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormat3
    | StreamRunAgentResponseFormat1
    | StreamRunAgentResponseFormat2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamRunAgentModelStreamOptions | null | undefined;
  thinking?: StreamRunAgentModelThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoice2
    | StreamRunAgentToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<StreamRunAgentModelModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: StreamRunAgentModelWebSearchOptions | undefined;
};

/**
 * Model configuration with parameters
 */
export type StreamRunAgentModel2 = {
  /**
   * Model ID or provider/model string
   */
  id: string;
  /**
   * Optional integration ID for custom configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model parameters to customize behavior (snake_case). Common: temperature (0-1, controls randomness), max_tokens (response length). Advanced: top_p (nucleus sampling), frequency_penalty, presence_penalty, response_format, reasoning_effort. Not all parameters work with all models.
   */
  parameters?: StreamRunAgentModelParameters | undefined;
};

/**
 * The language model that powers the agent. Can be a simple string (e.g., "openai/gpt-4o") or an object with model ID and parameters. The model must support tool calling capabilities.
 */
export type StreamRunAgentModel = StreamRunAgentModel2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentFallbackModelsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentFallbackModelsVoice = ClosedEnum<
  typeof StreamRunAgentFallbackModelsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentFallbackModelsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentFallbackModelsFormat = ClosedEnum<
  typeof StreamRunAgentFallbackModelsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentFallbackModelsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentFallbackModelsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentFallbackModelsFormat;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type =
  {
    JsonSchema: "json_schema",
  } as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type =
  ClosedEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type
  >;

export type StreamRunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

export type StreamRunAgentResponseFormatAgents3 = {
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type;
  jsonSchema: StreamRunAgentResponseFormatAgentsJsonSchema;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  {
    JsonObject: "json_object",
  } as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  ClosedEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  >;

export type StreamRunAgentResponseFormatAgents2 = {
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType;
};

export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType = {
  Text: "text",
} as const;
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyType =
  ClosedEnum<typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType>;

export type StreamRunAgentResponseFormatAgents1 = {
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType;
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentFallbackModelsResponseFormat =
  | StreamRunAgentResponseFormatAgents3
  | StreamRunAgentResponseFormatAgents1
  | StreamRunAgentResponseFormatAgents2;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentFallbackModelsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentFallbackModelsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const StreamRunAgentFallbackModelsType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type StreamRunAgentFallbackModelsType = ClosedEnum<
  typeof StreamRunAgentFallbackModelsType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const StreamRunAgentFallbackModelsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type StreamRunAgentFallbackModelsThinkingLevel = ClosedEnum<
  typeof StreamRunAgentFallbackModelsThinkingLevel
>;

export type StreamRunAgentFallbackModelsThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: StreamRunAgentFallbackModelsType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: StreamRunAgentFallbackModelsThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceAgentsType = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgentsType
>;

export type StreamRunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type StreamRunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceAgentsType | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction;
};

export const StreamRunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoiceAgents1 = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentFallbackModelsToolChoice =
  | StreamRunAgentToolChoiceAgents2
  | StreamRunAgentToolChoiceAgents1;

export const StreamRunAgentFallbackModelsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentFallbackModelsModalities = ClosedEnum<
  typeof StreamRunAgentFallbackModelsModalities
>;

/**
 * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
 */
export type StreamRunAgentFallbackModelsWebSearchOptions = {
  /**
   * Whether to enable web search for this request.
   */
  enabled?: boolean | undefined;
};

export type StreamRunAgentFallbackModelsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentFallbackModelsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatAgents3
    | StreamRunAgentResponseFormatAgents1
    | StreamRunAgentResponseFormatAgents2
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamRunAgentFallbackModelsStreamOptions | null | undefined;
  thinking?: StreamRunAgentFallbackModelsThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoiceAgents2
    | StreamRunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<StreamRunAgentFallbackModelsModalities> | null | undefined;
  /**
   * This tool searches the web for relevant results to use in a response. Learn more about the web search tool.
   */
  webSearchOptions?: StreamRunAgentFallbackModelsWebSearchOptions | undefined;
};

export type StreamRunAgentFallbackModels2 = {
  /**
   * Fallback model ID
   */
  id: string;
  integrationId?: string | null | undefined;
  parameters?: StreamRunAgentFallbackModelsParameters | undefined;
};

export type StreamRunAgentFallbackModels =
  | StreamRunAgentFallbackModels2
  | string;

/**
 * Tool message
 */
export const StreamRunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Tool message
 */
export type StreamRunAgentRoleToolMessage = ClosedEnum<
  typeof StreamRunAgentRoleToolMessage
>;

/**
 * User message
 */
export const StreamRunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * User message
 */
export type StreamRunAgentRoleUserMessage = ClosedEnum<
  typeof StreamRunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamRunAgentRole =
  | StreamRunAgentRoleUserMessage
  | StreamRunAgentRoleToolMessage;

export const StreamRunAgentPublicMessagePartAgentsRequestKind = {
  ToolResult: "tool_result",
} as const;
export type StreamRunAgentPublicMessagePartAgentsRequestKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartAgentsRequestKind
>;

/**
 * Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request.
 */
export type StreamRunAgentPublicMessagePartToolResultPart = {
  kind: StreamRunAgentPublicMessagePartAgentsRequestKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPublicMessagePartAgentsKind = {
  File: "file",
} as const;
export type StreamRunAgentPublicMessagePartAgentsKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type StreamRunAgentFileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type StreamRunAgentFileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPublicMessagePartFile =
  | StreamRunAgentFileBinaryFormat
  | StreamRunAgentFileFileInURIFormat;

/**
 * File attachment part. Use this to send files (images, documents, etc.) to the agent for processing.
 */
export type StreamRunAgentPublicMessagePartFilePart = {
  kind: StreamRunAgentPublicMessagePartAgentsKind;
  file: StreamRunAgentFileBinaryFormat | StreamRunAgentFileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPublicMessagePartKind = {
  Text: "text",
} as const;
export type StreamRunAgentPublicMessagePartKind = ClosedEnum<
  typeof StreamRunAgentPublicMessagePartKind
>;

/**
 * Text content part. Use this to send text messages to the agent.
 */
export type StreamRunAgentPublicMessagePartTextPart = {
  kind: StreamRunAgentPublicMessagePartKind;
  text: string;
};

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamRunAgentPublicMessagePart =
  | StreamRunAgentPublicMessagePartTextPart
  | StreamRunAgentPublicMessagePartFilePart
  | StreamRunAgentPublicMessagePartToolResultPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type StreamRunAgentMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamRunAgentRoleUserMessage | StreamRunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | StreamRunAgentPublicMessagePartTextPart
    | StreamRunAgentPublicMessagePartFilePart
    | StreamRunAgentPublicMessagePartToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type StreamRunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamRunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamRunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamRunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type StreamRunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  >;

export type StreamRunAgentAgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunFunctionToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  >;

export const AgentToolInputRunLanguage = {
  Python: "python",
} as const;
export type AgentToolInputRunLanguage = ClosedEnum<
  typeof AgentToolInputRunLanguage
>;

export type AgentToolInputRunCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: AgentToolInputRunLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunCodeToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: AgentToolInputRunCodeTool;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * The HTTP method to use.
 */
export const AgentToolInputRunMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type AgentToolInputRunMethod = ClosedEnum<
  typeof AgentToolInputRunMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type AgentToolInputRunBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: AgentToolInputRunMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type AgentToolInputRunDefaultValue = string | number | boolean;

export type AgentToolInputRunArguments = {
  /**
   * The type of the argument.
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type AgentToolInputRunHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: AgentToolInputRunBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: AgentToolInputRunArguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunHTTPToolRun = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: AgentToolInputRunHttp;
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type StreamRunAgentAgentToolInputRunCurrentDateTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  >;

/**
 * Lists available memory stores
 */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Writes information to agent memory stores
 */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType =
  {
    QueryMemoryStore: "query_memory_store",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  >;

/**
 * Queries agent memory stores for context
 */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  >;

/**
 * Retrieves available agents in the system
 */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunAgentsRequestType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool = {
  type: StreamRunAgentAgentToolInputRunAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsType = {
  WebScraper: "web_scraper",
} as const;
export type StreamRunAgentAgentToolInputRunAgentsType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunAgentsType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type StreamRunAgentAgentToolInputRunWebScraperTool = {
  type: StreamRunAgentAgentToolInputRunAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunType = {
  GoogleSearch: "google_search",
} as const;
export type StreamRunAgentAgentToolInputRunType = ClosedEnum<
  typeof StreamRunAgentAgentToolInputRunType
>;

/**
 * Performs Google searches to retrieve web content
 */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool = {
  type: StreamRunAgentAgentToolInputRunType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function) support full inline definitions for on-the-fly creation.
 */
export type StreamRunAgentAgentToolInputRun =
  | AgentToolInputRunHTTPToolRun
  | AgentToolInputRunCodeToolRun
  | AgentToolInputRunFunctionToolRun
  | StreamRunAgentAgentToolInputRunGoogleSearchTool
  | StreamRunAgentAgentToolInputRunWebScraperTool
  | StreamRunAgentAgentToolInputRunCallSubAgentTool
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  | StreamRunAgentAgentToolInputRunCurrentDateTool;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const StreamRunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type StreamRunAgentToolApprovalRequired = ClosedEnum<
  typeof StreamRunAgentToolApprovalRequired
>;

export type StreamRunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | AgentToolInputRunHTTPToolRun
      | AgentToolInputRunCodeToolRun
      | AgentToolInputRunFunctionToolRun
      | StreamRunAgentAgentToolInputRunGoogleSearchTool
      | StreamRunAgentAgentToolInputRunWebScraperTool
      | StreamRunAgentAgentToolInputRunCallSubAgentTool
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
      | StreamRunAgentAgentToolInputRunCurrentDateTool
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: StreamRunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
};

export type StreamRunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The language model that powers the agent. Can be a simple string (e.g., "openai/gpt-4o") or an object with model ID and parameters. The model must support tool calling capabilities.
   */
  model: StreamRunAgentModel2 | string;
  /**
   * Optional array of fallback models (string IDs or config objects) to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities.
   */
  fallbackModels?: Array<StreamRunAgentFallbackModels2 | string> | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: StreamRunAgentMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: StreamRunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamRunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamRunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * The list of keys of the memory stores that are accessible to the agent.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<StreamRunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<StreamRunAgentTeamOfAgents> | undefined;
  settings: StreamRunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

/**
 * SSE stream of agent events
 */
export type StreamRunAgentResponseBody = {
  /**
   * JSON-encoded event data
   */
  data: string;
};

/** @internal */
export const StreamRunAgentModelVoice$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelVoice
> = z.nativeEnum(StreamRunAgentModelVoice);
/** @internal */
export const StreamRunAgentModelVoice$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelVoice
> = StreamRunAgentModelVoice$inboundSchema;

/** @internal */
export const StreamRunAgentModelFormat$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelFormat
> = z.nativeEnum(StreamRunAgentModelFormat);
/** @internal */
export const StreamRunAgentModelFormat$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelFormat
> = StreamRunAgentModelFormat$inboundSchema;

/** @internal */
export const StreamRunAgentModelAudio$inboundSchema: z.ZodType<
  StreamRunAgentModelAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: StreamRunAgentModelVoice$inboundSchema,
  format: StreamRunAgentModelFormat$inboundSchema,
});
/** @internal */
export type StreamRunAgentModelAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentModelAudio$outboundSchema: z.ZodType<
  StreamRunAgentModelAudio$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelAudio
> = z.object({
  voice: StreamRunAgentModelVoice$outboundSchema,
  format: StreamRunAgentModelFormat$outboundSchema,
});

export function streamRunAgentModelAudioToJSON(
  streamRunAgentModelAudio: StreamRunAgentModelAudio,
): string {
  return JSON.stringify(
    StreamRunAgentModelAudio$outboundSchema.parse(streamRunAgentModelAudio),
  );
}
export function streamRunAgentModelAudioFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsRequestType> = z
    .nativeEnum(StreamRunAgentResponseFormatAgentsRequestType);
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsRequestType> =
    StreamRunAgentResponseFormatAgentsRequestType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatJsonSchema$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type StreamRunAgentResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentResponseFormatJsonSchema$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function streamRunAgentResponseFormatJsonSchemaToJSON(
  streamRunAgentResponseFormatJsonSchema:
    StreamRunAgentResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJsonSchema$outboundSchema.parse(
      streamRunAgentResponseFormatJsonSchema,
    ),
  );
}
export function streamRunAgentResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormat3$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestType$inboundSchema,
  json_schema: z.lazy(() =>
    StreamRunAgentResponseFormatJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type StreamRunAgentResponseFormat3$Outbound = {
  type: string;
  json_schema: StreamRunAgentResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormat3$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormat3$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormat3
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestType$outboundSchema,
  jsonSchema: z.lazy(() =>
    StreamRunAgentResponseFormatJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function streamRunAgentResponseFormat3ToJSON(
  streamRunAgentResponseFormat3: StreamRunAgentResponseFormat3,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormat3$outboundSchema.parse(
      streamRunAgentResponseFormat3,
    ),
  );
}
export function streamRunAgentResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormat3' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsType> = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsType,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentResponseFormatAgentsType> =
    StreamRunAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormat2$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormat2$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormat2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormat2
> = z.object({
  type: StreamRunAgentResponseFormatAgentsType$outboundSchema,
});

export function streamRunAgentResponseFormat2ToJSON(
  streamRunAgentResponseFormat2: StreamRunAgentResponseFormat2,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormat2$outboundSchema.parse(
      streamRunAgentResponseFormat2,
    ),
  );
}
export function streamRunAgentResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormat2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentResponseFormatType
> = z.nativeEnum(StreamRunAgentResponseFormatType);
/** @internal */
export const StreamRunAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentResponseFormatType
> = StreamRunAgentResponseFormatType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormat1$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormat1$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormat1$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormat1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormat1
> = z.object({
  type: StreamRunAgentResponseFormatType$outboundSchema,
});

export function streamRunAgentResponseFormat1ToJSON(
  streamRunAgentResponseFormat1: StreamRunAgentResponseFormat1,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormat1$outboundSchema.parse(
      streamRunAgentResponseFormat1,
    ),
  );
}
export function streamRunAgentResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormat1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelResponseFormat$inboundSchema: z.ZodType<
  StreamRunAgentModelResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentResponseFormat3$inboundSchema),
  z.lazy(() => StreamRunAgentResponseFormat1$inboundSchema),
  z.lazy(() => StreamRunAgentResponseFormat2$inboundSchema),
]);
/** @internal */
export type StreamRunAgentModelResponseFormat$Outbound =
  | StreamRunAgentResponseFormat3$Outbound
  | StreamRunAgentResponseFormat1$Outbound
  | StreamRunAgentResponseFormat2$Outbound;

/** @internal */
export const StreamRunAgentModelResponseFormat$outboundSchema: z.ZodType<
  StreamRunAgentModelResponseFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelResponseFormat
> = z.union([
  z.lazy(() => StreamRunAgentResponseFormat3$outboundSchema),
  z.lazy(() => StreamRunAgentResponseFormat1$outboundSchema),
  z.lazy(() => StreamRunAgentResponseFormat2$outboundSchema),
]);

export function streamRunAgentModelResponseFormatToJSON(
  streamRunAgentModelResponseFormat: StreamRunAgentModelResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentModelResponseFormat$outboundSchema.parse(
      streamRunAgentModelResponseFormat,
    ),
  );
}
export function streamRunAgentModelResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelStop$inboundSchema: z.ZodType<
  StreamRunAgentModelStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentModelStop$Outbound = string | Array<string>;

/** @internal */
export const StreamRunAgentModelStop$outboundSchema: z.ZodType<
  StreamRunAgentModelStop$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelStop
> = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentModelStopToJSON(
  streamRunAgentModelStop: StreamRunAgentModelStop,
): string {
  return JSON.stringify(
    StreamRunAgentModelStop$outboundSchema.parse(streamRunAgentModelStop),
  );
}
export function streamRunAgentModelStopFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelStreamOptions$inboundSchema: z.ZodType<
  StreamRunAgentModelStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type StreamRunAgentModelStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentModelStreamOptions$outboundSchema: z.ZodType<
  StreamRunAgentModelStreamOptions$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamRunAgentModelStreamOptionsToJSON(
  streamRunAgentModelStreamOptions: StreamRunAgentModelStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentModelStreamOptions$outboundSchema.parse(
      streamRunAgentModelStreamOptions,
    ),
  );
}
export function streamRunAgentModelStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelType
> = z.nativeEnum(StreamRunAgentModelType);
/** @internal */
export const StreamRunAgentModelType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelType
> = StreamRunAgentModelType$inboundSchema;

/** @internal */
export const StreamRunAgentModelThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelThinkingLevel
> = z.nativeEnum(StreamRunAgentModelThinkingLevel);
/** @internal */
export const StreamRunAgentModelThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelThinkingLevel
> = StreamRunAgentModelThinkingLevel$inboundSchema;

/** @internal */
export const StreamRunAgentModelThinking$inboundSchema: z.ZodType<
  StreamRunAgentModelThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentModelType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: StreamRunAgentModelThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type StreamRunAgentModelThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const StreamRunAgentModelThinking$outboundSchema: z.ZodType<
  StreamRunAgentModelThinking$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelThinking
> = z.object({
  type: StreamRunAgentModelType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: StreamRunAgentModelThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function streamRunAgentModelThinkingToJSON(
  streamRunAgentModelThinking: StreamRunAgentModelThinking,
): string {
  return JSON.stringify(
    StreamRunAgentModelThinking$outboundSchema.parse(
      streamRunAgentModelThinking,
    ),
  );
}
export function streamRunAgentModelThinkingFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = z.nativeEnum(StreamRunAgentToolChoiceType);
/** @internal */
export const StreamRunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = StreamRunAgentToolChoiceType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function streamRunAgentToolChoiceFunctionToJSON(
  streamRunAgentToolChoiceFunction: StreamRunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceFunction$outboundSchema.parse(
      streamRunAgentToolChoiceFunction,
    ),
  );
}
export function streamRunAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoice2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoice2
> = z.object({
  type: StreamRunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$outboundSchema),
});

export function streamRunAgentToolChoice2ToJSON(
  streamRunAgentToolChoice2: StreamRunAgentToolChoice2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoice2$outboundSchema.parse(streamRunAgentToolChoice2),
  );
}
export function streamRunAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = z.nativeEnum(StreamRunAgentToolChoice1);
/** @internal */
export const StreamRunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = StreamRunAgentToolChoice1$inboundSchema;

/** @internal */
export const StreamRunAgentModelToolChoice$inboundSchema: z.ZodType<
  StreamRunAgentModelToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
  StreamRunAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type StreamRunAgentModelToolChoice$Outbound =
  | StreamRunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelToolChoice$outboundSchema: z.ZodType<
  StreamRunAgentModelToolChoice$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelToolChoice
> = z.union([
  z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
  StreamRunAgentToolChoice1$outboundSchema,
]);

export function streamRunAgentModelToolChoiceToJSON(
  streamRunAgentModelToolChoice: StreamRunAgentModelToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentModelToolChoice$outboundSchema.parse(
      streamRunAgentModelToolChoice,
    ),
  );
}
export function streamRunAgentModelToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelModalities$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelModalities
> = z.nativeEnum(StreamRunAgentModelModalities);
/** @internal */
export const StreamRunAgentModelModalities$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentModelModalities
> = StreamRunAgentModelModalities$inboundSchema;

/** @internal */
export const StreamRunAgentModelWebSearchOptions$inboundSchema: z.ZodType<
  StreamRunAgentModelWebSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  enabled: z.boolean().optional(),
});
/** @internal */
export type StreamRunAgentModelWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentModelWebSearchOptions$outboundSchema: z.ZodType<
  StreamRunAgentModelWebSearchOptions$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelWebSearchOptions
> = z.object({
  enabled: z.boolean().optional(),
});

export function streamRunAgentModelWebSearchOptionsToJSON(
  streamRunAgentModelWebSearchOptions: StreamRunAgentModelWebSearchOptions,
): string {
  return JSON.stringify(
    StreamRunAgentModelWebSearchOptions$outboundSchema.parse(
      streamRunAgentModelWebSearchOptions,
    ),
  );
}
export function streamRunAgentModelWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelWebSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelWebSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelParameters$inboundSchema: z.ZodType<
  StreamRunAgentModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => StreamRunAgentModelAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => StreamRunAgentResponseFormat3$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormat1$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormat2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => StreamRunAgentModelStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => StreamRunAgentModelThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
    StreamRunAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(StreamRunAgentModelModalities$inboundSchema))
    .optional(),
  web_search_options: z.lazy(() =>
    StreamRunAgentModelWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type StreamRunAgentModelParameters$Outbound = {
  audio?: StreamRunAgentModelAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormat3$Outbound
    | StreamRunAgentResponseFormat1$Outbound
    | StreamRunAgentResponseFormat2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: StreamRunAgentModelStreamOptions$Outbound | null | undefined;
  thinking?: StreamRunAgentModelThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?: StreamRunAgentModelWebSearchOptions$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModelParameters$outboundSchema: z.ZodType<
  StreamRunAgentModelParameters$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelParameters
> = z.object({
  audio: z.nullable(z.lazy(() => StreamRunAgentModelAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => StreamRunAgentResponseFormat3$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormat1$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormat2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => StreamRunAgentModelStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => StreamRunAgentModelThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
    StreamRunAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(StreamRunAgentModelModalities$outboundSchema))
    .optional(),
  webSearchOptions: z.lazy(() =>
    StreamRunAgentModelWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function streamRunAgentModelParametersToJSON(
  streamRunAgentModelParameters: StreamRunAgentModelParameters,
): string {
  return JSON.stringify(
    StreamRunAgentModelParameters$outboundSchema.parse(
      streamRunAgentModelParameters,
    ),
  );
}
export function streamRunAgentModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModel2$inboundSchema: z.ZodType<
  StreamRunAgentModel2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => StreamRunAgentModelParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type StreamRunAgentModel2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: StreamRunAgentModelParameters$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModel2$outboundSchema: z.ZodType<
  StreamRunAgentModel2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModel2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => StreamRunAgentModelParameters$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function streamRunAgentModel2ToJSON(
  streamRunAgentModel2: StreamRunAgentModel2,
): string {
  return JSON.stringify(
    StreamRunAgentModel2$outboundSchema.parse(streamRunAgentModel2),
  );
}
export function streamRunAgentModel2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModel2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModel2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModel2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModel$inboundSchema: z.ZodType<
  StreamRunAgentModel,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => StreamRunAgentModel2$inboundSchema), z.string()]);
/** @internal */
export type StreamRunAgentModel$Outbound =
  | StreamRunAgentModel2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModel$outboundSchema: z.ZodType<
  StreamRunAgentModel$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModel
> = z.union([z.lazy(() => StreamRunAgentModel2$outboundSchema), z.string()]);

export function streamRunAgentModelToJSON(
  streamRunAgentModel: StreamRunAgentModel,
): string {
  return JSON.stringify(
    StreamRunAgentModel$outboundSchema.parse(streamRunAgentModel),
  );
}
export function streamRunAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModel' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsVoice$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsVoice
> = z.nativeEnum(StreamRunAgentFallbackModelsVoice);
/** @internal */
export const StreamRunAgentFallbackModelsVoice$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsVoice
> = StreamRunAgentFallbackModelsVoice$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsFormat$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsFormat
> = z.nativeEnum(StreamRunAgentFallbackModelsFormat);
/** @internal */
export const StreamRunAgentFallbackModelsFormat$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsFormat
> = StreamRunAgentFallbackModelsFormat$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsAudio$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: StreamRunAgentFallbackModelsVoice$inboundSchema,
  format: StreamRunAgentFallbackModelsFormat$inboundSchema,
});
/** @internal */
export type StreamRunAgentFallbackModelsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentFallbackModelsAudio$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsAudio$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelsAudio
> = z.object({
  voice: StreamRunAgentFallbackModelsVoice$outboundSchema,
  format: StreamRunAgentFallbackModelsFormat$outboundSchema,
});

export function streamRunAgentFallbackModelsAudioToJSON(
  streamRunAgentFallbackModelsAudio: StreamRunAgentFallbackModelsAudio,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsAudio$outboundSchema.parse(
      streamRunAgentFallbackModelsAudio,
    ),
  );
}
export function streamRunAgentFallbackModelsAudioFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModelsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFallbackModelsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelsAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type
  > = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type
  > =
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function streamRunAgentResponseFormatAgentsJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsJsonSchema:
    StreamRunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgents3$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type$inboundSchema,
  json_schema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type StreamRunAgentResponseFormatAgents3$Outbound = {
  type: string;
  json_schema: StreamRunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatAgents3$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents3$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgents3
> = z.object({
  type:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModels2Type$outboundSchema,
  jsonSchema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function streamRunAgentResponseFormatAgents3ToJSON(
  streamRunAgentResponseFormatAgents3: StreamRunAgentResponseFormatAgents3,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgents3$outboundSchema.parse(
      streamRunAgentResponseFormatAgents3,
    ),
  );
}
export function streamRunAgentResponseFormatAgents3FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatAgents3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgents3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgents3' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > = z.nativeEnum(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType,
  );
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > =
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgents2$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormatAgents2$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatAgents2$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgents2
> = z.object({
  type:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema,
});

export function streamRunAgentResponseFormatAgents2ToJSON(
  streamRunAgentResponseFormatAgents2: StreamRunAgentResponseFormatAgents2,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgents2$outboundSchema.parse(
      streamRunAgentResponseFormatAgents2,
    ),
  );
}
export function streamRunAgentResponseFormatAgents2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgents2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType
  > = z.nativeEnum(StreamRunAgentResponseFormatAgentsRequestRequestBodyType);
/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentResponseFormatAgentsRequestRequestBodyType
  > = StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const StreamRunAgentResponseFormatAgents1$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema,
});
/** @internal */
export type StreamRunAgentResponseFormatAgents1$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentResponseFormatAgents1$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgents1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgents1
> = z.object({
  type: StreamRunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema,
});

export function streamRunAgentResponseFormatAgents1ToJSON(
  streamRunAgentResponseFormatAgents1: StreamRunAgentResponseFormatAgents1,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgents1$outboundSchema.parse(
      streamRunAgentResponseFormatAgents1,
    ),
  );
}
export function streamRunAgentResponseFormatAgents1FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgents1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsResponseFormat$inboundSchema:
  z.ZodType<StreamRunAgentFallbackModelsResponseFormat, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => StreamRunAgentResponseFormatAgents3$inboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgents1$inboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgents2$inboundSchema),
    ]);
/** @internal */
export type StreamRunAgentFallbackModelsResponseFormat$Outbound =
  | StreamRunAgentResponseFormatAgents3$Outbound
  | StreamRunAgentResponseFormatAgents1$Outbound
  | StreamRunAgentResponseFormatAgents2$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelsResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelsResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelsResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgents3$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents1$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents2$outboundSchema),
  ]);

export function streamRunAgentFallbackModelsResponseFormatToJSON(
  streamRunAgentFallbackModelsResponseFormat:
    StreamRunAgentFallbackModelsResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsResponseFormat$outboundSchema.parse(
      streamRunAgentFallbackModelsResponseFormat,
    ),
  );
}
export function streamRunAgentFallbackModelsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelsResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsStop$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentFallbackModelsStop$Outbound = string | Array<string>;

/** @internal */
export const StreamRunAgentFallbackModelsStop$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsStop$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelsStop
> = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentFallbackModelsStopToJSON(
  streamRunAgentFallbackModelsStop: StreamRunAgentFallbackModelsStop,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsStop$outboundSchema.parse(
      streamRunAgentFallbackModelsStop,
    ),
  );
}
export function streamRunAgentFallbackModelsStopFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModelsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFallbackModelsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelsStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsStreamOptions$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type StreamRunAgentFallbackModelsStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelsStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelsStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelsStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentFallbackModelsStreamOptionsToJSON(
  streamRunAgentFallbackModelsStreamOptions:
    StreamRunAgentFallbackModelsStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsStreamOptions$outboundSchema.parse(
      streamRunAgentFallbackModelsStreamOptions,
    ),
  );
}
export function streamRunAgentFallbackModelsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelsStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelsStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsType
> = z.nativeEnum(StreamRunAgentFallbackModelsType);
/** @internal */
export const StreamRunAgentFallbackModelsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentFallbackModelsType
> = StreamRunAgentFallbackModelsType$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelsThinkingLevel> = z
    .nativeEnum(StreamRunAgentFallbackModelsThinkingLevel);
/** @internal */
export const StreamRunAgentFallbackModelsThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelsThinkingLevel> =
    StreamRunAgentFallbackModelsThinkingLevel$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsThinking$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentFallbackModelsType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: StreamRunAgentFallbackModelsThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type StreamRunAgentFallbackModelsThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelsThinking$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsThinking$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelsThinking
> = z.object({
  type: StreamRunAgentFallbackModelsType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: StreamRunAgentFallbackModelsThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function streamRunAgentFallbackModelsThinkingToJSON(
  streamRunAgentFallbackModelsThinking: StreamRunAgentFallbackModelsThinking,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsThinking$outboundSchema.parse(
      streamRunAgentFallbackModelsThinking,
    ),
  );
}
export function streamRunAgentFallbackModelsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModelsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelsThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = z.nativeEnum(StreamRunAgentToolChoiceAgentsType);
/** @internal */
export const StreamRunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = StreamRunAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function streamRunAgentToolChoiceAgentsFunctionToJSON(
  streamRunAgentToolChoiceAgentsFunction:
    StreamRunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      streamRunAgentToolChoiceAgentsFunction,
    ),
  );
}
export function streamRunAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgents2
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function streamRunAgentToolChoiceAgents2ToJSON(
  streamRunAgentToolChoiceAgents2: StreamRunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgents2$outboundSchema.parse(
      streamRunAgentToolChoiceAgents2,
    ),
  );
}
export function streamRunAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = z.nativeEnum(StreamRunAgentToolChoiceAgents1);
/** @internal */
export const StreamRunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = StreamRunAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsToolChoice$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
  StreamRunAgentToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type StreamRunAgentFallbackModelsToolChoice$Outbound =
  | StreamRunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelsToolChoice$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsToolChoice$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelsToolChoice
> = z.union([
  z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
  StreamRunAgentToolChoiceAgents1$outboundSchema,
]);

export function streamRunAgentFallbackModelsToolChoiceToJSON(
  streamRunAgentFallbackModelsToolChoice:
    StreamRunAgentFallbackModelsToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsToolChoice$outboundSchema.parse(
      streamRunAgentFallbackModelsToolChoice,
    ),
  );
}
export function streamRunAgentFallbackModelsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModelsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelsToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsModalities$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelsModalities> = z.nativeEnum(
    StreamRunAgentFallbackModelsModalities,
  );
/** @internal */
export const StreamRunAgentFallbackModelsModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelsModalities> =
    StreamRunAgentFallbackModelsModalities$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelsWebSearchOptions$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelsWebSearchOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    enabled: z.boolean().optional(),
  });
/** @internal */
export type StreamRunAgentFallbackModelsWebSearchOptions$Outbound = {
  enabled?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelsWebSearchOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelsWebSearchOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelsWebSearchOptions
  > = z.object({
    enabled: z.boolean().optional(),
  });

export function streamRunAgentFallbackModelsWebSearchOptionsToJSON(
  streamRunAgentFallbackModelsWebSearchOptions:
    StreamRunAgentFallbackModelsWebSearchOptions,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsWebSearchOptions$outboundSchema.parse(
      streamRunAgentFallbackModelsWebSearchOptions,
    ),
  );
}
export function streamRunAgentFallbackModelsWebSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelsWebSearchOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsWebSearchOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelsWebSearchOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelsParameters$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(
    z.lazy(() => StreamRunAgentFallbackModelsAudio$inboundSchema),
  ).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgents3$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents1$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents2$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => StreamRunAgentFallbackModelsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => StreamRunAgentFallbackModelsThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
    StreamRunAgentToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(StreamRunAgentFallbackModelsModalities$inboundSchema),
  ).optional(),
  web_search_options: z.lazy(() =>
    StreamRunAgentFallbackModelsWebSearchOptions$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "web_search_options": "webSearchOptions",
  });
});
/** @internal */
export type StreamRunAgentFallbackModelsParameters$Outbound = {
  audio?: StreamRunAgentFallbackModelsAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatAgents3$Outbound
    | StreamRunAgentResponseFormatAgents1$Outbound
    | StreamRunAgentResponseFormatAgents2$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentFallbackModelsStreamOptions$Outbound
    | null
    | undefined;
  thinking?: StreamRunAgentFallbackModelsThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  web_search_options?:
    | StreamRunAgentFallbackModelsWebSearchOptions$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelsParameters$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelsParameters$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelsParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => StreamRunAgentFallbackModelsAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgents3$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents1$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgents2$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => StreamRunAgentFallbackModelsStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => StreamRunAgentFallbackModelsThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
    StreamRunAgentToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(StreamRunAgentFallbackModelsModalities$outboundSchema),
  ).optional(),
  webSearchOptions: z.lazy(() =>
    StreamRunAgentFallbackModelsWebSearchOptions$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    webSearchOptions: "web_search_options",
  });
});

export function streamRunAgentFallbackModelsParametersToJSON(
  streamRunAgentFallbackModelsParameters:
    StreamRunAgentFallbackModelsParameters,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelsParameters$outboundSchema.parse(
      streamRunAgentFallbackModelsParameters,
    ),
  );
}
export function streamRunAgentFallbackModelsParametersFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModelsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelsParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModels2$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModels2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => StreamRunAgentFallbackModelsParameters$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
  });
});
/** @internal */
export type StreamRunAgentFallbackModels2$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: StreamRunAgentFallbackModelsParameters$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModels2$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModels2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModels2
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() =>
    StreamRunAgentFallbackModelsParameters$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
  });
});

export function streamRunAgentFallbackModels2ToJSON(
  streamRunAgentFallbackModels2: StreamRunAgentFallbackModels2,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModels2$outboundSchema.parse(
      streamRunAgentFallbackModels2,
    ),
  );
}
export function streamRunAgentFallbackModels2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModels2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFallbackModels2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModels2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModels$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModels,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModels2$inboundSchema),
  z.string(),
]);
/** @internal */
export type StreamRunAgentFallbackModels$Outbound =
  | StreamRunAgentFallbackModels2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModels$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModels$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModels
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModels2$outboundSchema),
  z.string(),
]);

export function streamRunAgentFallbackModelsToJSON(
  streamRunAgentFallbackModels: StreamRunAgentFallbackModels,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModels$outboundSchema.parse(
      streamRunAgentFallbackModels,
    ),
  );
}
export function streamRunAgentFallbackModelsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFallbackModels, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFallbackModels$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModels' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = z.nativeEnum(StreamRunAgentRoleToolMessage);
/** @internal */
export const StreamRunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = StreamRunAgentRoleToolMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = z.nativeEnum(StreamRunAgentRoleUserMessage);
/** @internal */
export const StreamRunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = StreamRunAgentRoleUserMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRole$inboundSchema: z.ZodType<
  StreamRunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  StreamRunAgentRoleUserMessage$inboundSchema,
  StreamRunAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type StreamRunAgentRole$Outbound = string | string;

/** @internal */
export const StreamRunAgentRole$outboundSchema: z.ZodType<
  StreamRunAgentRole$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRole
> = z.union([
  StreamRunAgentRoleUserMessage$outboundSchema,
  StreamRunAgentRoleToolMessage$outboundSchema,
]);

export function streamRunAgentRoleToJSON(
  streamRunAgentRole: StreamRunAgentRole,
): string {
  return JSON.stringify(
    StreamRunAgentRole$outboundSchema.parse(streamRunAgentRole),
  );
}
export function streamRunAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRole' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsRequestKind> = z
    .nativeEnum(StreamRunAgentPublicMessagePartAgentsRequestKind);
/** @internal */
export const StreamRunAgentPublicMessagePartAgentsRequestKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsRequestKind> =
    StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema;

/** @internal */
export const StreamRunAgentPublicMessagePartToolResultPart$inboundSchema:
  z.ZodType<
    StreamRunAgentPublicMessagePartToolResultPart,
    z.ZodTypeDef,
    unknown
  > = z.object({
    kind: StreamRunAgentPublicMessagePartAgentsRequestKind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });
/** @internal */
export type StreamRunAgentPublicMessagePartToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPublicMessagePartToolResultPart$outboundSchema:
  z.ZodType<
    StreamRunAgentPublicMessagePartToolResultPart$Outbound,
    z.ZodTypeDef,
    StreamRunAgentPublicMessagePartToolResultPart
  > = z.object({
    kind: StreamRunAgentPublicMessagePartAgentsRequestKind$outboundSchema,
    toolCallId: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCallId: "tool_call_id",
    });
  });

export function streamRunAgentPublicMessagePartToolResultPartToJSON(
  streamRunAgentPublicMessagePartToolResultPart:
    StreamRunAgentPublicMessagePartToolResultPart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartToolResultPart$outboundSchema.parse(
      streamRunAgentPublicMessagePartToolResultPart,
    ),
  );
}
export function streamRunAgentPublicMessagePartToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartToolResultPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartToolResultPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartToolResultPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartAgentsKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsKind> = z
    .nativeEnum(StreamRunAgentPublicMessagePartAgentsKind);
/** @internal */
export const StreamRunAgentPublicMessagePartAgentsKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartAgentsKind> =
    StreamRunAgentPublicMessagePartAgentsKind$inboundSchema;

/** @internal */
export const StreamRunAgentFileFileInURIFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileFileInURIFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileFileInURIFormatToJSON(
  streamRunAgentFileFileInURIFormat: StreamRunAgentFileFileInURIFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileFileInURIFormat$outboundSchema.parse(
      streamRunAgentFileFileInURIFormat,
    ),
  );
}
export function streamRunAgentFileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFileBinaryFormat$inboundSchema: z.ZodType<
  StreamRunAgentFileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type StreamRunAgentFileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFileBinaryFormat$outboundSchema: z.ZodType<
  StreamRunAgentFileBinaryFormat$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function streamRunAgentFileBinaryFormatToJSON(
  streamRunAgentFileBinaryFormat: StreamRunAgentFileBinaryFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFileBinaryFormat$outboundSchema.parse(
      streamRunAgentFileBinaryFormat,
    ),
  );
}
export function streamRunAgentFileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartFile$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFileBinaryFormat$inboundSchema),
  z.lazy(() => StreamRunAgentFileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPublicMessagePartFile$Outbound =
  | StreamRunAgentFileBinaryFormat$Outbound
  | StreamRunAgentFileFileInURIFormat$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePartFile$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartFile
> = z.union([
  z.lazy(() => StreamRunAgentFileBinaryFormat$outboundSchema),
  z.lazy(() => StreamRunAgentFileFileInURIFormat$outboundSchema),
]);

export function streamRunAgentPublicMessagePartFileToJSON(
  streamRunAgentPublicMessagePartFile: StreamRunAgentPublicMessagePartFile,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartFile$outboundSchema.parse(
      streamRunAgentPublicMessagePartFile,
    ),
  );
}
export function streamRunAgentPublicMessagePartFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPublicMessagePartFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPublicMessagePartFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartFilePart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPublicMessagePartAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileBinaryFormat$inboundSchema),
    z.lazy(() => StreamRunAgentFileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentPublicMessagePartFilePart$Outbound = {
  kind: string;
  file:
    | StreamRunAgentFileBinaryFormat$Outbound
    | StreamRunAgentFileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentPublicMessagePartFilePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartFilePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartFilePart
> = z.object({
  kind: StreamRunAgentPublicMessagePartAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFileBinaryFormat$outboundSchema),
    z.lazy(() => StreamRunAgentFileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function streamRunAgentPublicMessagePartFilePartToJSON(
  streamRunAgentPublicMessagePartFilePart:
    StreamRunAgentPublicMessagePartFilePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartFilePart$outboundSchema.parse(
      streamRunAgentPublicMessagePartFilePart,
    ),
  );
}
export function streamRunAgentPublicMessagePartFilePartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartFilePart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartFilePart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartFilePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPublicMessagePartKind
> = z.nativeEnum(StreamRunAgentPublicMessagePartKind);
/** @internal */
export const StreamRunAgentPublicMessagePartKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPublicMessagePartKind> =
    StreamRunAgentPublicMessagePartKind$inboundSchema;

/** @internal */
export const StreamRunAgentPublicMessagePartTextPart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPublicMessagePartKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type StreamRunAgentPublicMessagePartTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentPublicMessagePartTextPart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePartTextPart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePartTextPart
> = z.object({
  kind: StreamRunAgentPublicMessagePartKind$outboundSchema,
  text: z.string(),
});

export function streamRunAgentPublicMessagePartTextPartToJSON(
  streamRunAgentPublicMessagePartTextPart:
    StreamRunAgentPublicMessagePartTextPart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePartTextPart$outboundSchema.parse(
      streamRunAgentPublicMessagePartTextPart,
    ),
  );
}
export function streamRunAgentPublicMessagePartTextPartFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentPublicMessagePartTextPart,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentPublicMessagePartTextPart$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentPublicMessagePartTextPart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentPublicMessagePartTextPart$inboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartFilePart$inboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$inboundSchema),
]);
/** @internal */
export type StreamRunAgentPublicMessagePart$Outbound =
  | StreamRunAgentPublicMessagePartTextPart$Outbound
  | StreamRunAgentPublicMessagePartFilePart$Outbound
  | StreamRunAgentPublicMessagePartToolResultPart$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePart
> = z.union([
  z.lazy(() => StreamRunAgentPublicMessagePartTextPart$outboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartFilePart$outboundSchema),
  z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$outboundSchema),
]);

export function streamRunAgentPublicMessagePartToJSON(
  streamRunAgentPublicMessagePart: StreamRunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePart$outboundSchema.parse(
      streamRunAgentPublicMessagePart,
    ),
  );
}
export function streamRunAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMessage$inboundSchema: z.ZodType<
  StreamRunAgentMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$inboundSchema,
    StreamRunAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPublicMessagePartTextPart$inboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartFilePart$inboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type StreamRunAgentMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | StreamRunAgentPublicMessagePartTextPart$Outbound
    | StreamRunAgentPublicMessagePartFilePart$Outbound
    | StreamRunAgentPublicMessagePartToolResultPart$Outbound
  >;
};

/** @internal */
export const StreamRunAgentMessage$outboundSchema: z.ZodType<
  StreamRunAgentMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$outboundSchema,
    StreamRunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentPublicMessagePartTextPart$outboundSchema),
      z.lazy(() => StreamRunAgentPublicMessagePartFilePart$outboundSchema),
      z.lazy(() =>
        StreamRunAgentPublicMessagePartToolResultPart$outboundSchema
      ),
    ]),
  ),
});

export function streamRunAgentMessageToJSON(
  streamRunAgentMessage: StreamRunAgentMessage,
): string {
  return JSON.stringify(
    StreamRunAgentMessage$outboundSchema.parse(streamRunAgentMessage),
  );
}
export function streamRunAgentMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMessage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentContact$inboundSchema: z.ZodType<
  StreamRunAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type StreamRunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentContact$outboundSchema: z.ZodType<
  StreamRunAgentContact$Outbound,
  z.ZodTypeDef,
  StreamRunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentContactToJSON(
  streamRunAgentContact: StreamRunAgentContact,
): string {
  return JSON.stringify(
    StreamRunAgentContact$outboundSchema.parse(streamRunAgentContact),
  );
}
export function streamRunAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentContact' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentThread$inboundSchema: z.ZodType<
  StreamRunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type StreamRunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentThread$outboundSchema: z.ZodType<
  StreamRunAgentThread$Outbound,
  z.ZodTypeDef,
  StreamRunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamRunAgentThreadToJSON(
  streamRunAgentThread: StreamRunAgentThread,
): string {
  return JSON.stringify(
    StreamRunAgentThread$outboundSchema.parse(streamRunAgentThread),
  );
}
export function streamRunAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentThread' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMemory$inboundSchema: z.ZodType<
  StreamRunAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamRunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentMemory$outboundSchema: z.ZodType<
  StreamRunAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentMemoryToJSON(
  streamRunAgentMemory: StreamRunAgentMemory,
): string {
  return JSON.stringify(
    StreamRunAgentMemory$outboundSchema.parse(streamRunAgentMemory),
  );
}
export function streamRunAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMemory' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentKnowledgeBases$inboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type StreamRunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const StreamRunAgentKnowledgeBases$outboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  StreamRunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function streamRunAgentKnowledgeBasesToJSON(
  streamRunAgentKnowledgeBases: StreamRunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    StreamRunAgentKnowledgeBases$outboundSchema.parse(
      streamRunAgentKnowledgeBases,
    ),
  );
}
export function streamRunAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentTeamOfAgents$inboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type StreamRunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const StreamRunAgentTeamOfAgents$outboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function streamRunAgentTeamOfAgentsToJSON(
  streamRunAgentTeamOfAgents: StreamRunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    StreamRunAgentTeamOfAgents$outboundSchema.parse(streamRunAgentTeamOfAgents),
  );
}
export function streamRunAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type StreamRunAgentAgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function streamRunAgentAgentToolInputRunFunctionToJSON(
  streamRunAgentAgentToolInputRunFunction:
    StreamRunAgentAgentToolInputRunFunction,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunFunction$outboundSchema.parse(
      streamRunAgentAgentToolInputRunFunction,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunFunction' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunFunctionToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => StreamRunAgentAgentToolInputRunFunction$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunFunctionToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunFunctionToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunctionToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() =>
    StreamRunAgentAgentToolInputRunFunction$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunFunctionToolRunToJSON(
  agentToolInputRunFunctionToolRun: AgentToolInputRunFunctionToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunFunctionToolRun$outboundSchema.parse(
      agentToolInputRunFunctionToolRun,
    ),
  );
}
export function agentToolInputRunFunctionToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunFunctionToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunFunctionToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunFunctionToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema;

/** @internal */
export const AgentToolInputRunLanguage$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = z.nativeEnum(AgentToolInputRunLanguage);
/** @internal */
export const AgentToolInputRunLanguage$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = AgentToolInputRunLanguage$inboundSchema;

/** @internal */
export const AgentToolInputRunCodeTool$inboundSchema: z.ZodType<
  AgentToolInputRunCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: AgentToolInputRunLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type AgentToolInputRunCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const AgentToolInputRunCodeTool$outboundSchema: z.ZodType<
  AgentToolInputRunCodeTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: AgentToolInputRunLanguage$outboundSchema,
  code: z.string(),
});

export function agentToolInputRunCodeToolToJSON(
  agentToolInputRunCodeTool: AgentToolInputRunCodeTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeTool$outboundSchema.parse(agentToolInputRunCodeTool),
  );
}
export function agentToolInputRunCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunCodeToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  code_tool: z.lazy(() => AgentToolInputRunCodeTool$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "code_tool": "codeTool",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunCodeToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: AgentToolInputRunCodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunCodeToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => AgentToolInputRunCodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCodeToolRunToJSON(
  agentToolInputRunCodeToolRun: AgentToolInputRunCodeToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeToolRun$outboundSchema.parse(
      agentToolInputRunCodeToolRun,
    ),
  );
}
export function agentToolInputRunCodeToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema;

/** @internal */
export const AgentToolInputRunMethod$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = z.nativeEnum(AgentToolInputRunMethod);
/** @internal */
export const AgentToolInputRunMethod$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = AgentToolInputRunMethod$inboundSchema;

/** @internal */
export const AgentToolInputRunBlueprint$inboundSchema: z.ZodType<
  AgentToolInputRunBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type AgentToolInputRunBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const AgentToolInputRunBlueprint$outboundSchema: z.ZodType<
  AgentToolInputRunBlueprint$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunBlueprint
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

export function agentToolInputRunBlueprintToJSON(
  agentToolInputRunBlueprint: AgentToolInputRunBlueprint,
): string {
  return JSON.stringify(
    AgentToolInputRunBlueprint$outboundSchema.parse(agentToolInputRunBlueprint),
  );
}
export function agentToolInputRunBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunBlueprint' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema;

/** @internal */
export const AgentToolInputRunDefaultValue$inboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AgentToolInputRunDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const AgentToolInputRunDefaultValue$outboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function agentToolInputRunDefaultValueToJSON(
  agentToolInputRunDefaultValue: AgentToolInputRunDefaultValue,
): string {
  return JSON.stringify(
    AgentToolInputRunDefaultValue$outboundSchema.parse(
      agentToolInputRunDefaultValue,
    ),
  );
}
export function agentToolInputRunDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunDefaultValue' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunArguments$inboundSchema: z.ZodType<
  AgentToolInputRunArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type AgentToolInputRunArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const AgentToolInputRunArguments$outboundSchema: z.ZodType<
  AgentToolInputRunArguments$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunArguments
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function agentToolInputRunArgumentsToJSON(
  agentToolInputRunArguments: AgentToolInputRunArguments,
): string {
  return JSON.stringify(
    AgentToolInputRunArguments$outboundSchema.parse(agentToolInputRunArguments),
  );
}
export function agentToolInputRunArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunArguments' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHttp$inboundSchema: z.ZodType<
  AgentToolInputRunHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type AgentToolInputRunHttp$Outbound = {
  blueprint: AgentToolInputRunBlueprint$Outbound;
  arguments?: { [k: string]: AgentToolInputRunArguments$Outbound } | undefined;
};

/** @internal */
export const AgentToolInputRunHttp$outboundSchema: z.ZodType<
  AgentToolInputRunHttp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHttp
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$outboundSchema))
    .optional(),
});

export function agentToolInputRunHttpToJSON(
  agentToolInputRunHttp: AgentToolInputRunHttp,
): string {
  return JSON.stringify(
    AgentToolInputRunHttp$outboundSchema.parse(agentToolInputRunHttp),
  );
}
export function agentToolInputRunHttpFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHttp' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHTTPToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunHTTPToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: AgentToolInputRunHttp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunHTTPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHTTPToolRun
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunHTTPToolRunToJSON(
  agentToolInputRunHTTPToolRun: AgentToolInputRunHTTPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunHTTPToolRun$outboundSchema.parse(
      agentToolInputRunHTTPToolRun,
    ),
  );
}
export function agentToolInputRunHTTPToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHTTPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHTTPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHTTPToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCurrentDateTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCurrentDateToolToJSON(
  streamRunAgentAgentToolInputRunCurrentDateTool:
    StreamRunAgentAgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCurrentDateTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCurrentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCurrentDateTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCurrentDateTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolToJSON(
  streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool:
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound =
  {
    type: string;
    requires_approval?: boolean | undefined;
  };

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool:
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolToJSON(
  streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool:
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool),
  );
}
export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools7Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool:
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunWriteMemoryStoreTool:
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunQueryMemoryStoreTool:
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = z.nativeEnum(StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveAgentsToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveAgentsTool:
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunRetrieveAgentsTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsRequestType> = z
    .nativeEnum(StreamRunAgentAgentToolInputRunAgentsRequestType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsRequestType> =
    StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsRequestType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCallSubAgentTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsRequestType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCallSubAgentToolToJSON(
  streamRunAgentAgentToolInputRunCallSubAgentTool:
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCallSubAgentTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCallSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCallSubAgentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsType> = z
    .nativeEnum(StreamRunAgentAgentToolInputRunAgentsType);
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunAgentsType> =
    StreamRunAgentAgentToolInputRunAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWebScraperTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunAgentsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWebScraperToolToJSON(
  streamRunAgentAgentToolInputRunWebScraperTool:
    StreamRunAgentAgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWebScraperTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWebScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWebScraperTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWebScraperTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentToolInputRunType
> = z.nativeEnum(StreamRunAgentAgentToolInputRunType);
/** @internal */
export const StreamRunAgentAgentToolInputRunType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentAgentToolInputRunType> =
    StreamRunAgentAgentToolInputRunType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: StreamRunAgentAgentToolInputRunType$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunGoogleSearchTool
  > = z.object({
    type: StreamRunAgentAgentToolInputRunType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunGoogleSearchToolToJSON(
  streamRunAgentAgentToolInputRunGoogleSearchTool:
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunGoogleSearchTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunGoogleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunGoogleSearchTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunGoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRun$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema),
]);
/** @internal */
export type StreamRunAgentAgentToolInputRun$Outbound =
  | AgentToolInputRunHTTPToolRun$Outbound
  | AgentToolInputRunCodeToolRun$Outbound
  | AgentToolInputRunFunctionToolRun$Outbound
  | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
  | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
  | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound;

/** @internal */
export const StreamRunAgentAgentToolInputRun$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRun
> = z.union([
  z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema),
]);

export function streamRunAgentAgentToolInputRunToJSON(
  streamRunAgentAgentToolInputRun: StreamRunAgentAgentToolInputRun,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRun$outboundSchema.parse(
      streamRunAgentAgentToolInputRun,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentAgentToolInputRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = z.nativeEnum(StreamRunAgentToolApprovalRequired);
/** @internal */
export const StreamRunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = StreamRunAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const StreamRunAgentSettings$inboundSchema: z.ZodType<
  StreamRunAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema
      ),
    ]),
  ).optional(),
  tool_approval_required: StreamRunAgentToolApprovalRequired$inboundSchema
    .default("none"),
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});
/** @internal */
export type StreamRunAgentSettings$Outbound = {
  tools?:
    | Array<
      | AgentToolInputRunHTTPToolRun$Outbound
      | AgentToolInputRunCodeToolRun$Outbound
      | AgentToolInputRunFunctionToolRun$Outbound
      | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
      | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
      | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
};

/** @internal */
export const StreamRunAgentSettings$outboundSchema: z.ZodType<
  StreamRunAgentSettings$Outbound,
  z.ZodTypeDef,
  StreamRunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema
      ),
    ]),
  ).optional(),
  toolApprovalRequired: StreamRunAgentToolApprovalRequired$outboundSchema
    .default("none"),
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

export function streamRunAgentSettingsToJSON(
  streamRunAgentSettings: StreamRunAgentSettings,
): string {
  return JSON.stringify(
    StreamRunAgentSettings$outboundSchema.parse(streamRunAgentSettings),
  );
}
export function streamRunAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentSettings' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRequestBody$inboundSchema: z.ZodType<
  StreamRunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  task_id: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModel2$inboundSchema),
    z.string(),
  ]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModels2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$inboundSchema),
  ).optional(),
  team_of_agents: z.array(
    z.lazy(() => StreamRunAgentTeamOfAgents$inboundSchema),
  ).optional(),
  settings: z.lazy(() => StreamRunAgentSettings$inboundSchema),
  metadata: z.record(z.any()).optional(),
  stream_timeout_seconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
    "stream_timeout_seconds": "streamTimeoutSeconds",
  });
});
/** @internal */
export type StreamRunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: StreamRunAgentModel2$Outbound | string;
  fallback_models?:
    | Array<StreamRunAgentFallbackModels2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: StreamRunAgentMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: StreamRunAgentContact$Outbound | undefined;
  thread?: StreamRunAgentThread$Outbound | undefined;
  memory?: StreamRunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<StreamRunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<StreamRunAgentTeamOfAgents$Outbound> | undefined;
  settings: StreamRunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamRunAgentRequestBody$outboundSchema: z.ZodType<
  StreamRunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModel2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModels2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => StreamRunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => StreamRunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamRunAgentRequestBodyToJSON(
  streamRunAgentRequestBody: StreamRunAgentRequestBody,
): string {
  return JSON.stringify(
    StreamRunAgentRequestBody$outboundSchema.parse(streamRunAgentRequestBody),
  );
}
export function streamRunAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseBody$inboundSchema: z.ZodType<
  StreamRunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
});
/** @internal */
export type StreamRunAgentResponseBody$Outbound = {
  data: string;
};

/** @internal */
export const StreamRunAgentResponseBody$outboundSchema: z.ZodType<
  StreamRunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseBody
> = z.object({
  data: z.string(),
});

export function streamRunAgentResponseBodyToJSON(
  streamRunAgentResponseBody: StreamRunAgentResponseBody,
): string {
  return JSON.stringify(
    StreamRunAgentResponseBody$outboundSchema.parse(streamRunAgentResponseBody),
  );
}
export function streamRunAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseBody' from JSON`,
  );
}
