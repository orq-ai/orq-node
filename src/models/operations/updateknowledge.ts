/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const RequestBodyRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type RequestBodyRetrievalType = ClosedEnum<
  typeof RequestBodyRetrievalType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeRequestBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeRequestBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeRequestBodyRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: RequestBodyRetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: UpdateKnowledgeRequestBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeRequestBodyAgenticRagConfig
    | null
    | undefined;
};

export const UpdateKnowledgeRequestBodyKnowledgeType = {
  Internal: "internal",
} as const;
export type UpdateKnowledgeRequestBodyKnowledgeType = ClosedEnum<
  typeof UpdateKnowledgeRequestBodyKnowledgeType
>;

export type UpdateKnowledgeRequestBody2 = {
  /**
   * The description of the knowledge base.
   */
  description?: string | null | undefined;
  /**
   * The embeddings model used for the knowledge base. If the models is provided and is different than the previous set model, all the datasources in the knowledge base will be re-embedded.
   */
  embeddingModel?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: UpdateKnowledgeRequestBodyRetrievalSettings | undefined;
  type?: UpdateKnowledgeRequestBodyKnowledgeType | undefined;
};

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type RequestBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type RequestBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type RequestBodyRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: RequestBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: RequestBodyAgenticRagConfig | null | undefined;
};

/**
 * Configuration for the external knowledge base.
 */
export type RequestBodyExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name?: string | undefined;
  /**
   * The API URL for the external knowledge base.
   */
  apiUrl?: string | undefined;
  /**
   * The API key for the external knowledge base.
   */
  apiKey?: string | undefined;
};

export const UpdateKnowledgeRequestBodyType = {
  External: "external",
} as const;
export type UpdateKnowledgeRequestBodyType = ClosedEnum<
  typeof UpdateKnowledgeRequestBodyType
>;

export type UpdateKnowledgeRequestBody1 = {
  /**
   * The description of the knowledge base.
   */
  description?: string | null | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?: RequestBodyRetrievalSettings | undefined;
  /**
   * Configuration for the external knowledge base.
   */
  externalConfig?: RequestBodyExternalConfig | undefined;
  type?: UpdateKnowledgeRequestBodyType | undefined;
};

export type UpdateKnowledgeRequestBody =
  | UpdateKnowledgeRequestBody1
  | UpdateKnowledgeRequestBody2;

export type UpdateKnowledgeRequest = {
  /**
   * The unique identifier of the knowledge base
   */
  knowledgeId: string;
  requestBody: UpdateKnowledgeRequestBody1 | UpdateKnowledgeRequestBody2;
};

export const UpdateKnowledgeResponseBodyKnowledgeType = {
  External: "external",
} as const;
export type UpdateKnowledgeResponseBodyKnowledgeType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyKnowledgeType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeResponseBodyKnowledgeRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK: number;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold: number;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK: number;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold: number;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?:
    | UpdateKnowledgeResponseBodyKnowledgeRerankConfig
    | null
    | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig
    | null
    | undefined;
};

export type UpdateKnowledgeResponseBodyExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
};

export type UpdateKnowledgeResponseBody2 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type: UpdateKnowledgeResponseBodyKnowledgeType;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?:
    | UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings
    | undefined;
  externalConfig: UpdateKnowledgeResponseBodyExternalConfig;
};

export const UpdateKnowledgeResponseBodyType = {
  Internal: "internal",
} as const;
export type UpdateKnowledgeResponseBodyType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const UpdateKnowledgeResponseBodyRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeResponseBodyRetrievalType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyRetrievalType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeResponseBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK: number;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold: number;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeResponseBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeResponseBodyRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType: UpdateKnowledgeResponseBodyRetrievalType;
  /**
   * The number of results to return from the search.
   */
  topK: number;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold: number;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: UpdateKnowledgeResponseBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeResponseBodyAgenticRagConfig
    | null
    | undefined;
};

export type UpdateKnowledgeResponseBody1 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type: UpdateKnowledgeResponseBodyType;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: UpdateKnowledgeResponseBodyRetrievalSettings | undefined;
  /**
   * The embeddings model used for the knowledge base.
   */
  model: string;
};

/**
 * Knowledge successfully updated
 */
export type UpdateKnowledgeResponseBody =
  | UpdateKnowledgeResponseBody1
  | UpdateKnowledgeResponseBody2;

/** @internal */
export const RequestBodyRetrievalType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyRetrievalType
> = z.nativeEnum(RequestBodyRetrievalType);

/** @internal */
export type UpdateKnowledgeRequestBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const UpdateKnowledgeRequestBodyRerankConfig$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function updateKnowledgeRequestBodyRerankConfigToJSON(
  updateKnowledgeRequestBodyRerankConfig:
    UpdateKnowledgeRequestBodyRerankConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyRerankConfig$outboundSchema.parse(
      updateKnowledgeRequestBodyRerankConfig,
    ),
  );
}

/** @internal */
export type UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeRequestBodyAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeRequestBodyAgenticRagConfigToJSON(
  updateKnowledgeRequestBodyAgenticRagConfig:
    UpdateKnowledgeRequestBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema.parse(
      updateKnowledgeRequestBodyAgenticRagConfig,
    ),
  );
}

/** @internal */
export type UpdateKnowledgeRequestBodyRetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?:
    | UpdateKnowledgeRequestBodyRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema:
  z.ZodType<
    UpdateKnowledgeRequestBodyRetrievalSettings$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeRequestBodyRetrievalSettings
  > = z.object({
    retrievalType: RequestBodyRetrievalType$outboundSchema.default(
      "hybrid_search",
    ),
    topK: z.number().int().default(5),
    threshold: z.number().default(0),
    rerankConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyRerankConfig$outboundSchema),
    ).optional(),
    agenticRagConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      retrievalType: "retrieval_type",
      topK: "top_k",
      rerankConfig: "rerank_config",
      agenticRagConfig: "agentic_rag_config",
    });
  });

export function updateKnowledgeRequestBodyRetrievalSettingsToJSON(
  updateKnowledgeRequestBodyRetrievalSettings:
    UpdateKnowledgeRequestBodyRetrievalSettings,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema.parse(
      updateKnowledgeRequestBodyRetrievalSettings,
    ),
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeRequestBodyKnowledgeType> = z
    .nativeEnum(UpdateKnowledgeRequestBodyKnowledgeType);

/** @internal */
export type UpdateKnowledgeRequestBody2$Outbound = {
  description?: string | null | undefined;
  embedding_model?: string | undefined;
  path?: string | undefined;
  retrieval_settings?:
    | UpdateKnowledgeRequestBodyRetrievalSettings$Outbound
    | undefined;
  type: string;
};

/** @internal */
export const UpdateKnowledgeRequestBody2$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody2$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody2
> = z.object({
  description: z.nullable(z.string()).optional(),
  embeddingModel: z.string().optional(),
  path: z.string().optional(),
  retrievalSettings: z.lazy(() =>
    UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema
  ).optional(),
  type: UpdateKnowledgeRequestBodyKnowledgeType$outboundSchema.default(
    "internal",
  ),
}).transform((v) => {
  return remap$(v, {
    embeddingModel: "embedding_model",
    retrievalSettings: "retrieval_settings",
  });
});

export function updateKnowledgeRequestBody2ToJSON(
  updateKnowledgeRequestBody2: UpdateKnowledgeRequestBody2,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody2$outboundSchema.parse(
      updateKnowledgeRequestBody2,
    ),
  );
}

/** @internal */
export type RequestBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const RequestBodyRerankConfig$outboundSchema: z.ZodType<
  RequestBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function requestBodyRerankConfigToJSON(
  requestBodyRerankConfig: RequestBodyRerankConfig,
): string {
  return JSON.stringify(
    RequestBodyRerankConfig$outboundSchema.parse(requestBodyRerankConfig),
  );
}

/** @internal */
export type RequestBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const RequestBodyAgenticRagConfig$outboundSchema: z.ZodType<
  RequestBodyAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function requestBodyAgenticRagConfigToJSON(
  requestBodyAgenticRagConfig: RequestBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    RequestBodyAgenticRagConfig$outboundSchema.parse(
      requestBodyAgenticRagConfig,
    ),
  );
}

/** @internal */
export type RequestBodyRetrievalSettings$Outbound = {
  top_k: number;
  threshold: number;
  rerank_config?: RequestBodyRerankConfig$Outbound | null | undefined;
  agentic_rag_config?: RequestBodyAgenticRagConfig$Outbound | null | undefined;
};

/** @internal */
export const RequestBodyRetrievalSettings$outboundSchema: z.ZodType<
  RequestBodyRetrievalSettings$Outbound,
  z.ZodTypeDef,
  RequestBodyRetrievalSettings
> = z.object({
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(z.lazy(() => RequestBodyRerankConfig$outboundSchema))
    .optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => RequestBodyAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function requestBodyRetrievalSettingsToJSON(
  requestBodyRetrievalSettings: RequestBodyRetrievalSettings,
): string {
  return JSON.stringify(
    RequestBodyRetrievalSettings$outboundSchema.parse(
      requestBodyRetrievalSettings,
    ),
  );
}

/** @internal */
export type RequestBodyExternalConfig$Outbound = {
  name?: string | undefined;
  api_url?: string | undefined;
  api_key?: string | undefined;
};

/** @internal */
export const RequestBodyExternalConfig$outboundSchema: z.ZodType<
  RequestBodyExternalConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyExternalConfig
> = z.object({
  name: z.string().optional(),
  apiUrl: z.string().optional(),
  apiKey: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    apiUrl: "api_url",
    apiKey: "api_key",
  });
});

export function requestBodyExternalConfigToJSON(
  requestBodyExternalConfig: RequestBodyExternalConfig,
): string {
  return JSON.stringify(
    RequestBodyExternalConfig$outboundSchema.parse(requestBodyExternalConfig),
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeRequestBodyType
> = z.nativeEnum(UpdateKnowledgeRequestBodyType);

/** @internal */
export type UpdateKnowledgeRequestBody1$Outbound = {
  description?: string | null | undefined;
  path?: string | undefined;
  retrieval_settings?: RequestBodyRetrievalSettings$Outbound | undefined;
  external_config?: RequestBodyExternalConfig$Outbound | undefined;
  type: string;
};

/** @internal */
export const UpdateKnowledgeRequestBody1$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody1$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody1
> = z.object({
  description: z.nullable(z.string()).optional(),
  path: z.string().optional(),
  retrievalSettings: z.lazy(() => RequestBodyRetrievalSettings$outboundSchema)
    .optional(),
  externalConfig: z.lazy(() => RequestBodyExternalConfig$outboundSchema)
    .optional(),
  type: UpdateKnowledgeRequestBodyType$outboundSchema.default("external"),
}).transform((v) => {
  return remap$(v, {
    retrievalSettings: "retrieval_settings",
    externalConfig: "external_config",
  });
});

export function updateKnowledgeRequestBody1ToJSON(
  updateKnowledgeRequestBody1: UpdateKnowledgeRequestBody1,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody1$outboundSchema.parse(
      updateKnowledgeRequestBody1,
    ),
  );
}

/** @internal */
export type UpdateKnowledgeRequestBody$Outbound =
  | UpdateKnowledgeRequestBody1$Outbound
  | UpdateKnowledgeRequestBody2$Outbound;

/** @internal */
export const UpdateKnowledgeRequestBody$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody
> = z.union([
  z.lazy(() => UpdateKnowledgeRequestBody1$outboundSchema),
  z.lazy(() => UpdateKnowledgeRequestBody2$outboundSchema),
]);

export function updateKnowledgeRequestBodyToJSON(
  updateKnowledgeRequestBody: UpdateKnowledgeRequestBody,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody$outboundSchema.parse(updateKnowledgeRequestBody),
  );
}

/** @internal */
export type UpdateKnowledgeRequest$Outbound = {
  knowledge_id: string;
  RequestBody:
    | UpdateKnowledgeRequestBody1$Outbound
    | UpdateKnowledgeRequestBody2$Outbound;
};

/** @internal */
export const UpdateKnowledgeRequest$outboundSchema: z.ZodType<
  UpdateKnowledgeRequest$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequest
> = z.object({
  knowledgeId: z.string(),
  requestBody: z.union([
    z.lazy(() => UpdateKnowledgeRequestBody1$outboundSchema),
    z.lazy(() => UpdateKnowledgeRequestBody2$outboundSchema),
  ]),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    requestBody: "RequestBody",
  });
});

export function updateKnowledgeRequestToJSON(
  updateKnowledgeRequest: UpdateKnowledgeRequest,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequest$outboundSchema.parse(updateKnowledgeRequest),
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyKnowledgeType> = z
    .nativeEnum(UpdateKnowledgeResponseBodyKnowledgeType);

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    top_k: z.number().int().default(5),
    rerank_threshold: z.number().default(0.5),
    rerank_model: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "top_k": "topK",
      "rerank_threshold": "rerankThreshold",
      "rerank_model": "rerankModel",
    });
  });

export function updateKnowledgeResponseBodyKnowledgeRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeRerankConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeRerankConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeResponseBodyKnowledgeAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema
      ),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });

export function updateKnowledgeResponseBodyKnowledgeRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyExternalConfig$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBodyExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
  });
});

export function updateKnowledgeResponseBodyExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyExternalConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyExternalConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyExternalConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody2$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyKnowledgeType$inboundSchema.default(
    "external",
  ),
  retrieval_settings: z.lazy(() =>
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema
  ).optional(),
  external_config: z.lazy(() =>
    UpdateKnowledgeResponseBodyExternalConfig$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
    "external_config": "externalConfig",
  });
});

export function updateKnowledgeResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody2' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeResponseBodyType
> = z.nativeEnum(UpdateKnowledgeResponseBodyType);

/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyRetrievalType> = z
    .nativeEnum(UpdateKnowledgeResponseBodyRetrievalType);

/** @internal */
export const UpdateKnowledgeResponseBodyRerankConfig$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});

export function updateKnowledgeResponseBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyRerankConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyRerankConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyAgenticRagConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeResponseBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    retrieval_type: UpdateKnowledgeResponseBodyRetrievalType$inboundSchema
      .default("hybrid_search"),
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyRerankConfig$inboundSchema),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "retrieval_type": "retrievalType",
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });

export function updateKnowledgeResponseBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody1$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyType$inboundSchema.default("internal"),
  retrieval_settings: z.lazy(() =>
    UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema
  ).optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
  });
});

export function updateKnowledgeResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody1' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateKnowledgeResponseBody1$inboundSchema),
  z.lazy(() => UpdateKnowledgeResponseBody2$inboundSchema),
]);

export function updateKnowledgeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody' from JSON`,
  );
}
