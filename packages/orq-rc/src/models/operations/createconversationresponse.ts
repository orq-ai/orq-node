/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateConversationResponseRequestBody = {
  /**
   * The user message to send to the model
   */
  message: components.UserMessageRequest;
  /**
   * The model to use for generation in format provider/model_id (e.g., openai/gpt-4o).
   */
  model: string;
  /**
   * Task ID for continuing a previous conversation turn
   */
  taskId?: string | undefined;
  /**
   * Whether to stream the response (default: true)
   */
  stream?: boolean | undefined;
};

export type CreateConversationResponseRequest = {
  /**
   * The unique identifier of the conversation
   */
  conversationId: string;
  requestBody: CreateConversationResponseRequestBody;
};

export const CreateConversationResponseResponseStreamingEventType = {
  PartDone: "part.done",
} as const;
export type CreateConversationResponseResponseStreamingEventType = ClosedEnum<
  typeof CreateConversationResponseResponseStreamingEventType
>;

/**
 * Type discriminator indicating this is a reasoning part
 */
export const PartKind = {
  Reasoning: "reasoning",
} as const;
/**
 * Type discriminator indicating this is a reasoning part
 */
export type PartKind = ClosedEnum<typeof PartKind>;

/**
 * A message part containing reasoning or chain-of-thought content
 */
export type PartReasoningPart = {
  /**
   * Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)
   */
  id?: string | undefined;
  /**
   * Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Type discriminator indicating this is a reasoning part
   */
  kind: PartKind;
  /**
   * The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking.
   */
  reasoning: string;
  /**
   * Optional cryptographic signature to verify the authenticity and integrity of the reasoning content
   */
  signature?: string | undefined;
};

export type CreateConversationResponseResponseStreamingEventData = {
  /**
   * Unique identifier for this part. Matches the partId from part.delta events.
   */
  partId: string;
  part?: any | undefined;
};

/**
 * Emitted when a part has been fully streamed. Contains the complete part with all content.
 */
export type PartDoneEvent = {
  type: CreateConversationResponseResponseStreamingEventType;
  /**
   * ISO timestamp of when the event occurred
   */
  timestamp: string;
  data: CreateConversationResponseResponseStreamingEventData;
};

export const ResponseStreamingEventType = {
  PartDelta: "part.delta",
} as const;
export type ResponseStreamingEventType = ClosedEnum<
  typeof ResponseStreamingEventType
>;

/**
 * Type discriminator indicating this is a reasoning part
 */
export const DeltaKind = {
  Reasoning: "reasoning",
} as const;
/**
 * Type discriminator indicating this is a reasoning part
 */
export type DeltaKind = ClosedEnum<typeof DeltaKind>;

/**
 * A message part containing reasoning or chain-of-thought content
 */
export type ReasoningPart = {
  /**
   * Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)
   */
  id?: string | undefined;
  /**
   * Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Type discriminator indicating this is a reasoning part
   */
  kind: DeltaKind;
  /**
   * The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking.
   */
  reasoning: string;
  /**
   * Optional cryptographic signature to verify the authenticity and integrity of the reasoning content
   */
  signature?: string | undefined;
};

export type ResponseStreamingEventData = {
  /**
   * Unique identifier for this part. Format: {kind}_{ulid}. Use to correlate with part.done event.
   */
  partId: string;
  delta?: any | undefined;
};

/**
 * Emitted for each content chunk streamed from the LLM. The delta field contains a discriminated union based on the kind field.
 */
export type PartDeltaEvent = {
  type: ResponseStreamingEventType;
  /**
   * ISO timestamp of when the event occurred
   */
  timestamp: string;
  data: ResponseStreamingEventData;
};

/**
 * Union of all possible streaming events. Each event has a type field for discrimination.
 */
export type ResponseStreamingEvent =
  | components.ResponseStartedEvent
  | components.ResponseDoneEvent
  | components.ResponseFailedEvent
  | components.ToolStartedEvent
  | components.ToolDoneEvent
  | components.ToolFailedEvent
  | components.ToolReviewRequestedEvent
  | components.ToolReviewDoneEvent
  | components.PartDeltaEvent
  | components.PartDoneEvent;

/**
 * Response successfully created.
 */
export type CreateConversationResponseResponseBody = {
  data?:
    | components.ResponseStartedEvent
    | components.ResponseDoneEvent
    | components.ResponseFailedEvent
    | components.ToolStartedEvent
    | components.ToolDoneEvent
    | components.ToolFailedEvent
    | components.ToolReviewRequestedEvent
    | components.ToolReviewDoneEvent
    | components.PartDeltaEvent
    | components.PartDoneEvent
    | undefined;
};

/** @internal */
export const CreateConversationResponseRequestBody$inboundSchema: z.ZodType<
  CreateConversationResponseRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  message: components.UserMessageRequest$inboundSchema,
  model: z.string(),
  task_id: z.string().optional(),
  stream: z.boolean().default(true),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type CreateConversationResponseRequestBody$Outbound = {
  message: components.UserMessageRequest$Outbound;
  model: string;
  task_id?: string | undefined;
  stream: boolean;
};

/** @internal */
export const CreateConversationResponseRequestBody$outboundSchema: z.ZodType<
  CreateConversationResponseRequestBody$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseRequestBody
> = z.object({
  message: components.UserMessageRequest$outboundSchema,
  model: z.string(),
  taskId: z.string().optional(),
  stream: z.boolean().default(true),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function createConversationResponseRequestBodyToJSON(
  createConversationResponseRequestBody: CreateConversationResponseRequestBody,
): string {
  return JSON.stringify(
    CreateConversationResponseRequestBody$outboundSchema.parse(
      createConversationResponseRequestBody,
    ),
  );
}
export function createConversationResponseRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationResponseRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationResponseRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationResponseRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseRequest$inboundSchema: z.ZodType<
  CreateConversationResponseRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  conversation_id: z.string(),
  RequestBody: z.lazy(() =>
    CreateConversationResponseRequestBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "conversation_id": "conversationId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateConversationResponseRequest$Outbound = {
  conversation_id: string;
  RequestBody: CreateConversationResponseRequestBody$Outbound;
};

/** @internal */
export const CreateConversationResponseRequest$outboundSchema: z.ZodType<
  CreateConversationResponseRequest$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseRequest
> = z.object({
  conversationId: z.string(),
  requestBody: z.lazy(() =>
    CreateConversationResponseRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    conversationId: "conversation_id",
    requestBody: "RequestBody",
  });
});

export function createConversationResponseRequestToJSON(
  createConversationResponseRequest: CreateConversationResponseRequest,
): string {
  return JSON.stringify(
    CreateConversationResponseRequest$outboundSchema.parse(
      createConversationResponseRequest,
    ),
  );
}
export function createConversationResponseRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationResponseRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateConversationResponseRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationResponseRequest' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseResponseStreamingEventType$inboundSchema:
  z.ZodNativeEnum<typeof CreateConversationResponseResponseStreamingEventType> =
    z.nativeEnum(CreateConversationResponseResponseStreamingEventType);
/** @internal */
export const CreateConversationResponseResponseStreamingEventType$outboundSchema:
  z.ZodNativeEnum<typeof CreateConversationResponseResponseStreamingEventType> =
    CreateConversationResponseResponseStreamingEventType$inboundSchema;

/** @internal */
export const PartKind$inboundSchema: z.ZodNativeEnum<typeof PartKind> = z
  .nativeEnum(PartKind);
/** @internal */
export const PartKind$outboundSchema: z.ZodNativeEnum<typeof PartKind> =
  PartKind$inboundSchema;

/** @internal */
export const PartReasoningPart$inboundSchema: z.ZodType<
  PartReasoningPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("reasoning_01kf0v8bqcw2ay6xyr5evgtyex"),
  metadata: z.record(z.any()).optional(),
  kind: PartKind$inboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});
/** @internal */
export type PartReasoningPart$Outbound = {
  _id: string;
  metadata?: { [k: string]: any } | undefined;
  kind: string;
  reasoning: string;
  signature?: string | undefined;
};

/** @internal */
export const PartReasoningPart$outboundSchema: z.ZodType<
  PartReasoningPart$Outbound,
  z.ZodTypeDef,
  PartReasoningPart
> = z.object({
  id: z.string().default("reasoning_01kf0v8bqcw2ay6xyr5evgtyex"),
  metadata: z.record(z.any()).optional(),
  kind: PartKind$outboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
  });
});

export function partReasoningPartToJSON(
  partReasoningPart: PartReasoningPart,
): string {
  return JSON.stringify(
    PartReasoningPart$outboundSchema.parse(partReasoningPart),
  );
}
export function partReasoningPartFromJSON(
  jsonString: string,
): SafeParseResult<PartReasoningPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartReasoningPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartReasoningPart' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseResponseStreamingEventData$inboundSchema:
  z.ZodType<
    CreateConversationResponseResponseStreamingEventData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    partId: z.string(),
    part: z.any().optional(),
  });
/** @internal */
export type CreateConversationResponseResponseStreamingEventData$Outbound = {
  partId: string;
  part?: any | undefined;
};

/** @internal */
export const CreateConversationResponseResponseStreamingEventData$outboundSchema:
  z.ZodType<
    CreateConversationResponseResponseStreamingEventData$Outbound,
    z.ZodTypeDef,
    CreateConversationResponseResponseStreamingEventData
  > = z.object({
    partId: z.string(),
    part: z.any().optional(),
  });

export function createConversationResponseResponseStreamingEventDataToJSON(
  createConversationResponseResponseStreamingEventData:
    CreateConversationResponseResponseStreamingEventData,
): string {
  return JSON.stringify(
    CreateConversationResponseResponseStreamingEventData$outboundSchema.parse(
      createConversationResponseResponseStreamingEventData,
    ),
  );
}
export function createConversationResponseResponseStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateConversationResponseResponseStreamingEventData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationResponseResponseStreamingEventData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateConversationResponseResponseStreamingEventData' from JSON`,
  );
}

/** @internal */
export const PartDoneEvent$inboundSchema: z.ZodType<
  PartDoneEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateConversationResponseResponseStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    CreateConversationResponseResponseStreamingEventData$inboundSchema
  ),
});
/** @internal */
export type PartDoneEvent$Outbound = {
  type: string;
  timestamp: string;
  data: CreateConversationResponseResponseStreamingEventData$Outbound;
};

/** @internal */
export const PartDoneEvent$outboundSchema: z.ZodType<
  PartDoneEvent$Outbound,
  z.ZodTypeDef,
  PartDoneEvent
> = z.object({
  type: CreateConversationResponseResponseStreamingEventType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    CreateConversationResponseResponseStreamingEventData$outboundSchema
  ),
});

export function partDoneEventToJSON(partDoneEvent: PartDoneEvent): string {
  return JSON.stringify(PartDoneEvent$outboundSchema.parse(partDoneEvent));
}
export function partDoneEventFromJSON(
  jsonString: string,
): SafeParseResult<PartDoneEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartDoneEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartDoneEvent' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEventType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseStreamingEventType
> = z.nativeEnum(ResponseStreamingEventType);
/** @internal */
export const ResponseStreamingEventType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseStreamingEventType
> = ResponseStreamingEventType$inboundSchema;

/** @internal */
export const DeltaKind$inboundSchema: z.ZodNativeEnum<typeof DeltaKind> = z
  .nativeEnum(DeltaKind);
/** @internal */
export const DeltaKind$outboundSchema: z.ZodNativeEnum<typeof DeltaKind> =
  DeltaKind$inboundSchema;

/** @internal */
export const ReasoningPart$inboundSchema: z.ZodType<
  ReasoningPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("reasoning_01kf0v8bq8y38ecnn9qq2y5bgn"),
  metadata: z.record(z.any()).optional(),
  kind: DeltaKind$inboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});
/** @internal */
export type ReasoningPart$Outbound = {
  _id: string;
  metadata?: { [k: string]: any } | undefined;
  kind: string;
  reasoning: string;
  signature?: string | undefined;
};

/** @internal */
export const ReasoningPart$outboundSchema: z.ZodType<
  ReasoningPart$Outbound,
  z.ZodTypeDef,
  ReasoningPart
> = z.object({
  id: z.string().default("reasoning_01kf0v8bq8y38ecnn9qq2y5bgn"),
  metadata: z.record(z.any()).optional(),
  kind: DeltaKind$outboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
  });
});

export function reasoningPartToJSON(reasoningPart: ReasoningPart): string {
  return JSON.stringify(ReasoningPart$outboundSchema.parse(reasoningPart));
}
export function reasoningPartFromJSON(
  jsonString: string,
): SafeParseResult<ReasoningPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReasoningPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReasoningPart' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEventData$inboundSchema: z.ZodType<
  ResponseStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  partId: z.string(),
  delta: z.any().optional(),
});
/** @internal */
export type ResponseStreamingEventData$Outbound = {
  partId: string;
  delta?: any | undefined;
};

/** @internal */
export const ResponseStreamingEventData$outboundSchema: z.ZodType<
  ResponseStreamingEventData$Outbound,
  z.ZodTypeDef,
  ResponseStreamingEventData
> = z.object({
  partId: z.string(),
  delta: z.any().optional(),
});

export function responseStreamingEventDataToJSON(
  responseStreamingEventData: ResponseStreamingEventData,
): string {
  return JSON.stringify(
    ResponseStreamingEventData$outboundSchema.parse(responseStreamingEventData),
  );
}
export function responseStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<ResponseStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseStreamingEventData' from JSON`,
  );
}

/** @internal */
export const PartDeltaEvent$inboundSchema: z.ZodType<
  PartDeltaEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ResponseStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => ResponseStreamingEventData$inboundSchema),
});
/** @internal */
export type PartDeltaEvent$Outbound = {
  type: string;
  timestamp: string;
  data: ResponseStreamingEventData$Outbound;
};

/** @internal */
export const PartDeltaEvent$outboundSchema: z.ZodType<
  PartDeltaEvent$Outbound,
  z.ZodTypeDef,
  PartDeltaEvent
> = z.object({
  type: ResponseStreamingEventType$outboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => ResponseStreamingEventData$outboundSchema),
});

export function partDeltaEventToJSON(partDeltaEvent: PartDeltaEvent): string {
  return JSON.stringify(PartDeltaEvent$outboundSchema.parse(partDeltaEvent));
}
export function partDeltaEventFromJSON(
  jsonString: string,
): SafeParseResult<PartDeltaEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartDeltaEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartDeltaEvent' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEvent$inboundSchema: z.ZodType<
  ResponseStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ResponseStartedEvent$inboundSchema,
  components.ResponseDoneEvent$inboundSchema,
  components.ResponseFailedEvent$inboundSchema,
  components.ToolStartedEvent$inboundSchema,
  components.ToolDoneEvent$inboundSchema,
  components.ToolFailedEvent$inboundSchema,
  components.ToolReviewRequestedEvent$inboundSchema,
  components.ToolReviewDoneEvent$inboundSchema,
  components.PartDeltaEvent$inboundSchema,
  components.PartDoneEvent$inboundSchema,
]);
/** @internal */
export type ResponseStreamingEvent$Outbound =
  | components.ResponseStartedEvent$Outbound
  | components.ResponseDoneEvent$Outbound
  | components.ResponseFailedEvent$Outbound
  | components.ToolStartedEvent$Outbound
  | components.ToolDoneEvent$Outbound
  | components.ToolFailedEvent$Outbound
  | components.ToolReviewRequestedEvent$Outbound
  | components.ToolReviewDoneEvent$Outbound
  | components.PartDeltaEvent$Outbound
  | components.PartDoneEvent$Outbound;

/** @internal */
export const ResponseStreamingEvent$outboundSchema: z.ZodType<
  ResponseStreamingEvent$Outbound,
  z.ZodTypeDef,
  ResponseStreamingEvent
> = z.union([
  components.ResponseStartedEvent$outboundSchema,
  components.ResponseDoneEvent$outboundSchema,
  components.ResponseFailedEvent$outboundSchema,
  components.ToolStartedEvent$outboundSchema,
  components.ToolDoneEvent$outboundSchema,
  components.ToolFailedEvent$outboundSchema,
  components.ToolReviewRequestedEvent$outboundSchema,
  components.ToolReviewDoneEvent$outboundSchema,
  components.PartDeltaEvent$outboundSchema,
  components.PartDoneEvent$outboundSchema,
]);

export function responseStreamingEventToJSON(
  responseStreamingEvent: ResponseStreamingEvent,
): string {
  return JSON.stringify(
    ResponseStreamingEvent$outboundSchema.parse(responseStreamingEvent),
  );
}
export function responseStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<ResponseStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseStreamingEvent' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseResponseBody$inboundSchema: z.ZodType<
  CreateConversationResponseResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().optional().transform((v, ctx) => {
    if (v === undefined) return undefined;
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.ResponseStartedEvent$inboundSchema,
      components.ResponseDoneEvent$inboundSchema,
      components.ResponseFailedEvent$inboundSchema,
      components.ToolStartedEvent$inboundSchema,
      components.ToolDoneEvent$inboundSchema,
      components.ToolFailedEvent$inboundSchema,
      components.ToolReviewRequestedEvent$inboundSchema,
      components.ToolReviewDoneEvent$inboundSchema,
      components.PartDeltaEvent$inboundSchema,
      components.PartDoneEvent$inboundSchema,
    ]).optional(),
  ),
});
/** @internal */
export type CreateConversationResponseResponseBody$Outbound = {
  data?:
    | components.ResponseStartedEvent$Outbound
    | components.ResponseDoneEvent$Outbound
    | components.ResponseFailedEvent$Outbound
    | components.ToolStartedEvent$Outbound
    | components.ToolDoneEvent$Outbound
    | components.ToolFailedEvent$Outbound
    | components.ToolReviewRequestedEvent$Outbound
    | components.ToolReviewDoneEvent$Outbound
    | components.PartDeltaEvent$Outbound
    | components.PartDoneEvent$Outbound
    | undefined;
};

/** @internal */
export const CreateConversationResponseResponseBody$outboundSchema: z.ZodType<
  CreateConversationResponseResponseBody$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseResponseBody
> = z.object({
  data: z.union([
    components.ResponseStartedEvent$outboundSchema,
    components.ResponseDoneEvent$outboundSchema,
    components.ResponseFailedEvent$outboundSchema,
    components.ToolStartedEvent$outboundSchema,
    components.ToolDoneEvent$outboundSchema,
    components.ToolFailedEvent$outboundSchema,
    components.ToolReviewRequestedEvent$outboundSchema,
    components.ToolReviewDoneEvent$outboundSchema,
    components.PartDeltaEvent$outboundSchema,
    components.PartDoneEvent$outboundSchema,
  ]).optional(),
});

export function createConversationResponseResponseBodyToJSON(
  createConversationResponseResponseBody:
    CreateConversationResponseResponseBody,
): string {
  return JSON.stringify(
    CreateConversationResponseResponseBody$outboundSchema.parse(
      createConversationResponseResponseBody,
    ),
  );
}
export function createConversationResponseResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationResponseResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationResponseResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationResponseResponseBody' from JSON`,
  );
}
