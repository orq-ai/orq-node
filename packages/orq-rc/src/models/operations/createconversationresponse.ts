/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateConversationResponseRequestBody = {
  /**
   * The user message to send to the model
   */
  message: components.UserMessageRequest;
  /**
   * The model to use for generation in format provider/model_id (e.g., openai/gpt-4o).
   */
  model: string;
  /**
   * Task ID for continuing a previous conversation turn
   */
  taskId?: string | undefined;
  /**
   * Whether to stream the response (default: true)
   */
  stream?: boolean | undefined;
};

export type CreateConversationResponseRequest = {
  /**
   * The unique identifier of the conversation
   */
  conversationId: string;
  requestBody: CreateConversationResponseRequestBody;
};

export const CreateConversationResponseResponseStreamingEventType = {
  PartDone: "part.done",
} as const;
export type CreateConversationResponseResponseStreamingEventType = ClosedEnum<
  typeof CreateConversationResponseResponseStreamingEventType
>;

/**
 * Type discriminator indicating this is a reasoning part
 */
export const PartKind = {
  Reasoning: "reasoning",
} as const;
/**
 * Type discriminator indicating this is a reasoning part
 */
export type PartKind = ClosedEnum<typeof PartKind>;

/**
 * A message part containing reasoning or chain-of-thought content
 */
export type PartReasoningPart = {
  /**
   * Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)
   */
  id: string;
  /**
   * Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Type discriminator indicating this is a reasoning part
   */
  kind: PartKind;
  /**
   * The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking.
   */
  reasoning: string;
  /**
   * Optional cryptographic signature to verify the authenticity and integrity of the reasoning content
   */
  signature?: string | undefined;
};

export type CreateConversationResponseResponseStreamingEventData = {
  /**
   * Unique identifier for this part. Matches the partId from part.delta events.
   */
  partId: string;
  part?: any | undefined;
};

/**
 * Emitted when a part has been fully streamed. Contains the complete part with all content.
 */
export type PartDoneEvent = {
  type: CreateConversationResponseResponseStreamingEventType;
  /**
   * ISO timestamp of when the event occurred
   */
  timestamp: string;
  data: CreateConversationResponseResponseStreamingEventData;
};

export const ResponseStreamingEventType = {
  PartDelta: "part.delta",
} as const;
export type ResponseStreamingEventType = ClosedEnum<
  typeof ResponseStreamingEventType
>;

/**
 * Type discriminator indicating this is a reasoning part
 */
export const DeltaKind = {
  Reasoning: "reasoning",
} as const;
/**
 * Type discriminator indicating this is a reasoning part
 */
export type DeltaKind = ClosedEnum<typeof DeltaKind>;

/**
 * A message part containing reasoning or chain-of-thought content
 */
export type ReasoningPart = {
  /**
   * Unique identifier for the part. Format: reasoning_{ulid} (e.g., reasoning_01hxyz...)
   */
  id: string;
  /**
   * Optional metadata associated with the message part. Can store arbitrary key-value pairs for custom data. Maximum size of 50KB and maximum of 20 keys.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Type discriminator indicating this is a reasoning part
   */
  kind: DeltaKind;
  /**
   * The reasoning or thought process behind the response. Used for chain-of-thought or extended thinking.
   */
  reasoning: string;
  /**
   * Optional cryptographic signature to verify the authenticity and integrity of the reasoning content
   */
  signature?: string | undefined;
};

export type ResponseStreamingEventData = {
  /**
   * Unique identifier for this part. Format: {kind}_{ulid}. Use to correlate with part.done event.
   */
  partId: string;
  delta?: any | undefined;
};

/**
 * Emitted for each content chunk streamed from the LLM. The delta field contains a discriminated union based on the kind field.
 */
export type PartDeltaEvent = {
  type: ResponseStreamingEventType;
  /**
   * ISO timestamp of when the event occurred
   */
  timestamp: string;
  data: ResponseStreamingEventData;
};

/**
 * Union of all possible streaming events. Each event has a type field for discrimination.
 */
export type ResponseStreamingEvent =
  | components.ResponseStartedEvent
  | components.ResponseDoneEvent
  | components.ResponseFailedEvent
  | components.ToolStartedEvent
  | components.ToolDoneEvent
  | components.ToolFailedEvent
  | components.ToolReviewRequestedEvent
  | components.ToolReviewDoneEvent
  | components.PartDeltaEvent
  | components.PartDoneEvent;

/**
 * Response successfully created.
 */
export type CreateConversationResponseResponseBody = {
  data?:
    | components.ResponseStartedEvent
    | components.ResponseDoneEvent
    | components.ResponseFailedEvent
    | components.ToolStartedEvent
    | components.ToolDoneEvent
    | components.ToolFailedEvent
    | components.ToolReviewRequestedEvent
    | components.ToolReviewDoneEvent
    | components.PartDeltaEvent
    | components.PartDoneEvent
    | undefined;
};

/** @internal */
export type CreateConversationResponseRequestBody$Outbound = {
  message: components.UserMessageRequest$Outbound;
  model: string;
  task_id?: string | undefined;
  stream: boolean;
};

/** @internal */
export const CreateConversationResponseRequestBody$outboundSchema: z.ZodType<
  CreateConversationResponseRequestBody$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseRequestBody
> = z.object({
  message: components.UserMessageRequest$outboundSchema,
  model: z.string(),
  taskId: z.string().optional(),
  stream: z.boolean().default(true),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function createConversationResponseRequestBodyToJSON(
  createConversationResponseRequestBody: CreateConversationResponseRequestBody,
): string {
  return JSON.stringify(
    CreateConversationResponseRequestBody$outboundSchema.parse(
      createConversationResponseRequestBody,
    ),
  );
}

/** @internal */
export type CreateConversationResponseRequest$Outbound = {
  conversation_id: string;
  RequestBody: CreateConversationResponseRequestBody$Outbound;
};

/** @internal */
export const CreateConversationResponseRequest$outboundSchema: z.ZodType<
  CreateConversationResponseRequest$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseRequest
> = z.object({
  conversationId: z.string(),
  requestBody: z.lazy(() =>
    CreateConversationResponseRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    conversationId: "conversation_id",
    requestBody: "RequestBody",
  });
});

export function createConversationResponseRequestToJSON(
  createConversationResponseRequest: CreateConversationResponseRequest,
): string {
  return JSON.stringify(
    CreateConversationResponseRequest$outboundSchema.parse(
      createConversationResponseRequest,
    ),
  );
}

/** @internal */
export const CreateConversationResponseResponseStreamingEventType$inboundSchema:
  z.ZodNativeEnum<typeof CreateConversationResponseResponseStreamingEventType> =
    z.nativeEnum(CreateConversationResponseResponseStreamingEventType);

/** @internal */
export const PartKind$inboundSchema: z.ZodNativeEnum<typeof PartKind> = z
  .nativeEnum(PartKind);

/** @internal */
export const PartReasoningPart$inboundSchema: z.ZodType<
  PartReasoningPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("reasoning_01khzwfwyrfnzs3569xmnh24wd"),
  metadata: z.record(z.any()).optional(),
  kind: PartKind$inboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});

export function partReasoningPartFromJSON(
  jsonString: string,
): SafeParseResult<PartReasoningPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartReasoningPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartReasoningPart' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseResponseStreamingEventData$inboundSchema:
  z.ZodType<
    CreateConversationResponseResponseStreamingEventData,
    z.ZodTypeDef,
    unknown
  > = z.object({
    partId: z.string(),
    part: z.any().optional(),
  });

export function createConversationResponseResponseStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateConversationResponseResponseStreamingEventData,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationResponseResponseStreamingEventData$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateConversationResponseResponseStreamingEventData' from JSON`,
  );
}

/** @internal */
export const PartDoneEvent$inboundSchema: z.ZodType<
  PartDoneEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateConversationResponseResponseStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() =>
    CreateConversationResponseResponseStreamingEventData$inboundSchema
  ),
});

export function partDoneEventFromJSON(
  jsonString: string,
): SafeParseResult<PartDoneEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartDoneEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartDoneEvent' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEventType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseStreamingEventType
> = z.nativeEnum(ResponseStreamingEventType);

/** @internal */
export const DeltaKind$inboundSchema: z.ZodNativeEnum<typeof DeltaKind> = z
  .nativeEnum(DeltaKind);

/** @internal */
export const ReasoningPart$inboundSchema: z.ZodType<
  ReasoningPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("reasoning_01khzwfwynr01adk8vnfs0z31y"),
  metadata: z.record(z.any()).optional(),
  kind: DeltaKind$inboundSchema,
  reasoning: z.string(),
  signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});

export function reasoningPartFromJSON(
  jsonString: string,
): SafeParseResult<ReasoningPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ReasoningPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ReasoningPart' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEventData$inboundSchema: z.ZodType<
  ResponseStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  partId: z.string(),
  delta: z.any().optional(),
});

export function responseStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<ResponseStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseStreamingEventData' from JSON`,
  );
}

/** @internal */
export const PartDeltaEvent$inboundSchema: z.ZodType<
  PartDeltaEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ResponseStreamingEventType$inboundSchema,
  timestamp: z.string(),
  data: z.lazy(() => ResponseStreamingEventData$inboundSchema),
});

export function partDeltaEventFromJSON(
  jsonString: string,
): SafeParseResult<PartDeltaEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartDeltaEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartDeltaEvent' from JSON`,
  );
}

/** @internal */
export const ResponseStreamingEvent$inboundSchema: z.ZodType<
  ResponseStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ResponseStartedEvent$inboundSchema,
  components.ResponseDoneEvent$inboundSchema,
  components.ResponseFailedEvent$inboundSchema,
  components.ToolStartedEvent$inboundSchema,
  components.ToolDoneEvent$inboundSchema,
  components.ToolFailedEvent$inboundSchema,
  components.ToolReviewRequestedEvent$inboundSchema,
  components.ToolReviewDoneEvent$inboundSchema,
  components.PartDeltaEvent$inboundSchema,
  components.PartDoneEvent$inboundSchema,
]);

export function responseStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<ResponseStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseStreamingEvent' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseResponseBody$inboundSchema: z.ZodType<
  CreateConversationResponseResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().optional().transform((v, ctx) => {
    if (v === undefined) return undefined;
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.ResponseStartedEvent$inboundSchema,
      components.ResponseDoneEvent$inboundSchema,
      components.ResponseFailedEvent$inboundSchema,
      components.ToolStartedEvent$inboundSchema,
      components.ToolDoneEvent$inboundSchema,
      components.ToolFailedEvent$inboundSchema,
      components.ToolReviewRequestedEvent$inboundSchema,
      components.ToolReviewDoneEvent$inboundSchema,
      components.PartDeltaEvent$inboundSchema,
      components.PartDoneEvent$inboundSchema,
    ]).optional(),
  ),
});

export function createConversationResponseResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationResponseResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationResponseResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationResponseResponseBody' from JSON`,
  );
}
