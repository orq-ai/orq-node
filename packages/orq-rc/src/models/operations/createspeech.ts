/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import * as components from "../components/index.js";

/**
 * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
 */
export const CreateSpeechResponseFormat = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
/**
 * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
 */
export type CreateSpeechResponseFormat = ClosedEnum<
  typeof CreateSpeechResponseFormat
>;

export type CreateSpeechFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateSpeechRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateSpeechLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateSpeechLoadBalancerType = ClosedEnum<
  typeof CreateSpeechLoadBalancerType
>;

export type CreateSpeechLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateSpeechLoadBalancer1 = {
  type: CreateSpeechLoadBalancerType;
  models: Array<CreateSpeechLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type CreateSpeechLoadBalancer = CreateSpeechLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateSpeechTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Retry configuration for the request
 */
export type CreateSpeechRouterAudioSpeechRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateSpeechRouterAudioSpeechFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Thread information to group related requests
 */
export type CreateSpeechThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

export const CreateSpeechLoadBalancerRouterAudioSpeechType = {
  WeightBased: "weight_based",
} as const;
export type CreateSpeechLoadBalancerRouterAudioSpeechType = ClosedEnum<
  typeof CreateSpeechLoadBalancerRouterAudioSpeechType
>;

export type CreateSpeechLoadBalancerRouterAudioSpeechModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateSpeechLoadBalancerRouterAudioSpeech1 = {
  type: CreateSpeechLoadBalancerRouterAudioSpeechType;
  models: Array<CreateSpeechLoadBalancerRouterAudioSpeechModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateSpeechRouterAudioSpeechLoadBalancer =
  CreateSpeechLoadBalancerRouterAudioSpeech1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateSpeechRouterAudioSpeechTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateSpeechOrq = {
  /**
   * Retry configuration for the request
   */
  retry?: CreateSpeechRouterAudioSpeechRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateSpeechRouterAudioSpeechFallbacks> | undefined;
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: components.PublicContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateSpeechThread | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: CreateSpeechLoadBalancerRouterAudioSpeech1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateSpeechRouterAudioSpeechTimeout | undefined;
};

/**
 * input
 */
export type CreateSpeechRequestBody = {
  /**
   * The text to generate audio for. The maximum length is 4096 characters
   */
  input: string;
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * The voice to use.
   *
   * @remarks
   *
   *  Available voices for OpenAI
   *
   *  `alloy`, `echo`, `fable`, `onyx`, `nova`, and `shimmer`
   *
   *  Available voices for ElevenLabs
   *
   *  `aria`, `roger`, `sarah`, `laura`, `charlie`, `george`, `callum`, `river`, `liam`, `charlotte`, `alice`, `matilda`, `will`, `jessica`, `eric`, `chris`, `brian`, `daniel`, `lily`, `bill`
   */
  voice: string;
  /**
   * The format to audio in. Supported formats are `mp3`, `opus`, `aac`, `flac`, `wav`, and `pcm`. If a format is provided but not supported by the provider, the response will be in the default format. When the provided format is not supported by the provider, the response will be in the default format.
   */
  responseFormat?: CreateSpeechResponseFormat | undefined;
  /**
   * The speed of the generated audio.
   */
  speed?: number | undefined;
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateSpeechFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateSpeechRetry | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: CreateSpeechLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateSpeechTimeout | undefined;
  orq?: CreateSpeechOrq | undefined;
};

/** @internal */
export const CreateSpeechResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateSpeechResponseFormat
> = z.nativeEnum(CreateSpeechResponseFormat);

/** @internal */
export type CreateSpeechFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateSpeechFallbacks$outboundSchema: z.ZodType<
  CreateSpeechFallbacks$Outbound,
  z.ZodTypeDef,
  CreateSpeechFallbacks
> = z.object({
  model: z.string(),
});

export function createSpeechFallbacksToJSON(
  createSpeechFallbacks: CreateSpeechFallbacks,
): string {
  return JSON.stringify(
    CreateSpeechFallbacks$outboundSchema.parse(createSpeechFallbacks),
  );
}

/** @internal */
export type CreateSpeechRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateSpeechRetry$outboundSchema: z.ZodType<
  CreateSpeechRetry$Outbound,
  z.ZodTypeDef,
  CreateSpeechRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createSpeechRetryToJSON(
  createSpeechRetry: CreateSpeechRetry,
): string {
  return JSON.stringify(
    CreateSpeechRetry$outboundSchema.parse(createSpeechRetry),
  );
}

/** @internal */
export const CreateSpeechLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateSpeechLoadBalancerType
> = z.nativeEnum(CreateSpeechLoadBalancerType);

/** @internal */
export type CreateSpeechLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateSpeechLoadBalancerModels$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createSpeechLoadBalancerModelsToJSON(
  createSpeechLoadBalancerModels: CreateSpeechLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancerModels$outboundSchema.parse(
      createSpeechLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateSpeechLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateSpeechLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateSpeechLoadBalancer1$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancer1
> = z.object({
  type: CreateSpeechLoadBalancerType$outboundSchema,
  models: z.array(z.lazy(() => CreateSpeechLoadBalancerModels$outboundSchema)),
});

export function createSpeechLoadBalancer1ToJSON(
  createSpeechLoadBalancer1: CreateSpeechLoadBalancer1,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancer1$outboundSchema.parse(createSpeechLoadBalancer1),
  );
}

/** @internal */
export type CreateSpeechLoadBalancer$Outbound =
  CreateSpeechLoadBalancer1$Outbound;

/** @internal */
export const CreateSpeechLoadBalancer$outboundSchema: z.ZodType<
  CreateSpeechLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateSpeechLoadBalancer
> = z.lazy(() => CreateSpeechLoadBalancer1$outboundSchema);

export function createSpeechLoadBalancerToJSON(
  createSpeechLoadBalancer: CreateSpeechLoadBalancer,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancer$outboundSchema.parse(createSpeechLoadBalancer),
  );
}

/** @internal */
export type CreateSpeechTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateSpeechTimeout$outboundSchema: z.ZodType<
  CreateSpeechTimeout$Outbound,
  z.ZodTypeDef,
  CreateSpeechTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createSpeechTimeoutToJSON(
  createSpeechTimeout: CreateSpeechTimeout,
): string {
  return JSON.stringify(
    CreateSpeechTimeout$outboundSchema.parse(createSpeechTimeout),
  );
}

/** @internal */
export type CreateSpeechRouterAudioSpeechRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateSpeechRouterAudioSpeechRetry$outboundSchema: z.ZodType<
  CreateSpeechRouterAudioSpeechRetry$Outbound,
  z.ZodTypeDef,
  CreateSpeechRouterAudioSpeechRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createSpeechRouterAudioSpeechRetryToJSON(
  createSpeechRouterAudioSpeechRetry: CreateSpeechRouterAudioSpeechRetry,
): string {
  return JSON.stringify(
    CreateSpeechRouterAudioSpeechRetry$outboundSchema.parse(
      createSpeechRouterAudioSpeechRetry,
    ),
  );
}

/** @internal */
export type CreateSpeechRouterAudioSpeechFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateSpeechRouterAudioSpeechFallbacks$outboundSchema: z.ZodType<
  CreateSpeechRouterAudioSpeechFallbacks$Outbound,
  z.ZodTypeDef,
  CreateSpeechRouterAudioSpeechFallbacks
> = z.object({
  model: z.string(),
});

export function createSpeechRouterAudioSpeechFallbacksToJSON(
  createSpeechRouterAudioSpeechFallbacks:
    CreateSpeechRouterAudioSpeechFallbacks,
): string {
  return JSON.stringify(
    CreateSpeechRouterAudioSpeechFallbacks$outboundSchema.parse(
      createSpeechRouterAudioSpeechFallbacks,
    ),
  );
}

/** @internal */
export type CreateSpeechThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateSpeechThread$outboundSchema: z.ZodType<
  CreateSpeechThread$Outbound,
  z.ZodTypeDef,
  CreateSpeechThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createSpeechThreadToJSON(
  createSpeechThread: CreateSpeechThread,
): string {
  return JSON.stringify(
    CreateSpeechThread$outboundSchema.parse(createSpeechThread),
  );
}

/** @internal */
export const CreateSpeechLoadBalancerRouterAudioSpeechType$outboundSchema:
  z.ZodNativeEnum<typeof CreateSpeechLoadBalancerRouterAudioSpeechType> = z
    .nativeEnum(CreateSpeechLoadBalancerRouterAudioSpeechType);

/** @internal */
export type CreateSpeechLoadBalancerRouterAudioSpeechModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateSpeechLoadBalancerRouterAudioSpeechModels$outboundSchema:
  z.ZodType<
    CreateSpeechLoadBalancerRouterAudioSpeechModels$Outbound,
    z.ZodTypeDef,
    CreateSpeechLoadBalancerRouterAudioSpeechModels
  > = z.object({
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function createSpeechLoadBalancerRouterAudioSpeechModelsToJSON(
  createSpeechLoadBalancerRouterAudioSpeechModels:
    CreateSpeechLoadBalancerRouterAudioSpeechModels,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancerRouterAudioSpeechModels$outboundSchema.parse(
      createSpeechLoadBalancerRouterAudioSpeechModels,
    ),
  );
}

/** @internal */
export type CreateSpeechLoadBalancerRouterAudioSpeech1$Outbound = {
  type: string;
  models: Array<CreateSpeechLoadBalancerRouterAudioSpeechModels$Outbound>;
};

/** @internal */
export const CreateSpeechLoadBalancerRouterAudioSpeech1$outboundSchema:
  z.ZodType<
    CreateSpeechLoadBalancerRouterAudioSpeech1$Outbound,
    z.ZodTypeDef,
    CreateSpeechLoadBalancerRouterAudioSpeech1
  > = z.object({
    type: CreateSpeechLoadBalancerRouterAudioSpeechType$outboundSchema,
    models: z.array(
      z.lazy(() =>
        CreateSpeechLoadBalancerRouterAudioSpeechModels$outboundSchema
      ),
    ),
  });

export function createSpeechLoadBalancerRouterAudioSpeech1ToJSON(
  createSpeechLoadBalancerRouterAudioSpeech1:
    CreateSpeechLoadBalancerRouterAudioSpeech1,
): string {
  return JSON.stringify(
    CreateSpeechLoadBalancerRouterAudioSpeech1$outboundSchema.parse(
      createSpeechLoadBalancerRouterAudioSpeech1,
    ),
  );
}

/** @internal */
export type CreateSpeechRouterAudioSpeechLoadBalancer$Outbound =
  CreateSpeechLoadBalancerRouterAudioSpeech1$Outbound;

/** @internal */
export const CreateSpeechRouterAudioSpeechLoadBalancer$outboundSchema:
  z.ZodType<
    CreateSpeechRouterAudioSpeechLoadBalancer$Outbound,
    z.ZodTypeDef,
    CreateSpeechRouterAudioSpeechLoadBalancer
  > = z.lazy(() => CreateSpeechLoadBalancerRouterAudioSpeech1$outboundSchema);

export function createSpeechRouterAudioSpeechLoadBalancerToJSON(
  createSpeechRouterAudioSpeechLoadBalancer:
    CreateSpeechRouterAudioSpeechLoadBalancer,
): string {
  return JSON.stringify(
    CreateSpeechRouterAudioSpeechLoadBalancer$outboundSchema.parse(
      createSpeechRouterAudioSpeechLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateSpeechRouterAudioSpeechTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateSpeechRouterAudioSpeechTimeout$outboundSchema: z.ZodType<
  CreateSpeechRouterAudioSpeechTimeout$Outbound,
  z.ZodTypeDef,
  CreateSpeechRouterAudioSpeechTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createSpeechRouterAudioSpeechTimeoutToJSON(
  createSpeechRouterAudioSpeechTimeout: CreateSpeechRouterAudioSpeechTimeout,
): string {
  return JSON.stringify(
    CreateSpeechRouterAudioSpeechTimeout$outboundSchema.parse(
      createSpeechRouterAudioSpeechTimeout,
    ),
  );
}

/** @internal */
export type CreateSpeechOrq$Outbound = {
  retry?: CreateSpeechRouterAudioSpeechRetry$Outbound | undefined;
  fallbacks?:
    | Array<CreateSpeechRouterAudioSpeechFallbacks$Outbound>
    | undefined;
  name?: string | undefined;
  identity?: components.PublicIdentity$Outbound | undefined;
  contact?: components.PublicContact$Outbound | undefined;
  thread?: CreateSpeechThread$Outbound | undefined;
  load_balancer?:
    | CreateSpeechLoadBalancerRouterAudioSpeech1$Outbound
    | undefined;
  timeout?: CreateSpeechRouterAudioSpeechTimeout$Outbound | undefined;
};

/** @internal */
export const CreateSpeechOrq$outboundSchema: z.ZodType<
  CreateSpeechOrq$Outbound,
  z.ZodTypeDef,
  CreateSpeechOrq
> = z.object({
  retry: z.lazy(() => CreateSpeechRouterAudioSpeechRetry$outboundSchema)
    .optional(),
  fallbacks: z.array(
    z.lazy(() => CreateSpeechRouterAudioSpeechFallbacks$outboundSchema),
  ).optional(),
  name: z.string().optional(),
  identity: components.PublicIdentity$outboundSchema.optional(),
  contact: components.PublicContact$outboundSchema.optional(),
  thread: z.lazy(() => CreateSpeechThread$outboundSchema).optional(),
  loadBalancer: z.lazy(() =>
    CreateSpeechLoadBalancerRouterAudioSpeech1$outboundSchema
  ).optional(),
  timeout: z.lazy(() => CreateSpeechRouterAudioSpeechTimeout$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createSpeechOrqToJSON(
  createSpeechOrq: CreateSpeechOrq,
): string {
  return JSON.stringify(CreateSpeechOrq$outboundSchema.parse(createSpeechOrq));
}

/** @internal */
export type CreateSpeechRequestBody$Outbound = {
  input: string;
  model: string;
  voice: string;
  response_format: string;
  speed: number;
  name?: string | undefined;
  fallbacks?: Array<CreateSpeechFallbacks$Outbound> | undefined;
  retry?: CreateSpeechRetry$Outbound | undefined;
  load_balancer?: CreateSpeechLoadBalancer1$Outbound | undefined;
  timeout?: CreateSpeechTimeout$Outbound | undefined;
  orq?: CreateSpeechOrq$Outbound | undefined;
};

/** @internal */
export const CreateSpeechRequestBody$outboundSchema: z.ZodType<
  CreateSpeechRequestBody$Outbound,
  z.ZodTypeDef,
  CreateSpeechRequestBody
> = z.object({
  input: z.string(),
  model: z.string(),
  voice: z.string(),
  responseFormat: CreateSpeechResponseFormat$outboundSchema.default("mp3"),
  speed: z.number().default(1),
  name: z.string().optional(),
  fallbacks: z.array(z.lazy(() => CreateSpeechFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => CreateSpeechRetry$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateSpeechLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateSpeechTimeout$outboundSchema).optional(),
  orq: z.lazy(() => CreateSpeechOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    responseFormat: "response_format",
    loadBalancer: "load_balancer",
  });
});

export function createSpeechRequestBodyToJSON(
  createSpeechRequestBody: CreateSpeechRequestBody,
): string {
  return JSON.stringify(
    CreateSpeechRequestBody$outboundSchema.parse(createSpeechRequestBody),
  );
}
