/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GenerateConversationNameRequestBody = {
  /**
   * The conversation context (e.g., user message or conversation summary) to generate a display name from
   */
  context: string;
};

export type GenerateConversationNameRequest = {
  /**
   * The unique identifier of the conversation to generate a name for
   */
  conversationId: string;
  requestBody: GenerateConversationNameRequestBody;
};

/**
 * Type discriminator indicating this is a conversation
 */
export const GenerateConversationNameKind = {
  Conversation: "conversation",
} as const;
/**
 * Type discriminator indicating this is a conversation
 */
export type GenerateConversationNameKind = ClosedEnum<
  typeof GenerateConversationNameKind
>;

/**
 * Optional metadata associated with the conversation.
 */
export type GenerateConversationNameMetadata = {
  /**
   * Indicates whether the conversation title is currently being generated by AI.
   */
  generatingTitle?: boolean | undefined;
  /**
   * Identifier of the parent entity (agent, deployment, etc.) this conversation belongs to. Used for filtering conversations by entity.
   */
  entityId?: string | undefined;
};

/**
 * Conversation name successfully generated and updated. Returns the complete updated conversation object.
 */
export type GenerateConversationNameResponseBody = {
  /**
   * Unique ULID (Universally Unique Lexicographically Sortable Identifier) for the conversation, prefixed with "conv_"
   */
  id?: string | undefined;
  /**
   * Identifier of the parent entity (agent, deployment, etc.) this conversation belongs to.
   */
  entityId: string;
  /**
   * Type discriminator indicating this is a conversation
   */
  kind: GenerateConversationNameKind;
  /**
   * Display name for the conversation. Can be auto-generated or set by the user.
   */
  displayName: string;
  /**
   * Unix timestamp (in milliseconds) when the conversation was created
   */
  createdAt: number;
  /**
   * Unix timestamp (in milliseconds) when the conversation was last updated
   */
  updatedAt: number;
  /**
   * Optional identifier of the user or agent that created the conversation
   */
  createdById?: string | undefined;
  /**
   * Optional identifier of the user or agent that last updated the conversation
   */
  updatedById?: string | undefined;
  /**
   * Optional metadata associated with the conversation.
   */
  metadata?: GenerateConversationNameMetadata | undefined;
};

/** @internal */
export const GenerateConversationNameRequestBody$inboundSchema: z.ZodType<
  GenerateConversationNameRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  context: z.string(),
});
/** @internal */
export type GenerateConversationNameRequestBody$Outbound = {
  context: string;
};

/** @internal */
export const GenerateConversationNameRequestBody$outboundSchema: z.ZodType<
  GenerateConversationNameRequestBody$Outbound,
  z.ZodTypeDef,
  GenerateConversationNameRequestBody
> = z.object({
  context: z.string(),
});

export function generateConversationNameRequestBodyToJSON(
  generateConversationNameRequestBody: GenerateConversationNameRequestBody,
): string {
  return JSON.stringify(
    GenerateConversationNameRequestBody$outboundSchema.parse(
      generateConversationNameRequestBody,
    ),
  );
}
export function generateConversationNameRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<GenerateConversationNameRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GenerateConversationNameRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateConversationNameRequestBody' from JSON`,
  );
}

/** @internal */
export const GenerateConversationNameRequest$inboundSchema: z.ZodType<
  GenerateConversationNameRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  conversation_id: z.string(),
  RequestBody: z.lazy(() => GenerateConversationNameRequestBody$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "conversation_id": "conversationId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type GenerateConversationNameRequest$Outbound = {
  conversation_id: string;
  RequestBody: GenerateConversationNameRequestBody$Outbound;
};

/** @internal */
export const GenerateConversationNameRequest$outboundSchema: z.ZodType<
  GenerateConversationNameRequest$Outbound,
  z.ZodTypeDef,
  GenerateConversationNameRequest
> = z.object({
  conversationId: z.string(),
  requestBody: z.lazy(() => GenerateConversationNameRequestBody$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    conversationId: "conversation_id",
    requestBody: "RequestBody",
  });
});

export function generateConversationNameRequestToJSON(
  generateConversationNameRequest: GenerateConversationNameRequest,
): string {
  return JSON.stringify(
    GenerateConversationNameRequest$outboundSchema.parse(
      generateConversationNameRequest,
    ),
  );
}
export function generateConversationNameRequestFromJSON(
  jsonString: string,
): SafeParseResult<GenerateConversationNameRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateConversationNameRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateConversationNameRequest' from JSON`,
  );
}

/** @internal */
export const GenerateConversationNameKind$inboundSchema: z.ZodNativeEnum<
  typeof GenerateConversationNameKind
> = z.nativeEnum(GenerateConversationNameKind);
/** @internal */
export const GenerateConversationNameKind$outboundSchema: z.ZodNativeEnum<
  typeof GenerateConversationNameKind
> = GenerateConversationNameKind$inboundSchema;

/** @internal */
export const GenerateConversationNameMetadata$inboundSchema: z.ZodType<
  GenerateConversationNameMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  generating_title: z.boolean().optional(),
  entity_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "generating_title": "generatingTitle",
    "entity_id": "entityId",
  });
});
/** @internal */
export type GenerateConversationNameMetadata$Outbound = {
  generating_title?: boolean | undefined;
  entity_id?: string | undefined;
};

/** @internal */
export const GenerateConversationNameMetadata$outboundSchema: z.ZodType<
  GenerateConversationNameMetadata$Outbound,
  z.ZodTypeDef,
  GenerateConversationNameMetadata
> = z.object({
  generatingTitle: z.boolean().optional(),
  entityId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    generatingTitle: "generating_title",
    entityId: "entity_id",
  });
});

export function generateConversationNameMetadataToJSON(
  generateConversationNameMetadata: GenerateConversationNameMetadata,
): string {
  return JSON.stringify(
    GenerateConversationNameMetadata$outboundSchema.parse(
      generateConversationNameMetadata,
    ),
  );
}
export function generateConversationNameMetadataFromJSON(
  jsonString: string,
): SafeParseResult<GenerateConversationNameMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GenerateConversationNameMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateConversationNameMetadata' from JSON`,
  );
}

/** @internal */
export const GenerateConversationNameResponseBody$inboundSchema: z.ZodType<
  GenerateConversationNameResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("conv_01kc3ce28pyjrqge73b610b30g"),
  entity_id: z.string(),
  kind: GenerateConversationNameKind$inboundSchema,
  display_name: z.string(),
  created_at: z.number(),
  updated_at: z.number(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  metadata: z.lazy(() => GenerateConversationNameMetadata$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "entity_id": "entityId",
    "display_name": "displayName",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
  });
});
/** @internal */
export type GenerateConversationNameResponseBody$Outbound = {
  _id: string;
  entity_id: string;
  kind: string;
  display_name: string;
  created_at: number;
  updated_at: number;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  metadata?: GenerateConversationNameMetadata$Outbound | undefined;
};

/** @internal */
export const GenerateConversationNameResponseBody$outboundSchema: z.ZodType<
  GenerateConversationNameResponseBody$Outbound,
  z.ZodTypeDef,
  GenerateConversationNameResponseBody
> = z.object({
  id: z.string().default("conv_01kc3ce28pyjrqge73b610b30g"),
  entityId: z.string(),
  kind: GenerateConversationNameKind$outboundSchema,
  displayName: z.string(),
  createdAt: z.number(),
  updatedAt: z.number(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  metadata: z.lazy(() => GenerateConversationNameMetadata$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    entityId: "entity_id",
    displayName: "display_name",
    createdAt: "created_at",
    updatedAt: "updated_at",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
  });
});

export function generateConversationNameResponseBodyToJSON(
  generateConversationNameResponseBody: GenerateConversationNameResponseBody,
): string {
  return JSON.stringify(
    GenerateConversationNameResponseBody$outboundSchema.parse(
      generateConversationNameResponseBody,
    ),
  );
}
export function generateConversationNameResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GenerateConversationNameResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GenerateConversationNameResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GenerateConversationNameResponseBody' from JSON`,
  );
}
