/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest5Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest5Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5Status
>;

/**
 * The type must be "object"
 */
export const UpdateToolRequestBodyToolsRequest5CodeToolType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolRequestBodyToolsRequest5CodeToolType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5CodeToolType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolRequestBodyToolsRequest5CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const UpdateToolRequestBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolRequestBodyLanguage = ClosedEnum<
  typeof UpdateToolRequestBodyLanguage
>;

export type UpdateToolRequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolRequestBodyToolsParameters | undefined;
  language: UpdateToolRequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Updates an existing code execution tool configuration.
 */
export type UpdateCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest5Status | undefined;
  type: "code";
  codeTool?: UpdateToolRequestBodyCodeTool | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest4Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest4Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4Status
>;

export type UpdateToolRequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const UpdateToolRequestBodyToolsRequest4McpType = {
  Object: "object",
} as const;
export type UpdateToolRequestBodyToolsRequest4McpType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4McpType
>;

export type UpdateToolRequestBodyToolsSchema = {
  type: UpdateToolRequestBodyToolsRequest4McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type RequestBodyTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: UpdateToolRequestBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const UpdateToolRequestBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type UpdateToolRequestBodyConnectionType = ClosedEnum<
  typeof UpdateToolRequestBodyConnectionType
>;

export type UpdateToolRequestBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl?: string | undefined;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: UpdateToolRequestBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools?: Array<RequestBodyTools> | undefined;
  /**
   * The connection type used by the MCP server
   */
  connectionType?: UpdateToolRequestBodyConnectionType | undefined;
};

/**
 * Updates an existing MCP tool configuration.
 */
export type UpdateMCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest4Status | undefined;
  type: "mcp";
  mcp?: UpdateToolRequestBodyMcp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequestStatus
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolRequestBodyMethod = ClosedEnum<
  typeof UpdateToolRequestBodyMethod
>;

export type UpdateToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type UpdateToolRequestBodyToolsHeaders = UpdateToolHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolRequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolRequestBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: UpdateToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type UpdateToolRequestBodyDefaultValue = string | number | boolean;

export type UpdateToolRequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolRequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolRequestBodyArguments } | undefined;
};

/**
 * Updates an existing HTTP tool configuration.
 */
export type UpdateHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequestStatus | undefined;
  type: "http";
  http?: UpdateToolRequestBodyHttp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolRequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: UpdateToolRequestBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * Updates an existing JSON Schema tool configuration.
 */
export type UpdateJSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsStatus | undefined;
  type: "json_schema";
  jsonSchema?: UpdateToolRequestBodyJsonSchema | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyStatus = ClosedEnum<
  typeof UpdateToolRequestBodyStatus
>;

/**
 * The type must be "object"
 */
export const UpdateToolRequestBodyToolsRequest1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolRequestBodyToolsRequest1Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest1Type
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolRequestBodyToolsRequest1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolRequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolRequestBodyParameters | undefined;
};

/**
 * Updates an existing function tool configuration.
 */
export type UpdateFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyStatus | undefined;
  type: "function";
  function?: UpdateToolRequestBodyFunction | undefined;
};

/**
 * The tool to update
 */
export type UpdateToolRequestBody =
  | UpdateFunctionTool
  | UpdateJSONSchemaTool
  | UpdateHTTPTool
  | UpdateMCPTool
  | UpdateCodeExecutionTool;

export type UpdateToolRequest = {
  toolId: string;
  /**
   * The tool to update
   */
  requestBody?:
    | UpdateFunctionTool
    | UpdateJSONSchemaTool
    | UpdateHTTPTool
    | UpdateMCPTool
    | UpdateCodeExecutionTool
    | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

/**
 * The type must be "object"
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson5Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const UpdateToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolResponseBodyLanguage = ClosedEnum<
  typeof UpdateToolResponseBodyLanguage
>;

export type UpdateToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolResponseBodyToolsParameters | undefined;
  language: UpdateToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type UpdateToolResponseBodyCodeExecutionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus;
  versionHash?: string | undefined;
  type: "code";
  codeTool: UpdateToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponse200Status
>;

export type UpdateToolResponseBodyHeaders = {
  value: string;
  encrypted: boolean;
};

export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type UpdateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type>;

export type UpdateToolResponseBodyToolsSchema = {
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type UpdateToolResponseBodyTools = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: UpdateToolResponseBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const UpdateToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type UpdateToolResponseBodyConnectionType = ClosedEnum<
  typeof UpdateToolResponseBodyConnectionType
>;

export type UpdateToolResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: UpdateToolResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<UpdateToolResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: UpdateToolResponseBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type UpdateToolResponseBodyMCPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateToolResponseBodyToolsResponse200Status;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: UpdateToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponseStatus
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolResponseBodyMethod = ClosedEnum<
  typeof UpdateToolResponseBodyMethod
>;

export type UpdateToolHeadersTools2 = {
  value: string;
  encrypted: boolean;
};

export type UpdateToolResponseBodyToolsHeaders =
  | UpdateToolHeadersTools2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: UpdateToolHeadersTools2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type UpdateToolResponseBodyDefaultValue = string | number | boolean;

export type UpdateToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel: boolean;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolResponseBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type UpdateToolResponseBodyHTTPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateToolResponseBodyToolsResponseStatus;
  versionHash?: string | undefined;
  type: "http";
  http: UpdateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: UpdateToolResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type UpdateToolResponseBodyJSONSchemaTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateToolResponseBodyToolsStatus;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: UpdateToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyStatus = ClosedEnum<
  typeof UpdateToolResponseBodyStatus
>;

/**
 * The type must be "object"
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson1Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolResponseBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type UpdateToolResponseBodyFunctionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateToolResponseBodyStatus;
  versionHash?: string | undefined;
  type: "function";
  function: UpdateToolResponseBodyFunction;
};

/**
 * Successfully updated the tool.
 */
export type UpdateToolResponseBody =
  | UpdateToolResponseBodyFunctionTool
  | UpdateToolResponseBodyJSONSchemaTool
  | UpdateToolResponseBodyHTTPTool
  | UpdateToolResponseBodyMCPTool
  | UpdateToolResponseBodyCodeExecutionTool;

/** @internal */
export const UpdateToolRequestBodyToolsRequest5Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest5Status);

/** @internal */
export const UpdateToolRequestBodyToolsRequest5CodeToolType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5CodeToolType> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest5CodeToolType);

/** @internal */
export type UpdateToolRequestBodyToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodyToolsParameters$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsParameters
> = z.object({
  type: UpdateToolRequestBodyToolsRequest5CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodyToolsParametersToJSON(
  updateToolRequestBodyToolsParameters: UpdateToolRequestBodyToolsParameters,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsParameters$outboundSchema.parse(
      updateToolRequestBodyToolsParameters,
    ),
  );
}

/** @internal */
export const UpdateToolRequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyLanguage
> = z.nativeEnum(UpdateToolRequestBodyLanguage);

/** @internal */
export type UpdateToolRequestBodyCodeTool$Outbound = {
  parameters?: UpdateToolRequestBodyToolsParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const UpdateToolRequestBodyCodeTool$outboundSchema: z.ZodType<
  UpdateToolRequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyCodeTool
> = z.object({
  parameters: z.lazy(() => UpdateToolRequestBodyToolsParameters$outboundSchema)
    .optional(),
  language: UpdateToolRequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function updateToolRequestBodyCodeToolToJSON(
  updateToolRequestBodyCodeTool: UpdateToolRequestBodyCodeTool,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyCodeTool$outboundSchema.parse(
      updateToolRequestBodyCodeTool,
    ),
  );
}

/** @internal */
export type UpdateCodeExecutionTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "code";
  code_tool?: UpdateToolRequestBodyCodeTool$Outbound | undefined;
};

/** @internal */
export const UpdateCodeExecutionTool$outboundSchema: z.ZodType<
  UpdateCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  UpdateCodeExecutionTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest5Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("code"),
  codeTool: z.lazy(() => UpdateToolRequestBodyCodeTool$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function updateCodeExecutionToolToJSON(
  updateCodeExecutionTool: UpdateCodeExecutionTool,
): string {
  return JSON.stringify(
    UpdateCodeExecutionTool$outboundSchema.parse(updateCodeExecutionTool),
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4Status);

/** @internal */
export type UpdateToolRequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolRequestBodyHeaders$outboundSchema: z.ZodType<
  UpdateToolRequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolRequestBodyHeadersToJSON(
  updateToolRequestBodyHeaders: UpdateToolRequestBodyHeaders,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyHeaders$outboundSchema.parse(
      updateToolRequestBodyHeaders,
    ),
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4McpType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4McpType> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4McpType);

/** @internal */
export type UpdateToolRequestBodyToolsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const UpdateToolRequestBodyToolsSchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsSchema
> = z.object({
  type: UpdateToolRequestBodyToolsRequest4McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function updateToolRequestBodyToolsSchemaToJSON(
  updateToolRequestBodyToolsSchema: UpdateToolRequestBodyToolsSchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsSchema$outboundSchema.parse(
      updateToolRequestBodyToolsSchema,
    ),
  );
}

/** @internal */
export type RequestBodyTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: UpdateToolRequestBodyToolsSchema$Outbound;
};

/** @internal */
export const RequestBodyTools$outboundSchema: z.ZodType<
  RequestBodyTools$Outbound,
  z.ZodTypeDef,
  RequestBodyTools
> = z.object({
  id: z.string().default("01KGHWGR7CYENHBY9K2K491ZG5"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolRequestBodyToolsSchema$outboundSchema),
});

export function requestBodyToolsToJSON(
  requestBodyTools: RequestBodyTools,
): string {
  return JSON.stringify(
    RequestBodyTools$outboundSchema.parse(requestBodyTools),
  );
}

/** @internal */
export const UpdateToolRequestBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyConnectionType> = z.nativeEnum(
    UpdateToolRequestBodyConnectionType,
  );

/** @internal */
export type UpdateToolRequestBodyMcp$Outbound = {
  server_url?: string | undefined;
  headers?: { [k: string]: UpdateToolRequestBodyHeaders$Outbound } | undefined;
  tools?: Array<RequestBodyTools$Outbound> | undefined;
  connection_type?: string | undefined;
};

/** @internal */
export const UpdateToolRequestBodyMcp$outboundSchema: z.ZodType<
  UpdateToolRequestBodyMcp$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyMcp
> = z.object({
  serverUrl: z.string().optional(),
  headers: z.record(z.lazy(() => UpdateToolRequestBodyHeaders$outboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => RequestBodyTools$outboundSchema)).optional(),
  connectionType: UpdateToolRequestBodyConnectionType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function updateToolRequestBodyMcpToJSON(
  updateToolRequestBodyMcp: UpdateToolRequestBodyMcp,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyMcp$outboundSchema.parse(updateToolRequestBodyMcp),
  );
}

/** @internal */
export type UpdateMCPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "mcp";
  mcp?: UpdateToolRequestBodyMcp$Outbound | undefined;
};

/** @internal */
export const UpdateMCPTool$outboundSchema: z.ZodType<
  UpdateMCPTool$Outbound,
  z.ZodTypeDef,
  UpdateMCPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest4Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolRequestBodyMcp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateMCPToolToJSON(updateMCPTool: UpdateMCPTool): string {
  return JSON.stringify(UpdateMCPTool$outboundSchema.parse(updateMCPTool));
}

/** @internal */
export const UpdateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequestStatus);

/** @internal */
export const UpdateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyMethod
> = z.nativeEnum(UpdateToolRequestBodyMethod);

/** @internal */
export type UpdateToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolHeaders2$outboundSchema: z.ZodType<
  UpdateToolHeaders2$Outbound,
  z.ZodTypeDef,
  UpdateToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolHeaders2ToJSON(
  updateToolHeaders2: UpdateToolHeaders2,
): string {
  return JSON.stringify(
    UpdateToolHeaders2$outboundSchema.parse(updateToolHeaders2),
  );
}

/** @internal */
export type UpdateToolRequestBodyToolsHeaders$Outbound =
  | UpdateToolHeaders2$Outbound
  | string;

/** @internal */
export const UpdateToolRequestBodyToolsHeaders$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsHeaders
> = z.union([z.lazy(() => UpdateToolHeaders2$outboundSchema), z.string()]);

export function updateToolRequestBodyToolsHeadersToJSON(
  updateToolRequestBodyToolsHeaders: UpdateToolRequestBodyToolsHeaders,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsHeaders$outboundSchema.parse(
      updateToolRequestBodyToolsHeaders,
    ),
  );
}

/** @internal */
export type UpdateToolRequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: UpdateToolHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolRequestBodyBlueprint$outboundSchema: z.ZodType<
  UpdateToolRequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: UpdateToolRequestBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolRequestBodyBlueprintToJSON(
  updateToolRequestBodyBlueprint: UpdateToolRequestBodyBlueprint,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyBlueprint$outboundSchema.parse(
      updateToolRequestBodyBlueprint,
    ),
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest3Type,
  );

/** @internal */
export type UpdateToolRequestBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateToolRequestBodyDefaultValue$outboundSchema: z.ZodType<
  UpdateToolRequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolRequestBodyDefaultValueToJSON(
  updateToolRequestBodyDefaultValue: UpdateToolRequestBodyDefaultValue,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyDefaultValue$outboundSchema.parse(
      updateToolRequestBodyDefaultValue,
    ),
  );
}

/** @internal */
export type UpdateToolRequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyArguments$outboundSchema: z.ZodType<
  UpdateToolRequestBodyArguments$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyArguments
> = z.object({
  type: UpdateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function updateToolRequestBodyArgumentsToJSON(
  updateToolRequestBodyArguments: UpdateToolRequestBodyArguments,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyArguments$outboundSchema.parse(
      updateToolRequestBodyArguments,
    ),
  );
}

/** @internal */
export type UpdateToolRequestBodyHttp$Outbound = {
  blueprint: UpdateToolRequestBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: UpdateToolRequestBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const UpdateToolRequestBodyHttp$outboundSchema: z.ZodType<
  UpdateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => UpdateToolRequestBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolRequestBodyArguments$outboundSchema),
  ).optional(),
});

export function updateToolRequestBodyHttpToJSON(
  updateToolRequestBodyHttp: UpdateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyHttp$outboundSchema.parse(updateToolRequestBodyHttp),
  );
}

/** @internal */
export type UpdateHTTPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "http";
  http?: UpdateToolRequestBodyHttp$Outbound | undefined;
};

/** @internal */
export const UpdateHTTPTool$outboundSchema: z.ZodType<
  UpdateHTTPTool$Outbound,
  z.ZodTypeDef,
  UpdateHTTPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolRequestBodyHttp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateHTTPToolToJSON(updateHTTPTool: UpdateHTTPTool): string {
  return JSON.stringify(UpdateHTTPTool$outboundSchema.parse(updateHTTPTool));
}

/** @internal */
export const UpdateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsStatus
> = z.nativeEnum(UpdateToolRequestBodyToolsStatus);

/** @internal */
export type UpdateToolRequestBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodySchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodySchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodySchemaToJSON(
  updateToolRequestBodySchema: UpdateToolRequestBodySchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodySchema$outboundSchema.parse(
      updateToolRequestBodySchema,
    ),
  );
}

/** @internal */
export type UpdateToolRequestBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: UpdateToolRequestBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyJsonSchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolRequestBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function updateToolRequestBodyJsonSchemaToJSON(
  updateToolRequestBodyJsonSchema: UpdateToolRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyJsonSchema$outboundSchema.parse(
      updateToolRequestBodyJsonSchema,
    ),
  );
}

/** @internal */
export type UpdateJSONSchemaTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "json_schema";
  json_schema?: UpdateToolRequestBodyJsonSchema$Outbound | undefined;
};

/** @internal */
export const UpdateJSONSchemaTool$outboundSchema: z.ZodType<
  UpdateJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  UpdateJSONSchemaTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => UpdateToolRequestBodyJsonSchema$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function updateJSONSchemaToolToJSON(
  updateJSONSchemaTool: UpdateJSONSchemaTool,
): string {
  return JSON.stringify(
    UpdateJSONSchemaTool$outboundSchema.parse(updateJSONSchemaTool),
  );
}

/** @internal */
export const UpdateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyStatus
> = z.nativeEnum(UpdateToolRequestBodyStatus);

/** @internal */
export const UpdateToolRequestBodyToolsRequest1Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest1Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest1Type,
  );

/** @internal */
export type UpdateToolRequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodyParameters$outboundSchema: z.ZodType<
  UpdateToolRequestBodyParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyParameters
> = z.object({
  type: UpdateToolRequestBodyToolsRequest1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodyParametersToJSON(
  updateToolRequestBodyParameters: UpdateToolRequestBodyParameters,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyParameters$outboundSchema.parse(
      updateToolRequestBodyParameters,
    ),
  );
}

/** @internal */
export type UpdateToolRequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: UpdateToolRequestBodyParameters$Outbound | undefined;
};

/** @internal */
export const UpdateToolRequestBodyFunction$outboundSchema: z.ZodType<
  UpdateToolRequestBodyFunction$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolRequestBodyParameters$outboundSchema)
    .optional(),
});

export function updateToolRequestBodyFunctionToJSON(
  updateToolRequestBodyFunction: UpdateToolRequestBodyFunction,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyFunction$outboundSchema.parse(
      updateToolRequestBodyFunction,
    ),
  );
}

/** @internal */
export type UpdateFunctionTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "function";
  function?: UpdateToolRequestBodyFunction$Outbound | undefined;
};

/** @internal */
export const UpdateFunctionTool$outboundSchema: z.ZodType<
  UpdateFunctionTool$Outbound,
  z.ZodTypeDef,
  UpdateFunctionTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolRequestBodyFunction$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateFunctionToolToJSON(
  updateFunctionTool: UpdateFunctionTool,
): string {
  return JSON.stringify(
    UpdateFunctionTool$outboundSchema.parse(updateFunctionTool),
  );
}

/** @internal */
export type UpdateToolRequestBody$Outbound =
  | UpdateFunctionTool$Outbound
  | UpdateJSONSchemaTool$Outbound
  | UpdateHTTPTool$Outbound
  | UpdateMCPTool$Outbound
  | UpdateCodeExecutionTool$Outbound;

/** @internal */
export const UpdateToolRequestBody$outboundSchema: z.ZodType<
  UpdateToolRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBody
> = z.union([
  z.lazy(() => UpdateFunctionTool$outboundSchema),
  z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
  z.lazy(() => UpdateHTTPTool$outboundSchema),
  z.lazy(() => UpdateMCPTool$outboundSchema),
  z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
]);

export function updateToolRequestBodyToJSON(
  updateToolRequestBody: UpdateToolRequestBody,
): string {
  return JSON.stringify(
    UpdateToolRequestBody$outboundSchema.parse(updateToolRequestBody),
  );
}

/** @internal */
export type UpdateToolRequest$Outbound = {
  tool_id: string;
  RequestBody?:
    | UpdateFunctionTool$Outbound
    | UpdateJSONSchemaTool$Outbound
    | UpdateHTTPTool$Outbound
    | UpdateMCPTool$Outbound
    | UpdateCodeExecutionTool$Outbound
    | undefined;
};

/** @internal */
export const UpdateToolRequest$outboundSchema: z.ZodType<
  UpdateToolRequest$Outbound,
  z.ZodTypeDef,
  UpdateToolRequest
> = z.object({
  toolId: z.string(),
  requestBody: z.union([
    z.lazy(() => UpdateFunctionTool$outboundSchema),
    z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
    z.lazy(() => UpdateHTTPTool$outboundSchema),
    z.lazy(() => UpdateMCPTool$outboundSchema),
    z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requestBody: "RequestBody",
  });
});

export function updateToolRequestToJSON(
  updateToolRequest: UpdateToolRequest,
): string {
  return JSON.stringify(
    UpdateToolRequest$outboundSchema.parse(updateToolRequest),
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus);

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson5Type);

/** @internal */
export const UpdateToolResponseBodyToolsParameters$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function updateToolResponseBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyToolsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyLanguage
> = z.nativeEnum(UpdateToolResponseBodyLanguage);

/** @internal */
export const UpdateToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => UpdateToolResponseBodyToolsParameters$inboundSchema)
    .optional(),
  language: UpdateToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});

export function updateToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyCodeExecutionTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KGHWGR76FKTAT019JF6CKNBA"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => UpdateToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

export function updateToolResponseBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateToolResponseBodyCodeExecutionTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyCodeExecutionTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateToolResponseBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponse200Status);

/** @internal */
export const UpdateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson4Type);

/** @internal */
export const UpdateToolResponseBodyToolsSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function updateToolResponseBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyTools$inboundSchema: z.ZodType<
  UpdateToolResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KGHWGR75BGDAKQ94ZVYQ3HBD"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolResponseBodyToolsSchema$inboundSchema),
});

export function updateToolResponseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyConnectionType> = z.nativeEnum(
    UpdateToolResponseBodyConnectionType,
  );

/** @internal */
export const UpdateToolResponseBodyMcp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => UpdateToolResponseBodyHeaders$inboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => UpdateToolResponseBodyTools$inboundSchema)),
  connection_type: UpdateToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});

export function updateToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyMCPTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KGHWGR741S2E9461WECPBS3P"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function updateToolResponseBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponseStatus);

/** @internal */
export const UpdateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyMethod
> = z.nativeEnum(UpdateToolResponseBodyMethod);

/** @internal */
export const UpdateToolHeadersTools2$inboundSchema: z.ZodType<
  UpdateToolHeadersTools2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolHeadersTools2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolHeadersTools2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolHeadersTools2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolHeadersTools2' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsHeaders$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => UpdateToolHeadersTools2$inboundSchema), z.string()]);

export function updateToolResponseBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  UpdateToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: UpdateToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeadersTools2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson3Type);

/** @internal */
export const UpdateToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  UpdateToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyArguments$inboundSchema: z.ZodType<
  UpdateToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

export function updateToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyHttp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => UpdateToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolResponseBodyArguments$inboundSchema),
  ).optional(),
});

export function updateToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyHTTPTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KGHWGR72SFDZV361NXRXGE1X"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function updateToolResponseBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsStatus
> = z.nativeEnum(UpdateToolResponseBodyToolsStatus);

/** @internal */
export const UpdateToolResponseBodySchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function updateToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});

export function updateToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyJSONSchemaTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KGHWGR718D74CST2VSX67QM0"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => UpdateToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

export function updateToolResponseBodyJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyStatus
> = z.nativeEnum(UpdateToolResponseBodyStatus);

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson1Type);

/** @internal */
export const UpdateToolResponseBodyParameters$inboundSchema: z.ZodType<
  UpdateToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function updateToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyFunction$inboundSchema: z.ZodType<
  UpdateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolResponseBodyParameters$inboundSchema)
    .optional(),
});

export function updateToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyFunctionTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KGHWGR70FXB07KYAJBA1XJD1"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function updateToolResponseBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody$inboundSchema: z.ZodType<
  UpdateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateToolResponseBodyFunctionTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyJSONSchemaTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyHTTPTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyMCPTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyCodeExecutionTool$inboundSchema),
]);

export function updateToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody' from JSON`,
  );
}
