/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest5Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest5Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5Status
>;

/**
 * The type must be "object"
 */
export const UpdateToolRequestBodyToolsRequest5CodeToolType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolRequestBodyToolsRequest5CodeToolType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest5CodeToolType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolRequestBodyToolsRequest5CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const UpdateToolRequestBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolRequestBodyLanguage = ClosedEnum<
  typeof UpdateToolRequestBodyLanguage
>;

export type UpdateToolRequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolRequestBodyToolsParameters | undefined;
  language: UpdateToolRequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Updates an existing code execution tool configuration.
 */
export type UpdateCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest5Status | undefined;
  type: "code";
  codeTool?: UpdateToolRequestBodyCodeTool | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequest4Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequest4Status = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4Status
>;

export type UpdateToolRequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const UpdateToolRequestBodyToolsRequest4McpType = {
  Object: "object",
} as const;
export type UpdateToolRequestBodyToolsRequest4McpType = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest4McpType
>;

export type UpdateToolRequestBodyToolsSchema = {
  type: UpdateToolRequestBodyToolsRequest4McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type RequestBodyTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: UpdateToolRequestBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const UpdateToolRequestBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type UpdateToolRequestBodyConnectionType = ClosedEnum<
  typeof UpdateToolRequestBodyConnectionType
>;

export type UpdateToolRequestBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl?: string | undefined;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: UpdateToolRequestBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools?: Array<RequestBodyTools> | undefined;
  /**
   * The connection type used by the MCP server
   */
  connectionType?: UpdateToolRequestBodyConnectionType | undefined;
};

/**
 * Updates an existing MCP tool configuration.
 */
export type UpdateMCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequest4Status | undefined;
  type: "mcp";
  mcp?: UpdateToolRequestBodyMcp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequestStatus
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolRequestBodyMethod = ClosedEnum<
  typeof UpdateToolRequestBodyMethod
>;

export type UpdateToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type UpdateToolRequestBodyToolsHeaders = UpdateToolHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolRequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolRequestBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: UpdateToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type UpdateToolRequestBodyDefaultValue = string | number | boolean;

export type UpdateToolRequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolRequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolRequestBodyArguments } | undefined;
};

/**
 * Updates an existing HTTP tool configuration.
 */
export type UpdateHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsRequestStatus | undefined;
  type: "http";
  http?: UpdateToolRequestBodyHttp | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyToolsStatus = ClosedEnum<
  typeof UpdateToolRequestBodyToolsStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolRequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: UpdateToolRequestBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * Updates an existing JSON Schema tool configuration.
 */
export type UpdateJSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyToolsStatus | undefined;
  type: "json_schema";
  jsonSchema?: UpdateToolRequestBodyJsonSchema | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolRequestBodyStatus = ClosedEnum<
  typeof UpdateToolRequestBodyStatus
>;

/**
 * The type must be "object"
 */
export const UpdateToolRequestBodyToolsRequest1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolRequestBodyToolsRequest1Type = ClosedEnum<
  typeof UpdateToolRequestBodyToolsRequest1Type
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolRequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolRequestBodyToolsRequest1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolRequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolRequestBodyParameters | undefined;
};

/**
 * Updates an existing function tool configuration.
 */
export type UpdateFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key?: string | undefined;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description?: string | undefined;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolRequestBodyStatus | undefined;
  type: "function";
  function?: UpdateToolRequestBodyFunction | undefined;
};

/**
 * The tool to update
 */
export type UpdateToolRequestBody =
  | UpdateFunctionTool
  | UpdateJSONSchemaTool
  | UpdateHTTPTool
  | UpdateMCPTool
  | UpdateCodeExecutionTool;

export type UpdateToolRequest = {
  toolId: string;
  /**
   * The tool to update
   */
  requestBody?:
    | UpdateFunctionTool
    | UpdateJSONSchemaTool
    | UpdateHTTPTool
    | UpdateMCPTool
    | UpdateCodeExecutionTool
    | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

/**
 * The type must be "object"
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson5Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const UpdateToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type UpdateToolResponseBodyLanguage = ClosedEnum<
  typeof UpdateToolResponseBodyLanguage
>;

export type UpdateToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolResponseBodyToolsParameters | undefined;
  language: UpdateToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type UpdateToolResponseBodyCodeExecutionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?:
    | UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
    | undefined;
  versionHash?: string | undefined;
  type: "code";
  codeTool: UpdateToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponse200Status
>;

export type UpdateToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type UpdateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type>;

export type UpdateToolResponseBodyToolsSchema = {
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type UpdateToolResponseBodyTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: UpdateToolResponseBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const UpdateToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type UpdateToolResponseBodyConnectionType = ClosedEnum<
  typeof UpdateToolResponseBodyConnectionType
>;

export type UpdateToolResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: UpdateToolResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<UpdateToolResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: UpdateToolResponseBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type UpdateToolResponseBodyMCPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: UpdateToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsResponseStatus
>;

/**
 * The HTTP method to use.
 */
export const UpdateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type UpdateToolResponseBodyMethod = ClosedEnum<
  typeof UpdateToolResponseBodyMethod
>;

export type UpdateToolHeadersTools2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type UpdateToolResponseBodyToolsHeaders =
  | UpdateToolHeadersTools2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type UpdateToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: UpdateToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: UpdateToolHeadersTools2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type UpdateToolResponseBodyDefaultValue = string | number | boolean;

export type UpdateToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type UpdateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: UpdateToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: UpdateToolResponseBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type UpdateToolResponseBodyHTTPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: "http";
  http: UpdateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyToolsStatus = ClosedEnum<
  typeof UpdateToolResponseBodyToolsStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: UpdateToolResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type UpdateToolResponseBodyJSONSchemaTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: UpdateToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateToolResponseBodyStatus = ClosedEnum<
  typeof UpdateToolResponseBodyStatus
>;

/**
 * The type must be "object"
 */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type UpdateToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<typeof UpdateToolResponseBodyToolsResponse200ApplicationJson1Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type UpdateToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: UpdateToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type UpdateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: UpdateToolResponseBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type UpdateToolResponseBodyFunctionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: UpdateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: "function";
  function: UpdateToolResponseBodyFunction;
};

/**
 * Successfully updated the tool.
 */
export type UpdateToolResponseBody =
  | UpdateToolResponseBodyFunctionTool
  | UpdateToolResponseBodyJSONSchemaTool
  | UpdateToolResponseBodyHTTPTool
  | UpdateToolResponseBodyMCPTool
  | UpdateToolResponseBodyCodeExecutionTool;

/** @internal */
export const UpdateToolRequestBodyToolsRequest5Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest5Status);
/** @internal */
export const UpdateToolRequestBodyToolsRequest5Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5Status> =
    UpdateToolRequestBodyToolsRequest5Status$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsRequest5CodeToolType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5CodeToolType> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest5CodeToolType);
/** @internal */
export const UpdateToolRequestBodyToolsRequest5CodeToolType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest5CodeToolType> =
    UpdateToolRequestBodyToolsRequest5CodeToolType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsParameters$inboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: UpdateToolRequestBodyToolsRequest5CodeToolType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolRequestBodyToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodyToolsParameters$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsParameters
> = z.object({
  type: UpdateToolRequestBodyToolsRequest5CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodyToolsParametersToJSON(
  updateToolRequestBodyToolsParameters: UpdateToolRequestBodyToolsParameters,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsParameters$outboundSchema.parse(
      updateToolRequestBodyToolsParameters,
    ),
  );
}
export function updateToolRequestBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyToolsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolRequestBodyToolsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyLanguage
> = z.nativeEnum(UpdateToolRequestBodyLanguage);
/** @internal */
export const UpdateToolRequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyLanguage
> = UpdateToolRequestBodyLanguage$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyCodeTool$inboundSchema: z.ZodType<
  UpdateToolRequestBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => UpdateToolRequestBodyToolsParameters$inboundSchema)
    .optional(),
  language: UpdateToolRequestBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type UpdateToolRequestBodyCodeTool$Outbound = {
  parameters?: UpdateToolRequestBodyToolsParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const UpdateToolRequestBodyCodeTool$outboundSchema: z.ZodType<
  UpdateToolRequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyCodeTool
> = z.object({
  parameters: z.lazy(() => UpdateToolRequestBodyToolsParameters$outboundSchema)
    .optional(),
  language: UpdateToolRequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function updateToolRequestBodyCodeToolToJSON(
  updateToolRequestBodyCodeTool: UpdateToolRequestBodyCodeTool,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyCodeTool$outboundSchema.parse(
      updateToolRequestBodyCodeTool,
    ),
  );
}
export function updateToolRequestBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const UpdateCodeExecutionTool$inboundSchema: z.ZodType<
  UpdateCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest5Status$inboundSchema.default(
    "live",
  ),
  type: z.literal("code"),
  code_tool: z.lazy(() => UpdateToolRequestBodyCodeTool$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type UpdateCodeExecutionTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "code";
  code_tool?: UpdateToolRequestBodyCodeTool$Outbound | undefined;
};

/** @internal */
export const UpdateCodeExecutionTool$outboundSchema: z.ZodType<
  UpdateCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  UpdateCodeExecutionTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest5Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("code"),
  codeTool: z.lazy(() => UpdateToolRequestBodyCodeTool$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function updateCodeExecutionToolToJSON(
  updateCodeExecutionTool: UpdateCodeExecutionTool,
): string {
  return JSON.stringify(
    UpdateCodeExecutionTool$outboundSchema.parse(updateCodeExecutionTool),
  );
}
export function updateCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Status> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4Status);
/** @internal */
export const UpdateToolRequestBodyToolsRequest4Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4Status> =
    UpdateToolRequestBodyToolsRequest4Status$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyHeaders$inboundSchema: z.ZodType<
  UpdateToolRequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type UpdateToolRequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolRequestBodyHeaders$outboundSchema: z.ZodType<
  UpdateToolRequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolRequestBodyHeadersToJSON(
  updateToolRequestBodyHeaders: UpdateToolRequestBodyHeaders,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyHeaders$outboundSchema.parse(
      updateToolRequestBodyHeaders,
    ),
  );
}
export function updateToolRequestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest4McpType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4McpType> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequest4McpType);
/** @internal */
export const UpdateToolRequestBodyToolsRequest4McpType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest4McpType> =
    UpdateToolRequestBodyToolsRequest4McpType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsSchema$inboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateToolRequestBodyToolsRequest4McpType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type UpdateToolRequestBodyToolsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const UpdateToolRequestBodyToolsSchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsSchema
> = z.object({
  type: UpdateToolRequestBodyToolsRequest4McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function updateToolRequestBodyToolsSchemaToJSON(
  updateToolRequestBodyToolsSchema: UpdateToolRequestBodyToolsSchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsSchema$outboundSchema.parse(
      updateToolRequestBodyToolsSchema,
    ),
  );
}
export function updateToolRequestBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const RequestBodyTools$inboundSchema: z.ZodType<
  RequestBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KF392YFFMCCSNEAMWVW33W8B"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolRequestBodyToolsSchema$inboundSchema),
});
/** @internal */
export type RequestBodyTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: UpdateToolRequestBodyToolsSchema$Outbound;
};

/** @internal */
export const RequestBodyTools$outboundSchema: z.ZodType<
  RequestBodyTools$Outbound,
  z.ZodTypeDef,
  RequestBodyTools
> = z.object({
  id: z.string().default("01KF392YFFMCCSNEAMWVW33W8B"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolRequestBodyToolsSchema$outboundSchema),
});

export function requestBodyToolsToJSON(
  requestBodyTools: RequestBodyTools,
): string {
  return JSON.stringify(
    RequestBodyTools$outboundSchema.parse(requestBodyTools),
  );
}
export function requestBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyTools' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyConnectionType
> = z.nativeEnum(UpdateToolRequestBodyConnectionType);
/** @internal */
export const UpdateToolRequestBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyConnectionType> =
    UpdateToolRequestBodyConnectionType$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyMcp$inboundSchema: z.ZodType<
  UpdateToolRequestBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string().optional(),
  headers: z.record(z.lazy(() => UpdateToolRequestBodyHeaders$inboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => RequestBodyTools$inboundSchema)).optional(),
  connection_type: UpdateToolRequestBodyConnectionType$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type UpdateToolRequestBodyMcp$Outbound = {
  server_url?: string | undefined;
  headers?: { [k: string]: UpdateToolRequestBodyHeaders$Outbound } | undefined;
  tools?: Array<RequestBodyTools$Outbound> | undefined;
  connection_type?: string | undefined;
};

/** @internal */
export const UpdateToolRequestBodyMcp$outboundSchema: z.ZodType<
  UpdateToolRequestBodyMcp$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyMcp
> = z.object({
  serverUrl: z.string().optional(),
  headers: z.record(z.lazy(() => UpdateToolRequestBodyHeaders$outboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => RequestBodyTools$outboundSchema)).optional(),
  connectionType: UpdateToolRequestBodyConnectionType$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function updateToolRequestBodyMcpToJSON(
  updateToolRequestBodyMcp: UpdateToolRequestBodyMcp,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyMcp$outboundSchema.parse(updateToolRequestBodyMcp),
  );
}
export function updateToolRequestBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyMcp' from JSON`,
  );
}

/** @internal */
export const UpdateMCPTool$inboundSchema: z.ZodType<
  UpdateMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest4Status$inboundSchema.default(
    "live",
  ),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolRequestBodyMcp$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateMCPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "mcp";
  mcp?: UpdateToolRequestBodyMcp$Outbound | undefined;
};

/** @internal */
export const UpdateMCPTool$outboundSchema: z.ZodType<
  UpdateMCPTool$Outbound,
  z.ZodTypeDef,
  UpdateMCPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequest4Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolRequestBodyMcp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateMCPToolToJSON(updateMCPTool: UpdateMCPTool): string {
  return JSON.stringify(UpdateMCPTool$outboundSchema.parse(updateMCPTool));
}
export function updateMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMCPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequestStatus$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(UpdateToolRequestBodyToolsRequestStatus);
/** @internal */
export const UpdateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequestStatus> =
    UpdateToolRequestBodyToolsRequestStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyMethod
> = z.nativeEnum(UpdateToolRequestBodyMethod);
/** @internal */
export const UpdateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyMethod
> = UpdateToolRequestBodyMethod$inboundSchema;

/** @internal */
export const UpdateToolHeaders2$inboundSchema: z.ZodType<
  UpdateToolHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type UpdateToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolHeaders2$outboundSchema: z.ZodType<
  UpdateToolHeaders2$Outbound,
  z.ZodTypeDef,
  UpdateToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolHeaders2ToJSON(
  updateToolHeaders2: UpdateToolHeaders2,
): string {
  return JSON.stringify(
    UpdateToolHeaders2$outboundSchema.parse(updateToolHeaders2),
  );
}
export function updateToolHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolHeaders2' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsHeaders$inboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => UpdateToolHeaders2$inboundSchema), z.string()]);
/** @internal */
export type UpdateToolRequestBodyToolsHeaders$Outbound =
  | UpdateToolHeaders2$Outbound
  | string;

/** @internal */
export const UpdateToolRequestBodyToolsHeaders$outboundSchema: z.ZodType<
  UpdateToolRequestBodyToolsHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyToolsHeaders
> = z.union([z.lazy(() => UpdateToolHeaders2$outboundSchema), z.string()]);

export function updateToolRequestBodyToolsHeadersToJSON(
  updateToolRequestBodyToolsHeaders: UpdateToolRequestBodyToolsHeaders,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyToolsHeaders$outboundSchema.parse(
      updateToolRequestBodyToolsHeaders,
    ),
  );
}
export function updateToolRequestBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyBlueprint$inboundSchema: z.ZodType<
  UpdateToolRequestBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: UpdateToolRequestBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolRequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: UpdateToolHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolRequestBodyBlueprint$outboundSchema: z.ZodType<
  UpdateToolRequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: UpdateToolRequestBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolRequestBodyBlueprintToJSON(
  updateToolRequestBodyBlueprint: UpdateToolRequestBodyBlueprint,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyBlueprint$outboundSchema.parse(
      updateToolRequestBodyBlueprint,
    ),
  );
}
export function updateToolRequestBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsRequest3Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest3Type,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest3Type> =
    UpdateToolRequestBodyToolsRequest3Type$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyDefaultValue$inboundSchema: z.ZodType<
  UpdateToolRequestBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateToolRequestBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateToolRequestBodyDefaultValue$outboundSchema: z.ZodType<
  UpdateToolRequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolRequestBodyDefaultValueToJSON(
  updateToolRequestBodyDefaultValue: UpdateToolRequestBodyDefaultValue,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyDefaultValue$outboundSchema.parse(
      updateToolRequestBodyDefaultValue,
    ),
  );
}
export function updateToolRequestBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyArguments$inboundSchema: z.ZodType<
  UpdateToolRequestBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateToolRequestBodyToolsRequest3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type UpdateToolRequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyArguments$outboundSchema: z.ZodType<
  UpdateToolRequestBodyArguments$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyArguments
> = z.object({
  type: UpdateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function updateToolRequestBodyArgumentsToJSON(
  updateToolRequestBodyArguments: UpdateToolRequestBodyArguments,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyArguments$outboundSchema.parse(
      updateToolRequestBodyArguments,
    ),
  );
}
export function updateToolRequestBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyArguments' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyHttp$inboundSchema: z.ZodType<
  UpdateToolRequestBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => UpdateToolRequestBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolRequestBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateToolRequestBodyHttp$Outbound = {
  blueprint: UpdateToolRequestBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: UpdateToolRequestBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const UpdateToolRequestBodyHttp$outboundSchema: z.ZodType<
  UpdateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => UpdateToolRequestBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolRequestBodyArguments$outboundSchema),
  ).optional(),
});

export function updateToolRequestBodyHttpToJSON(
  updateToolRequestBodyHttp: UpdateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyHttp$outboundSchema.parse(updateToolRequestBodyHttp),
  );
}
export function updateToolRequestBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyHttp' from JSON`,
  );
}

/** @internal */
export const UpdateHTTPTool$inboundSchema: z.ZodType<
  UpdateHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequestStatus$inboundSchema.default("live"),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolRequestBodyHttp$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateHTTPTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "http";
  http?: UpdateToolRequestBodyHttp$Outbound | undefined;
};

/** @internal */
export const UpdateHTTPTool$outboundSchema: z.ZodType<
  UpdateHTTPTool$Outbound,
  z.ZodTypeDef,
  UpdateHTTPTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolRequestBodyHttp$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateHTTPToolToJSON(updateHTTPTool: UpdateHTTPTool): string {
  return JSON.stringify(UpdateHTTPTool$outboundSchema.parse(updateHTTPTool));
}
export function updateHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateHTTPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsStatus
> = z.nativeEnum(UpdateToolRequestBodyToolsStatus);
/** @internal */
export const UpdateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyToolsStatus
> = UpdateToolRequestBodyToolsStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodySchema$inboundSchema: z.ZodType<
  UpdateToolRequestBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolRequestBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodySchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodySchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodySchemaToJSON(
  updateToolRequestBodySchema: UpdateToolRequestBodySchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodySchema$outboundSchema.parse(
      updateToolRequestBodySchema,
    ),
  );
}
export function updateToolRequestBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodySchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyJsonSchema$inboundSchema: z.ZodType<
  UpdateToolRequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolRequestBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type UpdateToolRequestBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: UpdateToolRequestBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const UpdateToolRequestBodyJsonSchema$outboundSchema: z.ZodType<
  UpdateToolRequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolRequestBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function updateToolRequestBodyJsonSchemaToJSON(
  updateToolRequestBodyJsonSchema: UpdateToolRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyJsonSchema$outboundSchema.parse(
      updateToolRequestBodyJsonSchema,
    ),
  );
}
export function updateToolRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateJSONSchemaTool$inboundSchema: z.ZodType<
  UpdateJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsStatus$inboundSchema.default("live"),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => UpdateToolRequestBodyJsonSchema$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type UpdateJSONSchemaTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "json_schema";
  json_schema?: UpdateToolRequestBodyJsonSchema$Outbound | undefined;
};

/** @internal */
export const UpdateJSONSchemaTool$outboundSchema: z.ZodType<
  UpdateJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  UpdateJSONSchemaTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => UpdateToolRequestBodyJsonSchema$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function updateJSONSchemaToolToJSON(
  updateJSONSchemaTool: UpdateJSONSchemaTool,
): string {
  return JSON.stringify(
    UpdateJSONSchemaTool$outboundSchema.parse(updateJSONSchemaTool),
  );
}
export function updateJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyStatus
> = z.nativeEnum(UpdateToolRequestBodyStatus);
/** @internal */
export const UpdateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolRequestBodyStatus
> = UpdateToolRequestBodyStatus$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyToolsRequest1Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest1Type> = z.nativeEnum(
    UpdateToolRequestBodyToolsRequest1Type,
  );
/** @internal */
export const UpdateToolRequestBodyToolsRequest1Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolRequestBodyToolsRequest1Type> =
    UpdateToolRequestBodyToolsRequest1Type$inboundSchema;

/** @internal */
export const UpdateToolRequestBodyParameters$inboundSchema: z.ZodType<
  UpdateToolRequestBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: UpdateToolRequestBodyToolsRequest1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolRequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolRequestBodyParameters$outboundSchema: z.ZodType<
  UpdateToolRequestBodyParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyParameters
> = z.object({
  type: UpdateToolRequestBodyToolsRequest1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolRequestBodyParametersToJSON(
  updateToolRequestBodyParameters: UpdateToolRequestBodyParameters,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyParameters$outboundSchema.parse(
      updateToolRequestBodyParameters,
    ),
  );
}
export function updateToolRequestBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBodyFunction$inboundSchema: z.ZodType<
  UpdateToolRequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolRequestBodyParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type UpdateToolRequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: UpdateToolRequestBodyParameters$Outbound | undefined;
};

/** @internal */
export const UpdateToolRequestBodyFunction$outboundSchema: z.ZodType<
  UpdateToolRequestBodyFunction$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolRequestBodyParameters$outboundSchema)
    .optional(),
});

export function updateToolRequestBodyFunctionToJSON(
  updateToolRequestBodyFunction: UpdateToolRequestBodyFunction,
): string {
  return JSON.stringify(
    UpdateToolRequestBodyFunction$outboundSchema.parse(
      updateToolRequestBodyFunction,
    ),
  );
}
export function updateToolRequestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const UpdateFunctionTool$inboundSchema: z.ZodType<
  UpdateFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyStatus$inboundSchema.default("live"),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolRequestBodyFunction$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type UpdateFunctionTool$Outbound = {
  path?: string | undefined;
  key?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  status: string;
  type: "function";
  function?: UpdateToolRequestBodyFunction$Outbound | undefined;
};

/** @internal */
export const UpdateFunctionTool$outboundSchema: z.ZodType<
  UpdateFunctionTool$Outbound,
  z.ZodTypeDef,
  UpdateFunctionTool
> = z.object({
  path: z.string().optional(),
  key: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  status: UpdateToolRequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolRequestBodyFunction$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function updateFunctionToolToJSON(
  updateFunctionTool: UpdateFunctionTool,
): string {
  return JSON.stringify(
    UpdateFunctionTool$outboundSchema.parse(updateFunctionTool),
  );
}
export function updateFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateFunctionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequestBody$inboundSchema: z.ZodType<
  UpdateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateFunctionTool$inboundSchema),
  z.lazy(() => UpdateJSONSchemaTool$inboundSchema),
  z.lazy(() => UpdateHTTPTool$inboundSchema),
  z.lazy(() => UpdateMCPTool$inboundSchema),
  z.lazy(() => UpdateCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type UpdateToolRequestBody$Outbound =
  | UpdateFunctionTool$Outbound
  | UpdateJSONSchemaTool$Outbound
  | UpdateHTTPTool$Outbound
  | UpdateMCPTool$Outbound
  | UpdateCodeExecutionTool$Outbound;

/** @internal */
export const UpdateToolRequestBody$outboundSchema: z.ZodType<
  UpdateToolRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateToolRequestBody
> = z.union([
  z.lazy(() => UpdateFunctionTool$outboundSchema),
  z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
  z.lazy(() => UpdateHTTPTool$outboundSchema),
  z.lazy(() => UpdateMCPTool$outboundSchema),
  z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
]);

export function updateToolRequestBodyToJSON(
  updateToolRequestBody: UpdateToolRequestBody,
): string {
  return JSON.stringify(
    UpdateToolRequestBody$outboundSchema.parse(updateToolRequestBody),
  );
}
export function updateToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateToolRequest$inboundSchema: z.ZodType<
  UpdateToolRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tool_id: z.string(),
  RequestBody: z.union([
    z.lazy(() => UpdateFunctionTool$inboundSchema),
    z.lazy(() => UpdateJSONSchemaTool$inboundSchema),
    z.lazy(() => UpdateHTTPTool$inboundSchema),
    z.lazy(() => UpdateMCPTool$inboundSchema),
    z.lazy(() => UpdateCodeExecutionTool$inboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateToolRequest$Outbound = {
  tool_id: string;
  RequestBody?:
    | UpdateFunctionTool$Outbound
    | UpdateJSONSchemaTool$Outbound
    | UpdateHTTPTool$Outbound
    | UpdateMCPTool$Outbound
    | UpdateCodeExecutionTool$Outbound
    | undefined;
};

/** @internal */
export const UpdateToolRequest$outboundSchema: z.ZodType<
  UpdateToolRequest$Outbound,
  z.ZodTypeDef,
  UpdateToolRequest
> = z.object({
  toolId: z.string(),
  requestBody: z.union([
    z.lazy(() => UpdateFunctionTool$outboundSchema),
    z.lazy(() => UpdateJSONSchemaTool$outboundSchema),
    z.lazy(() => UpdateHTTPTool$outboundSchema),
    z.lazy(() => UpdateMCPTool$outboundSchema),
    z.lazy(() => UpdateCodeExecutionTool$outboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requestBody: "RequestBody",
  });
});

export function updateToolRequestToJSON(
  updateToolRequest: UpdateToolRequest,
): string {
  return JSON.stringify(
    UpdateToolRequest$outboundSchema.parse(updateToolRequest),
  );
}
export function updateToolRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolRequest' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson5Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsParameters$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolResponseBodyToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolResponseBodyToolsParameters$outboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyToolsParameters
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolResponseBodyToolsParametersToJSON(
  updateToolResponseBodyToolsParameters: UpdateToolResponseBodyToolsParameters,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyToolsParameters$outboundSchema.parse(
      updateToolResponseBodyToolsParameters,
    ),
  );
}
export function updateToolResponseBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyToolsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyLanguage
> = z.nativeEnum(UpdateToolResponseBodyLanguage);
/** @internal */
export const UpdateToolResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyLanguage
> = UpdateToolResponseBodyLanguage$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => UpdateToolResponseBodyToolsParameters$inboundSchema)
    .optional(),
  language: UpdateToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type UpdateToolResponseBodyCodeTool$Outbound = {
  parameters?: UpdateToolResponseBodyToolsParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const UpdateToolResponseBodyCodeTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyCodeTool
> = z.object({
  parameters: z.lazy(() => UpdateToolResponseBodyToolsParameters$outboundSchema)
    .optional(),
  language: UpdateToolResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function updateToolResponseBodyCodeToolToJSON(
  updateToolResponseBodyCodeTool: UpdateToolResponseBodyCodeTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyCodeTool$outboundSchema.parse(
      updateToolResponseBodyCodeTool,
    ),
  );
}
export function updateToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyCodeExecutionTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KF392YF877S9DGRETG12C6WC"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => UpdateToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type UpdateToolResponseBodyCodeExecutionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "code";
  code_tool: UpdateToolResponseBodyCodeTool$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyCodeExecutionTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyCodeExecutionTool
> = z.object({
  id: z.string().default("tool_01KF392YF877S9DGRETG12C6WC"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    UpdateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema
      .default("live"),
  versionHash: z.string().optional(),
  type: z.literal("code"),
  codeTool: z.lazy(() => UpdateToolResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function updateToolResponseBodyCodeExecutionToolToJSON(
  updateToolResponseBodyCodeExecutionTool:
    UpdateToolResponseBodyCodeExecutionTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyCodeExecutionTool$outboundSchema.parse(
      updateToolResponseBodyCodeExecutionTool,
    ),
  );
}
export function updateToolResponseBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateToolResponseBodyCodeExecutionTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyCodeExecutionTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateToolResponseBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponse200Status);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponse200Status> =
    UpdateToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type UpdateToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  UpdateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolResponseBodyHeadersToJSON(
  updateToolResponseBodyHeaders: UpdateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyHeaders$outboundSchema.parse(
      updateToolResponseBodyHeaders,
    ),
  );
}
export function updateToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson4Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type UpdateToolResponseBodyToolsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const UpdateToolResponseBodyToolsSchema$outboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyToolsSchema
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function updateToolResponseBodyToolsSchemaToJSON(
  updateToolResponseBodyToolsSchema: UpdateToolResponseBodyToolsSchema,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyToolsSchema$outboundSchema.parse(
      updateToolResponseBodyToolsSchema,
    ),
  );
}
export function updateToolResponseBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyTools$inboundSchema: z.ZodType<
  UpdateToolResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KF392YF7M8Q9T4KPMSZZEKJW"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolResponseBodyToolsSchema$inboundSchema),
});
/** @internal */
export type UpdateToolResponseBodyTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: UpdateToolResponseBodyToolsSchema$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyTools$outboundSchema: z.ZodType<
  UpdateToolResponseBodyTools$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyTools
> = z.object({
  id: z.string().default("01KF392YF7M8Q9T4KPMSZZEKJW"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => UpdateToolResponseBodyToolsSchema$outboundSchema),
});

export function updateToolResponseBodyToolsToJSON(
  updateToolResponseBodyTools: UpdateToolResponseBodyTools,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyTools$outboundSchema.parse(
      updateToolResponseBodyTools,
    ),
  );
}
export function updateToolResponseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyConnectionType> = z.nativeEnum(
    UpdateToolResponseBodyConnectionType,
  );
/** @internal */
export const UpdateToolResponseBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyConnectionType> =
    UpdateToolResponseBodyConnectionType$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyMcp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => UpdateToolResponseBodyHeaders$inboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => UpdateToolResponseBodyTools$inboundSchema)),
  connection_type: UpdateToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type UpdateToolResponseBodyMcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: UpdateToolResponseBodyHeaders$Outbound } | undefined;
  tools: Array<UpdateToolResponseBodyTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const UpdateToolResponseBodyMcp$outboundSchema: z.ZodType<
  UpdateToolResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => UpdateToolResponseBodyHeaders$outboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => UpdateToolResponseBodyTools$outboundSchema)),
  connectionType: UpdateToolResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function updateToolResponseBodyMcpToJSON(
  updateToolResponseBodyMcp: UpdateToolResponseBodyMcp,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyMcp$outboundSchema.parse(updateToolResponseBodyMcp),
  );
}
export function updateToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyMCPTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KF392YF5ZVGMJD1VWB1MXEV2"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBodyMCPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "mcp";
  mcp: UpdateToolResponseBodyMcp$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyMCPTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyMCPTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyMCPTool
> = z.object({
  id: z.string().default("tool_01KF392YF5ZVGMJD1VWB1MXEV2"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => UpdateToolResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBodyMCPToolToJSON(
  updateToolResponseBodyMCPTool: UpdateToolResponseBodyMCPTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyMCPTool$outboundSchema.parse(
      updateToolResponseBodyMCPTool,
    ),
  );
}
export function updateToolResponseBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(UpdateToolResponseBodyToolsResponseStatus);
/** @internal */
export const UpdateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof UpdateToolResponseBodyToolsResponseStatus> =
    UpdateToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyMethod
> = z.nativeEnum(UpdateToolResponseBodyMethod);
/** @internal */
export const UpdateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyMethod
> = UpdateToolResponseBodyMethod$inboundSchema;

/** @internal */
export const UpdateToolHeadersTools2$inboundSchema: z.ZodType<
  UpdateToolHeadersTools2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type UpdateToolHeadersTools2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const UpdateToolHeadersTools2$outboundSchema: z.ZodType<
  UpdateToolHeadersTools2$Outbound,
  z.ZodTypeDef,
  UpdateToolHeadersTools2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function updateToolHeadersTools2ToJSON(
  updateToolHeadersTools2: UpdateToolHeadersTools2,
): string {
  return JSON.stringify(
    UpdateToolHeadersTools2$outboundSchema.parse(updateToolHeadersTools2),
  );
}
export function updateToolHeadersTools2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolHeadersTools2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolHeadersTools2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolHeadersTools2' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsHeaders$inboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => UpdateToolHeadersTools2$inboundSchema), z.string()]);
/** @internal */
export type UpdateToolResponseBodyToolsHeaders$Outbound =
  | UpdateToolHeadersTools2$Outbound
  | string;

/** @internal */
export const UpdateToolResponseBodyToolsHeaders$outboundSchema: z.ZodType<
  UpdateToolResponseBodyToolsHeaders$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyToolsHeaders
> = z.union([z.lazy(() => UpdateToolHeadersTools2$outboundSchema), z.string()]);

export function updateToolResponseBodyToolsHeadersToJSON(
  updateToolResponseBodyToolsHeaders: UpdateToolResponseBodyToolsHeaders,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyToolsHeaders$outboundSchema.parse(
      updateToolResponseBodyToolsHeaders,
    ),
  );
}
export function updateToolResponseBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  UpdateToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: UpdateToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeadersTools2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type UpdateToolResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: UpdateToolHeadersTools2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateToolResponseBodyBlueprint$outboundSchema: z.ZodType<
  UpdateToolResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: UpdateToolResponseBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => UpdateToolHeadersTools2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function updateToolResponseBodyBlueprintToJSON(
  updateToolResponseBodyBlueprint: UpdateToolResponseBodyBlueprint,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyBlueprint$outboundSchema.parse(
      updateToolResponseBodyBlueprint,
    ),
  );
}
export function updateToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson3Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  UpdateToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type UpdateToolResponseBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const UpdateToolResponseBodyDefaultValue$outboundSchema: z.ZodType<
  UpdateToolResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function updateToolResponseBodyDefaultValueToJSON(
  updateToolResponseBodyDefaultValue: UpdateToolResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyDefaultValue$outboundSchema.parse(
      updateToolResponseBodyDefaultValue,
    ),
  );
}
export function updateToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyArguments$inboundSchema: z.ZodType<
  UpdateToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type UpdateToolResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const UpdateToolResponseBodyArguments$outboundSchema: z.ZodType<
  UpdateToolResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyArguments
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function updateToolResponseBodyArgumentsToJSON(
  updateToolResponseBodyArguments: UpdateToolResponseBodyArguments,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyArguments$outboundSchema.parse(
      updateToolResponseBodyArguments,
    ),
  );
}
export function updateToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyHttp$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => UpdateToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolResponseBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type UpdateToolResponseBodyHttp$Outbound = {
  blueprint: UpdateToolResponseBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: UpdateToolResponseBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const UpdateToolResponseBodyHttp$outboundSchema: z.ZodType<
  UpdateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => UpdateToolResponseBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => UpdateToolResponseBodyArguments$outboundSchema),
  ).optional(),
});

export function updateToolResponseBodyHttpToJSON(
  updateToolResponseBodyHttp: UpdateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyHttp$outboundSchema.parse(updateToolResponseBodyHttp),
  );
}
export function updateToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyHTTPTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KF392YF2HZ9843SHE091JW44"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBodyHTTPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "http";
  http: UpdateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyHTTPTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyHTTPTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyHTTPTool
> = z.object({
  id: z.string().default("tool_01KF392YF2HZ9843SHE091JW44"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => UpdateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBodyHTTPToolToJSON(
  updateToolResponseBodyHTTPTool: UpdateToolResponseBodyHTTPTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyHTTPTool$outboundSchema.parse(
      updateToolResponseBodyHTTPTool,
    ),
  );
}
export function updateToolResponseBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsStatus
> = z.nativeEnum(UpdateToolResponseBodyToolsStatus);
/** @internal */
export const UpdateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyToolsStatus
> = UpdateToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodySchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolResponseBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolResponseBodySchema$outboundSchema: z.ZodType<
  UpdateToolResponseBodySchema$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolResponseBodySchemaToJSON(
  updateToolResponseBodySchema: UpdateToolResponseBodySchema,
): string {
  return JSON.stringify(
    UpdateToolResponseBodySchema$outboundSchema.parse(
      updateToolResponseBodySchema,
    ),
  );
}
export function updateToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  UpdateToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type UpdateToolResponseBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: UpdateToolResponseBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const UpdateToolResponseBodyJsonSchema$outboundSchema: z.ZodType<
  UpdateToolResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => UpdateToolResponseBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function updateToolResponseBodyJsonSchemaToJSON(
  updateToolResponseBodyJsonSchema: UpdateToolResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyJsonSchema$outboundSchema.parse(
      updateToolResponseBodyJsonSchema,
    ),
  );
}
export function updateToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyJSONSchemaTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KF392YF02XM4ECMFVT2XJTS3"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => UpdateToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type UpdateToolResponseBodyJSONSchemaTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "json_schema";
  json_schema: UpdateToolResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyJSONSchemaTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyJSONSchemaTool
> = z.object({
  id: z.string().default("tool_01KF392YF02XM4ECMFVT2XJTS3"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => UpdateToolResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function updateToolResponseBodyJSONSchemaToolToJSON(
  updateToolResponseBodyJSONSchemaTool: UpdateToolResponseBodyJSONSchemaTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyJSONSchemaTool$outboundSchema.parse(
      updateToolResponseBodyJSONSchemaTool,
    ),
  );
}
export function updateToolResponseBodyJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyStatus
> = z.nativeEnum(UpdateToolResponseBodyStatus);
/** @internal */
export const UpdateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateToolResponseBodyStatus
> = UpdateToolResponseBodyStatus$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(UpdateToolResponseBodyToolsResponse200ApplicationJson1Type);
/** @internal */
export const UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema;

/** @internal */
export const UpdateToolResponseBodyParameters$inboundSchema: z.ZodType<
  UpdateToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type UpdateToolResponseBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const UpdateToolResponseBodyParameters$outboundSchema: z.ZodType<
  UpdateToolResponseBodyParameters$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyParameters
> = z.object({
  type:
    UpdateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function updateToolResponseBodyParametersToJSON(
  updateToolResponseBodyParameters: UpdateToolResponseBodyParameters,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyParameters$outboundSchema.parse(
      updateToolResponseBodyParameters,
    ),
  );
}
export function updateToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyFunction$inboundSchema: z.ZodType<
  UpdateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolResponseBodyParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type UpdateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: UpdateToolResponseBodyParameters$Outbound | undefined;
};

/** @internal */
export const UpdateToolResponseBodyFunction$outboundSchema: z.ZodType<
  UpdateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => UpdateToolResponseBodyParameters$outboundSchema)
    .optional(),
});

export function updateToolResponseBodyFunctionToJSON(
  updateToolResponseBodyFunction: UpdateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyFunction$outboundSchema.parse(
      updateToolResponseBodyFunction,
    ),
  );
}
export function updateToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBodyFunctionTool$inboundSchema: z.ZodType<
  UpdateToolResponseBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KF392YEXNAMMZVZW8PWF0DSC"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type UpdateToolResponseBodyFunctionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "function";
  function: UpdateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const UpdateToolResponseBodyFunctionTool$outboundSchema: z.ZodType<
  UpdateToolResponseBodyFunctionTool$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBodyFunctionTool
> = z.object({
  id: z.string().default("tool_01KF392YEXNAMMZVZW8PWF0DSC"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: UpdateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => UpdateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function updateToolResponseBodyFunctionToolToJSON(
  updateToolResponseBodyFunctionTool: UpdateToolResponseBodyFunctionTool,
): string {
  return JSON.stringify(
    UpdateToolResponseBodyFunctionTool$outboundSchema.parse(
      updateToolResponseBodyFunctionTool,
    ),
  );
}
export function updateToolResponseBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateToolResponseBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const UpdateToolResponseBody$inboundSchema: z.ZodType<
  UpdateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateToolResponseBodyFunctionTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyJSONSchemaTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyHTTPTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyMCPTool$inboundSchema),
  z.lazy(() => UpdateToolResponseBodyCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type UpdateToolResponseBody$Outbound =
  | UpdateToolResponseBodyFunctionTool$Outbound
  | UpdateToolResponseBodyJSONSchemaTool$Outbound
  | UpdateToolResponseBodyHTTPTool$Outbound
  | UpdateToolResponseBodyMCPTool$Outbound
  | UpdateToolResponseBodyCodeExecutionTool$Outbound;

/** @internal */
export const UpdateToolResponseBody$outboundSchema: z.ZodType<
  UpdateToolResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateToolResponseBody
> = z.union([
  z.lazy(() => UpdateToolResponseBodyFunctionTool$outboundSchema),
  z.lazy(() => UpdateToolResponseBodyJSONSchemaTool$outboundSchema),
  z.lazy(() => UpdateToolResponseBodyHTTPTool$outboundSchema),
  z.lazy(() => UpdateToolResponseBodyMCPTool$outboundSchema),
  z.lazy(() => UpdateToolResponseBodyCodeExecutionTool$outboundSchema),
]);

export function updateToolResponseBodyToJSON(
  updateToolResponseBody: UpdateToolResponseBody,
): string {
  return JSON.stringify(
    UpdateToolResponseBody$outboundSchema.parse(updateToolResponseBody),
  );
}
export function updateToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateToolResponseBody' from JSON`,
  );
}
