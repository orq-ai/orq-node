/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const RequestBodyRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type RequestBodyRetrievalType = ClosedEnum<
  typeof RequestBodyRetrievalType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeRequestBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeRequestBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeRequestBodyRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: RequestBodyRetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: UpdateKnowledgeRequestBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeRequestBodyAgenticRagConfig
    | null
    | undefined;
};

export const UpdateKnowledgeRequestBodyKnowledgeType = {
  Internal: "internal",
} as const;
export type UpdateKnowledgeRequestBodyKnowledgeType = ClosedEnum<
  typeof UpdateKnowledgeRequestBodyKnowledgeType
>;

export type UpdateKnowledgeRequestBody2 = {
  /**
   * The description of the knowledge base.
   */
  description?: string | null | undefined;
  /**
   * The embeddings model used for the knowledge base. If the models is provided and is different than the previous set model, all the datasources in the knowledge base will be re-embedded.
   */
  embeddingModel?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: UpdateKnowledgeRequestBodyRetrievalSettings | undefined;
  type?: UpdateKnowledgeRequestBodyKnowledgeType | undefined;
};

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type RequestBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type RequestBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type RequestBodyRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: RequestBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: RequestBodyAgenticRagConfig | null | undefined;
};

/**
 * Configuration for the external knowledge base.
 */
export type RequestBodyExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name?: string | undefined;
  /**
   * The API URL for the external knowledge base.
   */
  apiUrl?: string | undefined;
  /**
   * The API key for the external knowledge base.
   */
  apiKey?: string | undefined;
};

export const UpdateKnowledgeRequestBodyType = {
  External: "external",
} as const;
export type UpdateKnowledgeRequestBodyType = ClosedEnum<
  typeof UpdateKnowledgeRequestBodyType
>;

export type UpdateKnowledgeRequestBody1 = {
  /**
   * The description of the knowledge base.
   */
  description?: string | null | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?: RequestBodyRetrievalSettings | undefined;
  /**
   * Configuration for the external knowledge base.
   */
  externalConfig?: RequestBodyExternalConfig | undefined;
  type?: UpdateKnowledgeRequestBodyType | undefined;
};

export type UpdateKnowledgeRequestBody =
  | UpdateKnowledgeRequestBody1
  | UpdateKnowledgeRequestBody2;

export type UpdateKnowledgeRequest = {
  /**
   * The unique identifier of the knowledge base
   */
  knowledgeId: string;
  requestBody: UpdateKnowledgeRequestBody1 | UpdateKnowledgeRequestBody2;
};

export const UpdateKnowledgeResponseBodyKnowledgeType = {
  External: "external",
} as const;
export type UpdateKnowledgeResponseBodyKnowledgeType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyKnowledgeType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeResponseBodyKnowledgeRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?:
    | UpdateKnowledgeResponseBodyKnowledgeRerankConfig
    | null
    | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig
    | null
    | undefined;
};

export type UpdateKnowledgeResponseBodyExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
};

export type UpdateKnowledgeResponseBody2 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: UpdateKnowledgeResponseBodyKnowledgeType | undefined;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?:
    | UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings
    | undefined;
  externalConfig: UpdateKnowledgeResponseBodyExternalConfig;
};

export const UpdateKnowledgeResponseBodyType = {
  Internal: "internal",
} as const;
export type UpdateKnowledgeResponseBodyType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const UpdateKnowledgeResponseBodyRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeResponseBodyRetrievalType = ClosedEnum<
  typeof UpdateKnowledgeResponseBodyRetrievalType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type UpdateKnowledgeResponseBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type UpdateKnowledgeResponseBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type UpdateKnowledgeResponseBodyRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: UpdateKnowledgeResponseBodyRetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: UpdateKnowledgeResponseBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | UpdateKnowledgeResponseBodyAgenticRagConfig
    | null
    | undefined;
};

export type UpdateKnowledgeResponseBody1 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: UpdateKnowledgeResponseBodyType | undefined;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: UpdateKnowledgeResponseBodyRetrievalSettings | undefined;
  /**
   * The embeddings model used for the knowledge base.
   */
  model: string;
};

/**
 * Knowledge successfully updated
 */
export type UpdateKnowledgeResponseBody =
  | UpdateKnowledgeResponseBody1
  | UpdateKnowledgeResponseBody2;

/** @internal */
export const RequestBodyRetrievalType$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyRetrievalType
> = z.nativeEnum(RequestBodyRetrievalType);
/** @internal */
export const RequestBodyRetrievalType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyRetrievalType
> = RequestBodyRetrievalType$inboundSchema;

/** @internal */
export const UpdateKnowledgeRequestBodyRerankConfig$inboundSchema: z.ZodType<
  UpdateKnowledgeRequestBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type UpdateKnowledgeRequestBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const UpdateKnowledgeRequestBodyRerankConfig$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function updateKnowledgeRequestBodyRerankConfigToJSON(
  updateKnowledgeRequestBodyRerankConfig:
    UpdateKnowledgeRequestBodyRerankConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyRerankConfig$outboundSchema.parse(
      updateKnowledgeRequestBodyRerankConfig,
    ),
  );
}
export function updateKnowledgeRequestBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeRequestBodyRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeRequestBodyRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeRequestBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyAgenticRagConfig$inboundSchema:
  z.ZodType<UpdateKnowledgeRequestBodyAgenticRagConfig, z.ZodTypeDef, unknown> =
    z.object({
      model: z.string(),
    });
/** @internal */
export type UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeRequestBodyAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeRequestBodyAgenticRagConfigToJSON(
  updateKnowledgeRequestBodyAgenticRagConfig:
    UpdateKnowledgeRequestBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema.parse(
      updateKnowledgeRequestBodyAgenticRagConfig,
    ),
  );
}
export function updateKnowledgeRequestBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeRequestBodyAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeRequestBodyAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeRequestBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyRetrievalSettings$inboundSchema:
  z.ZodType<
    UpdateKnowledgeRequestBodyRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    retrieval_type: RequestBodyRetrievalType$inboundSchema.default(
      "hybrid_search",
    ),
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyRerankConfig$inboundSchema),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyAgenticRagConfig$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "retrieval_type": "retrievalType",
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });
/** @internal */
export type UpdateKnowledgeRequestBodyRetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?:
    | UpdateKnowledgeRequestBodyRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | UpdateKnowledgeRequestBodyAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema:
  z.ZodType<
    UpdateKnowledgeRequestBodyRetrievalSettings$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeRequestBodyRetrievalSettings
  > = z.object({
    retrievalType: RequestBodyRetrievalType$outboundSchema.default(
      "hybrid_search",
    ),
    topK: z.number().int().default(5),
    threshold: z.number().default(0),
    rerankConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyRerankConfig$outboundSchema),
    ).optional(),
    agenticRagConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeRequestBodyAgenticRagConfig$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      retrievalType: "retrieval_type",
      topK: "top_k",
      rerankConfig: "rerank_config",
      agenticRagConfig: "agentic_rag_config",
    });
  });

export function updateKnowledgeRequestBodyRetrievalSettingsToJSON(
  updateKnowledgeRequestBodyRetrievalSettings:
    UpdateKnowledgeRequestBodyRetrievalSettings,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema.parse(
      updateKnowledgeRequestBodyRetrievalSettings,
    ),
  );
}
export function updateKnowledgeRequestBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeRequestBodyRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeRequestBodyRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeRequestBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyKnowledgeType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeRequestBodyKnowledgeType> = z
    .nativeEnum(UpdateKnowledgeRequestBodyKnowledgeType);
/** @internal */
export const UpdateKnowledgeRequestBodyKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeRequestBodyKnowledgeType> =
    UpdateKnowledgeRequestBodyKnowledgeType$inboundSchema;

/** @internal */
export const UpdateKnowledgeRequestBody2$inboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.nullable(z.string()).optional(),
  embedding_model: z.string().optional(),
  path: z.string().optional(),
  retrieval_settings: z.lazy(() =>
    UpdateKnowledgeRequestBodyRetrievalSettings$inboundSchema
  ).optional(),
  type: UpdateKnowledgeRequestBodyKnowledgeType$inboundSchema.default(
    "internal",
  ),
}).transform((v) => {
  return remap$(v, {
    "embedding_model": "embeddingModel",
    "retrieval_settings": "retrievalSettings",
  });
});
/** @internal */
export type UpdateKnowledgeRequestBody2$Outbound = {
  description?: string | null | undefined;
  embedding_model?: string | undefined;
  path?: string | undefined;
  retrieval_settings?:
    | UpdateKnowledgeRequestBodyRetrievalSettings$Outbound
    | undefined;
  type: string;
};

/** @internal */
export const UpdateKnowledgeRequestBody2$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody2$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody2
> = z.object({
  description: z.nullable(z.string()).optional(),
  embeddingModel: z.string().optional(),
  path: z.string().optional(),
  retrievalSettings: z.lazy(() =>
    UpdateKnowledgeRequestBodyRetrievalSettings$outboundSchema
  ).optional(),
  type: UpdateKnowledgeRequestBodyKnowledgeType$outboundSchema.default(
    "internal",
  ),
}).transform((v) => {
  return remap$(v, {
    embeddingModel: "embedding_model",
    retrievalSettings: "retrieval_settings",
  });
});

export function updateKnowledgeRequestBody2ToJSON(
  updateKnowledgeRequestBody2: UpdateKnowledgeRequestBody2,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody2$outboundSchema.parse(
      updateKnowledgeRequestBody2,
    ),
  );
}
export function updateKnowledgeRequestBody2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeRequestBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeRequestBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeRequestBody2' from JSON`,
  );
}

/** @internal */
export const RequestBodyRerankConfig$inboundSchema: z.ZodType<
  RequestBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type RequestBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const RequestBodyRerankConfig$outboundSchema: z.ZodType<
  RequestBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function requestBodyRerankConfigToJSON(
  requestBodyRerankConfig: RequestBodyRerankConfig,
): string {
  return JSON.stringify(
    RequestBodyRerankConfig$outboundSchema.parse(requestBodyRerankConfig),
  );
}
export function requestBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const RequestBodyAgenticRagConfig$inboundSchema: z.ZodType<
  RequestBodyAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type RequestBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const RequestBodyAgenticRagConfig$outboundSchema: z.ZodType<
  RequestBodyAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function requestBodyAgenticRagConfigToJSON(
  requestBodyAgenticRagConfig: RequestBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    RequestBodyAgenticRagConfig$outboundSchema.parse(
      requestBodyAgenticRagConfig,
    ),
  );
}
export function requestBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const RequestBodyRetrievalSettings$inboundSchema: z.ZodType<
  RequestBodyRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(z.lazy(() => RequestBodyRerankConfig$inboundSchema))
    .optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => RequestBodyAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});
/** @internal */
export type RequestBodyRetrievalSettings$Outbound = {
  top_k: number;
  threshold: number;
  rerank_config?: RequestBodyRerankConfig$Outbound | null | undefined;
  agentic_rag_config?: RequestBodyAgenticRagConfig$Outbound | null | undefined;
};

/** @internal */
export const RequestBodyRetrievalSettings$outboundSchema: z.ZodType<
  RequestBodyRetrievalSettings$Outbound,
  z.ZodTypeDef,
  RequestBodyRetrievalSettings
> = z.object({
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(z.lazy(() => RequestBodyRerankConfig$outboundSchema))
    .optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => RequestBodyAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function requestBodyRetrievalSettingsToJSON(
  requestBodyRetrievalSettings: RequestBodyRetrievalSettings,
): string {
  return JSON.stringify(
    RequestBodyRetrievalSettings$outboundSchema.parse(
      requestBodyRetrievalSettings,
    ),
  );
}
export function requestBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyRetrievalSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyRetrievalSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const RequestBodyExternalConfig$inboundSchema: z.ZodType<
  RequestBodyExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  api_url: z.string().optional(),
  api_key: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
    "api_key": "apiKey",
  });
});
/** @internal */
export type RequestBodyExternalConfig$Outbound = {
  name?: string | undefined;
  api_url?: string | undefined;
  api_key?: string | undefined;
};

/** @internal */
export const RequestBodyExternalConfig$outboundSchema: z.ZodType<
  RequestBodyExternalConfig$Outbound,
  z.ZodTypeDef,
  RequestBodyExternalConfig
> = z.object({
  name: z.string().optional(),
  apiUrl: z.string().optional(),
  apiKey: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    apiUrl: "api_url",
    apiKey: "api_key",
  });
});

export function requestBodyExternalConfigToJSON(
  requestBodyExternalConfig: RequestBodyExternalConfig,
): string {
  return JSON.stringify(
    RequestBodyExternalConfig$outboundSchema.parse(requestBodyExternalConfig),
  );
}
export function requestBodyExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyExternalConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyExternalConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyExternalConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeRequestBodyType
> = z.nativeEnum(UpdateKnowledgeRequestBodyType);
/** @internal */
export const UpdateKnowledgeRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeRequestBodyType
> = UpdateKnowledgeRequestBodyType$inboundSchema;

/** @internal */
export const UpdateKnowledgeRequestBody1$inboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.nullable(z.string()).optional(),
  path: z.string().optional(),
  retrieval_settings: z.lazy(() => RequestBodyRetrievalSettings$inboundSchema)
    .optional(),
  external_config: z.lazy(() => RequestBodyExternalConfig$inboundSchema)
    .optional(),
  type: UpdateKnowledgeRequestBodyType$inboundSchema.default("external"),
}).transform((v) => {
  return remap$(v, {
    "retrieval_settings": "retrievalSettings",
    "external_config": "externalConfig",
  });
});
/** @internal */
export type UpdateKnowledgeRequestBody1$Outbound = {
  description?: string | null | undefined;
  path?: string | undefined;
  retrieval_settings?: RequestBodyRetrievalSettings$Outbound | undefined;
  external_config?: RequestBodyExternalConfig$Outbound | undefined;
  type: string;
};

/** @internal */
export const UpdateKnowledgeRequestBody1$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody1$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody1
> = z.object({
  description: z.nullable(z.string()).optional(),
  path: z.string().optional(),
  retrievalSettings: z.lazy(() => RequestBodyRetrievalSettings$outboundSchema)
    .optional(),
  externalConfig: z.lazy(() => RequestBodyExternalConfig$outboundSchema)
    .optional(),
  type: UpdateKnowledgeRequestBodyType$outboundSchema.default("external"),
}).transform((v) => {
  return remap$(v, {
    retrievalSettings: "retrieval_settings",
    externalConfig: "external_config",
  });
});

export function updateKnowledgeRequestBody1ToJSON(
  updateKnowledgeRequestBody1: UpdateKnowledgeRequestBody1,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody1$outboundSchema.parse(
      updateKnowledgeRequestBody1,
    ),
  );
}
export function updateKnowledgeRequestBody1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeRequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeRequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeRequestBody1' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequestBody$inboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateKnowledgeRequestBody1$inboundSchema),
  z.lazy(() => UpdateKnowledgeRequestBody2$inboundSchema),
]);
/** @internal */
export type UpdateKnowledgeRequestBody$Outbound =
  | UpdateKnowledgeRequestBody1$Outbound
  | UpdateKnowledgeRequestBody2$Outbound;

/** @internal */
export const UpdateKnowledgeRequestBody$outboundSchema: z.ZodType<
  UpdateKnowledgeRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequestBody
> = z.union([
  z.lazy(() => UpdateKnowledgeRequestBody1$outboundSchema),
  z.lazy(() => UpdateKnowledgeRequestBody2$outboundSchema),
]);

export function updateKnowledgeRequestBodyToJSON(
  updateKnowledgeRequestBody: UpdateKnowledgeRequestBody,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequestBody$outboundSchema.parse(updateKnowledgeRequestBody),
  );
}
export function updateKnowledgeRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeRequest$inboundSchema: z.ZodType<
  UpdateKnowledgeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
  RequestBody: z.union([
    z.lazy(() => UpdateKnowledgeRequestBody1$inboundSchema),
    z.lazy(() => UpdateKnowledgeRequestBody2$inboundSchema),
  ]),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateKnowledgeRequest$Outbound = {
  knowledge_id: string;
  RequestBody:
    | UpdateKnowledgeRequestBody1$Outbound
    | UpdateKnowledgeRequestBody2$Outbound;
};

/** @internal */
export const UpdateKnowledgeRequest$outboundSchema: z.ZodType<
  UpdateKnowledgeRequest$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeRequest
> = z.object({
  knowledgeId: z.string(),
  requestBody: z.union([
    z.lazy(() => UpdateKnowledgeRequestBody1$outboundSchema),
    z.lazy(() => UpdateKnowledgeRequestBody2$outboundSchema),
  ]),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    requestBody: "RequestBody",
  });
});

export function updateKnowledgeRequestToJSON(
  updateKnowledgeRequest: UpdateKnowledgeRequest,
): string {
  return JSON.stringify(
    UpdateKnowledgeRequest$outboundSchema.parse(updateKnowledgeRequest),
  );
}
export function updateKnowledgeRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeRequest' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyKnowledgeType> = z
    .nativeEnum(UpdateKnowledgeResponseBodyKnowledgeType);
/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyKnowledgeType> =
    UpdateKnowledgeResponseBodyKnowledgeType$inboundSchema;

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    top_k: z.number().int().default(5),
    rerank_threshold: z.number().default(0.5),
    rerank_model: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "top_k": "topK",
      "rerank_threshold": "rerankThreshold",
      "rerank_model": "rerankModel",
    });
  });
/** @internal */
export type UpdateKnowledgeResponseBodyKnowledgeRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRerankConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig
  > = z.object({
    topK: z.number().int().default(5),
    rerankThreshold: z.number().default(0.5),
    rerankModel: z.string(),
  }).transform((v) => {
    return remap$(v, {
      topK: "top_k",
      rerankThreshold: "rerank_threshold",
      rerankModel: "rerank_model",
    });
  });

export function updateKnowledgeResponseBodyKnowledgeRerankConfigToJSON(
  updateKnowledgeResponseBodyKnowledgeRerankConfig:
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyKnowledgeRerankConfig$outboundSchema.parse(
      updateKnowledgeResponseBodyKnowledgeRerankConfig,
    ),
  );
}
export function updateKnowledgeResponseBodyKnowledgeRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeRerankConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeRerankConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });
/** @internal */
export type UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeResponseBodyKnowledgeAgenticRagConfigToJSON(
  updateKnowledgeResponseBodyKnowledgeAgenticRagConfig:
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$outboundSchema.parse(
      updateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
    ),
  );
}
export function updateKnowledgeResponseBodyKnowledgeAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeRerankConfig$inboundSchema
      ),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$inboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });
/** @internal */
export type UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$Outbound = {
  top_k: number;
  threshold: number;
  rerank_config?:
    | UpdateKnowledgeResponseBodyKnowledgeRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings
  > = z.object({
    topK: z.number().int().default(5),
    threshold: z.number().default(0),
    rerankConfig: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeRerankConfig$outboundSchema
      ),
    ).optional(),
    agenticRagConfig: z.nullable(
      z.lazy(() =>
        UpdateKnowledgeResponseBodyKnowledgeAgenticRagConfig$outboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      topK: "top_k",
      rerankConfig: "rerank_config",
      agenticRagConfig: "agentic_rag_config",
    });
  });

export function updateKnowledgeResponseBodyKnowledgeRetrievalSettingsToJSON(
  updateKnowledgeResponseBodyKnowledgeRetrievalSettings:
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$outboundSchema.parse(
      updateKnowledgeResponseBodyKnowledgeRetrievalSettings,
    ),
  );
}
export function updateKnowledgeResponseBodyKnowledgeRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyExternalConfig$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBodyExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
  });
});
/** @internal */
export type UpdateKnowledgeResponseBodyExternalConfig$Outbound = {
  name: string;
  api_url: string;
};

/** @internal */
export const UpdateKnowledgeResponseBodyExternalConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyExternalConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyExternalConfig
  > = z.object({
    name: z.string(),
    apiUrl: z.string(),
  }).transform((v) => {
    return remap$(v, {
      apiUrl: "api_url",
    });
  });

export function updateKnowledgeResponseBodyExternalConfigToJSON(
  updateKnowledgeResponseBodyExternalConfig:
    UpdateKnowledgeResponseBodyExternalConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyExternalConfig$outboundSchema.parse(
      updateKnowledgeResponseBodyExternalConfig,
    ),
  );
}
export function updateKnowledgeResponseBodyExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyExternalConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyExternalConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyExternalConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody2$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyKnowledgeType$inboundSchema.default(
    "external",
  ),
  retrieval_settings: z.lazy(() =>
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$inboundSchema
  ).optional(),
  external_config: z.lazy(() =>
    UpdateKnowledgeResponseBodyExternalConfig$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
    "external_config": "externalConfig",
  });
});
/** @internal */
export type UpdateKnowledgeResponseBody2$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?:
    | UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$Outbound
    | undefined;
  external_config: UpdateKnowledgeResponseBodyExternalConfig$Outbound;
};

/** @internal */
export const UpdateKnowledgeResponseBody2$outboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody2$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeResponseBody2
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyKnowledgeType$outboundSchema.default(
    "external",
  ),
  retrievalSettings: z.lazy(() =>
    UpdateKnowledgeResponseBodyKnowledgeRetrievalSettings$outboundSchema
  ).optional(),
  externalConfig: z.lazy(() =>
    UpdateKnowledgeResponseBodyExternalConfig$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
    externalConfig: "external_config",
  });
});

export function updateKnowledgeResponseBody2ToJSON(
  updateKnowledgeResponseBody2: UpdateKnowledgeResponseBody2,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBody2$outboundSchema.parse(
      updateKnowledgeResponseBody2,
    ),
  );
}
export function updateKnowledgeResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody2' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeResponseBodyType
> = z.nativeEnum(UpdateKnowledgeResponseBodyType);
/** @internal */
export const UpdateKnowledgeResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateKnowledgeResponseBodyType
> = UpdateKnowledgeResponseBodyType$inboundSchema;

/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyRetrievalType> = z
    .nativeEnum(UpdateKnowledgeResponseBodyRetrievalType);
/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateKnowledgeResponseBodyRetrievalType> =
    UpdateKnowledgeResponseBodyRetrievalType$inboundSchema;

/** @internal */
export const UpdateKnowledgeResponseBodyRerankConfig$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type UpdateKnowledgeResponseBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const UpdateKnowledgeResponseBodyRerankConfig$outboundSchema: z.ZodType<
  UpdateKnowledgeResponseBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeResponseBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function updateKnowledgeResponseBodyRerankConfigToJSON(
  updateKnowledgeResponseBodyRerankConfig:
    UpdateKnowledgeResponseBodyRerankConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyRerankConfig$outboundSchema.parse(
      updateKnowledgeResponseBodyRerankConfig,
    ),
  );
}
export function updateKnowledgeResponseBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyRerankConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyRerankConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyAgenticRagConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });
/** @internal */
export type UpdateKnowledgeResponseBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const UpdateKnowledgeResponseBodyAgenticRagConfig$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function updateKnowledgeResponseBodyAgenticRagConfigToJSON(
  updateKnowledgeResponseBodyAgenticRagConfig:
    UpdateKnowledgeResponseBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyAgenticRagConfig$outboundSchema.parse(
      updateKnowledgeResponseBodyAgenticRagConfig,
    ),
  );
}
export function updateKnowledgeResponseBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    retrieval_type: UpdateKnowledgeResponseBodyRetrievalType$inboundSchema
      .default("hybrid_search"),
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyRerankConfig$inboundSchema),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyAgenticRagConfig$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "retrieval_type": "retrievalType",
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });
/** @internal */
export type UpdateKnowledgeResponseBodyRetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?:
    | UpdateKnowledgeResponseBodyRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | UpdateKnowledgeResponseBodyAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const UpdateKnowledgeResponseBodyRetrievalSettings$outboundSchema:
  z.ZodType<
    UpdateKnowledgeResponseBodyRetrievalSettings$Outbound,
    z.ZodTypeDef,
    UpdateKnowledgeResponseBodyRetrievalSettings
  > = z.object({
    retrievalType: UpdateKnowledgeResponseBodyRetrievalType$outboundSchema
      .default("hybrid_search"),
    topK: z.number().int().default(5),
    threshold: z.number().default(0),
    rerankConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyRerankConfig$outboundSchema),
    ).optional(),
    agenticRagConfig: z.nullable(
      z.lazy(() => UpdateKnowledgeResponseBodyAgenticRagConfig$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      retrievalType: "retrieval_type",
      topK: "top_k",
      rerankConfig: "rerank_config",
      agenticRagConfig: "agentic_rag_config",
    });
  });

export function updateKnowledgeResponseBodyRetrievalSettingsToJSON(
  updateKnowledgeResponseBodyRetrievalSettings:
    UpdateKnowledgeResponseBodyRetrievalSettings,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBodyRetrievalSettings$outboundSchema.parse(
      updateKnowledgeResponseBodyRetrievalSettings,
    ),
  );
}
export function updateKnowledgeResponseBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateKnowledgeResponseBodyRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateKnowledgeResponseBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody1$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyType$inboundSchema.default("internal"),
  retrieval_settings: z.lazy(() =>
    UpdateKnowledgeResponseBodyRetrievalSettings$inboundSchema
  ).optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
  });
});
/** @internal */
export type UpdateKnowledgeResponseBody1$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?:
    | UpdateKnowledgeResponseBodyRetrievalSettings$Outbound
    | undefined;
  model: string;
};

/** @internal */
export const UpdateKnowledgeResponseBody1$outboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody1$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeResponseBody1
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: UpdateKnowledgeResponseBodyType$outboundSchema.default("internal"),
  retrievalSettings: z.lazy(() =>
    UpdateKnowledgeResponseBodyRetrievalSettings$outboundSchema
  ).optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
  });
});

export function updateKnowledgeResponseBody1ToJSON(
  updateKnowledgeResponseBody1: UpdateKnowledgeResponseBody1,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBody1$outboundSchema.parse(
      updateKnowledgeResponseBody1,
    ),
  );
}
export function updateKnowledgeResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody1' from JSON`,
  );
}

/** @internal */
export const UpdateKnowledgeResponseBody$inboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateKnowledgeResponseBody1$inboundSchema),
  z.lazy(() => UpdateKnowledgeResponseBody2$inboundSchema),
]);
/** @internal */
export type UpdateKnowledgeResponseBody$Outbound =
  | UpdateKnowledgeResponseBody1$Outbound
  | UpdateKnowledgeResponseBody2$Outbound;

/** @internal */
export const UpdateKnowledgeResponseBody$outboundSchema: z.ZodType<
  UpdateKnowledgeResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateKnowledgeResponseBody
> = z.union([
  z.lazy(() => UpdateKnowledgeResponseBody1$outboundSchema),
  z.lazy(() => UpdateKnowledgeResponseBody2$outboundSchema),
]);

export function updateKnowledgeResponseBodyToJSON(
  updateKnowledgeResponseBody: UpdateKnowledgeResponseBody,
): string {
  return JSON.stringify(
    UpdateKnowledgeResponseBody$outboundSchema.parse(
      updateKnowledgeResponseBody,
    ),
  );
}
export function updateKnowledgeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateKnowledgeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateKnowledgeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateKnowledgeResponseBody' from JSON`,
  );
}
