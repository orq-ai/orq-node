/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Input text to embed, encoded as a string or array of tokens.
 */
export type CreateEmbeddingInput = string | Array<string>;

/**
 * Type of the document element
 */
export const EncodingFormat = {
  Base64: "base64",
  Float: "float",
} as const;
/**
 * Type of the document element
 */
export type EncodingFormat = ClosedEnum<typeof EncodingFormat>;

export type CreateEmbeddingFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

export const CreateEmbeddingType = {
  ExactMatch: "exact_match",
} as const;
export type CreateEmbeddingType = ClosedEnum<typeof CreateEmbeddingType>;

/**
 * Cache configuration for the request.
 */
export type CreateEmbeddingCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateEmbeddingType;
};

/**
 * Retry configuration for the request
 */
export type CreateEmbeddingRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateEmbeddingContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

export const CreateEmbeddingLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateEmbeddingLoadBalancerType = ClosedEnum<
  typeof CreateEmbeddingLoadBalancerType
>;

export type CreateEmbeddingLoadBalancer1 = {
  type: CreateEmbeddingLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateEmbeddingLoadBalancer = CreateEmbeddingLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateEmbeddingTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateEmbeddingOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateEmbeddingFallbacks> | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateEmbeddingCache | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateEmbeddingRetry | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateEmbeddingContact | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateEmbeddingLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateEmbeddingTimeout | undefined;
};

/**
 * input
 */
export type CreateEmbeddingRequestBody = {
  /**
   * Input text to embed, encoded as a string or array of tokens.
   */
  input: string | Array<string>;
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * Type of the document element
   */
  encodingFormat?: EncodingFormat | undefined;
  /**
   * The number of dimensions the resulting output embeddings should have.
   */
  dimensions?: number | undefined;
  /**
   * A unique identifier representing your end-user
   */
  user?: string | undefined;
  orq?: CreateEmbeddingOrq | undefined;
};

export const CreateEmbeddingObject = {
  List: "list",
} as const;
export type CreateEmbeddingObject = ClosedEnum<typeof CreateEmbeddingObject>;

/**
 * The object type, which is always `embedding`.
 */
export const CreateEmbeddingRouterEmbeddingsObject = {
  Embedding: "embedding",
} as const;
/**
 * The object type, which is always `embedding`.
 */
export type CreateEmbeddingRouterEmbeddingsObject = ClosedEnum<
  typeof CreateEmbeddingRouterEmbeddingsObject
>;

/**
 * The embedding vector, which is a list of floats. The length of vector depends on the model.
 */
export type Embedding = Array<number> | string;

export type CreateEmbeddingData = {
  /**
   * The object type, which is always `embedding`.
   */
  object: CreateEmbeddingRouterEmbeddingsObject;
  /**
   * The embedding vector, which is a list of floats. The length of vector depends on the model.
   */
  embedding: Array<number> | string;
  /**
   * The index of the embedding in the list of embeddings.
   */
  index: number;
};

/**
 * The usage information for the request.
 */
export type CreateEmbeddingUsage = {
  /**
   * The number of tokens used by the prompt.
   */
  promptTokens: number;
  /**
   * The total number of tokens used by the request.
   */
  totalTokens: number;
};

/**
 * Returns the embedding vector.
 */
export type CreateEmbeddingResponseBody = {
  object: CreateEmbeddingObject;
  data: Array<CreateEmbeddingData>;
  /**
   * ID of the model to used.
   */
  model: string;
  /**
   * The usage information for the request.
   */
  usage: CreateEmbeddingUsage;
};

/** @internal */
export type CreateEmbeddingInput$Outbound = string | Array<string>;

/** @internal */
export const CreateEmbeddingInput$outboundSchema: z.ZodType<
  CreateEmbeddingInput$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingInput
> = z.union([z.string(), z.array(z.string())]);

export function createEmbeddingInputToJSON(
  createEmbeddingInput: CreateEmbeddingInput,
): string {
  return JSON.stringify(
    CreateEmbeddingInput$outboundSchema.parse(createEmbeddingInput),
  );
}

/** @internal */
export const EncodingFormat$outboundSchema: z.ZodNativeEnum<
  typeof EncodingFormat
> = z.nativeEnum(EncodingFormat);

/** @internal */
export type CreateEmbeddingFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateEmbeddingFallbacks$outboundSchema: z.ZodType<
  CreateEmbeddingFallbacks$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingFallbacks
> = z.object({
  model: z.string(),
});

export function createEmbeddingFallbacksToJSON(
  createEmbeddingFallbacks: CreateEmbeddingFallbacks,
): string {
  return JSON.stringify(
    CreateEmbeddingFallbacks$outboundSchema.parse(createEmbeddingFallbacks),
  );
}

/** @internal */
export const CreateEmbeddingType$outboundSchema: z.ZodNativeEnum<
  typeof CreateEmbeddingType
> = z.nativeEnum(CreateEmbeddingType);

/** @internal */
export type CreateEmbeddingCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateEmbeddingCache$outboundSchema: z.ZodType<
  CreateEmbeddingCache$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateEmbeddingType$outboundSchema,
});

export function createEmbeddingCacheToJSON(
  createEmbeddingCache: CreateEmbeddingCache,
): string {
  return JSON.stringify(
    CreateEmbeddingCache$outboundSchema.parse(createEmbeddingCache),
  );
}

/** @internal */
export type CreateEmbeddingRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateEmbeddingRetry$outboundSchema: z.ZodType<
  CreateEmbeddingRetry$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createEmbeddingRetryToJSON(
  createEmbeddingRetry: CreateEmbeddingRetry,
): string {
  return JSON.stringify(
    CreateEmbeddingRetry$outboundSchema.parse(createEmbeddingRetry),
  );
}

/** @internal */
export type CreateEmbeddingContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateEmbeddingContact$outboundSchema: z.ZodType<
  CreateEmbeddingContact$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createEmbeddingContactToJSON(
  createEmbeddingContact: CreateEmbeddingContact,
): string {
  return JSON.stringify(
    CreateEmbeddingContact$outboundSchema.parse(createEmbeddingContact),
  );
}

/** @internal */
export const CreateEmbeddingLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateEmbeddingLoadBalancerType
> = z.nativeEnum(CreateEmbeddingLoadBalancerType);

/** @internal */
export type CreateEmbeddingLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const CreateEmbeddingLoadBalancer1$outboundSchema: z.ZodType<
  CreateEmbeddingLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingLoadBalancer1
> = z.object({
  type: CreateEmbeddingLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createEmbeddingLoadBalancer1ToJSON(
  createEmbeddingLoadBalancer1: CreateEmbeddingLoadBalancer1,
): string {
  return JSON.stringify(
    CreateEmbeddingLoadBalancer1$outboundSchema.parse(
      createEmbeddingLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateEmbeddingLoadBalancer$Outbound =
  CreateEmbeddingLoadBalancer1$Outbound;

/** @internal */
export const CreateEmbeddingLoadBalancer$outboundSchema: z.ZodType<
  CreateEmbeddingLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingLoadBalancer
> = z.lazy(() => CreateEmbeddingLoadBalancer1$outboundSchema);

export function createEmbeddingLoadBalancerToJSON(
  createEmbeddingLoadBalancer: CreateEmbeddingLoadBalancer,
): string {
  return JSON.stringify(
    CreateEmbeddingLoadBalancer$outboundSchema.parse(
      createEmbeddingLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateEmbeddingTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateEmbeddingTimeout$outboundSchema: z.ZodType<
  CreateEmbeddingTimeout$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createEmbeddingTimeoutToJSON(
  createEmbeddingTimeout: CreateEmbeddingTimeout,
): string {
  return JSON.stringify(
    CreateEmbeddingTimeout$outboundSchema.parse(createEmbeddingTimeout),
  );
}

/** @internal */
export type CreateEmbeddingOrq$Outbound = {
  name?: string | undefined;
  fallbacks?: Array<CreateEmbeddingFallbacks$Outbound> | undefined;
  cache?: CreateEmbeddingCache$Outbound | undefined;
  retry?: CreateEmbeddingRetry$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateEmbeddingContact$Outbound | undefined;
  load_balancer?: Array<CreateEmbeddingLoadBalancer1$Outbound> | undefined;
  timeout?: CreateEmbeddingTimeout$Outbound | undefined;
};

/** @internal */
export const CreateEmbeddingOrq$outboundSchema: z.ZodType<
  CreateEmbeddingOrq$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingOrq
> = z.object({
  name: z.string().optional(),
  fallbacks: z.array(z.lazy(() => CreateEmbeddingFallbacks$outboundSchema))
    .optional(),
  cache: z.lazy(() => CreateEmbeddingCache$outboundSchema).optional(),
  retry: z.lazy(() => CreateEmbeddingRetry$outboundSchema).optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateEmbeddingContact$outboundSchema).optional(),
  loadBalancer: z.array(
    z.lazy(() => CreateEmbeddingLoadBalancer1$outboundSchema),
  ).optional(),
  timeout: z.lazy(() => CreateEmbeddingTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createEmbeddingOrqToJSON(
  createEmbeddingOrq: CreateEmbeddingOrq,
): string {
  return JSON.stringify(
    CreateEmbeddingOrq$outboundSchema.parse(createEmbeddingOrq),
  );
}

/** @internal */
export type CreateEmbeddingRequestBody$Outbound = {
  input: string | Array<string>;
  model: string;
  encoding_format: string;
  dimensions?: number | undefined;
  user?: string | undefined;
  orq?: CreateEmbeddingOrq$Outbound | undefined;
};

/** @internal */
export const CreateEmbeddingRequestBody$outboundSchema: z.ZodType<
  CreateEmbeddingRequestBody$Outbound,
  z.ZodTypeDef,
  CreateEmbeddingRequestBody
> = z.object({
  input: z.union([z.string(), z.array(z.string())]),
  model: z.string(),
  encodingFormat: EncodingFormat$outboundSchema.default("float"),
  dimensions: z.number().optional(),
  user: z.string().optional(),
  orq: z.lazy(() => CreateEmbeddingOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

export function createEmbeddingRequestBodyToJSON(
  createEmbeddingRequestBody: CreateEmbeddingRequestBody,
): string {
  return JSON.stringify(
    CreateEmbeddingRequestBody$outboundSchema.parse(createEmbeddingRequestBody),
  );
}

/** @internal */
export const CreateEmbeddingObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateEmbeddingObject
> = z.nativeEnum(CreateEmbeddingObject);

/** @internal */
export const CreateEmbeddingRouterEmbeddingsObject$inboundSchema:
  z.ZodNativeEnum<typeof CreateEmbeddingRouterEmbeddingsObject> = z.nativeEnum(
    CreateEmbeddingRouterEmbeddingsObject,
  );

/** @internal */
export const Embedding$inboundSchema: z.ZodType<
  Embedding,
  z.ZodTypeDef,
  unknown
> = z.union([z.array(z.number()), z.string()]);

export function embeddingFromJSON(
  jsonString: string,
): SafeParseResult<Embedding, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Embedding$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Embedding' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingData$inboundSchema: z.ZodType<
  CreateEmbeddingData,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: CreateEmbeddingRouterEmbeddingsObject$inboundSchema,
  embedding: z.union([z.array(z.number()), z.string()]),
  index: z.number(),
});

export function createEmbeddingDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingData' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingUsage$inboundSchema: z.ZodType<
  CreateEmbeddingUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  prompt_tokens: z.number(),
  total_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
  });
});

export function createEmbeddingUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingUsage' from JSON`,
  );
}

/** @internal */
export const CreateEmbeddingResponseBody$inboundSchema: z.ZodType<
  CreateEmbeddingResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: CreateEmbeddingObject$inboundSchema,
  data: z.array(z.lazy(() => CreateEmbeddingData$inboundSchema)),
  model: z.string(),
  usage: z.lazy(() => CreateEmbeddingUsage$inboundSchema),
});

export function createEmbeddingResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateEmbeddingResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateEmbeddingResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateEmbeddingResponseBody' from JSON`,
  );
}
