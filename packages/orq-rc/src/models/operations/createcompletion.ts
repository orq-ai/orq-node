/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
 */
export type CreateCompletionStop = string | Array<string>;

/**
 * Retry configuration for the request
 */
export type CreateCompletionRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateCompletionFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export const CreateCompletionVersion = {
  Latest: "latest",
} as const;
/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export type CreateCompletionVersion = ClosedEnum<
  typeof CreateCompletionVersion
>;

/**
 * Prompt configuration for the request
 */
export type CreateCompletionPrompt = {
  /**
   * Unique identifier of the prompt to use
   */
  id: string;
  /**
   * Version of the prompt to use (currently only "latest" supported)
   */
  version: CreateCompletionVersion;
};

/**
 * Thread information to group related requests
 */
export type CreateCompletionThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

export type CreateCompletionInputs2 = {
  key: string;
  value?: any | undefined;
  isPii?: boolean | undefined;
};

/**
 * Values to replace in the prompt messages using {{variableName}} syntax
 */
export type CreateCompletionInputs =
  | { [k: string]: any }
  | Array<CreateCompletionInputs2>;

export const CreateCompletionType = {
  ExactMatch: "exact_match",
} as const;
export type CreateCompletionType = ClosedEnum<typeof CreateCompletionType>;

/**
 * Cache configuration for the request.
 */
export type CreateCompletionCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateCompletionType;
};

/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export const CreateCompletionSearchType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export type CreateCompletionSearchType = ClosedEnum<
  typeof CreateCompletionSearchType
>;

/**
 * Exists
 */
export type CreateCompletionOrExists = {
  exists: boolean;
};

export type CreateCompletionOrRouterCompletionsNin = string | number | boolean;

/**
 * Not in
 */
export type CreateCompletionOrNin = {
  nin: Array<string | number | boolean>;
};

export type CreateCompletionOrRouterCompletionsIn = string | number | boolean;

/**
 * In
 */
export type CreateCompletionOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateCompletionOrLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateCompletionOrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateCompletionOrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateCompletionOrGt = {
  gt: number;
};

export type CreateCompletionOrRouterCompletionsNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateCompletionOrNe = {
  ne: string | number | boolean;
};

export type CreateCompletionOrRouterCompletionsEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateCompletionOrEq = {
  eq: string | number | boolean;
};

export type CreateCompletionFilterByRouterCompletionsOr =
  | CreateCompletionOrEq
  | CreateCompletionOrNe
  | CreateCompletionOrGt
  | CreateCompletionOrGte
  | CreateCompletionOrLt
  | CreateCompletionOrLte
  | CreateCompletionOrIn
  | CreateCompletionOrNin
  | CreateCompletionOrExists;

/**
 * Or
 */
export type CreateCompletionFilterByOr = {
  or: Array<
    {
      [k: string]:
        | CreateCompletionOrEq
        | CreateCompletionOrNe
        | CreateCompletionOrGt
        | CreateCompletionOrGte
        | CreateCompletionOrLt
        | CreateCompletionOrLte
        | CreateCompletionOrIn
        | CreateCompletionOrNin
        | CreateCompletionOrExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateCompletionAndExists = {
  exists: boolean;
};

export type CreateCompletionAndRouterCompletionsNin = string | number | boolean;

/**
 * Not in
 */
export type CreateCompletionAndNin = {
  nin: Array<string | number | boolean>;
};

export type CreateCompletionAndRouterCompletionsIn = string | number | boolean;

/**
 * In
 */
export type CreateCompletionAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateCompletionAndLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateCompletionAndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateCompletionAndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateCompletionAndGt = {
  gt: number;
};

export type CreateCompletionAndRouterCompletionsNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateCompletionAndNe = {
  ne: string | number | boolean;
};

export type CreateCompletionAndRouterCompletionsEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateCompletionAndEq = {
  eq: string | number | boolean;
};

export type CreateCompletionFilterByRouterCompletionsAnd =
  | CreateCompletionAndEq
  | CreateCompletionAndNe
  | CreateCompletionAndGt
  | CreateCompletionAndGte
  | CreateCompletionAndLt
  | CreateCompletionAndLte
  | CreateCompletionAndIn
  | CreateCompletionAndNin
  | CreateCompletionAndExists;

/**
 * And
 */
export type CreateCompletionFilterByAnd = {
  and: Array<
    {
      [k: string]:
        | CreateCompletionAndEq
        | CreateCompletionAndNe
        | CreateCompletionAndGt
        | CreateCompletionAndGte
        | CreateCompletionAndLt
        | CreateCompletionAndLte
        | CreateCompletionAndIn
        | CreateCompletionAndNin
        | CreateCompletionAndExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateCompletion1Exists = {
  exists: boolean;
};

export type CreateCompletion1RouterCompletionsNin = string | number | boolean;

/**
 * Not in
 */
export type CreateCompletion1Nin = {
  nin: Array<string | number | boolean>;
};

export type CreateCompletion1RouterCompletionsIn = string | number | boolean;

/**
 * In
 */
export type CreateCompletion1In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateCompletion1Lte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateCompletion1Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateCompletion1Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateCompletion1Gt = {
  gt: number;
};

export type CreateCompletion1RouterCompletionsNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateCompletion1Ne = {
  ne: string | number | boolean;
};

export type CreateCompletion1RouterCompletionsEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateCompletion1Eq = {
  eq: string | number | boolean;
};

export type CreateCompletionFilterBy1 =
  | CreateCompletion1Eq
  | CreateCompletion1Ne
  | CreateCompletion1Gt
  | CreateCompletion1Gte
  | CreateCompletion1Lt
  | CreateCompletion1Lte
  | CreateCompletion1In
  | CreateCompletion1Nin
  | CreateCompletion1Exists;

/**
 * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
 */
export type CreateCompletionFilterBy =
  | CreateCompletionFilterByAnd
  | CreateCompletionFilterByOr
  | {
    [k: string]:
      | CreateCompletion1Eq
      | CreateCompletion1Ne
      | CreateCompletion1Gt
      | CreateCompletion1Gte
      | CreateCompletion1Lt
      | CreateCompletion1Lte
      | CreateCompletion1In
      | CreateCompletion1Nin
      | CreateCompletion1Exists;
  };

/**
 * Additional search options
 */
export type CreateCompletionSearchOptions = {
  /**
   * Whether to include the vector in the chunk
   */
  includeVectors?: boolean | undefined;
  /**
   * Whether to include the metadata in the chunk
   */
  includeMetadata?: boolean | undefined;
  /**
   * Whether to include the scores in the chunk
   */
  includeScores?: boolean | undefined;
};

/**
 * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
 */
export type CreateCompletionRerankConfig = {
  /**
   * The name of the rerank model to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/rerank-models).
   */
  model: string;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The number of top results to return after reranking. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
};

/**
 * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
 */
export type CreateCompletionAgenticRagConfig = {
  /**
   * The name of the model for the Agent to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/chat-models).
   */
  model: string;
};

export type CreateCompletionKnowledgeBases = {
  /**
   * The number of results to return. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
  /**
   * The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`
   */
  threshold?: number | undefined;
  /**
   * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
   */
  searchType?: CreateCompletionSearchType | undefined;
  /**
   * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
   */
  filterBy?: CreateCompletionFilterByAnd | CreateCompletionFilterByOr | {
    [k: string]:
      | CreateCompletion1Eq
      | CreateCompletion1Ne
      | CreateCompletion1Gt
      | CreateCompletion1Gte
      | CreateCompletion1Lt
      | CreateCompletion1Lte
      | CreateCompletion1In
      | CreateCompletion1Nin
      | CreateCompletion1Exists;
  } | undefined;
  /**
   * Additional search options
   */
  searchOptions?: CreateCompletionSearchOptions | undefined;
  /**
   * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
   */
  rerankConfig?: CreateCompletionRerankConfig | undefined;
  /**
   * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
   */
  agenticRagConfig?: CreateCompletionAgenticRagConfig | undefined;
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
  /**
   * The query to use to search the knowledge base. If not provided we will use the last user message from the messages of the requests
   */
  query?: string | undefined;
};

export const CreateCompletionLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateCompletionLoadBalancerType = ClosedEnum<
  typeof CreateCompletionLoadBalancerType
>;

export type CreateCompletionLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateCompletionLoadBalancer1 = {
  type: CreateCompletionLoadBalancerType;
  models: Array<CreateCompletionLoadBalancerModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateCompletionLoadBalancer = CreateCompletionLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateCompletionTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateCompletionOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateCompletionRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateCompletionFallbacks> | undefined;
  /**
   * Prompt configuration for the request
   */
  prompt?: CreateCompletionPrompt | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: components.PublicContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateCompletionThread | undefined;
  /**
   * Values to replace in the prompt messages using {{variableName}} syntax
   */
  inputs?: { [k: string]: any } | Array<CreateCompletionInputs2> | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateCompletionCache | undefined;
  knowledgeBases?: Array<CreateCompletionKnowledgeBases> | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: CreateCompletionLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateCompletionTimeout | undefined;
};

export type CreateCompletionRequestBody = {
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * The prompt(s) to generate completions for, encoded as a string, array of strings, array of tokens, or array of token arrays.
   */
  prompt: string;
  /**
   * Echo back the prompt in addition to the completion
   */
  echo?: boolean | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * The maximum number of tokens that can be generated in the completion.
   */
  maxTokens?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens. The returned text will not contain the stop sequence.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
   */
  topP?: number | null | undefined;
  /**
   * How many completions to generate for each prompt. Note: Because this parameter generates many completions, it can quickly consume your token quota.
   */
  n?: number | null | undefined;
  /**
   * A unique identifier representing your end-user, which can help OpenAI to monitor and detect abuse.
   */
  user?: string | undefined;
  /**
   * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  orq?: CreateCompletionOrq | undefined;
  stream?: boolean | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const CreateCompletionRouterCompletionsFinishReason = {
  Stop: "stop",
  Length: "length",
  ContentFilter: "content_filter",
  ToolCalls: "tool_calls",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type CreateCompletionRouterCompletionsFinishReason = ClosedEnum<
  typeof CreateCompletionRouterCompletionsFinishReason
>;

export type CreateCompletionRouterCompletionsChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: CreateCompletionRouterCompletionsFinishReason;
  /**
   * The index of the choice in the list of choices.
   */
  index: number;
  text: string;
};

/**
 * The Unix timestamp (in seconds) of when the chat completion was created.
 */
export type CreateCompletionCreated = string | number;

export type CreateCompletionRouterCompletionsPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateCompletionRouterCompletionsCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateCompletionRouterCompletionsUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | CreateCompletionRouterCompletionsPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | CreateCompletionRouterCompletionsCompletionTokensDetails
    | null
    | undefined;
};

export type CreateCompletionData = {
  /**
   * A unique identifier for the completion.
   */
  id: string;
  /**
   * The list of completion choices the model generated for the input prompt.
   */
  choices: Array<CreateCompletionRouterCompletionsChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created?: string | number | undefined;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | undefined;
  /**
   * The object type
   */
  object: string;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateCompletionRouterCompletionsUsage | undefined;
};

/**
 * Represents a completion response from the API.
 */
export type CreateCompletionRouterCompletionsResponseBody = {
  data?: CreateCompletionData | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const CreateCompletionFinishReason = {
  Stop: "stop",
  Length: "length",
  ContentFilter: "content_filter",
  ToolCalls: "tool_calls",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type CreateCompletionFinishReason = ClosedEnum<
  typeof CreateCompletionFinishReason
>;

export type CreateCompletionChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: CreateCompletionFinishReason;
  /**
   * The index of the choice in the list of choices.
   */
  index: number;
  text: string;
};

/**
 * The Unix timestamp (in seconds) of when the chat completion was created.
 */
export type Created = string | number;

export type CreateCompletionPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateCompletionCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateCompletionUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: CreateCompletionPromptTokensDetails | null | undefined;
  completionTokensDetails?:
    | CreateCompletionCompletionTokensDetails
    | null
    | undefined;
};

/**
 * Represents a completion response from the API.
 */
export type CreateCompletionResponseBody = {
  /**
   * A unique identifier for the completion.
   */
  id: string;
  /**
   * The list of completion choices the model generated for the input prompt.
   */
  choices: Array<CreateCompletionChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created?: string | number | undefined;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | undefined;
  /**
   * The object type
   */
  object: string;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateCompletionUsage | undefined;
};

export type CreateCompletionResponse =
  | CreateCompletionResponseBody
  | EventStream<CreateCompletionRouterCompletionsResponseBody>;

/** @internal */
export type CreateCompletionStop$Outbound = string | Array<string>;

/** @internal */
export const CreateCompletionStop$outboundSchema: z.ZodType<
  CreateCompletionStop$Outbound,
  z.ZodTypeDef,
  CreateCompletionStop
> = z.union([z.string(), z.array(z.string())]);

export function createCompletionStopToJSON(
  createCompletionStop: CreateCompletionStop,
): string {
  return JSON.stringify(
    CreateCompletionStop$outboundSchema.parse(createCompletionStop),
  );
}

/** @internal */
export type CreateCompletionRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateCompletionRetry$outboundSchema: z.ZodType<
  CreateCompletionRetry$Outbound,
  z.ZodTypeDef,
  CreateCompletionRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createCompletionRetryToJSON(
  createCompletionRetry: CreateCompletionRetry,
): string {
  return JSON.stringify(
    CreateCompletionRetry$outboundSchema.parse(createCompletionRetry),
  );
}

/** @internal */
export type CreateCompletionFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateCompletionFallbacks$outboundSchema: z.ZodType<
  CreateCompletionFallbacks$Outbound,
  z.ZodTypeDef,
  CreateCompletionFallbacks
> = z.object({
  model: z.string(),
});

export function createCompletionFallbacksToJSON(
  createCompletionFallbacks: CreateCompletionFallbacks,
): string {
  return JSON.stringify(
    CreateCompletionFallbacks$outboundSchema.parse(createCompletionFallbacks),
  );
}

/** @internal */
export const CreateCompletionVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateCompletionVersion
> = z.nativeEnum(CreateCompletionVersion);

/** @internal */
export type CreateCompletionPrompt$Outbound = {
  id: string;
  version: string;
};

/** @internal */
export const CreateCompletionPrompt$outboundSchema: z.ZodType<
  CreateCompletionPrompt$Outbound,
  z.ZodTypeDef,
  CreateCompletionPrompt
> = z.object({
  id: z.string(),
  version: CreateCompletionVersion$outboundSchema,
});

export function createCompletionPromptToJSON(
  createCompletionPrompt: CreateCompletionPrompt,
): string {
  return JSON.stringify(
    CreateCompletionPrompt$outboundSchema.parse(createCompletionPrompt),
  );
}

/** @internal */
export type CreateCompletionThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateCompletionThread$outboundSchema: z.ZodType<
  CreateCompletionThread$Outbound,
  z.ZodTypeDef,
  CreateCompletionThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createCompletionThreadToJSON(
  createCompletionThread: CreateCompletionThread,
): string {
  return JSON.stringify(
    CreateCompletionThread$outboundSchema.parse(createCompletionThread),
  );
}

/** @internal */
export type CreateCompletionInputs2$Outbound = {
  key: string;
  value?: any | undefined;
  is_pii?: boolean | undefined;
};

/** @internal */
export const CreateCompletionInputs2$outboundSchema: z.ZodType<
  CreateCompletionInputs2$Outbound,
  z.ZodTypeDef,
  CreateCompletionInputs2
> = z.object({
  key: z.string(),
  value: z.any().optional(),
  isPii: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    isPii: "is_pii",
  });
});

export function createCompletionInputs2ToJSON(
  createCompletionInputs2: CreateCompletionInputs2,
): string {
  return JSON.stringify(
    CreateCompletionInputs2$outboundSchema.parse(createCompletionInputs2),
  );
}

/** @internal */
export type CreateCompletionInputs$Outbound =
  | { [k: string]: any }
  | Array<CreateCompletionInputs2$Outbound>;

/** @internal */
export const CreateCompletionInputs$outboundSchema: z.ZodType<
  CreateCompletionInputs$Outbound,
  z.ZodTypeDef,
  CreateCompletionInputs
> = z.union([
  z.record(z.any()),
  z.array(z.lazy(() => CreateCompletionInputs2$outboundSchema)),
]);

export function createCompletionInputsToJSON(
  createCompletionInputs: CreateCompletionInputs,
): string {
  return JSON.stringify(
    CreateCompletionInputs$outboundSchema.parse(createCompletionInputs),
  );
}

/** @internal */
export const CreateCompletionType$outboundSchema: z.ZodNativeEnum<
  typeof CreateCompletionType
> = z.nativeEnum(CreateCompletionType);

/** @internal */
export type CreateCompletionCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateCompletionCache$outboundSchema: z.ZodType<
  CreateCompletionCache$Outbound,
  z.ZodTypeDef,
  CreateCompletionCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateCompletionType$outboundSchema,
});

export function createCompletionCacheToJSON(
  createCompletionCache: CreateCompletionCache,
): string {
  return JSON.stringify(
    CreateCompletionCache$outboundSchema.parse(createCompletionCache),
  );
}

/** @internal */
export const CreateCompletionSearchType$outboundSchema: z.ZodNativeEnum<
  typeof CreateCompletionSearchType
> = z.nativeEnum(CreateCompletionSearchType);

/** @internal */
export type CreateCompletionOrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateCompletionOrExists$outboundSchema: z.ZodType<
  CreateCompletionOrExists$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrExists
> = z.object({
  exists: z.boolean(),
});

export function createCompletionOrExistsToJSON(
  createCompletionOrExists: CreateCompletionOrExists,
): string {
  return JSON.stringify(
    CreateCompletionOrExists$outboundSchema.parse(createCompletionOrExists),
  );
}

/** @internal */
export type CreateCompletionOrRouterCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionOrRouterCompletionsNin$outboundSchema: z.ZodType<
  CreateCompletionOrRouterCompletionsNin$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrRouterCompletionsNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionOrRouterCompletionsNinToJSON(
  createCompletionOrRouterCompletionsNin:
    CreateCompletionOrRouterCompletionsNin,
): string {
  return JSON.stringify(
    CreateCompletionOrRouterCompletionsNin$outboundSchema.parse(
      createCompletionOrRouterCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateCompletionOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletionOrNin$outboundSchema: z.ZodType<
  CreateCompletionOrNin$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletionOrNinToJSON(
  createCompletionOrNin: CreateCompletionOrNin,
): string {
  return JSON.stringify(
    CreateCompletionOrNin$outboundSchema.parse(createCompletionOrNin),
  );
}

/** @internal */
export type CreateCompletionOrRouterCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionOrRouterCompletionsIn$outboundSchema: z.ZodType<
  CreateCompletionOrRouterCompletionsIn$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrRouterCompletionsIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionOrRouterCompletionsInToJSON(
  createCompletionOrRouterCompletionsIn: CreateCompletionOrRouterCompletionsIn,
): string {
  return JSON.stringify(
    CreateCompletionOrRouterCompletionsIn$outboundSchema.parse(
      createCompletionOrRouterCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateCompletionOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletionOrIn$outboundSchema: z.ZodType<
  CreateCompletionOrIn$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletionOrInToJSON(
  createCompletionOrIn: CreateCompletionOrIn,
): string {
  return JSON.stringify(
    CreateCompletionOrIn$outboundSchema.parse(createCompletionOrIn),
  );
}

/** @internal */
export type CreateCompletionOrLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateCompletionOrLte$outboundSchema: z.ZodType<
  CreateCompletionOrLte$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrLte
> = z.object({
  lte: z.number(),
});

export function createCompletionOrLteToJSON(
  createCompletionOrLte: CreateCompletionOrLte,
): string {
  return JSON.stringify(
    CreateCompletionOrLte$outboundSchema.parse(createCompletionOrLte),
  );
}

/** @internal */
export type CreateCompletionOrLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateCompletionOrLt$outboundSchema: z.ZodType<
  CreateCompletionOrLt$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrLt
> = z.object({
  lt: z.number(),
});

export function createCompletionOrLtToJSON(
  createCompletionOrLt: CreateCompletionOrLt,
): string {
  return JSON.stringify(
    CreateCompletionOrLt$outboundSchema.parse(createCompletionOrLt),
  );
}

/** @internal */
export type CreateCompletionOrGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateCompletionOrGte$outboundSchema: z.ZodType<
  CreateCompletionOrGte$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrGte
> = z.object({
  gte: z.number(),
});

export function createCompletionOrGteToJSON(
  createCompletionOrGte: CreateCompletionOrGte,
): string {
  return JSON.stringify(
    CreateCompletionOrGte$outboundSchema.parse(createCompletionOrGte),
  );
}

/** @internal */
export type CreateCompletionOrGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateCompletionOrGt$outboundSchema: z.ZodType<
  CreateCompletionOrGt$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrGt
> = z.object({
  gt: z.number(),
});

export function createCompletionOrGtToJSON(
  createCompletionOrGt: CreateCompletionOrGt,
): string {
  return JSON.stringify(
    CreateCompletionOrGt$outboundSchema.parse(createCompletionOrGt),
  );
}

/** @internal */
export type CreateCompletionOrRouterCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionOrRouterCompletionsNe$outboundSchema: z.ZodType<
  CreateCompletionOrRouterCompletionsNe$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrRouterCompletionsNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionOrRouterCompletionsNeToJSON(
  createCompletionOrRouterCompletionsNe: CreateCompletionOrRouterCompletionsNe,
): string {
  return JSON.stringify(
    CreateCompletionOrRouterCompletionsNe$outboundSchema.parse(
      createCompletionOrRouterCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateCompletionOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateCompletionOrNe$outboundSchema: z.ZodType<
  CreateCompletionOrNe$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletionOrNeToJSON(
  createCompletionOrNe: CreateCompletionOrNe,
): string {
  return JSON.stringify(
    CreateCompletionOrNe$outboundSchema.parse(createCompletionOrNe),
  );
}

/** @internal */
export type CreateCompletionOrRouterCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionOrRouterCompletionsEq$outboundSchema: z.ZodType<
  CreateCompletionOrRouterCompletionsEq$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrRouterCompletionsEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionOrRouterCompletionsEqToJSON(
  createCompletionOrRouterCompletionsEq: CreateCompletionOrRouterCompletionsEq,
): string {
  return JSON.stringify(
    CreateCompletionOrRouterCompletionsEq$outboundSchema.parse(
      createCompletionOrRouterCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateCompletionOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateCompletionOrEq$outboundSchema: z.ZodType<
  CreateCompletionOrEq$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletionOrEqToJSON(
  createCompletionOrEq: CreateCompletionOrEq,
): string {
  return JSON.stringify(
    CreateCompletionOrEq$outboundSchema.parse(createCompletionOrEq),
  );
}

/** @internal */
export type CreateCompletionFilterByRouterCompletionsOr$Outbound =
  | CreateCompletionOrEq$Outbound
  | CreateCompletionOrNe$Outbound
  | CreateCompletionOrGt$Outbound
  | CreateCompletionOrGte$Outbound
  | CreateCompletionOrLt$Outbound
  | CreateCompletionOrLte$Outbound
  | CreateCompletionOrIn$Outbound
  | CreateCompletionOrNin$Outbound
  | CreateCompletionOrExists$Outbound;

/** @internal */
export const CreateCompletionFilterByRouterCompletionsOr$outboundSchema:
  z.ZodType<
    CreateCompletionFilterByRouterCompletionsOr$Outbound,
    z.ZodTypeDef,
    CreateCompletionFilterByRouterCompletionsOr
  > = z.union([
    z.lazy(() => CreateCompletionOrEq$outboundSchema),
    z.lazy(() => CreateCompletionOrNe$outboundSchema),
    z.lazy(() => CreateCompletionOrGt$outboundSchema),
    z.lazy(() => CreateCompletionOrGte$outboundSchema),
    z.lazy(() => CreateCompletionOrLt$outboundSchema),
    z.lazy(() => CreateCompletionOrLte$outboundSchema),
    z.lazy(() => CreateCompletionOrIn$outboundSchema),
    z.lazy(() => CreateCompletionOrNin$outboundSchema),
    z.lazy(() => CreateCompletionOrExists$outboundSchema),
  ]);

export function createCompletionFilterByRouterCompletionsOrToJSON(
  createCompletionFilterByRouterCompletionsOr:
    CreateCompletionFilterByRouterCompletionsOr,
): string {
  return JSON.stringify(
    CreateCompletionFilterByRouterCompletionsOr$outboundSchema.parse(
      createCompletionFilterByRouterCompletionsOr,
    ),
  );
}

/** @internal */
export type CreateCompletionFilterByOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | CreateCompletionOrEq$Outbound
        | CreateCompletionOrNe$Outbound
        | CreateCompletionOrGt$Outbound
        | CreateCompletionOrGte$Outbound
        | CreateCompletionOrLt$Outbound
        | CreateCompletionOrLte$Outbound
        | CreateCompletionOrIn$Outbound
        | CreateCompletionOrNin$Outbound
        | CreateCompletionOrExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateCompletionFilterByOr$outboundSchema: z.ZodType<
  CreateCompletionFilterByOr$Outbound,
  z.ZodTypeDef,
  CreateCompletionFilterByOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => CreateCompletionOrEq$outboundSchema),
      z.lazy(() =>
        CreateCompletionOrNe$outboundSchema
      ),
      z.lazy(() => CreateCompletionOrGt$outboundSchema),
      z.lazy(() => CreateCompletionOrGte$outboundSchema),
      z.lazy(() => CreateCompletionOrLt$outboundSchema),
      z.lazy(() => CreateCompletionOrLte$outboundSchema),
      z.lazy(() => CreateCompletionOrIn$outboundSchema),
      z.lazy(() => CreateCompletionOrNin$outboundSchema),
      z.lazy(() => CreateCompletionOrExists$outboundSchema),
    ])),
  ),
});

export function createCompletionFilterByOrToJSON(
  createCompletionFilterByOr: CreateCompletionFilterByOr,
): string {
  return JSON.stringify(
    CreateCompletionFilterByOr$outboundSchema.parse(createCompletionFilterByOr),
  );
}

/** @internal */
export type CreateCompletionAndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateCompletionAndExists$outboundSchema: z.ZodType<
  CreateCompletionAndExists$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndExists
> = z.object({
  exists: z.boolean(),
});

export function createCompletionAndExistsToJSON(
  createCompletionAndExists: CreateCompletionAndExists,
): string {
  return JSON.stringify(
    CreateCompletionAndExists$outboundSchema.parse(createCompletionAndExists),
  );
}

/** @internal */
export type CreateCompletionAndRouterCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionAndRouterCompletionsNin$outboundSchema: z.ZodType<
  CreateCompletionAndRouterCompletionsNin$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndRouterCompletionsNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionAndRouterCompletionsNinToJSON(
  createCompletionAndRouterCompletionsNin:
    CreateCompletionAndRouterCompletionsNin,
): string {
  return JSON.stringify(
    CreateCompletionAndRouterCompletionsNin$outboundSchema.parse(
      createCompletionAndRouterCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateCompletionAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletionAndNin$outboundSchema: z.ZodType<
  CreateCompletionAndNin$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletionAndNinToJSON(
  createCompletionAndNin: CreateCompletionAndNin,
): string {
  return JSON.stringify(
    CreateCompletionAndNin$outboundSchema.parse(createCompletionAndNin),
  );
}

/** @internal */
export type CreateCompletionAndRouterCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionAndRouterCompletionsIn$outboundSchema: z.ZodType<
  CreateCompletionAndRouterCompletionsIn$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndRouterCompletionsIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionAndRouterCompletionsInToJSON(
  createCompletionAndRouterCompletionsIn:
    CreateCompletionAndRouterCompletionsIn,
): string {
  return JSON.stringify(
    CreateCompletionAndRouterCompletionsIn$outboundSchema.parse(
      createCompletionAndRouterCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateCompletionAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletionAndIn$outboundSchema: z.ZodType<
  CreateCompletionAndIn$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletionAndInToJSON(
  createCompletionAndIn: CreateCompletionAndIn,
): string {
  return JSON.stringify(
    CreateCompletionAndIn$outboundSchema.parse(createCompletionAndIn),
  );
}

/** @internal */
export type CreateCompletionAndLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateCompletionAndLte$outboundSchema: z.ZodType<
  CreateCompletionAndLte$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndLte
> = z.object({
  lte: z.number(),
});

export function createCompletionAndLteToJSON(
  createCompletionAndLte: CreateCompletionAndLte,
): string {
  return JSON.stringify(
    CreateCompletionAndLte$outboundSchema.parse(createCompletionAndLte),
  );
}

/** @internal */
export type CreateCompletionAndLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateCompletionAndLt$outboundSchema: z.ZodType<
  CreateCompletionAndLt$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndLt
> = z.object({
  lt: z.number(),
});

export function createCompletionAndLtToJSON(
  createCompletionAndLt: CreateCompletionAndLt,
): string {
  return JSON.stringify(
    CreateCompletionAndLt$outboundSchema.parse(createCompletionAndLt),
  );
}

/** @internal */
export type CreateCompletionAndGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateCompletionAndGte$outboundSchema: z.ZodType<
  CreateCompletionAndGte$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndGte
> = z.object({
  gte: z.number(),
});

export function createCompletionAndGteToJSON(
  createCompletionAndGte: CreateCompletionAndGte,
): string {
  return JSON.stringify(
    CreateCompletionAndGte$outboundSchema.parse(createCompletionAndGte),
  );
}

/** @internal */
export type CreateCompletionAndGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateCompletionAndGt$outboundSchema: z.ZodType<
  CreateCompletionAndGt$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndGt
> = z.object({
  gt: z.number(),
});

export function createCompletionAndGtToJSON(
  createCompletionAndGt: CreateCompletionAndGt,
): string {
  return JSON.stringify(
    CreateCompletionAndGt$outboundSchema.parse(createCompletionAndGt),
  );
}

/** @internal */
export type CreateCompletionAndRouterCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionAndRouterCompletionsNe$outboundSchema: z.ZodType<
  CreateCompletionAndRouterCompletionsNe$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndRouterCompletionsNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionAndRouterCompletionsNeToJSON(
  createCompletionAndRouterCompletionsNe:
    CreateCompletionAndRouterCompletionsNe,
): string {
  return JSON.stringify(
    CreateCompletionAndRouterCompletionsNe$outboundSchema.parse(
      createCompletionAndRouterCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateCompletionAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateCompletionAndNe$outboundSchema: z.ZodType<
  CreateCompletionAndNe$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletionAndNeToJSON(
  createCompletionAndNe: CreateCompletionAndNe,
): string {
  return JSON.stringify(
    CreateCompletionAndNe$outboundSchema.parse(createCompletionAndNe),
  );
}

/** @internal */
export type CreateCompletionAndRouterCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletionAndRouterCompletionsEq$outboundSchema: z.ZodType<
  CreateCompletionAndRouterCompletionsEq$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndRouterCompletionsEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletionAndRouterCompletionsEqToJSON(
  createCompletionAndRouterCompletionsEq:
    CreateCompletionAndRouterCompletionsEq,
): string {
  return JSON.stringify(
    CreateCompletionAndRouterCompletionsEq$outboundSchema.parse(
      createCompletionAndRouterCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateCompletionAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateCompletionAndEq$outboundSchema: z.ZodType<
  CreateCompletionAndEq$Outbound,
  z.ZodTypeDef,
  CreateCompletionAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletionAndEqToJSON(
  createCompletionAndEq: CreateCompletionAndEq,
): string {
  return JSON.stringify(
    CreateCompletionAndEq$outboundSchema.parse(createCompletionAndEq),
  );
}

/** @internal */
export type CreateCompletionFilterByRouterCompletionsAnd$Outbound =
  | CreateCompletionAndEq$Outbound
  | CreateCompletionAndNe$Outbound
  | CreateCompletionAndGt$Outbound
  | CreateCompletionAndGte$Outbound
  | CreateCompletionAndLt$Outbound
  | CreateCompletionAndLte$Outbound
  | CreateCompletionAndIn$Outbound
  | CreateCompletionAndNin$Outbound
  | CreateCompletionAndExists$Outbound;

/** @internal */
export const CreateCompletionFilterByRouterCompletionsAnd$outboundSchema:
  z.ZodType<
    CreateCompletionFilterByRouterCompletionsAnd$Outbound,
    z.ZodTypeDef,
    CreateCompletionFilterByRouterCompletionsAnd
  > = z.union([
    z.lazy(() => CreateCompletionAndEq$outboundSchema),
    z.lazy(() => CreateCompletionAndNe$outboundSchema),
    z.lazy(() => CreateCompletionAndGt$outboundSchema),
    z.lazy(() => CreateCompletionAndGte$outboundSchema),
    z.lazy(() => CreateCompletionAndLt$outboundSchema),
    z.lazy(() => CreateCompletionAndLte$outboundSchema),
    z.lazy(() => CreateCompletionAndIn$outboundSchema),
    z.lazy(() => CreateCompletionAndNin$outboundSchema),
    z.lazy(() => CreateCompletionAndExists$outboundSchema),
  ]);

export function createCompletionFilterByRouterCompletionsAndToJSON(
  createCompletionFilterByRouterCompletionsAnd:
    CreateCompletionFilterByRouterCompletionsAnd,
): string {
  return JSON.stringify(
    CreateCompletionFilterByRouterCompletionsAnd$outboundSchema.parse(
      createCompletionFilterByRouterCompletionsAnd,
    ),
  );
}

/** @internal */
export type CreateCompletionFilterByAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | CreateCompletionAndEq$Outbound
        | CreateCompletionAndNe$Outbound
        | CreateCompletionAndGt$Outbound
        | CreateCompletionAndGte$Outbound
        | CreateCompletionAndLt$Outbound
        | CreateCompletionAndLte$Outbound
        | CreateCompletionAndIn$Outbound
        | CreateCompletionAndNin$Outbound
        | CreateCompletionAndExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateCompletionFilterByAnd$outboundSchema: z.ZodType<
  CreateCompletionFilterByAnd$Outbound,
  z.ZodTypeDef,
  CreateCompletionFilterByAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => CreateCompletionAndEq$outboundSchema),
      z.lazy(() =>
        CreateCompletionAndNe$outboundSchema
      ),
      z.lazy(() => CreateCompletionAndGt$outboundSchema),
      z.lazy(() => CreateCompletionAndGte$outboundSchema),
      z.lazy(() => CreateCompletionAndLt$outboundSchema),
      z.lazy(() => CreateCompletionAndLte$outboundSchema),
      z.lazy(() => CreateCompletionAndIn$outboundSchema),
      z.lazy(() => CreateCompletionAndNin$outboundSchema),
      z.lazy(() => CreateCompletionAndExists$outboundSchema),
    ])),
  ),
});

export function createCompletionFilterByAndToJSON(
  createCompletionFilterByAnd: CreateCompletionFilterByAnd,
): string {
  return JSON.stringify(
    CreateCompletionFilterByAnd$outboundSchema.parse(
      createCompletionFilterByAnd,
    ),
  );
}

/** @internal */
export type CreateCompletion1Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateCompletion1Exists$outboundSchema: z.ZodType<
  CreateCompletion1Exists$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Exists
> = z.object({
  exists: z.boolean(),
});

export function createCompletion1ExistsToJSON(
  createCompletion1Exists: CreateCompletion1Exists,
): string {
  return JSON.stringify(
    CreateCompletion1Exists$outboundSchema.parse(createCompletion1Exists),
  );
}

/** @internal */
export type CreateCompletion1RouterCompletionsNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletion1RouterCompletionsNin$outboundSchema: z.ZodType<
  CreateCompletion1RouterCompletionsNin$Outbound,
  z.ZodTypeDef,
  CreateCompletion1RouterCompletionsNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletion1RouterCompletionsNinToJSON(
  createCompletion1RouterCompletionsNin: CreateCompletion1RouterCompletionsNin,
): string {
  return JSON.stringify(
    CreateCompletion1RouterCompletionsNin$outboundSchema.parse(
      createCompletion1RouterCompletionsNin,
    ),
  );
}

/** @internal */
export type CreateCompletion1Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletion1Nin$outboundSchema: z.ZodType<
  CreateCompletion1Nin$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Nin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletion1NinToJSON(
  createCompletion1Nin: CreateCompletion1Nin,
): string {
  return JSON.stringify(
    CreateCompletion1Nin$outboundSchema.parse(createCompletion1Nin),
  );
}

/** @internal */
export type CreateCompletion1RouterCompletionsIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletion1RouterCompletionsIn$outboundSchema: z.ZodType<
  CreateCompletion1RouterCompletionsIn$Outbound,
  z.ZodTypeDef,
  CreateCompletion1RouterCompletionsIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletion1RouterCompletionsInToJSON(
  createCompletion1RouterCompletionsIn: CreateCompletion1RouterCompletionsIn,
): string {
  return JSON.stringify(
    CreateCompletion1RouterCompletionsIn$outboundSchema.parse(
      createCompletion1RouterCompletionsIn,
    ),
  );
}

/** @internal */
export type CreateCompletion1In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateCompletion1In$outboundSchema: z.ZodType<
  CreateCompletion1In$Outbound,
  z.ZodTypeDef,
  CreateCompletion1In
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createCompletion1InToJSON(
  createCompletion1In: CreateCompletion1In,
): string {
  return JSON.stringify(
    CreateCompletion1In$outboundSchema.parse(createCompletion1In),
  );
}

/** @internal */
export type CreateCompletion1Lte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateCompletion1Lte$outboundSchema: z.ZodType<
  CreateCompletion1Lte$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Lte
> = z.object({
  lte: z.number(),
});

export function createCompletion1LteToJSON(
  createCompletion1Lte: CreateCompletion1Lte,
): string {
  return JSON.stringify(
    CreateCompletion1Lte$outboundSchema.parse(createCompletion1Lte),
  );
}

/** @internal */
export type CreateCompletion1Lt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateCompletion1Lt$outboundSchema: z.ZodType<
  CreateCompletion1Lt$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Lt
> = z.object({
  lt: z.number(),
});

export function createCompletion1LtToJSON(
  createCompletion1Lt: CreateCompletion1Lt,
): string {
  return JSON.stringify(
    CreateCompletion1Lt$outboundSchema.parse(createCompletion1Lt),
  );
}

/** @internal */
export type CreateCompletion1Gte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateCompletion1Gte$outboundSchema: z.ZodType<
  CreateCompletion1Gte$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Gte
> = z.object({
  gte: z.number(),
});

export function createCompletion1GteToJSON(
  createCompletion1Gte: CreateCompletion1Gte,
): string {
  return JSON.stringify(
    CreateCompletion1Gte$outboundSchema.parse(createCompletion1Gte),
  );
}

/** @internal */
export type CreateCompletion1Gt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateCompletion1Gt$outboundSchema: z.ZodType<
  CreateCompletion1Gt$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Gt
> = z.object({
  gt: z.number(),
});

export function createCompletion1GtToJSON(
  createCompletion1Gt: CreateCompletion1Gt,
): string {
  return JSON.stringify(
    CreateCompletion1Gt$outboundSchema.parse(createCompletion1Gt),
  );
}

/** @internal */
export type CreateCompletion1RouterCompletionsNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletion1RouterCompletionsNe$outboundSchema: z.ZodType<
  CreateCompletion1RouterCompletionsNe$Outbound,
  z.ZodTypeDef,
  CreateCompletion1RouterCompletionsNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletion1RouterCompletionsNeToJSON(
  createCompletion1RouterCompletionsNe: CreateCompletion1RouterCompletionsNe,
): string {
  return JSON.stringify(
    CreateCompletion1RouterCompletionsNe$outboundSchema.parse(
      createCompletion1RouterCompletionsNe,
    ),
  );
}

/** @internal */
export type CreateCompletion1Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateCompletion1Ne$outboundSchema: z.ZodType<
  CreateCompletion1Ne$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Ne
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletion1NeToJSON(
  createCompletion1Ne: CreateCompletion1Ne,
): string {
  return JSON.stringify(
    CreateCompletion1Ne$outboundSchema.parse(createCompletion1Ne),
  );
}

/** @internal */
export type CreateCompletion1RouterCompletionsEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateCompletion1RouterCompletionsEq$outboundSchema: z.ZodType<
  CreateCompletion1RouterCompletionsEq$Outbound,
  z.ZodTypeDef,
  CreateCompletion1RouterCompletionsEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createCompletion1RouterCompletionsEqToJSON(
  createCompletion1RouterCompletionsEq: CreateCompletion1RouterCompletionsEq,
): string {
  return JSON.stringify(
    CreateCompletion1RouterCompletionsEq$outboundSchema.parse(
      createCompletion1RouterCompletionsEq,
    ),
  );
}

/** @internal */
export type CreateCompletion1Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateCompletion1Eq$outboundSchema: z.ZodType<
  CreateCompletion1Eq$Outbound,
  z.ZodTypeDef,
  CreateCompletion1Eq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createCompletion1EqToJSON(
  createCompletion1Eq: CreateCompletion1Eq,
): string {
  return JSON.stringify(
    CreateCompletion1Eq$outboundSchema.parse(createCompletion1Eq),
  );
}

/** @internal */
export type CreateCompletionFilterBy1$Outbound =
  | CreateCompletion1Eq$Outbound
  | CreateCompletion1Ne$Outbound
  | CreateCompletion1Gt$Outbound
  | CreateCompletion1Gte$Outbound
  | CreateCompletion1Lt$Outbound
  | CreateCompletion1Lte$Outbound
  | CreateCompletion1In$Outbound
  | CreateCompletion1Nin$Outbound
  | CreateCompletion1Exists$Outbound;

/** @internal */
export const CreateCompletionFilterBy1$outboundSchema: z.ZodType<
  CreateCompletionFilterBy1$Outbound,
  z.ZodTypeDef,
  CreateCompletionFilterBy1
> = z.union([
  z.lazy(() => CreateCompletion1Eq$outboundSchema),
  z.lazy(() => CreateCompletion1Ne$outboundSchema),
  z.lazy(() => CreateCompletion1Gt$outboundSchema),
  z.lazy(() => CreateCompletion1Gte$outboundSchema),
  z.lazy(() => CreateCompletion1Lt$outboundSchema),
  z.lazy(() => CreateCompletion1Lte$outboundSchema),
  z.lazy(() => CreateCompletion1In$outboundSchema),
  z.lazy(() => CreateCompletion1Nin$outboundSchema),
  z.lazy(() => CreateCompletion1Exists$outboundSchema),
]);

export function createCompletionFilterBy1ToJSON(
  createCompletionFilterBy1: CreateCompletionFilterBy1,
): string {
  return JSON.stringify(
    CreateCompletionFilterBy1$outboundSchema.parse(createCompletionFilterBy1),
  );
}

/** @internal */
export type CreateCompletionFilterBy$Outbound =
  | CreateCompletionFilterByAnd$Outbound
  | CreateCompletionFilterByOr$Outbound
  | {
    [k: string]:
      | CreateCompletion1Eq$Outbound
      | CreateCompletion1Ne$Outbound
      | CreateCompletion1Gt$Outbound
      | CreateCompletion1Gte$Outbound
      | CreateCompletion1Lt$Outbound
      | CreateCompletion1Lte$Outbound
      | CreateCompletion1In$Outbound
      | CreateCompletion1Nin$Outbound
      | CreateCompletion1Exists$Outbound;
  };

/** @internal */
export const CreateCompletionFilterBy$outboundSchema: z.ZodType<
  CreateCompletionFilterBy$Outbound,
  z.ZodTypeDef,
  CreateCompletionFilterBy
> = z.union([
  z.lazy(() => CreateCompletionFilterByAnd$outboundSchema),
  z.lazy(() => CreateCompletionFilterByOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => CreateCompletion1Eq$outboundSchema),
    z.lazy(() => CreateCompletion1Ne$outboundSchema),
    z.lazy(() => CreateCompletion1Gt$outboundSchema),
    z.lazy(() => CreateCompletion1Gte$outboundSchema),
    z.lazy(() => CreateCompletion1Lt$outboundSchema),
    z.lazy(() => CreateCompletion1Lte$outboundSchema),
    z.lazy(() => CreateCompletion1In$outboundSchema),
    z.lazy(() => CreateCompletion1Nin$outboundSchema),
    z.lazy(() => CreateCompletion1Exists$outboundSchema),
  ])),
]);

export function createCompletionFilterByToJSON(
  createCompletionFilterBy: CreateCompletionFilterBy,
): string {
  return JSON.stringify(
    CreateCompletionFilterBy$outboundSchema.parse(createCompletionFilterBy),
  );
}

/** @internal */
export type CreateCompletionSearchOptions$Outbound = {
  include_vectors?: boolean | undefined;
  include_metadata?: boolean | undefined;
  include_scores?: boolean | undefined;
};

/** @internal */
export const CreateCompletionSearchOptions$outboundSchema: z.ZodType<
  CreateCompletionSearchOptions$Outbound,
  z.ZodTypeDef,
  CreateCompletionSearchOptions
> = z.object({
  includeVectors: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeScores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeVectors: "include_vectors",
    includeMetadata: "include_metadata",
    includeScores: "include_scores",
  });
});

export function createCompletionSearchOptionsToJSON(
  createCompletionSearchOptions: CreateCompletionSearchOptions,
): string {
  return JSON.stringify(
    CreateCompletionSearchOptions$outboundSchema.parse(
      createCompletionSearchOptions,
    ),
  );
}

/** @internal */
export type CreateCompletionRerankConfig$Outbound = {
  model: string;
  threshold: number;
  top_k: number;
};

/** @internal */
export const CreateCompletionRerankConfig$outboundSchema: z.ZodType<
  CreateCompletionRerankConfig$Outbound,
  z.ZodTypeDef,
  CreateCompletionRerankConfig
> = z.object({
  model: z.string(),
  threshold: z.number().default(0),
  topK: z.number().int().default(10),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
  });
});

export function createCompletionRerankConfigToJSON(
  createCompletionRerankConfig: CreateCompletionRerankConfig,
): string {
  return JSON.stringify(
    CreateCompletionRerankConfig$outboundSchema.parse(
      createCompletionRerankConfig,
    ),
  );
}

/** @internal */
export type CreateCompletionAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const CreateCompletionAgenticRagConfig$outboundSchema: z.ZodType<
  CreateCompletionAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  CreateCompletionAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function createCompletionAgenticRagConfigToJSON(
  createCompletionAgenticRagConfig: CreateCompletionAgenticRagConfig,
): string {
  return JSON.stringify(
    CreateCompletionAgenticRagConfig$outboundSchema.parse(
      createCompletionAgenticRagConfig,
    ),
  );
}

/** @internal */
export type CreateCompletionKnowledgeBases$Outbound = {
  top_k?: number | undefined;
  threshold?: number | undefined;
  search_type: string;
  filter_by?:
    | CreateCompletionFilterByAnd$Outbound
    | CreateCompletionFilterByOr$Outbound
    | {
      [k: string]:
        | CreateCompletion1Eq$Outbound
        | CreateCompletion1Ne$Outbound
        | CreateCompletion1Gt$Outbound
        | CreateCompletion1Gte$Outbound
        | CreateCompletion1Lt$Outbound
        | CreateCompletion1Lte$Outbound
        | CreateCompletion1In$Outbound
        | CreateCompletion1Nin$Outbound
        | CreateCompletion1Exists$Outbound;
    }
    | undefined;
  search_options?: CreateCompletionSearchOptions$Outbound | undefined;
  rerank_config?: CreateCompletionRerankConfig$Outbound | undefined;
  agentic_rag_config?: CreateCompletionAgenticRagConfig$Outbound | undefined;
  knowledge_id: string;
  query?: string | undefined;
};

/** @internal */
export const CreateCompletionKnowledgeBases$outboundSchema: z.ZodType<
  CreateCompletionKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateCompletionKnowledgeBases
> = z.object({
  topK: z.number().int().optional(),
  threshold: z.number().optional(),
  searchType: CreateCompletionSearchType$outboundSchema.default(
    "hybrid_search",
  ),
  filterBy: z.union([
    z.lazy(() => CreateCompletionFilterByAnd$outboundSchema),
    z.lazy(() => CreateCompletionFilterByOr$outboundSchema),
    z.record(z.union([
      z.lazy(() => CreateCompletion1Eq$outboundSchema),
      z.lazy(() => CreateCompletion1Ne$outboundSchema),
      z.lazy(() => CreateCompletion1Gt$outboundSchema),
      z.lazy(() => CreateCompletion1Gte$outboundSchema),
      z.lazy(() => CreateCompletion1Lt$outboundSchema),
      z.lazy(() => CreateCompletion1Lte$outboundSchema),
      z.lazy(() => CreateCompletion1In$outboundSchema),
      z.lazy(() => CreateCompletion1Nin$outboundSchema),
      z.lazy(() => CreateCompletion1Exists$outboundSchema),
    ])),
  ]).optional(),
  searchOptions: z.lazy(() => CreateCompletionSearchOptions$outboundSchema)
    .optional(),
  rerankConfig: z.lazy(() => CreateCompletionRerankConfig$outboundSchema)
    .optional(),
  agenticRagConfig: z.lazy(() =>
    CreateCompletionAgenticRagConfig$outboundSchema
  ).optional(),
  knowledgeId: z.string(),
  query: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    searchType: "search_type",
    filterBy: "filter_by",
    searchOptions: "search_options",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
    knowledgeId: "knowledge_id",
  });
});

export function createCompletionKnowledgeBasesToJSON(
  createCompletionKnowledgeBases: CreateCompletionKnowledgeBases,
): string {
  return JSON.stringify(
    CreateCompletionKnowledgeBases$outboundSchema.parse(
      createCompletionKnowledgeBases,
    ),
  );
}

/** @internal */
export const CreateCompletionLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateCompletionLoadBalancerType
> = z.nativeEnum(CreateCompletionLoadBalancerType);

/** @internal */
export type CreateCompletionLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateCompletionLoadBalancerModels$outboundSchema: z.ZodType<
  CreateCompletionLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateCompletionLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createCompletionLoadBalancerModelsToJSON(
  createCompletionLoadBalancerModels: CreateCompletionLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateCompletionLoadBalancerModels$outboundSchema.parse(
      createCompletionLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateCompletionLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateCompletionLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateCompletionLoadBalancer1$outboundSchema: z.ZodType<
  CreateCompletionLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateCompletionLoadBalancer1
> = z.object({
  type: CreateCompletionLoadBalancerType$outboundSchema,
  models: z.array(
    z.lazy(() => CreateCompletionLoadBalancerModels$outboundSchema),
  ),
});

export function createCompletionLoadBalancer1ToJSON(
  createCompletionLoadBalancer1: CreateCompletionLoadBalancer1,
): string {
  return JSON.stringify(
    CreateCompletionLoadBalancer1$outboundSchema.parse(
      createCompletionLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateCompletionLoadBalancer$Outbound =
  CreateCompletionLoadBalancer1$Outbound;

/** @internal */
export const CreateCompletionLoadBalancer$outboundSchema: z.ZodType<
  CreateCompletionLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateCompletionLoadBalancer
> = z.lazy(() => CreateCompletionLoadBalancer1$outboundSchema);

export function createCompletionLoadBalancerToJSON(
  createCompletionLoadBalancer: CreateCompletionLoadBalancer,
): string {
  return JSON.stringify(
    CreateCompletionLoadBalancer$outboundSchema.parse(
      createCompletionLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateCompletionTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateCompletionTimeout$outboundSchema: z.ZodType<
  CreateCompletionTimeout$Outbound,
  z.ZodTypeDef,
  CreateCompletionTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createCompletionTimeoutToJSON(
  createCompletionTimeout: CreateCompletionTimeout,
): string {
  return JSON.stringify(
    CreateCompletionTimeout$outboundSchema.parse(createCompletionTimeout),
  );
}

/** @internal */
export type CreateCompletionOrq$Outbound = {
  name?: string | undefined;
  retry?: CreateCompletionRetry$Outbound | undefined;
  fallbacks?: Array<CreateCompletionFallbacks$Outbound> | undefined;
  prompt?: CreateCompletionPrompt$Outbound | undefined;
  identity?: components.PublicIdentity$Outbound | undefined;
  contact?: components.PublicContact$Outbound | undefined;
  thread?: CreateCompletionThread$Outbound | undefined;
  inputs?:
    | { [k: string]: any }
    | Array<CreateCompletionInputs2$Outbound>
    | undefined;
  cache?: CreateCompletionCache$Outbound | undefined;
  knowledge_bases?: Array<CreateCompletionKnowledgeBases$Outbound> | undefined;
  load_balancer?: CreateCompletionLoadBalancer1$Outbound | undefined;
  timeout?: CreateCompletionTimeout$Outbound | undefined;
};

/** @internal */
export const CreateCompletionOrq$outboundSchema: z.ZodType<
  CreateCompletionOrq$Outbound,
  z.ZodTypeDef,
  CreateCompletionOrq
> = z.object({
  name: z.string().optional(),
  retry: z.lazy(() => CreateCompletionRetry$outboundSchema).optional(),
  fallbacks: z.array(z.lazy(() => CreateCompletionFallbacks$outboundSchema))
    .optional(),
  prompt: z.lazy(() => CreateCompletionPrompt$outboundSchema).optional(),
  identity: components.PublicIdentity$outboundSchema.optional(),
  contact: components.PublicContact$outboundSchema.optional(),
  thread: z.lazy(() => CreateCompletionThread$outboundSchema).optional(),
  inputs: z.union([
    z.record(z.any()),
    z.array(z.lazy(() => CreateCompletionInputs2$outboundSchema)),
  ]).optional(),
  cache: z.lazy(() => CreateCompletionCache$outboundSchema).optional(),
  knowledgeBases: z.array(
    z.lazy(() => CreateCompletionKnowledgeBases$outboundSchema),
  ).optional(),
  loadBalancer: z.lazy(() => CreateCompletionLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateCompletionTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    knowledgeBases: "knowledge_bases",
    loadBalancer: "load_balancer",
  });
});

export function createCompletionOrqToJSON(
  createCompletionOrq: CreateCompletionOrq,
): string {
  return JSON.stringify(
    CreateCompletionOrq$outboundSchema.parse(createCompletionOrq),
  );
}

/** @internal */
export type CreateCompletionRequestBody$Outbound = {
  model: string;
  prompt: string;
  echo: boolean | null;
  frequency_penalty: number | null;
  max_tokens: number | null;
  presence_penalty: number | null;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  temperature: number | null;
  top_p: number | null;
  n: number | null;
  user?: string | undefined;
  orq?: CreateCompletionOrq$Outbound | undefined;
  stream: boolean;
};

/** @internal */
export const CreateCompletionRequestBody$outboundSchema: z.ZodType<
  CreateCompletionRequestBody$Outbound,
  z.ZodTypeDef,
  CreateCompletionRequestBody
> = z.object({
  model: z.string(),
  prompt: z.string(),
  echo: z.nullable(z.boolean().default(false)),
  frequencyPenalty: z.nullable(z.number().default(0)),
  maxTokens: z.nullable(z.number().default(16)),
  presencePenalty: z.nullable(z.number().default(0)),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  temperature: z.nullable(z.number().default(1)),
  topP: z.nullable(z.number().default(1)),
  n: z.nullable(z.number().default(1)),
  user: z.string().optional(),
  orq: z.lazy(() => CreateCompletionOrq$outboundSchema).optional(),
  stream: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    presencePenalty: "presence_penalty",
    topP: "top_p",
  });
});

export function createCompletionRequestBodyToJSON(
  createCompletionRequestBody: CreateCompletionRequestBody,
): string {
  return JSON.stringify(
    CreateCompletionRequestBody$outboundSchema.parse(
      createCompletionRequestBody,
    ),
  );
}

/** @internal */
export const CreateCompletionRouterCompletionsFinishReason$inboundSchema:
  z.ZodNativeEnum<typeof CreateCompletionRouterCompletionsFinishReason> = z
    .nativeEnum(CreateCompletionRouterCompletionsFinishReason);

/** @internal */
export const CreateCompletionRouterCompletionsChoices$inboundSchema: z.ZodType<
  CreateCompletionRouterCompletionsChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: CreateCompletionRouterCompletionsFinishReason$inboundSchema,
  index: z.number(),
  text: z.string(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});

export function createCompletionRouterCompletionsChoicesFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCompletionRouterCompletionsChoices,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionRouterCompletionsChoices$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCompletionRouterCompletionsChoices' from JSON`,
  );
}

/** @internal */
export const CreateCompletionCreated$inboundSchema: z.ZodType<
  CreateCompletionCreated,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number()]);

export function createCompletionCreatedFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionCreated, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionCreated$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionCreated' from JSON`,
  );
}

/** @internal */
export const CreateCompletionRouterCompletionsPromptTokensDetails$inboundSchema:
  z.ZodType<
    CreateCompletionRouterCompletionsPromptTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    cached_tokens: z.nullable(z.number().int()).optional(),
    cache_creation_tokens: z.nullable(z.number().int()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "cache_creation_tokens": "cacheCreationTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function createCompletionRouterCompletionsPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCompletionRouterCompletionsPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionRouterCompletionsPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCompletionRouterCompletionsPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateCompletionRouterCompletionsCompletionTokensDetails$inboundSchema:
  z.ZodType<
    CreateCompletionRouterCompletionsCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });

export function createCompletionRouterCompletionsCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCompletionRouterCompletionsCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionRouterCompletionsCompletionTokensDetails$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionRouterCompletionsCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateCompletionRouterCompletionsUsage$inboundSchema: z.ZodType<
  CreateCompletionRouterCompletionsUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() =>
      CreateCompletionRouterCompletionsPromptTokensDetails$inboundSchema
    ),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() =>
      CreateCompletionRouterCompletionsCompletionTokensDetails$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});

export function createCompletionRouterCompletionsUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionRouterCompletionsUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionRouterCompletionsUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionRouterCompletionsUsage' from JSON`,
  );
}

/** @internal */
export const CreateCompletionData$inboundSchema: z.ZodType<
  CreateCompletionData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(
    z.lazy(() => CreateCompletionRouterCompletionsChoices$inboundSchema),
  ),
  created: z.union([z.string(), z.number()]).optional(),
  model: z.string(),
  system_fingerprint: z.string().optional(),
  object: z.string(),
  usage: z.lazy(() => CreateCompletionRouterCompletionsUsage$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});

export function createCompletionDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionData' from JSON`,
  );
}

/** @internal */
export const CreateCompletionRouterCompletionsResponseBody$inboundSchema:
  z.ZodType<
    CreateCompletionRouterCompletionsResponseBody,
    z.ZodTypeDef,
    unknown
  > = z.object({
    data: z.string().optional().transform((v, ctx) => {
      if (v === undefined) return undefined;
      try {
        return JSON.parse(v);
      } catch (err) {
        ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
        return z.NEVER;
      }
    }).pipe(z.lazy(() => CreateCompletionData$inboundSchema).optional()),
  });

export function createCompletionRouterCompletionsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCompletionRouterCompletionsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionRouterCompletionsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCompletionRouterCompletionsResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateCompletionFinishReason$inboundSchema: z.ZodNativeEnum<
  typeof CreateCompletionFinishReason
> = z.nativeEnum(CreateCompletionFinishReason);

/** @internal */
export const CreateCompletionChoices$inboundSchema: z.ZodType<
  CreateCompletionChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: CreateCompletionFinishReason$inboundSchema,
  index: z.number(),
  text: z.string(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});

export function createCompletionChoicesFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionChoices' from JSON`,
  );
}

/** @internal */
export const Created$inboundSchema: z.ZodType<Created, z.ZodTypeDef, unknown> =
  z.union([z.string(), z.number()]);

export function createdFromJSON(
  jsonString: string,
): SafeParseResult<Created, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Created$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Created' from JSON`,
  );
}

/** @internal */
export const CreateCompletionPromptTokensDetails$inboundSchema: z.ZodType<
  CreateCompletionPromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  cache_creation_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "cache_creation_tokens": "cacheCreationTokens",
    "audio_tokens": "audioTokens",
  });
});

export function createCompletionPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionPromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionPromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateCompletionCompletionTokensDetails$inboundSchema: z.ZodType<
  CreateCompletionCompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});

export function createCompletionCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateCompletionCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateCompletionCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateCompletionCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateCompletionUsage$inboundSchema: z.ZodType<
  CreateCompletionUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => CreateCompletionPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CreateCompletionCompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});

export function createCompletionUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionUsage' from JSON`,
  );
}

/** @internal */
export const CreateCompletionResponseBody$inboundSchema: z.ZodType<
  CreateCompletionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => CreateCompletionChoices$inboundSchema)),
  created: z.union([z.string(), z.number()]).optional(),
  model: z.string(),
  system_fingerprint: z.string().optional(),
  object: z.string(),
  usage: z.lazy(() => CreateCompletionUsage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});

export function createCompletionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateCompletionResponse$inboundSchema: z.ZodType<
  CreateCompletionResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateCompletionResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() =>
            CreateCompletionRouterCompletionsResponseBody$inboundSchema
          ).parse(rawEvent),
        };
      });
    }),
]);

export function createCompletionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateCompletionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateCompletionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateCompletionResponse' from JSON`,
  );
}
