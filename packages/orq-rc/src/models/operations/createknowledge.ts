/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const CreateKnowledgeRequestBodyKnowledgeType = {
  External: "external",
} as const;
export type CreateKnowledgeRequestBodyKnowledgeType = ClosedEnum<
  typeof CreateKnowledgeRequestBodyKnowledgeType
>;

export type ExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
  /**
   * The API key to access the external knowledge base.
   */
  apiKey: string;
};

export type RequestBody2 = {
  type?: CreateKnowledgeRequestBodyKnowledgeType | undefined;
  key: string;
  description?: string | undefined;
  externalConfig: ExternalConfig;
};

export const CreateKnowledgeRequestBodyType = {
  Internal: "internal",
} as const;
export type CreateKnowledgeRequestBodyType = ClosedEnum<
  typeof CreateKnowledgeRequestBodyType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const RetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type RetrievalType = ClosedEnum<typeof RetrievalType>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type CreateKnowledgeRequestBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type CreateKnowledgeRequestBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type RetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: RetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: CreateKnowledgeRequestBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | CreateKnowledgeRequestBodyAgenticRagConfig
    | null
    | undefined;
};

export type RequestBody1 = {
  type?: CreateKnowledgeRequestBodyType | undefined;
  key: string;
  description?: string | undefined;
  /**
   * The embeddings model to use for the knowledge base in the format "provider/model" for public models or "workspaceKey@provider/model" for private workspace models. This model will be used to embed the chunks when they are added to the knowledge base.
   */
  embeddingModel: string;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: RetrievalSettings | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
};

export type CreateKnowledgeRequestBody = RequestBody1 | RequestBody2;

export const CreateKnowledgeResponseBodyKnowledgeType = {
  External: "external",
} as const;
export type CreateKnowledgeResponseBodyKnowledgeType = ClosedEnum<
  typeof CreateKnowledgeResponseBodyKnowledgeType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type CreateKnowledgeResponseBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type CreateKnowledgeResponseBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type CreateKnowledgeResponseBodyRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: CreateKnowledgeResponseBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?:
    | CreateKnowledgeResponseBodyAgenticRagConfig
    | null
    | undefined;
};

export type ResponseBodyExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
};

export type ResponseBody2 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: CreateKnowledgeResponseBodyKnowledgeType | undefined;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?: CreateKnowledgeResponseBodyRetrievalSettings | undefined;
  externalConfig: ResponseBodyExternalConfig;
};

export const CreateKnowledgeResponseBodyType = {
  Internal: "internal",
} as const;
export type CreateKnowledgeResponseBodyType = ClosedEnum<
  typeof CreateKnowledgeResponseBodyType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const ResponseBodyRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type ResponseBodyRetrievalType = ClosedEnum<
  typeof ResponseBodyRetrievalType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type ResponseBodyRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type ResponseBodyAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type ResponseBodyRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: ResponseBodyRetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: ResponseBodyRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: ResponseBodyAgenticRagConfig | null | undefined;
};

export type ResponseBody1 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: CreateKnowledgeResponseBodyType | undefined;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: ResponseBodyRetrievalSettings | undefined;
  /**
   * The embeddings model used for the knowledge base.
   */
  model: string;
};

/**
 * Knowledge successfully created
 */
export type CreateKnowledgeResponseBody = ResponseBody1 | ResponseBody2;

/** @internal */
export const CreateKnowledgeRequestBodyKnowledgeType$inboundSchema:
  z.ZodNativeEnum<typeof CreateKnowledgeRequestBodyKnowledgeType> = z
    .nativeEnum(CreateKnowledgeRequestBodyKnowledgeType);
/** @internal */
export const CreateKnowledgeRequestBodyKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof CreateKnowledgeRequestBodyKnowledgeType> =
    CreateKnowledgeRequestBodyKnowledgeType$inboundSchema;

/** @internal */
export const ExternalConfig$inboundSchema: z.ZodType<
  ExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
  api_key: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
    "api_key": "apiKey",
  });
});
/** @internal */
export type ExternalConfig$Outbound = {
  name: string;
  api_url: string;
  api_key: string;
};

/** @internal */
export const ExternalConfig$outboundSchema: z.ZodType<
  ExternalConfig$Outbound,
  z.ZodTypeDef,
  ExternalConfig
> = z.object({
  name: z.string(),
  apiUrl: z.string(),
  apiKey: z.string(),
}).transform((v) => {
  return remap$(v, {
    apiUrl: "api_url",
    apiKey: "api_key",
  });
});

export function externalConfigToJSON(externalConfig: ExternalConfig): string {
  return JSON.stringify(ExternalConfig$outboundSchema.parse(externalConfig));
}
export function externalConfigFromJSON(
  jsonString: string,
): SafeParseResult<ExternalConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ExternalConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ExternalConfig' from JSON`,
  );
}

/** @internal */
export const RequestBody2$inboundSchema: z.ZodType<
  RequestBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateKnowledgeRequestBodyKnowledgeType$inboundSchema.default(
    "external",
  ),
  key: z.string(),
  description: z.string().optional(),
  external_config: z.lazy(() => ExternalConfig$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "external_config": "externalConfig",
  });
});
/** @internal */
export type RequestBody2$Outbound = {
  type: string;
  key: string;
  description?: string | undefined;
  external_config: ExternalConfig$Outbound;
};

/** @internal */
export const RequestBody2$outboundSchema: z.ZodType<
  RequestBody2$Outbound,
  z.ZodTypeDef,
  RequestBody2
> = z.object({
  type: CreateKnowledgeRequestBodyKnowledgeType$outboundSchema.default(
    "external",
  ),
  key: z.string(),
  description: z.string().optional(),
  externalConfig: z.lazy(() => ExternalConfig$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    externalConfig: "external_config",
  });
});

export function requestBody2ToJSON(requestBody2: RequestBody2): string {
  return JSON.stringify(RequestBody2$outboundSchema.parse(requestBody2));
}
export function requestBody2FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody2' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateKnowledgeRequestBodyType
> = z.nativeEnum(CreateKnowledgeRequestBodyType);
/** @internal */
export const CreateKnowledgeRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateKnowledgeRequestBodyType
> = CreateKnowledgeRequestBodyType$inboundSchema;

/** @internal */
export const RetrievalType$inboundSchema: z.ZodNativeEnum<
  typeof RetrievalType
> = z.nativeEnum(RetrievalType);
/** @internal */
export const RetrievalType$outboundSchema: z.ZodNativeEnum<
  typeof RetrievalType
> = RetrievalType$inboundSchema;

/** @internal */
export const CreateKnowledgeRequestBodyRerankConfig$inboundSchema: z.ZodType<
  CreateKnowledgeRequestBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type CreateKnowledgeRequestBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const CreateKnowledgeRequestBodyRerankConfig$outboundSchema: z.ZodType<
  CreateKnowledgeRequestBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  CreateKnowledgeRequestBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function createKnowledgeRequestBodyRerankConfigToJSON(
  createKnowledgeRequestBodyRerankConfig:
    CreateKnowledgeRequestBodyRerankConfig,
): string {
  return JSON.stringify(
    CreateKnowledgeRequestBodyRerankConfig$outboundSchema.parse(
      createKnowledgeRequestBodyRerankConfig,
    ),
  );
}
export function createKnowledgeRequestBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<CreateKnowledgeRequestBodyRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateKnowledgeRequestBodyRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateKnowledgeRequestBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeRequestBodyAgenticRagConfig$inboundSchema:
  z.ZodType<CreateKnowledgeRequestBodyAgenticRagConfig, z.ZodTypeDef, unknown> =
    z.object({
      model: z.string(),
    });
/** @internal */
export type CreateKnowledgeRequestBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const CreateKnowledgeRequestBodyAgenticRagConfig$outboundSchema:
  z.ZodType<
    CreateKnowledgeRequestBodyAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    CreateKnowledgeRequestBodyAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function createKnowledgeRequestBodyAgenticRagConfigToJSON(
  createKnowledgeRequestBodyAgenticRagConfig:
    CreateKnowledgeRequestBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    CreateKnowledgeRequestBodyAgenticRagConfig$outboundSchema.parse(
      createKnowledgeRequestBodyAgenticRagConfig,
    ),
  );
}
export function createKnowledgeRequestBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateKnowledgeRequestBodyAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateKnowledgeRequestBodyAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateKnowledgeRequestBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const RetrievalSettings$inboundSchema: z.ZodType<
  RetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  retrieval_type: RetrievalType$inboundSchema.default("hybrid_search"),
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(
    z.lazy(() => CreateKnowledgeRequestBodyRerankConfig$inboundSchema),
  ).optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => CreateKnowledgeRequestBodyAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "retrieval_type": "retrievalType",
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});
/** @internal */
export type RetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?:
    | CreateKnowledgeRequestBodyRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | CreateKnowledgeRequestBodyAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const RetrievalSettings$outboundSchema: z.ZodType<
  RetrievalSettings$Outbound,
  z.ZodTypeDef,
  RetrievalSettings
> = z.object({
  retrievalType: RetrievalType$outboundSchema.default("hybrid_search"),
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(
    z.lazy(() => CreateKnowledgeRequestBodyRerankConfig$outboundSchema),
  ).optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => CreateKnowledgeRequestBodyAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    retrievalType: "retrieval_type",
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function retrievalSettingsToJSON(
  retrievalSettings: RetrievalSettings,
): string {
  return JSON.stringify(
    RetrievalSettings$outboundSchema.parse(retrievalSettings),
  );
}
export function retrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<RetrievalSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrievalSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrievalSettings' from JSON`,
  );
}

/** @internal */
export const RequestBody1$inboundSchema: z.ZodType<
  RequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateKnowledgeRequestBodyType$inboundSchema.default("internal"),
  key: z.string(),
  description: z.string().optional(),
  embedding_model: z.string(),
  retrieval_settings: z.lazy(() => RetrievalSettings$inboundSchema).optional(),
  path: z.string(),
}).transform((v) => {
  return remap$(v, {
    "embedding_model": "embeddingModel",
    "retrieval_settings": "retrievalSettings",
  });
});
/** @internal */
export type RequestBody1$Outbound = {
  type: string;
  key: string;
  description?: string | undefined;
  embedding_model: string;
  retrieval_settings?: RetrievalSettings$Outbound | undefined;
  path: string;
};

/** @internal */
export const RequestBody1$outboundSchema: z.ZodType<
  RequestBody1$Outbound,
  z.ZodTypeDef,
  RequestBody1
> = z.object({
  type: CreateKnowledgeRequestBodyType$outboundSchema.default("internal"),
  key: z.string(),
  description: z.string().optional(),
  embeddingModel: z.string(),
  retrievalSettings: z.lazy(() => RetrievalSettings$outboundSchema).optional(),
  path: z.string(),
}).transform((v) => {
  return remap$(v, {
    embeddingModel: "embedding_model",
    retrievalSettings: "retrieval_settings",
  });
});

export function requestBody1ToJSON(requestBody1: RequestBody1): string {
  return JSON.stringify(RequestBody1$outboundSchema.parse(requestBody1));
}
export function requestBody1FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody1' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeRequestBody$inboundSchema: z.ZodType<
  CreateKnowledgeRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBody1$inboundSchema),
  z.lazy(() => RequestBody2$inboundSchema),
]);
/** @internal */
export type CreateKnowledgeRequestBody$Outbound =
  | RequestBody1$Outbound
  | RequestBody2$Outbound;

/** @internal */
export const CreateKnowledgeRequestBody$outboundSchema: z.ZodType<
  CreateKnowledgeRequestBody$Outbound,
  z.ZodTypeDef,
  CreateKnowledgeRequestBody
> = z.union([
  z.lazy(() => RequestBody1$outboundSchema),
  z.lazy(() => RequestBody2$outboundSchema),
]);

export function createKnowledgeRequestBodyToJSON(
  createKnowledgeRequestBody: CreateKnowledgeRequestBody,
): string {
  return JSON.stringify(
    CreateKnowledgeRequestBody$outboundSchema.parse(createKnowledgeRequestBody),
  );
}
export function createKnowledgeRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateKnowledgeRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateKnowledgeRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateKnowledgeRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeResponseBodyKnowledgeType$inboundSchema:
  z.ZodNativeEnum<typeof CreateKnowledgeResponseBodyKnowledgeType> = z
    .nativeEnum(CreateKnowledgeResponseBodyKnowledgeType);
/** @internal */
export const CreateKnowledgeResponseBodyKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof CreateKnowledgeResponseBodyKnowledgeType> =
    CreateKnowledgeResponseBodyKnowledgeType$inboundSchema;

/** @internal */
export const CreateKnowledgeResponseBodyRerankConfig$inboundSchema: z.ZodType<
  CreateKnowledgeResponseBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type CreateKnowledgeResponseBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const CreateKnowledgeResponseBodyRerankConfig$outboundSchema: z.ZodType<
  CreateKnowledgeResponseBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  CreateKnowledgeResponseBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function createKnowledgeResponseBodyRerankConfigToJSON(
  createKnowledgeResponseBodyRerankConfig:
    CreateKnowledgeResponseBodyRerankConfig,
): string {
  return JSON.stringify(
    CreateKnowledgeResponseBodyRerankConfig$outboundSchema.parse(
      createKnowledgeResponseBodyRerankConfig,
    ),
  );
}
export function createKnowledgeResponseBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateKnowledgeResponseBodyRerankConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateKnowledgeResponseBodyRerankConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateKnowledgeResponseBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeResponseBodyAgenticRagConfig$inboundSchema:
  z.ZodType<
    CreateKnowledgeResponseBodyAgenticRagConfig,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });
/** @internal */
export type CreateKnowledgeResponseBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const CreateKnowledgeResponseBodyAgenticRagConfig$outboundSchema:
  z.ZodType<
    CreateKnowledgeResponseBodyAgenticRagConfig$Outbound,
    z.ZodTypeDef,
    CreateKnowledgeResponseBodyAgenticRagConfig
  > = z.object({
    model: z.string(),
  });

export function createKnowledgeResponseBodyAgenticRagConfigToJSON(
  createKnowledgeResponseBodyAgenticRagConfig:
    CreateKnowledgeResponseBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    CreateKnowledgeResponseBodyAgenticRagConfig$outboundSchema.parse(
      createKnowledgeResponseBodyAgenticRagConfig,
    ),
  );
}
export function createKnowledgeResponseBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateKnowledgeResponseBodyAgenticRagConfig,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateKnowledgeResponseBodyAgenticRagConfig$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateKnowledgeResponseBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeResponseBodyRetrievalSettings$inboundSchema:
  z.ZodType<
    CreateKnowledgeResponseBodyRetrievalSettings,
    z.ZodTypeDef,
    unknown
  > = z.object({
    top_k: z.number().int().default(5),
    threshold: z.number().default(0),
    rerank_config: z.nullable(
      z.lazy(() => CreateKnowledgeResponseBodyRerankConfig$inboundSchema),
    ).optional(),
    agentic_rag_config: z.nullable(
      z.lazy(() => CreateKnowledgeResponseBodyAgenticRagConfig$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "top_k": "topK",
      "rerank_config": "rerankConfig",
      "agentic_rag_config": "agenticRagConfig",
    });
  });
/** @internal */
export type CreateKnowledgeResponseBodyRetrievalSettings$Outbound = {
  top_k: number;
  threshold: number;
  rerank_config?:
    | CreateKnowledgeResponseBodyRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | CreateKnowledgeResponseBodyAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const CreateKnowledgeResponseBodyRetrievalSettings$outboundSchema:
  z.ZodType<
    CreateKnowledgeResponseBodyRetrievalSettings$Outbound,
    z.ZodTypeDef,
    CreateKnowledgeResponseBodyRetrievalSettings
  > = z.object({
    topK: z.number().int().default(5),
    threshold: z.number().default(0),
    rerankConfig: z.nullable(
      z.lazy(() => CreateKnowledgeResponseBodyRerankConfig$outboundSchema),
    ).optional(),
    agenticRagConfig: z.nullable(
      z.lazy(() => CreateKnowledgeResponseBodyAgenticRagConfig$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      topK: "top_k",
      rerankConfig: "rerank_config",
      agenticRagConfig: "agentic_rag_config",
    });
  });

export function createKnowledgeResponseBodyRetrievalSettingsToJSON(
  createKnowledgeResponseBodyRetrievalSettings:
    CreateKnowledgeResponseBodyRetrievalSettings,
): string {
  return JSON.stringify(
    CreateKnowledgeResponseBodyRetrievalSettings$outboundSchema.parse(
      createKnowledgeResponseBodyRetrievalSettings,
    ),
  );
}
export function createKnowledgeResponseBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateKnowledgeResponseBodyRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateKnowledgeResponseBodyRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateKnowledgeResponseBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const ResponseBodyExternalConfig$inboundSchema: z.ZodType<
  ResponseBodyExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
  });
});
/** @internal */
export type ResponseBodyExternalConfig$Outbound = {
  name: string;
  api_url: string;
};

/** @internal */
export const ResponseBodyExternalConfig$outboundSchema: z.ZodType<
  ResponseBodyExternalConfig$Outbound,
  z.ZodTypeDef,
  ResponseBodyExternalConfig
> = z.object({
  name: z.string(),
  apiUrl: z.string(),
}).transform((v) => {
  return remap$(v, {
    apiUrl: "api_url",
  });
});

export function responseBodyExternalConfigToJSON(
  responseBodyExternalConfig: ResponseBodyExternalConfig,
): string {
  return JSON.stringify(
    ResponseBodyExternalConfig$outboundSchema.parse(responseBodyExternalConfig),
  );
}
export function responseBodyExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyExternalConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyExternalConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyExternalConfig' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: CreateKnowledgeResponseBodyKnowledgeType$inboundSchema.default(
    "external",
  ),
  retrieval_settings: z.lazy(() =>
    CreateKnowledgeResponseBodyRetrievalSettings$inboundSchema
  ).optional(),
  external_config: z.lazy(() => ResponseBodyExternalConfig$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
    "external_config": "externalConfig",
  });
});
/** @internal */
export type ResponseBody2$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?:
    | CreateKnowledgeResponseBodyRetrievalSettings$Outbound
    | undefined;
  external_config: ResponseBodyExternalConfig$Outbound;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: CreateKnowledgeResponseBodyKnowledgeType$outboundSchema.default(
    "external",
  ),
  retrievalSettings: z.lazy(() =>
    CreateKnowledgeResponseBodyRetrievalSettings$outboundSchema
  ).optional(),
  externalConfig: z.lazy(() => ResponseBodyExternalConfig$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
    externalConfig: "external_config",
  });
});

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}
export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateKnowledgeResponseBodyType
> = z.nativeEnum(CreateKnowledgeResponseBodyType);
/** @internal */
export const CreateKnowledgeResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateKnowledgeResponseBodyType
> = CreateKnowledgeResponseBodyType$inboundSchema;

/** @internal */
export const ResponseBodyRetrievalType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyRetrievalType
> = z.nativeEnum(ResponseBodyRetrievalType);
/** @internal */
export const ResponseBodyRetrievalType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyRetrievalType
> = ResponseBodyRetrievalType$inboundSchema;

/** @internal */
export const ResponseBodyRerankConfig$inboundSchema: z.ZodType<
  ResponseBodyRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type ResponseBodyRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const ResponseBodyRerankConfig$outboundSchema: z.ZodType<
  ResponseBodyRerankConfig$Outbound,
  z.ZodTypeDef,
  ResponseBodyRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function responseBodyRerankConfigToJSON(
  responseBodyRerankConfig: ResponseBodyRerankConfig,
): string {
  return JSON.stringify(
    ResponseBodyRerankConfig$outboundSchema.parse(responseBodyRerankConfig),
  );
}
export function responseBodyRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyRerankConfig' from JSON`,
  );
}

/** @internal */
export const ResponseBodyAgenticRagConfig$inboundSchema: z.ZodType<
  ResponseBodyAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type ResponseBodyAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const ResponseBodyAgenticRagConfig$outboundSchema: z.ZodType<
  ResponseBodyAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  ResponseBodyAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function responseBodyAgenticRagConfigToJSON(
  responseBodyAgenticRagConfig: ResponseBodyAgenticRagConfig,
): string {
  return JSON.stringify(
    ResponseBodyAgenticRagConfig$outboundSchema.parse(
      responseBodyAgenticRagConfig,
    ),
  );
}
export function responseBodyAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const ResponseBodyRetrievalSettings$inboundSchema: z.ZodType<
  ResponseBodyRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  retrieval_type: ResponseBodyRetrievalType$inboundSchema.default(
    "hybrid_search",
  ),
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(
    z.lazy(() => ResponseBodyRerankConfig$inboundSchema),
  ).optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => ResponseBodyAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "retrieval_type": "retrievalType",
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});
/** @internal */
export type ResponseBodyRetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?: ResponseBodyRerankConfig$Outbound | null | undefined;
  agentic_rag_config?: ResponseBodyAgenticRagConfig$Outbound | null | undefined;
};

/** @internal */
export const ResponseBodyRetrievalSettings$outboundSchema: z.ZodType<
  ResponseBodyRetrievalSettings$Outbound,
  z.ZodTypeDef,
  ResponseBodyRetrievalSettings
> = z.object({
  retrievalType: ResponseBodyRetrievalType$outboundSchema.default(
    "hybrid_search",
  ),
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(
    z.lazy(() => ResponseBodyRerankConfig$outboundSchema),
  ).optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => ResponseBodyAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    retrievalType: "retrieval_type",
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function responseBodyRetrievalSettingsToJSON(
  responseBodyRetrievalSettings: ResponseBodyRetrievalSettings,
): string {
  return JSON.stringify(
    ResponseBodyRetrievalSettings$outboundSchema.parse(
      responseBodyRetrievalSettings,
    ),
  );
}
export function responseBodyRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyRetrievalSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyRetrievalSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const ResponseBody1$inboundSchema: z.ZodType<
  ResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domain_id: z.string(),
  path: z.string().optional(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: CreateKnowledgeResponseBodyType$inboundSchema.default("internal"),
  retrieval_settings: z.lazy(() => ResponseBodyRetrievalSettings$inboundSchema)
    .optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "retrieval_settings": "retrievalSettings",
  });
});
/** @internal */
export type ResponseBody1$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?: ResponseBodyRetrievalSettings$Outbound | undefined;
  model: string;
};

/** @internal */
export const ResponseBody1$outboundSchema: z.ZodType<
  ResponseBody1$Outbound,
  z.ZodTypeDef,
  ResponseBody1
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: CreateKnowledgeResponseBodyType$outboundSchema.default("internal"),
  retrievalSettings: z.lazy(() => ResponseBodyRetrievalSettings$outboundSchema)
    .optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
  });
});

export function responseBody1ToJSON(responseBody1: ResponseBody1): string {
  return JSON.stringify(ResponseBody1$outboundSchema.parse(responseBody1));
}
export function responseBody1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateKnowledgeResponseBody$inboundSchema: z.ZodType<
  CreateKnowledgeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBody1$inboundSchema),
  z.lazy(() => ResponseBody2$inboundSchema),
]);
/** @internal */
export type CreateKnowledgeResponseBody$Outbound =
  | ResponseBody1$Outbound
  | ResponseBody2$Outbound;

/** @internal */
export const CreateKnowledgeResponseBody$outboundSchema: z.ZodType<
  CreateKnowledgeResponseBody$Outbound,
  z.ZodTypeDef,
  CreateKnowledgeResponseBody
> = z.union([
  z.lazy(() => ResponseBody1$outboundSchema),
  z.lazy(() => ResponseBody2$outboundSchema),
]);

export function createKnowledgeResponseBodyToJSON(
  createKnowledgeResponseBody: CreateKnowledgeResponseBody,
): string {
  return JSON.stringify(
    CreateKnowledgeResponseBody$outboundSchema.parse(
      createKnowledgeResponseBody,
    ),
  );
}
export function createKnowledgeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateKnowledgeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateKnowledgeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateKnowledgeResponseBody' from JSON`,
  );
}
