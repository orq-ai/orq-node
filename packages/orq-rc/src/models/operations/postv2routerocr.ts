/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * URL of the image to process
 */
export type ImageUrl2 = {
  url: string;
  detail?: string | undefined;
};

export type DocumentImageUrl = ImageUrl2 | string;

export type Document2 = {
  type: "image_url";
  imageUrl: ImageUrl2 | string;
};

export type Document1 = {
  type: "document_url";
  /**
   * URL of the document to process
   */
  documentUrl: string;
  /**
   * The name of the document
   */
  documentName?: string | undefined;
};

/**
 * Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk.
 */
export type Document = Document1 | Document2;

/**
 * Optional settings for the OCR run
 */
export type OcrSettings = {
  /**
   * Whether to include image Base64 in the response. Null for default.
   */
  includeImageBase64?: boolean | null | undefined;
  /**
   * Maximum number of images to extract. Null for no limit.
   */
  maxImagesToInclude?: number | undefined;
  /**
   * Minimum height and width of image to extract. Null for no minimum.
   */
  imageMinSize?: number | undefined;
};

/**
 * input
 */
export type PostV2RouterOcrRequestBody = {
  /**
   * ID of the model to use for OCR.
   */
  model: string;
  /**
   * Document to run OCR on. Can be a DocumentURLChunk or ImageURLChunk.
   */
  document: Document1 | Document2;
  /**
   * Specific pages to process. Can be a single number, range, or list. Starts from 0. Null for all pages.
   */
  pages?: Array<number> | null | undefined;
  /**
   * Optional settings for the OCR run
   */
  ocrSettings?: OcrSettings | undefined;
};

export type Images = {
  /**
   * The id of the image
   */
  id: string;
  /**
   * The base64 encoded image
   */
  imageBase64?: string | null | undefined;
};

/**
 * The dimensions of the PDF Page's screenshot image
 */
export type Dimensions = {
  /**
   * Dots per inch of the page-image
   */
  dpi: number;
  /**
   * Height of the image in pixels
   */
  height: number;
  /**
   * Width of the image in pixels
   */
  width: number;
};

export type Pages = {
  /**
   * The page index in a pdf document starting from 0
   */
  index: number;
  /**
   * The markdown string response of the page
   */
  markdown: string;
  images: Array<Images>;
  /**
   * The dimensions of the PDF Page's screenshot image
   */
  dimensions?: Dimensions | null | undefined;
};

/**
 * The usage information for the OCR run counted as tokens processed
 */
export type Usage2 = {
  type: "tokens";
  /**
   * The number of tokens processed
   */
  tokensProcessed: number;
};

/**
 * The usage information for the OCR run counted as pages processed
 */
export type Usage1 = {
  type: "pages";
  /**
   * The number of pages processed
   */
  pagesProcessed: number;
};

export type PostV2RouterOcrUsage = Usage1 | Usage2;

/**
 * Represents an OCR response from the API.
 */
export type PostV2RouterOcrResponseBody = {
  /**
   * ID of the model used for OCR.
   */
  model: string;
  pages: Array<Pages>;
  usage: Usage1 | Usage2;
};

/** @internal */
export type ImageUrl2$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl2$outboundSchema: z.ZodType<
  ImageUrl2$Outbound,
  z.ZodTypeDef,
  ImageUrl2
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

export function imageUrl2ToJSON(imageUrl2: ImageUrl2): string {
  return JSON.stringify(ImageUrl2$outboundSchema.parse(imageUrl2));
}

/** @internal */
export type DocumentImageUrl$Outbound = ImageUrl2$Outbound | string;

/** @internal */
export const DocumentImageUrl$outboundSchema: z.ZodType<
  DocumentImageUrl$Outbound,
  z.ZodTypeDef,
  DocumentImageUrl
> = z.union([z.lazy(() => ImageUrl2$outboundSchema), z.string()]);

export function documentImageUrlToJSON(
  documentImageUrl: DocumentImageUrl,
): string {
  return JSON.stringify(
    DocumentImageUrl$outboundSchema.parse(documentImageUrl),
  );
}

/** @internal */
export type Document2$Outbound = {
  type: "image_url";
  image_url: ImageUrl2$Outbound | string;
};

/** @internal */
export const Document2$outboundSchema: z.ZodType<
  Document2$Outbound,
  z.ZodTypeDef,
  Document2
> = z.object({
  type: z.literal("image_url"),
  imageUrl: z.union([z.lazy(() => ImageUrl2$outboundSchema), z.string()]),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function document2ToJSON(document2: Document2): string {
  return JSON.stringify(Document2$outboundSchema.parse(document2));
}

/** @internal */
export type Document1$Outbound = {
  type: "document_url";
  document_url: string;
  document_name?: string | undefined;
};

/** @internal */
export const Document1$outboundSchema: z.ZodType<
  Document1$Outbound,
  z.ZodTypeDef,
  Document1
> = z.object({
  type: z.literal("document_url"),
  documentUrl: z.string(),
  documentName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    documentUrl: "document_url",
    documentName: "document_name",
  });
});

export function document1ToJSON(document1: Document1): string {
  return JSON.stringify(Document1$outboundSchema.parse(document1));
}

/** @internal */
export type Document$Outbound = Document1$Outbound | Document2$Outbound;

/** @internal */
export const Document$outboundSchema: z.ZodType<
  Document$Outbound,
  z.ZodTypeDef,
  Document
> = z.union([
  z.lazy(() => Document1$outboundSchema),
  z.lazy(() => Document2$outboundSchema),
]);

export function documentToJSON(document: Document): string {
  return JSON.stringify(Document$outboundSchema.parse(document));
}

/** @internal */
export type OcrSettings$Outbound = {
  include_image_base64?: boolean | null | undefined;
  max_images_to_include?: number | undefined;
  image_min_size?: number | undefined;
};

/** @internal */
export const OcrSettings$outboundSchema: z.ZodType<
  OcrSettings$Outbound,
  z.ZodTypeDef,
  OcrSettings
> = z.object({
  includeImageBase64: z.nullable(z.boolean()).optional(),
  maxImagesToInclude: z.number().int().optional(),
  imageMinSize: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    includeImageBase64: "include_image_base64",
    maxImagesToInclude: "max_images_to_include",
    imageMinSize: "image_min_size",
  });
});

export function ocrSettingsToJSON(ocrSettings: OcrSettings): string {
  return JSON.stringify(OcrSettings$outboundSchema.parse(ocrSettings));
}

/** @internal */
export type PostV2RouterOcrRequestBody$Outbound = {
  model: string;
  document: Document1$Outbound | Document2$Outbound;
  pages?: Array<number> | null | undefined;
  ocr_settings?: OcrSettings$Outbound | undefined;
};

/** @internal */
export const PostV2RouterOcrRequestBody$outboundSchema: z.ZodType<
  PostV2RouterOcrRequestBody$Outbound,
  z.ZodTypeDef,
  PostV2RouterOcrRequestBody
> = z.object({
  model: z.string(),
  document: z.union([
    z.lazy(() => Document1$outboundSchema),
    z.lazy(() => Document2$outboundSchema),
  ]),
  pages: z.nullable(z.array(z.number().int())).optional(),
  ocrSettings: z.lazy(() => OcrSettings$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    ocrSettings: "ocr_settings",
  });
});

export function postV2RouterOcrRequestBodyToJSON(
  postV2RouterOcrRequestBody: PostV2RouterOcrRequestBody,
): string {
  return JSON.stringify(
    PostV2RouterOcrRequestBody$outboundSchema.parse(postV2RouterOcrRequestBody),
  );
}

/** @internal */
export const Images$inboundSchema: z.ZodType<Images, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    image_base64: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "image_base64": "imageBase64",
    });
  });

export function imagesFromJSON(
  jsonString: string,
): SafeParseResult<Images, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Images$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Images' from JSON`,
  );
}

/** @internal */
export const Dimensions$inboundSchema: z.ZodType<
  Dimensions,
  z.ZodTypeDef,
  unknown
> = z.object({
  dpi: z.number().int(),
  height: z.number().int(),
  width: z.number().int(),
});

export function dimensionsFromJSON(
  jsonString: string,
): SafeParseResult<Dimensions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Dimensions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Dimensions' from JSON`,
  );
}

/** @internal */
export const Pages$inboundSchema: z.ZodType<Pages, z.ZodTypeDef, unknown> = z
  .object({
    index: z.number(),
    markdown: z.string(),
    images: z.array(z.lazy(() => Images$inboundSchema)),
    dimensions: z.nullable(z.lazy(() => Dimensions$inboundSchema)).optional(),
  });

export function pagesFromJSON(
  jsonString: string,
): SafeParseResult<Pages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Pages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Pages' from JSON`,
  );
}

/** @internal */
export const Usage2$inboundSchema: z.ZodType<Usage2, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("tokens"),
    tokens_processed: z.number().int(),
  }).transform((v) => {
    return remap$(v, {
      "tokens_processed": "tokensProcessed",
    });
  });

export function usage2FromJSON(
  jsonString: string,
): SafeParseResult<Usage2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage2' from JSON`,
  );
}

/** @internal */
export const Usage1$inboundSchema: z.ZodType<Usage1, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("pages"),
    pages_processed: z.number().int(),
  }).transform((v) => {
    return remap$(v, {
      "pages_processed": "pagesProcessed",
    });
  });

export function usage1FromJSON(
  jsonString: string,
): SafeParseResult<Usage1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage1' from JSON`,
  );
}

/** @internal */
export const PostV2RouterOcrUsage$inboundSchema: z.ZodType<
  PostV2RouterOcrUsage,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Usage1$inboundSchema),
  z.lazy(() => Usage2$inboundSchema),
]);

export function postV2RouterOcrUsageFromJSON(
  jsonString: string,
): SafeParseResult<PostV2RouterOcrUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2RouterOcrUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2RouterOcrUsage' from JSON`,
  );
}

/** @internal */
export const PostV2RouterOcrResponseBody$inboundSchema: z.ZodType<
  PostV2RouterOcrResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  pages: z.array(z.lazy(() => Pages$inboundSchema)),
  usage: z.union([
    z.lazy(() => Usage1$inboundSchema),
    z.lazy(() => Usage2$inboundSchema),
  ]),
});

export function postV2RouterOcrResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<PostV2RouterOcrResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2RouterOcrResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2RouterOcrResponseBody' from JSON`,
  );
}
