/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Input (or inputs) to classify. Can be a single string, an array of strings, or an array of multi-modal input objects similar to other models.
 */
export type Input = string | Array<string>;

/**
 * Classifies if text violates content policy
 */
export type CreateModerationRequestBody = {
  /**
   * Input (or inputs) to classify. Can be a single string, an array of strings, or an array of multi-modal input objects similar to other models.
   */
  input: string | Array<string>;
  /**
   * The content moderation model you would like to use. Defaults to omni-moderation-latest
   */
  model: string;
};

/**
 * A list of the categories, and whether they are flagged or not
 */
export type ResultsCategories = {
  /**
   * Sexual content detected
   */
  sexual: boolean;
  /**
   * Hate and discrimination content detected
   */
  hateAndDiscrimination: boolean;
  /**
   * Violence and threats content detected
   */
  violenceAndThreats: boolean;
  /**
   * Dangerous and criminal content detected
   */
  dangerousAndCriminalContent: boolean;
  /**
   * Self-harm content detected
   */
  selfharm: boolean;
  /**
   * Unqualified health advice detected
   */
  health: boolean;
  /**
   * Unqualified financial advice detected
   */
  financial: boolean;
  /**
   * Unqualified legal advice detected
   */
  law: boolean;
  /**
   * Personally identifiable information detected
   */
  pii: boolean;
};

/**
 * A list of the categories along with their scores as predicted by model
 */
export type ResultsCategoryScores = {
  /**
   * The score for sexual content
   */
  sexual: number;
  /**
   * The score for hate and discrimination content
   */
  hateAndDiscrimination: number;
  /**
   * The score for violence and threats content
   */
  violenceAndThreats: number;
  /**
   * The score for dangerous and criminal content
   */
  dangerousAndCriminalContent: number;
  /**
   * The score for self-harm content
   */
  selfharm: number;
  /**
   * The score for unqualified health advice
   */
  health: number;
  /**
   * The score for unqualified financial advice
   */
  financial: number;
  /**
   * The score for unqualified legal advice
   */
  law: number;
  /**
   * The score for personally identifiable information
   */
  pii: number;
};

export type Results2 = {
  /**
   * A list of the categories, and whether they are flagged or not
   */
  categories: ResultsCategories;
  /**
   * A list of the categories along with their scores as predicted by model
   */
  categoryScores: ResultsCategoryScores;
};

/**
 * A list of the categories, and whether they are flagged or not
 */
export type Categories = {
  /**
   * Content that expresses, incites, or promotes hate based on race, gender, ethnicity, religion, nationality, sexual orientation, disability status, or caste.
   */
  hate: boolean;
  /**
   * Hateful content that also includes violence or serious harm towards the targeted group.
   */
  hateThreatening: boolean;
  /**
   * Content that expresses, incites, or promotes harassing language towards any target.
   */
  harassment: boolean;
  /**
   * Harassment content that also includes violence or serious harm towards any target.
   */
  harassmentThreatening: boolean;
  /**
   * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing.
   */
  illicit: boolean;
  /**
   * Content that includes instructions or advice that facilitate the planning or execution of wrongdoing that also includes violence.
   */
  illicitViolent: boolean;
  /**
   * Content that promotes, encourages, or depicts acts of self-harm, such as suicide, cutting, and eating disorders.
   */
  selfHarm: boolean;
  /**
   * Content where the speaker expresses that they are engaging or intend to engage in acts of self-harm.
   */
  selfHarmIntent: boolean;
  /**
   * Content that encourages performing acts of self-harm, or that gives instructions or advice on how to commit such acts.
   */
  selfHarmInstructions: boolean;
  /**
   * Content meant to arouse sexual excitement, such as the description of sexual activity, or that promotes sexual services.
   */
  sexual: boolean;
  /**
   * Sexual content that includes an individual who is under 18 years old.
   */
  sexualMinors: boolean;
  /**
   * Content that depicts death, violence, or physical injury.
   */
  violence: boolean;
  /**
   * Content that depicts death, violence, or physical injury in graphic detail.
   */
  violenceGraphic: boolean;
};

/**
 * A list of the categories along with their scores as predicted by model
 */
export type CategoryScores = {
  /**
   * The score for the category hate
   */
  hate: number;
  /**
   * The score for the category hate/threatening
   */
  hateThreatening: number;
  /**
   * The score for the category harassment
   */
  harassment: number;
  /**
   * The score for the category harassment/threatening
   */
  harassmentThreatening: number;
  /**
   * The score for the category illicit
   */
  illicit: number;
  /**
   * The score for the category illicit/violent
   */
  illicitViolent: number;
  /**
   * The score for the category self-harm
   */
  selfHarm: number;
  /**
   * The score for the category self-harm/intent
   */
  selfHarmIntent: number;
  /**
   * The score for the category self-harm/instructions
   */
  selfHarmInstructions: number;
  /**
   * The score for the category sexual
   */
  sexual: number;
  /**
   * The score for the category sexual/minors
   */
  sexualMinors: number;
  /**
   * The score for the category violence
   */
  violence: number;
  /**
   * The score for the category violence/graphic
   */
  violenceGraphic: number;
};

/**
 * A list of the categories along with the input type(s) that the score applies to
 */
export type CategoryAppliedInputTypes = {
  /**
   * The applied input type(s) for the category hate
   */
  hate: Array<string>;
  /**
   * The applied input type(s) for the category hate/threatening
   */
  hateThreatening: Array<string>;
  /**
   * The applied input type(s) for the category harassment
   */
  harassment: Array<string>;
  /**
   * The applied input type(s) for the category harassment/threatening
   */
  harassmentThreatening: Array<string>;
  /**
   * The applied input type(s) for the category illicit
   */
  illicit: Array<string>;
  /**
   * The applied input type(s) for the category illicit/violent
   */
  illicitViolent: Array<string>;
  /**
   * The applied input type(s) for the category self-harm
   */
  selfHarm: Array<string>;
  /**
   * The applied input type(s) for the category self-harm/intent
   */
  selfHarmIntent: Array<string>;
  /**
   * The applied input type(s) for the category self-harm/instructions
   */
  selfHarmInstructions: Array<string>;
  /**
   * The applied input type(s) for the category sexual
   */
  sexual: Array<string>;
  /**
   * The applied input type(s) for the category sexual/minors
   */
  sexualMinors: Array<string>;
  /**
   * The applied input type(s) for the category violence
   */
  violence: Array<string>;
  /**
   * The applied input type(s) for the category violence/graphic
   */
  violenceGraphic: Array<string>;
};

export type Results1 = {
  /**
   * Whether any of the categories are flagged
   */
  flagged: boolean;
  /**
   * A list of the categories, and whether they are flagged or not
   */
  categories: Categories;
  /**
   * A list of the categories along with their scores as predicted by model
   */
  categoryScores: CategoryScores;
  /**
   * A list of the categories along with the input type(s) that the score applies to
   */
  categoryAppliedInputTypes?: CategoryAppliedInputTypes | undefined;
};

export type Results = Results1 | Results2;

/**
 * Returns moderation classification results
 */
export type CreateModerationResponseBody = {
  /**
   * The unique identifier for the moderation request
   */
  id: string;
  /**
   * The model used to generate the moderation results
   */
  model: string;
  /**
   * A list of moderation objects
   */
  results: Array<Results1 | Results2>;
};

/** @internal */
export type Input$Outbound = string | Array<string>;

/** @internal */
export const Input$outboundSchema: z.ZodType<
  Input$Outbound,
  z.ZodTypeDef,
  Input
> = z.union([z.string(), z.array(z.string())]);

export function inputToJSON(input: Input): string {
  return JSON.stringify(Input$outboundSchema.parse(input));
}

/** @internal */
export type CreateModerationRequestBody$Outbound = {
  input: string | Array<string>;
  model: string;
};

/** @internal */
export const CreateModerationRequestBody$outboundSchema: z.ZodType<
  CreateModerationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateModerationRequestBody
> = z.object({
  input: z.union([z.string(), z.array(z.string())]),
  model: z.string(),
});

export function createModerationRequestBodyToJSON(
  createModerationRequestBody: CreateModerationRequestBody,
): string {
  return JSON.stringify(
    CreateModerationRequestBody$outboundSchema.parse(
      createModerationRequestBody,
    ),
  );
}

/** @internal */
export const ResultsCategories$inboundSchema: z.ZodType<
  ResultsCategories,
  z.ZodTypeDef,
  unknown
> = z.object({
  sexual: z.boolean(),
  hate_and_discrimination: z.boolean(),
  violence_and_threats: z.boolean(),
  dangerous_and_criminal_content: z.boolean(),
  selfharm: z.boolean(),
  health: z.boolean(),
  financial: z.boolean(),
  law: z.boolean(),
  pii: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "hate_and_discrimination": "hateAndDiscrimination",
    "violence_and_threats": "violenceAndThreats",
    "dangerous_and_criminal_content": "dangerousAndCriminalContent",
  });
});

export function resultsCategoriesFromJSON(
  jsonString: string,
): SafeParseResult<ResultsCategories, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResultsCategories$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResultsCategories' from JSON`,
  );
}

/** @internal */
export const ResultsCategoryScores$inboundSchema: z.ZodType<
  ResultsCategoryScores,
  z.ZodTypeDef,
  unknown
> = z.object({
  sexual: z.number(),
  hate_and_discrimination: z.number(),
  violence_and_threats: z.number(),
  dangerous_and_criminal_content: z.number(),
  selfharm: z.number(),
  health: z.number(),
  financial: z.number(),
  law: z.number(),
  pii: z.number(),
}).transform((v) => {
  return remap$(v, {
    "hate_and_discrimination": "hateAndDiscrimination",
    "violence_and_threats": "violenceAndThreats",
    "dangerous_and_criminal_content": "dangerousAndCriminalContent",
  });
});

export function resultsCategoryScoresFromJSON(
  jsonString: string,
): SafeParseResult<ResultsCategoryScores, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResultsCategoryScores$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResultsCategoryScores' from JSON`,
  );
}

/** @internal */
export const Results2$inboundSchema: z.ZodType<
  Results2,
  z.ZodTypeDef,
  unknown
> = z.object({
  categories: z.lazy(() => ResultsCategories$inboundSchema),
  category_scores: z.lazy(() => ResultsCategoryScores$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "category_scores": "categoryScores",
  });
});

export function results2FromJSON(
  jsonString: string,
): SafeParseResult<Results2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results2' from JSON`,
  );
}

/** @internal */
export const Categories$inboundSchema: z.ZodType<
  Categories,
  z.ZodTypeDef,
  unknown
> = z.object({
  hate: z.boolean(),
  "hate/threatening": z.boolean(),
  harassment: z.boolean(),
  "harassment/threatening": z.boolean(),
  illicit: z.boolean(),
  "illicit/violent": z.boolean(),
  "self-harm": z.boolean(),
  "self-harm/intent": z.boolean(),
  "self-harm/instructions": z.boolean(),
  sexual: z.boolean(),
  "sexual/minors": z.boolean(),
  violence: z.boolean(),
  "violence/graphic": z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "hate/threatening": "hateThreatening",
    "harassment/threatening": "harassmentThreatening",
    "illicit/violent": "illicitViolent",
    "self-harm": "selfHarm",
    "self-harm/intent": "selfHarmIntent",
    "self-harm/instructions": "selfHarmInstructions",
    "sexual/minors": "sexualMinors",
    "violence/graphic": "violenceGraphic",
  });
});

export function categoriesFromJSON(
  jsonString: string,
): SafeParseResult<Categories, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Categories$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Categories' from JSON`,
  );
}

/** @internal */
export const CategoryScores$inboundSchema: z.ZodType<
  CategoryScores,
  z.ZodTypeDef,
  unknown
> = z.object({
  hate: z.number(),
  "hate/threatening": z.number(),
  harassment: z.number(),
  "harassment/threatening": z.number(),
  illicit: z.number(),
  "illicit/violent": z.number(),
  "self-harm": z.number(),
  "self-harm/intent": z.number(),
  "self-harm/instructions": z.number(),
  sexual: z.number(),
  "sexual/minors": z.number(),
  violence: z.number(),
  "violence/graphic": z.number(),
}).transform((v) => {
  return remap$(v, {
    "hate/threatening": "hateThreatening",
    "harassment/threatening": "harassmentThreatening",
    "illicit/violent": "illicitViolent",
    "self-harm": "selfHarm",
    "self-harm/intent": "selfHarmIntent",
    "self-harm/instructions": "selfHarmInstructions",
    "sexual/minors": "sexualMinors",
    "violence/graphic": "violenceGraphic",
  });
});

export function categoryScoresFromJSON(
  jsonString: string,
): SafeParseResult<CategoryScores, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategoryScores$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategoryScores' from JSON`,
  );
}

/** @internal */
export const CategoryAppliedInputTypes$inboundSchema: z.ZodType<
  CategoryAppliedInputTypes,
  z.ZodTypeDef,
  unknown
> = z.object({
  hate: z.array(z.string()),
  "hate/threatening": z.array(z.string()),
  harassment: z.array(z.string()),
  "harassment/threatening": z.array(z.string()),
  illicit: z.array(z.string()),
  "illicit/violent": z.array(z.string()),
  "self-harm": z.array(z.string()),
  "self-harm/intent": z.array(z.string()),
  "self-harm/instructions": z.array(z.string()),
  sexual: z.array(z.string()),
  "sexual/minors": z.array(z.string()),
  violence: z.array(z.string()),
  "violence/graphic": z.array(z.string()),
}).transform((v) => {
  return remap$(v, {
    "hate/threatening": "hateThreatening",
    "harassment/threatening": "harassmentThreatening",
    "illicit/violent": "illicitViolent",
    "self-harm": "selfHarm",
    "self-harm/intent": "selfHarmIntent",
    "self-harm/instructions": "selfHarmInstructions",
    "sexual/minors": "sexualMinors",
    "violence/graphic": "violenceGraphic",
  });
});

export function categoryAppliedInputTypesFromJSON(
  jsonString: string,
): SafeParseResult<CategoryAppliedInputTypes, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CategoryAppliedInputTypes$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CategoryAppliedInputTypes' from JSON`,
  );
}

/** @internal */
export const Results1$inboundSchema: z.ZodType<
  Results1,
  z.ZodTypeDef,
  unknown
> = z.object({
  flagged: z.boolean(),
  categories: z.lazy(() => Categories$inboundSchema),
  category_scores: z.lazy(() => CategoryScores$inboundSchema),
  category_applied_input_types: z.lazy(() =>
    CategoryAppliedInputTypes$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "category_scores": "categoryScores",
    "category_applied_input_types": "categoryAppliedInputTypes",
  });
});

export function results1FromJSON(
  jsonString: string,
): SafeParseResult<Results1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results1' from JSON`,
  );
}

/** @internal */
export const Results$inboundSchema: z.ZodType<Results, z.ZodTypeDef, unknown> =
  z.union([
    z.lazy(() => Results1$inboundSchema),
    z.lazy(() => Results2$inboundSchema),
  ]);

export function resultsFromJSON(
  jsonString: string,
): SafeParseResult<Results, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Results$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Results' from JSON`,
  );
}

/** @internal */
export const CreateModerationResponseBody$inboundSchema: z.ZodType<
  CreateModerationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  model: z.string(),
  results: z.array(
    z.union([
      z.lazy(() => Results1$inboundSchema),
      z.lazy(() => Results2$inboundSchema),
    ]),
  ),
});

export function createModerationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateModerationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateModerationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateModerationResponseBody' from JSON`,
  );
}
