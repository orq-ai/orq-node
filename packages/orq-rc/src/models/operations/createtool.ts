/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyStatus = ClosedEnum<
  typeof CreateToolRequestBodyStatus
>;

export const CreateToolRequestBodyToolsType = {
  OrqHttp: "orq_http",
} as const;
export type CreateToolRequestBodyToolsType = ClosedEnum<
  typeof CreateToolRequestBodyToolsType
>;

/**
 * The HTTP method to use.
 */
export const Method = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type Method = ClosedEnum<typeof Method>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type Blueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: Method;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolRequestBodyToolsRequestType = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolRequestBodyToolsRequestType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestType
>;

/**
 * The default value of the argument.
 */
export type DefaultValue = string | number | boolean;

export type Arguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolRequestBodyToolsRequestType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type Http = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: Blueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: Arguments } | undefined;
};

export type RequestBody3 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolRequestBodyStatus;
  versionHash: string;
  type: CreateToolRequestBodyToolsType;
  http: Http;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RequestBodyStatus = ClosedEnum<typeof RequestBodyStatus>;

export const CreateToolRequestBodyType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolRequestBodyType = ClosedEnum<
  typeof CreateToolRequestBodyType
>;

export type RequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type RequestBody2 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RequestBodyStatus;
  versionHash: string;
  type: CreateToolRequestBodyType;
  jsonSchema: RequestBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsStatus
>;

export const RequestBodyType = {
  Function: "function",
} as const;
export type RequestBodyType = ClosedEnum<typeof RequestBodyType>;

export type RequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type RequestBody1 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolRequestBodyToolsStatus;
  versionHash: string;
  type: RequestBodyType;
  function: RequestBodyFunction;
};

/**
 * The tool to create
 */
export type CreateToolRequestBody = RequestBody1 | RequestBody2 | RequestBody3;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsStatus
>;

export const CreateToolResponseBodyToolsType = {
  OrqHttp: "orq_http",
} as const;
export type CreateToolResponseBodyToolsType = ClosedEnum<
  typeof CreateToolResponseBodyToolsType
>;

/**
 * The HTTP method to use.
 */
export const ResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type ResponseBodyMethod = ClosedEnum<typeof ResponseBodyMethod>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: ResponseBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolResponseBodyToolsResponseType = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseType
>;

/**
 * The default value of the argument.
 */
export type ResponseBodyDefaultValue = string | number | boolean;

export type ResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolResponseBodyToolsResponseType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type ResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ResponseBodyArguments } | undefined;
};

export type ResponseBody3 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyToolsStatus;
  versionHash: string;
  type: CreateToolResponseBodyToolsType;
  http: ResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyStatus = ClosedEnum<
  typeof CreateToolResponseBodyStatus
>;

export const CreateToolResponseBodyType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolResponseBodyType = ClosedEnum<
  typeof CreateToolResponseBodyType
>;

export type ResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type ResponseBody2 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyStatus;
  versionHash: string;
  type: CreateToolResponseBodyType;
  jsonSchema: ResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ResponseBodyStatus = ClosedEnum<typeof ResponseBodyStatus>;

export const ResponseBodyType = {
  Function: "function",
} as const;
export type ResponseBodyType = ClosedEnum<typeof ResponseBodyType>;

export type ResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type ResponseBody1 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: ResponseBodyStatus;
  versionHash: string;
  type: ResponseBodyType;
  function: ResponseBodyFunction;
};

/**
 * Successfully created the tool.
 */
export type CreateToolResponseBody =
  | ResponseBody1
  | ResponseBody2
  | ResponseBody3;

/** @internal */
export const CreateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = z.nativeEnum(CreateToolRequestBodyStatus);

/** @internal */
export const CreateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = CreateToolRequestBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyStatus$ {
  /** @deprecated use `CreateToolRequestBodyStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyStatus$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = z.nativeEnum(CreateToolRequestBodyToolsType);

/** @internal */
export const CreateToolRequestBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = CreateToolRequestBodyToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsType$ {
  /** @deprecated use `CreateToolRequestBodyToolsType$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyToolsType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsType$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyToolsType$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);

/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const Blueprint$inboundSchema: z.ZodType<
  Blueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: Method$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type Blueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const Blueprint$outboundSchema: z.ZodType<
  Blueprint$Outbound,
  z.ZodTypeDef,
  Blueprint
> = z.object({
  url: z.string(),
  method: Method$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Blueprint$ {
  /** @deprecated use `Blueprint$inboundSchema` instead. */
  export const inboundSchema = Blueprint$inboundSchema;
  /** @deprecated use `Blueprint$outboundSchema` instead. */
  export const outboundSchema = Blueprint$outboundSchema;
  /** @deprecated use `Blueprint$Outbound` instead. */
  export type Outbound = Blueprint$Outbound;
}

export function blueprintToJSON(blueprint: Blueprint): string {
  return JSON.stringify(Blueprint$outboundSchema.parse(blueprint));
}

export function blueprintFromJSON(
  jsonString: string,
): SafeParseResult<Blueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Blueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Blueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> = z.nativeEnum(
    CreateToolRequestBodyToolsRequestType,
  );

/** @internal */
export const CreateToolRequestBodyToolsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> =
    CreateToolRequestBodyToolsRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequestType$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequestType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequestType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequestType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequestType$outboundSchema;
}

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValue$ {
  /** @deprecated use `DefaultValue$inboundSchema` instead. */
  export const inboundSchema = DefaultValue$inboundSchema;
  /** @deprecated use `DefaultValue$outboundSchema` instead. */
  export const outboundSchema = DefaultValue$outboundSchema;
  /** @deprecated use `DefaultValue$Outbound` instead. */
  export type Outbound = DefaultValue$Outbound;
}

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const Arguments$inboundSchema: z.ZodType<
  Arguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequestType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type Arguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const Arguments$outboundSchema: z.ZodType<
  Arguments$Outbound,
  z.ZodTypeDef,
  Arguments
> = z.object({
  type: CreateToolRequestBodyToolsRequestType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Arguments$ {
  /** @deprecated use `Arguments$inboundSchema` instead. */
  export const inboundSchema = Arguments$inboundSchema;
  /** @deprecated use `Arguments$outboundSchema` instead. */
  export const outboundSchema = Arguments$outboundSchema;
  /** @deprecated use `Arguments$Outbound` instead. */
  export type Outbound = Arguments$Outbound;
}

export function argumentsToJSON(value: Arguments): string {
  return JSON.stringify(Arguments$outboundSchema.parse(value));
}

export function argumentsFromJSON(
  jsonString: string,
): SafeParseResult<Arguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Arguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Arguments' from JSON`,
  );
}

/** @internal */
export const Http$inboundSchema: z.ZodType<Http, z.ZodTypeDef, unknown> = z
  .object({
    blueprint: z.lazy(() => Blueprint$inboundSchema),
    arguments: z.record(z.lazy(() => Arguments$inboundSchema)).optional(),
  });

/** @internal */
export type Http$Outbound = {
  blueprint: Blueprint$Outbound;
  arguments?: { [k: string]: Arguments$Outbound } | undefined;
};

/** @internal */
export const Http$outboundSchema: z.ZodType<Http$Outbound, z.ZodTypeDef, Http> =
  z.object({
    blueprint: z.lazy(() => Blueprint$outboundSchema),
    arguments: z.record(z.lazy(() => Arguments$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Http$ {
  /** @deprecated use `Http$inboundSchema` instead. */
  export const inboundSchema = Http$inboundSchema;
  /** @deprecated use `Http$outboundSchema` instead. */
  export const outboundSchema = Http$outboundSchema;
  /** @deprecated use `Http$Outbound` instead. */
  export type Outbound = Http$Outbound;
}

export function httpToJSON(http: Http): string {
  return JSON.stringify(Http$outboundSchema.parse(http));
}

export function httpFromJSON(
  jsonString: string,
): SafeParseResult<Http, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Http$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Http' from JSON`,
  );
}

/** @internal */
export const RequestBody3$inboundSchema: z.ZodType<
  RequestBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$inboundSchema,
  version_hash: z.string(),
  type: CreateToolRequestBodyToolsType$inboundSchema,
  http: z.lazy(() => Http$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "version_hash": "versionHash",
  });
});

/** @internal */
export type RequestBody3$Outbound = {
  path: string;
  key: string;
  description: string;
  status: string;
  version_hash: string;
  type: string;
  http: Http$Outbound;
};

/** @internal */
export const RequestBody3$outboundSchema: z.ZodType<
  RequestBody3$Outbound,
  z.ZodTypeDef,
  RequestBody3
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$outboundSchema,
  versionHash: z.string(),
  type: CreateToolRequestBodyToolsType$outboundSchema,
  http: z.lazy(() => Http$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody3$ {
  /** @deprecated use `RequestBody3$inboundSchema` instead. */
  export const inboundSchema = RequestBody3$inboundSchema;
  /** @deprecated use `RequestBody3$outboundSchema` instead. */
  export const outboundSchema = RequestBody3$outboundSchema;
  /** @deprecated use `RequestBody3$Outbound` instead. */
  export type Outbound = RequestBody3$Outbound;
}

export function requestBody3ToJSON(requestBody3: RequestBody3): string {
  return JSON.stringify(RequestBody3$outboundSchema.parse(requestBody3));
}

export function requestBody3FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody3' from JSON`,
  );
}

/** @internal */
export const RequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = z.nativeEnum(RequestBodyStatus);

/** @internal */
export const RequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = RequestBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyStatus$ {
  /** @deprecated use `RequestBodyStatus$inboundSchema` instead. */
  export const inboundSchema = RequestBodyStatus$inboundSchema;
  /** @deprecated use `RequestBodyStatus$outboundSchema` instead. */
  export const outboundSchema = RequestBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = z.nativeEnum(CreateToolRequestBodyType);

/** @internal */
export const CreateToolRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = CreateToolRequestBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyType$ {
  /** @deprecated use `CreateToolRequestBodyType$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyType$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyType$outboundSchema;
}

/** @internal */
export const RequestBodyJsonSchema$inboundSchema: z.ZodType<
  RequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type RequestBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const RequestBodyJsonSchema$outboundSchema: z.ZodType<
  RequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyJsonSchema$ {
  /** @deprecated use `RequestBodyJsonSchema$inboundSchema` instead. */
  export const inboundSchema = RequestBodyJsonSchema$inboundSchema;
  /** @deprecated use `RequestBodyJsonSchema$outboundSchema` instead. */
  export const outboundSchema = RequestBodyJsonSchema$outboundSchema;
  /** @deprecated use `RequestBodyJsonSchema$Outbound` instead. */
  export type Outbound = RequestBodyJsonSchema$Outbound;
}

export function requestBodyJsonSchemaToJSON(
  requestBodyJsonSchema: RequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RequestBodyJsonSchema$outboundSchema.parse(requestBodyJsonSchema),
  );
}

export function requestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const RequestBody2$inboundSchema: z.ZodType<
  RequestBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: RequestBodyStatus$inboundSchema,
  version_hash: z.string(),
  type: CreateToolRequestBodyType$inboundSchema,
  json_schema: z.lazy(() => RequestBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type RequestBody2$Outbound = {
  path: string;
  key: string;
  description: string;
  status: string;
  version_hash: string;
  type: string;
  json_schema: RequestBodyJsonSchema$Outbound;
};

/** @internal */
export const RequestBody2$outboundSchema: z.ZodType<
  RequestBody2$Outbound,
  z.ZodTypeDef,
  RequestBody2
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: RequestBodyStatus$outboundSchema,
  versionHash: z.string(),
  type: CreateToolRequestBodyType$outboundSchema,
  jsonSchema: z.lazy(() => RequestBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody2$ {
  /** @deprecated use `RequestBody2$inboundSchema` instead. */
  export const inboundSchema = RequestBody2$inboundSchema;
  /** @deprecated use `RequestBody2$outboundSchema` instead. */
  export const outboundSchema = RequestBody2$outboundSchema;
  /** @deprecated use `RequestBody2$Outbound` instead. */
  export type Outbound = RequestBody2$Outbound;
}

export function requestBody2ToJSON(requestBody2: RequestBody2): string {
  return JSON.stringify(RequestBody2$outboundSchema.parse(requestBody2));
}

export function requestBody2FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody2' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = z.nativeEnum(CreateToolRequestBodyToolsStatus);

/** @internal */
export const CreateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = CreateToolRequestBodyToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsStatus$ {
  /** @deprecated use `CreateToolRequestBodyToolsStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyToolsStatus$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyToolsStatus$outboundSchema;
}

/** @internal */
export const RequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyType
> = z.nativeEnum(RequestBodyType);

/** @internal */
export const RequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyType
> = RequestBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyType$ {
  /** @deprecated use `RequestBodyType$inboundSchema` instead. */
  export const inboundSchema = RequestBodyType$inboundSchema;
  /** @deprecated use `RequestBodyType$outboundSchema` instead. */
  export const outboundSchema = RequestBodyType$outboundSchema;
}

/** @internal */
export const RequestBodyFunction$inboundSchema: z.ZodType<
  RequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type RequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyFunction$outboundSchema: z.ZodType<
  RequestBodyFunction$Outbound,
  z.ZodTypeDef,
  RequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyFunction$ {
  /** @deprecated use `RequestBodyFunction$inboundSchema` instead. */
  export const inboundSchema = RequestBodyFunction$inboundSchema;
  /** @deprecated use `RequestBodyFunction$outboundSchema` instead. */
  export const outboundSchema = RequestBodyFunction$outboundSchema;
  /** @deprecated use `RequestBodyFunction$Outbound` instead. */
  export type Outbound = RequestBodyFunction$Outbound;
}

export function requestBodyFunctionToJSON(
  requestBodyFunction: RequestBodyFunction,
): string {
  return JSON.stringify(
    RequestBodyFunction$outboundSchema.parse(requestBodyFunction),
  );
}

export function requestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const RequestBody1$inboundSchema: z.ZodType<
  RequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$inboundSchema,
  version_hash: z.string(),
  type: RequestBodyType$inboundSchema,
  function: z.lazy(() => RequestBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "version_hash": "versionHash",
  });
});

/** @internal */
export type RequestBody1$Outbound = {
  path: string;
  key: string;
  description: string;
  status: string;
  version_hash: string;
  type: string;
  function: RequestBodyFunction$Outbound;
};

/** @internal */
export const RequestBody1$outboundSchema: z.ZodType<
  RequestBody1$Outbound,
  z.ZodTypeDef,
  RequestBody1
> = z.object({
  path: z.string(),
  key: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$outboundSchema,
  versionHash: z.string(),
  type: RequestBodyType$outboundSchema,
  function: z.lazy(() => RequestBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody1$ {
  /** @deprecated use `RequestBody1$inboundSchema` instead. */
  export const inboundSchema = RequestBody1$inboundSchema;
  /** @deprecated use `RequestBody1$outboundSchema` instead. */
  export const outboundSchema = RequestBody1$outboundSchema;
  /** @deprecated use `RequestBody1$Outbound` instead. */
  export type Outbound = RequestBody1$Outbound;
}

export function requestBody1ToJSON(requestBody1: RequestBody1): string {
  return JSON.stringify(RequestBody1$outboundSchema.parse(requestBody1));
}

export function requestBody1FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody1' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBody$inboundSchema: z.ZodType<
  CreateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBody1$inboundSchema),
  z.lazy(() => RequestBody2$inboundSchema),
  z.lazy(() => RequestBody3$inboundSchema),
]);

/** @internal */
export type CreateToolRequestBody$Outbound =
  | RequestBody1$Outbound
  | RequestBody2$Outbound
  | RequestBody3$Outbound;

/** @internal */
export const CreateToolRequestBody$outboundSchema: z.ZodType<
  CreateToolRequestBody$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBody
> = z.union([
  z.lazy(() => RequestBody1$outboundSchema),
  z.lazy(() => RequestBody2$outboundSchema),
  z.lazy(() => RequestBody3$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBody$ {
  /** @deprecated use `CreateToolRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBody$inboundSchema;
  /** @deprecated use `CreateToolRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBody$outboundSchema;
  /** @deprecated use `CreateToolRequestBody$Outbound` instead. */
  export type Outbound = CreateToolRequestBody$Outbound;
}

export function createToolRequestBodyToJSON(
  createToolRequestBody: CreateToolRequestBody,
): string {
  return JSON.stringify(
    CreateToolRequestBody$outboundSchema.parse(createToolRequestBody),
  );
}

export function createToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = z.nativeEnum(CreateToolResponseBodyToolsStatus);

/** @internal */
export const CreateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = CreateToolResponseBodyToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsStatus$ {
  /** @deprecated use `CreateToolResponseBodyToolsStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyToolsStatus$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsStatus$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = z.nativeEnum(CreateToolResponseBodyToolsType);

/** @internal */
export const CreateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = CreateToolResponseBodyToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsType$ {
  /** @deprecated use `CreateToolResponseBodyToolsType$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyToolsType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsType$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyToolsType$outboundSchema;
}

/** @internal */
export const ResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyMethod
> = z.nativeEnum(ResponseBodyMethod);

/** @internal */
export const ResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyMethod
> = ResponseBodyMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyMethod$ {
  /** @deprecated use `ResponseBodyMethod$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyMethod$inboundSchema;
  /** @deprecated use `ResponseBodyMethod$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyMethod$outboundSchema;
}

/** @internal */
export const ResponseBodyBlueprint$inboundSchema: z.ZodType<
  ResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: ResponseBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type ResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseBodyBlueprint$outboundSchema: z.ZodType<
  ResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  ResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: ResponseBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyBlueprint$ {
  /** @deprecated use `ResponseBodyBlueprint$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyBlueprint$inboundSchema;
  /** @deprecated use `ResponseBodyBlueprint$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyBlueprint$outboundSchema;
  /** @deprecated use `ResponseBodyBlueprint$Outbound` instead. */
  export type Outbound = ResponseBodyBlueprint$Outbound;
}

export function responseBodyBlueprintToJSON(
  responseBodyBlueprint: ResponseBodyBlueprint,
): string {
  return JSON.stringify(
    ResponseBodyBlueprint$outboundSchema.parse(responseBodyBlueprint),
  );
}

export function responseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseType);

/** @internal */
export const CreateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> =
    CreateToolResponseBodyToolsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponseType$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponseType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponseType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponseType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponseType$outboundSchema;
}

/** @internal */
export const ResponseBodyDefaultValue$inboundSchema: z.ZodType<
  ResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type ResponseBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const ResponseBodyDefaultValue$outboundSchema: z.ZodType<
  ResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  ResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyDefaultValue$ {
  /** @deprecated use `ResponseBodyDefaultValue$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyDefaultValue$inboundSchema;
  /** @deprecated use `ResponseBodyDefaultValue$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyDefaultValue$outboundSchema;
  /** @deprecated use `ResponseBodyDefaultValue$Outbound` instead. */
  export type Outbound = ResponseBodyDefaultValue$Outbound;
}

export function responseBodyDefaultValueToJSON(
  responseBodyDefaultValue: ResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    ResponseBodyDefaultValue$outboundSchema.parse(responseBodyDefaultValue),
  );
}

export function responseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArguments$inboundSchema: z.ZodType<
  ResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolResponseBodyToolsResponseType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type ResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const ResponseBodyArguments$outboundSchema: z.ZodType<
  ResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  ResponseBodyArguments
> = z.object({
  type: CreateToolResponseBodyToolsResponseType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyArguments$ {
  /** @deprecated use `ResponseBodyArguments$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyArguments$inboundSchema;
  /** @deprecated use `ResponseBodyArguments$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyArguments$outboundSchema;
  /** @deprecated use `ResponseBodyArguments$Outbound` instead. */
  export type Outbound = ResponseBodyArguments$Outbound;
}

export function responseBodyArgumentsToJSON(
  responseBodyArguments: ResponseBodyArguments,
): string {
  return JSON.stringify(
    ResponseBodyArguments$outboundSchema.parse(responseBodyArguments),
  );
}

export function responseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const ResponseBodyHttp$inboundSchema: z.ZodType<
  ResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$inboundSchema))
    .optional(),
});

/** @internal */
export type ResponseBodyHttp$Outbound = {
  blueprint: ResponseBodyBlueprint$Outbound;
  arguments?: { [k: string]: ResponseBodyArguments$Outbound } | undefined;
};

/** @internal */
export const ResponseBodyHttp$outboundSchema: z.ZodType<
  ResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  ResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyHttp$ {
  /** @deprecated use `ResponseBodyHttp$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyHttp$inboundSchema;
  /** @deprecated use `ResponseBodyHttp$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyHttp$outboundSchema;
  /** @deprecated use `ResponseBodyHttp$Outbound` instead. */
  export type Outbound = ResponseBodyHttp$Outbound;
}

export function responseBodyHttpToJSON(
  responseBodyHttp: ResponseBodyHttp,
): string {
  return JSON.stringify(
    ResponseBodyHttp$outboundSchema.parse(responseBodyHttp),
  );
}

export function responseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const ResponseBody3$inboundSchema: z.ZodType<
  ResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01JRYX735KGKJC737GRFK21ZY7"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$inboundSchema,
  version_hash: z.string(),
  type: CreateToolResponseBodyToolsType$inboundSchema,
  http: z.lazy(() => ResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type ResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  http: ResponseBodyHttp$Outbound;
};

/** @internal */
export const ResponseBody3$outboundSchema: z.ZodType<
  ResponseBody3$Outbound,
  z.ZodTypeDef,
  ResponseBody3
> = z.object({
  id: z.string().default("tool_01JRYX735KGKJC737GRFK21ZY7"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$outboundSchema,
  versionHash: z.string(),
  type: CreateToolResponseBodyToolsType$outboundSchema,
  http: z.lazy(() => ResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody3$ {
  /** @deprecated use `ResponseBody3$inboundSchema` instead. */
  export const inboundSchema = ResponseBody3$inboundSchema;
  /** @deprecated use `ResponseBody3$outboundSchema` instead. */
  export const outboundSchema = ResponseBody3$outboundSchema;
  /** @deprecated use `ResponseBody3$Outbound` instead. */
  export type Outbound = ResponseBody3$Outbound;
}

export function responseBody3ToJSON(responseBody3: ResponseBody3): string {
  return JSON.stringify(ResponseBody3$outboundSchema.parse(responseBody3));
}

export function responseBody3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody3' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = z.nativeEnum(CreateToolResponseBodyStatus);

/** @internal */
export const CreateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = CreateToolResponseBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyStatus$ {
  /** @deprecated use `CreateToolResponseBodyStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyStatus$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = z.nativeEnum(CreateToolResponseBodyType);

/** @internal */
export const CreateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = CreateToolResponseBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyType$ {
  /** @deprecated use `CreateToolResponseBodyType$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyType$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyType$outboundSchema;
}

/** @internal */
export const ResponseBodyJsonSchema$inboundSchema: z.ZodType<
  ResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type ResponseBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const ResponseBodyJsonSchema$outboundSchema: z.ZodType<
  ResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyJsonSchema$ {
  /** @deprecated use `ResponseBodyJsonSchema$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyJsonSchema$inboundSchema;
  /** @deprecated use `ResponseBodyJsonSchema$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyJsonSchema$outboundSchema;
  /** @deprecated use `ResponseBodyJsonSchema$Outbound` instead. */
  export type Outbound = ResponseBodyJsonSchema$Outbound;
}

export function responseBodyJsonSchemaToJSON(
  responseBodyJsonSchema: ResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    ResponseBodyJsonSchema$outboundSchema.parse(responseBodyJsonSchema),
  );
}

export function responseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01JRYX735DT5SF0ED8E6NG49CJ"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$inboundSchema,
  version_hash: z.string(),
  type: CreateToolResponseBodyType$inboundSchema,
  json_schema: z.lazy(() => ResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type ResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  json_schema: ResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  id: z.string().default("tool_01JRYX735DT5SF0ED8E6NG49CJ"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$outboundSchema,
  versionHash: z.string(),
  type: CreateToolResponseBodyType$outboundSchema,
  jsonSchema: z.lazy(() => ResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody2$ {
  /** @deprecated use `ResponseBody2$inboundSchema` instead. */
  export const inboundSchema = ResponseBody2$inboundSchema;
  /** @deprecated use `ResponseBody2$outboundSchema` instead. */
  export const outboundSchema = ResponseBody2$outboundSchema;
  /** @deprecated use `ResponseBody2$Outbound` instead. */
  export type Outbound = ResponseBody2$Outbound;
}

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}

export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const ResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = z.nativeEnum(ResponseBodyStatus);

/** @internal */
export const ResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = ResponseBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyStatus$ {
  /** @deprecated use `ResponseBodyStatus$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyStatus$inboundSchema;
  /** @deprecated use `ResponseBodyStatus$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyStatus$outboundSchema;
}

/** @internal */
export const ResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyType
> = z.nativeEnum(ResponseBodyType);

/** @internal */
export const ResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyType
> = ResponseBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyType$ {
  /** @deprecated use `ResponseBodyType$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyType$inboundSchema;
  /** @deprecated use `ResponseBodyType$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyType$outboundSchema;
}

/** @internal */
export const ResponseBodyFunction$inboundSchema: z.ZodType<
  ResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type ResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseBodyFunction$outboundSchema: z.ZodType<
  ResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  ResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyFunction$ {
  /** @deprecated use `ResponseBodyFunction$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyFunction$inboundSchema;
  /** @deprecated use `ResponseBodyFunction$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyFunction$outboundSchema;
  /** @deprecated use `ResponseBodyFunction$Outbound` instead. */
  export type Outbound = ResponseBodyFunction$Outbound;
}

export function responseBodyFunctionToJSON(
  responseBodyFunction: ResponseBodyFunction,
): string {
  return JSON.stringify(
    ResponseBodyFunction$outboundSchema.parse(responseBodyFunction),
  );
}

export function responseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const ResponseBody1$inboundSchema: z.ZodType<
  ResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01JRYX735DTM273N0GWBCFPT83"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$inboundSchema,
  version_hash: z.string(),
  type: ResponseBodyType$inboundSchema,
  function: z.lazy(() => ResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type ResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  function: ResponseBodyFunction$Outbound;
};

/** @internal */
export const ResponseBody1$outboundSchema: z.ZodType<
  ResponseBody1$Outbound,
  z.ZodTypeDef,
  ResponseBody1
> = z.object({
  id: z.string().default("tool_01JRYX735DTM273N0GWBCFPT83"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$outboundSchema,
  versionHash: z.string(),
  type: ResponseBodyType$outboundSchema,
  function: z.lazy(() => ResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody1$ {
  /** @deprecated use `ResponseBody1$inboundSchema` instead. */
  export const inboundSchema = ResponseBody1$inboundSchema;
  /** @deprecated use `ResponseBody1$outboundSchema` instead. */
  export const outboundSchema = ResponseBody1$outboundSchema;
  /** @deprecated use `ResponseBody1$Outbound` instead. */
  export type Outbound = ResponseBody1$Outbound;
}

export function responseBody1ToJSON(responseBody1: ResponseBody1): string {
  return JSON.stringify(ResponseBody1$outboundSchema.parse(responseBody1));
}

export function responseBody1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBody$inboundSchema: z.ZodType<
  CreateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBody1$inboundSchema),
  z.lazy(() => ResponseBody2$inboundSchema),
  z.lazy(() => ResponseBody3$inboundSchema),
]);

/** @internal */
export type CreateToolResponseBody$Outbound =
  | ResponseBody1$Outbound
  | ResponseBody2$Outbound
  | ResponseBody3$Outbound;

/** @internal */
export const CreateToolResponseBody$outboundSchema: z.ZodType<
  CreateToolResponseBody$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBody
> = z.union([
  z.lazy(() => ResponseBody1$outboundSchema),
  z.lazy(() => ResponseBody2$outboundSchema),
  z.lazy(() => ResponseBody3$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBody$ {
  /** @deprecated use `CreateToolResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBody$inboundSchema;
  /** @deprecated use `CreateToolResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBody$outboundSchema;
  /** @deprecated use `CreateToolResponseBody$Outbound` instead. */
  export type Outbound = CreateToolResponseBody$Outbound;
}

export function createToolResponseBodyToJSON(
  createToolResponseBody: CreateToolResponseBody,
): string {
  return JSON.stringify(
    CreateToolResponseBody$outboundSchema.parse(createToolResponseBody),
  );
}

export function createToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBody' from JSON`,
  );
}
