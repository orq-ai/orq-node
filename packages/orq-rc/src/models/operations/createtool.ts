/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestStatus
>;

/**
 * The type must be "object"
 */
export const CreateToolRequestBodyToolsRequest5CodeToolType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolRequestBodyToolsRequest5CodeToolType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5CodeToolType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type CreateToolRequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolRequestBodyToolsRequest5CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const RequestBodyLanguage = {
  Python: "python",
} as const;
export type RequestBodyLanguage = ClosedEnum<typeof RequestBodyLanguage>;

export type RequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: CreateToolRequestBodyParameters | undefined;
  language: RequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type RequestBodyCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequestStatus | undefined;
  type: "code";
  codeTool: RequestBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsStatus
>;

export type RequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const RequestBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type RequestBodyConnectionType = ClosedEnum<
  typeof RequestBodyConnectionType
>;

export type RequestBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: RequestBodyHeaders } | undefined;
  /**
   * The connection type used by the MCP server
   */
  connectionType: RequestBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type RequestBodyMCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsStatus | undefined;
  type: "mcp";
  mcp: RequestBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyStatus = ClosedEnum<
  typeof CreateToolRequestBodyStatus
>;

/**
 * The HTTP method to use.
 */
export const CreateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolRequestBodyMethod = ClosedEnum<
  typeof CreateToolRequestBodyMethod
>;

export type CreateToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type CreateToolRequestBodyHeaders = CreateToolHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type RequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolRequestBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: CreateToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type RequestBodyDefaultValue = string | number | boolean;

export type RequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: RequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: RequestBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type RequestBodyHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyStatus | undefined;
  type: "http";
  http: CreateToolRequestBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RequestBodyStatus = ClosedEnum<typeof RequestBodyStatus>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RequestBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: RequestBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type RequestBodyJSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: RequestBodyStatus | undefined;
  type: "json_schema";
  jsonSchema: RequestBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequest1Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequest1Status = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest1Status
>;

/**
 * The type must be "object"
 */
export const CreateToolRequestBodyToolsRequest1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolRequestBodyToolsRequest1Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest1Type
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolRequestBodyToolsRequest1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RequestBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type RequestBodyFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequest1Status | undefined;
  type: "function";
  function: RequestBodyFunction;
};

/**
 * The tool to create
 */
export type CreateToolRequestBody =
  | RequestBodyFunctionTool
  | RequestBodyJSONSchemaTool
  | RequestBodyHTTPTool
  | RequestBodyMCPTool
  | RequestBodyCodeExecutionTool;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Status
>;

/**
 * The type must be "object"
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson5Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type CreateToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const ResponseBodyLanguage = {
  Python: "python",
} as const;
export type ResponseBodyLanguage = ClosedEnum<typeof ResponseBodyLanguage>;

export type ResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: CreateToolResponseBodyParameters | undefined;
  language: ResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type ResponseBodyCodeExecutionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyToolsResponse200Status;
  versionHash?: string | undefined;
  type: "code";
  codeTool: ResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseStatus
>;

export type ResponseBodyHeaders = {
  value: string;
  encrypted: boolean;
};

export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type>;

export type CreateToolResponseBodySchema = {
  type: CreateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type ResponseBodyTools = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: CreateToolResponseBodySchema;
};

/**
 * The connection type used by the MCP server
 */
export const ResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ResponseBodyConnectionType = ClosedEnum<
  typeof ResponseBodyConnectionType
>;

export type ResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: ResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<ResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ResponseBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type ResponseBodyMCPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyToolsResponseStatus;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: ResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsStatus
>;

/**
 * The HTTP method to use.
 */
export const CreateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolResponseBodyMethod = ClosedEnum<
  typeof CreateToolResponseBodyMethod
>;

export type CreateToolHeadersTools2 = {
  value: string;
  encrypted: boolean;
};

export type CreateToolResponseBodyHeaders = CreateToolHeadersTools2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: CreateToolHeadersTools2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type ResponseBodyDefaultValue = string | number | boolean;

export type ResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel: boolean;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ResponseBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type ResponseBodyHTTPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyToolsStatus;
  versionHash?: string | undefined;
  type: "http";
  http: CreateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyStatus = ClosedEnum<
  typeof CreateToolResponseBodyStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type ResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type ResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: ResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type ResponseBodyJSONSchemaTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateToolResponseBodyStatus;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: ResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ResponseBodyStatus = ClosedEnum<typeof ResponseBodyStatus>;

/**
 * The type must be "object"
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson1Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type ResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type CreateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: ResponseBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type ResponseBodyFunctionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: ResponseBodyStatus;
  versionHash?: string | undefined;
  type: "function";
  function: CreateToolResponseBodyFunction;
};

/**
 * Successfully created the tool.
 */
export type CreateToolResponseBody =
  | ResponseBodyFunctionTool
  | ResponseBodyJSONSchemaTool
  | ResponseBodyHTTPTool
  | ResponseBodyMCPTool
  | ResponseBodyCodeExecutionTool;

/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(CreateToolRequestBodyToolsRequestStatus);

/** @internal */
export const CreateToolRequestBodyToolsRequest5CodeToolType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5CodeToolType> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest5CodeToolType);

/** @internal */
export type CreateToolRequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const CreateToolRequestBodyParameters$outboundSchema: z.ZodType<
  CreateToolRequestBodyParameters$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyParameters
> = z.object({
  type: CreateToolRequestBodyToolsRequest5CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function createToolRequestBodyParametersToJSON(
  createToolRequestBodyParameters: CreateToolRequestBodyParameters,
): string {
  return JSON.stringify(
    CreateToolRequestBodyParameters$outboundSchema.parse(
      createToolRequestBodyParameters,
    ),
  );
}

/** @internal */
export const RequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = z.nativeEnum(RequestBodyLanguage);

/** @internal */
export type RequestBodyCodeTool$Outbound = {
  parameters?: CreateToolRequestBodyParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const RequestBodyCodeTool$outboundSchema: z.ZodType<
  RequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeTool
> = z.object({
  parameters: z.lazy(() => CreateToolRequestBodyParameters$outboundSchema)
    .optional(),
  language: RequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function requestBodyCodeToolToJSON(
  requestBodyCodeTool: RequestBodyCodeTool,
): string {
  return JSON.stringify(
    RequestBodyCodeTool$outboundSchema.parse(requestBodyCodeTool),
  );
}

/** @internal */
export type RequestBodyCodeExecutionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "code";
  code_tool: RequestBodyCodeTool$Outbound;
};

/** @internal */
export const RequestBodyCodeExecutionTool$outboundSchema: z.ZodType<
  RequestBodyCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeExecutionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: z.literal("code"),
  codeTool: z.lazy(() => RequestBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function requestBodyCodeExecutionToolToJSON(
  requestBodyCodeExecutionTool: RequestBodyCodeExecutionTool,
): string {
  return JSON.stringify(
    RequestBodyCodeExecutionTool$outboundSchema.parse(
      requestBodyCodeExecutionTool,
    ),
  );
}

/** @internal */
export const CreateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = z.nativeEnum(CreateToolRequestBodyToolsStatus);

/** @internal */
export type RequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const RequestBodyHeaders$outboundSchema: z.ZodType<
  RequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  RequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function requestBodyHeadersToJSON(
  requestBodyHeaders: RequestBodyHeaders,
): string {
  return JSON.stringify(
    RequestBodyHeaders$outboundSchema.parse(requestBodyHeaders),
  );
}

/** @internal */
export const RequestBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyConnectionType
> = z.nativeEnum(RequestBodyConnectionType);

/** @internal */
export type RequestBodyMcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: RequestBodyHeaders$Outbound } | undefined;
  connection_type: string;
};

/** @internal */
export const RequestBodyMcp$outboundSchema: z.ZodType<
  RequestBodyMcp$Outbound,
  z.ZodTypeDef,
  RequestBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => RequestBodyHeaders$outboundSchema)).optional(),
  connectionType: RequestBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function requestBodyMcpToJSON(requestBodyMcp: RequestBodyMcp): string {
  return JSON.stringify(RequestBodyMcp$outboundSchema.parse(requestBodyMcp));
}

/** @internal */
export type RequestBodyMCPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "mcp";
  mcp: RequestBodyMcp$Outbound;
};

/** @internal */
export const RequestBodyMCPTool$outboundSchema: z.ZodType<
  RequestBodyMCPTool$Outbound,
  z.ZodTypeDef,
  RequestBodyMCPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: z.literal("mcp"),
  mcp: z.lazy(() => RequestBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyMCPToolToJSON(
  requestBodyMCPTool: RequestBodyMCPTool,
): string {
  return JSON.stringify(
    RequestBodyMCPTool$outboundSchema.parse(requestBodyMCPTool),
  );
}

/** @internal */
export const CreateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = z.nativeEnum(CreateToolRequestBodyStatus);

/** @internal */
export const CreateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = z.nativeEnum(CreateToolRequestBodyMethod);

/** @internal */
export type CreateToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const CreateToolHeaders2$outboundSchema: z.ZodType<
  CreateToolHeaders2$Outbound,
  z.ZodTypeDef,
  CreateToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolHeaders2ToJSON(
  createToolHeaders2: CreateToolHeaders2,
): string {
  return JSON.stringify(
    CreateToolHeaders2$outboundSchema.parse(createToolHeaders2),
  );
}

/** @internal */
export type CreateToolRequestBodyHeaders$Outbound =
  | CreateToolHeaders2$Outbound
  | string;

/** @internal */
export const CreateToolRequestBodyHeaders$outboundSchema: z.ZodType<
  CreateToolRequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHeaders
> = z.union([z.lazy(() => CreateToolHeaders2$outboundSchema), z.string()]);

export function createToolRequestBodyHeadersToJSON(
  createToolRequestBodyHeaders: CreateToolRequestBodyHeaders,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHeaders$outboundSchema.parse(
      createToolRequestBodyHeaders,
    ),
  );
}

/** @internal */
export type RequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: CreateToolHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyBlueprint$outboundSchema: z.ZodType<
  RequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  RequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function requestBodyBlueprintToJSON(
  requestBodyBlueprint: RequestBodyBlueprint,
): string {
  return JSON.stringify(
    RequestBodyBlueprint$outboundSchema.parse(requestBodyBlueprint),
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest3Type,
  );

/** @internal */
export type RequestBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const RequestBodyDefaultValue$outboundSchema: z.ZodType<
  RequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  RequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function requestBodyDefaultValueToJSON(
  requestBodyDefaultValue: RequestBodyDefaultValue,
): string {
  return JSON.stringify(
    RequestBodyDefaultValue$outboundSchema.parse(requestBodyDefaultValue),
  );
}

/** @internal */
export type RequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const RequestBodyArguments$outboundSchema: z.ZodType<
  RequestBodyArguments$Outbound,
  z.ZodTypeDef,
  RequestBodyArguments
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function requestBodyArgumentsToJSON(
  requestBodyArguments: RequestBodyArguments,
): string {
  return JSON.stringify(
    RequestBodyArguments$outboundSchema.parse(requestBodyArguments),
  );
}

/** @internal */
export type CreateToolRequestBodyHttp$Outbound = {
  blueprint: RequestBodyBlueprint$Outbound;
  arguments?: { [k: string]: RequestBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolRequestBodyHttp$outboundSchema: z.ZodType<
  CreateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$outboundSchema))
    .optional(),
});

export function createToolRequestBodyHttpToJSON(
  createToolRequestBodyHttp: CreateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHttp$outboundSchema.parse(createToolRequestBodyHttp),
  );
}

/** @internal */
export type RequestBodyHTTPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "http";
  http: CreateToolRequestBodyHttp$Outbound;
};

/** @internal */
export const RequestBodyHTTPTool$outboundSchema: z.ZodType<
  RequestBodyHTTPTool$Outbound,
  z.ZodTypeDef,
  RequestBodyHTTPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolRequestBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyHTTPToolToJSON(
  requestBodyHTTPTool: RequestBodyHTTPTool,
): string {
  return JSON.stringify(
    RequestBodyHTTPTool$outboundSchema.parse(requestBodyHTTPTool),
  );
}

/** @internal */
export const RequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = z.nativeEnum(RequestBodyStatus);

/** @internal */
export type RequestBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RequestBodySchema$outboundSchema: z.ZodType<
  RequestBodySchema$Outbound,
  z.ZodTypeDef,
  RequestBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function requestBodySchemaToJSON(
  requestBodySchema: RequestBodySchema,
): string {
  return JSON.stringify(
    RequestBodySchema$outboundSchema.parse(requestBodySchema),
  );
}

/** @internal */
export type RequestBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: RequestBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const RequestBodyJsonSchema$outboundSchema: z.ZodType<
  RequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => RequestBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function requestBodyJsonSchemaToJSON(
  requestBodyJsonSchema: RequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RequestBodyJsonSchema$outboundSchema.parse(requestBodyJsonSchema),
  );
}

/** @internal */
export type RequestBodyJSONSchemaTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "json_schema";
  json_schema: RequestBodyJsonSchema$Outbound;
};

/** @internal */
export const RequestBodyJSONSchemaTool$outboundSchema: z.ZodType<
  RequestBodyJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  RequestBodyJSONSchemaTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: RequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => RequestBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function requestBodyJSONSchemaToolToJSON(
  requestBodyJSONSchemaTool: RequestBodyJSONSchemaTool,
): string {
  return JSON.stringify(
    RequestBodyJSONSchemaTool$outboundSchema.parse(requestBodyJSONSchemaTool),
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest1Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Status> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest1Status);

/** @internal */
export const CreateToolRequestBodyToolsRequest1Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest1Type,
  );

/** @internal */
export type RequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RequestBodyParameters$outboundSchema: z.ZodType<
  RequestBodyParameters$Outbound,
  z.ZodTypeDef,
  RequestBodyParameters
> = z.object({
  type: CreateToolRequestBodyToolsRequest1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function requestBodyParametersToJSON(
  requestBodyParameters: RequestBodyParameters,
): string {
  return JSON.stringify(
    RequestBodyParameters$outboundSchema.parse(requestBodyParameters),
  );
}

/** @internal */
export type RequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: RequestBodyParameters$Outbound | undefined;
};

/** @internal */
export const RequestBodyFunction$outboundSchema: z.ZodType<
  RequestBodyFunction$Outbound,
  z.ZodTypeDef,
  RequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RequestBodyParameters$outboundSchema).optional(),
});

export function requestBodyFunctionToJSON(
  requestBodyFunction: RequestBodyFunction,
): string {
  return JSON.stringify(
    RequestBodyFunction$outboundSchema.parse(requestBodyFunction),
  );
}

/** @internal */
export type RequestBodyFunctionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "function";
  function: RequestBodyFunction$Outbound;
};

/** @internal */
export const RequestBodyFunctionTool$outboundSchema: z.ZodType<
  RequestBodyFunctionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyFunctionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest1Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("function"),
  function: z.lazy(() => RequestBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyFunctionToolToJSON(
  requestBodyFunctionTool: RequestBodyFunctionTool,
): string {
  return JSON.stringify(
    RequestBodyFunctionTool$outboundSchema.parse(requestBodyFunctionTool),
  );
}

/** @internal */
export type CreateToolRequestBody$Outbound =
  | RequestBodyFunctionTool$Outbound
  | RequestBodyJSONSchemaTool$Outbound
  | RequestBodyHTTPTool$Outbound
  | RequestBodyMCPTool$Outbound
  | RequestBodyCodeExecutionTool$Outbound;

/** @internal */
export const CreateToolRequestBody$outboundSchema: z.ZodType<
  CreateToolRequestBody$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBody
> = z.union([
  z.lazy(() => RequestBodyFunctionTool$outboundSchema),
  z.lazy(() => RequestBodyJSONSchemaTool$outboundSchema),
  z.lazy(() => RequestBodyHTTPTool$outboundSchema),
  z.lazy(() => RequestBodyMCPTool$outboundSchema),
  z.lazy(() => RequestBodyCodeExecutionTool$outboundSchema),
]);

export function createToolRequestBodyToJSON(
  createToolRequestBody: CreateToolRequestBody,
): string {
  return JSON.stringify(
    CreateToolRequestBody$outboundSchema.parse(createToolRequestBody),
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Status);

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson5Type);

/** @internal */
export const CreateToolResponseBodyParameters$inboundSchema: z.ZodType<
  CreateToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      CreateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function createToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const ResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = z.nativeEnum(ResponseBodyLanguage);

/** @internal */
export const ResponseBodyCodeTool$inboundSchema: z.ZodType<
  ResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => CreateToolResponseBodyParameters$inboundSchema)
    .optional(),
  language: ResponseBodyLanguage$inboundSchema,
  code: z.string(),
});

export function responseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const ResponseBodyCodeExecutionTool$inboundSchema: z.ZodType<
  ResponseBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZVBYHG4P2YQMHJ5S7E7CFE"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => ResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

export function responseBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseStatus);

/** @internal */
export const ResponseBodyHeaders$inboundSchema: z.ZodType<
  ResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function responseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson4Type);

/** @internal */
export const CreateToolResponseBodySchema$inboundSchema: z.ZodType<
  CreateToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function createToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyTools$inboundSchema: z.ZodType<
  ResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KHZVBYHC8QT0XQ1Y0D1V8YET"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => CreateToolResponseBodySchema$inboundSchema),
});

export function responseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const ResponseBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = z.nativeEnum(ResponseBodyConnectionType);

/** @internal */
export const ResponseBodyMcp$inboundSchema: z.ZodType<
  ResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$inboundSchema)).optional(),
  tools: z.array(z.lazy(() => ResponseBodyTools$inboundSchema)),
  connection_type: ResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});

export function responseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const ResponseBodyMCPTool$inboundSchema: z.ZodType<
  ResponseBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZVBYH8EB8KJ1AGXS8WT9XS"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => ResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function responseBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = z.nativeEnum(CreateToolResponseBodyToolsStatus);

/** @internal */
export const CreateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = z.nativeEnum(CreateToolResponseBodyMethod);

/** @internal */
export const CreateToolHeadersTools2$inboundSchema: z.ZodType<
  CreateToolHeadersTools2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolHeadersTools2FromJSON(
  jsonString: string,
): SafeParseResult<CreateToolHeadersTools2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolHeadersTools2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolHeadersTools2' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  CreateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => CreateToolHeadersTools2$inboundSchema), z.string()]);

export function createToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const ResponseBodyBlueprint$inboundSchema: z.ZodType<
  ResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeadersTools2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function responseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson3Type);

/** @internal */
export const ResponseBodyDefaultValue$inboundSchema: z.ZodType<
  ResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

export function responseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArguments$inboundSchema: z.ZodType<
  ResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

export function responseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHttp$inboundSchema: z.ZodType<
  CreateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$inboundSchema))
    .optional(),
});

export function createToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const ResponseBodyHTTPTool$inboundSchema: z.ZodType<
  ResponseBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZVBYH66HQNZ61TM3FBYPZM"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function responseBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = z.nativeEnum(CreateToolResponseBodyStatus);

/** @internal */
export const ResponseBodySchema$inboundSchema: z.ZodType<
  ResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function responseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyJsonSchema$inboundSchema: z.ZodType<
  ResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => ResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});

export function responseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyJSONSchemaTool$inboundSchema: z.ZodType<
  ResponseBodyJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZVBYGX30482V72GH4P2HMH"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => ResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

export function responseBodyJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const ResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = z.nativeEnum(ResponseBodyStatus);

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson1Type);

/** @internal */
export const ResponseBodyParameters$inboundSchema: z.ZodType<
  ResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      CreateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function responseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyFunction$inboundSchema: z.ZodType<
  CreateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => ResponseBodyParameters$inboundSchema).optional(),
});

export function createToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const ResponseBodyFunctionTool$inboundSchema: z.ZodType<
  ResponseBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KHZVBYGT56TQNZ6MG95PKGY7"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => CreateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function responseBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBody$inboundSchema: z.ZodType<
  CreateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBodyFunctionTool$inboundSchema),
  z.lazy(() => ResponseBodyJSONSchemaTool$inboundSchema),
  z.lazy(() => ResponseBodyHTTPTool$inboundSchema),
  z.lazy(() => ResponseBodyMCPTool$inboundSchema),
  z.lazy(() => ResponseBodyCodeExecutionTool$inboundSchema),
]);

export function createToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBody' from JSON`,
  );
}
