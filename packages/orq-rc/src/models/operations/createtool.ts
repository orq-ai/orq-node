/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequest5Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequest5Status = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5Status
>;

export const CreateToolRequestBodyToolsRequest5Type = {
  Code: "code",
} as const;
export type CreateToolRequestBodyToolsRequest5Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5Type
>;

export const RequestBodyLanguage = {
  Python: "python",
} as const;
export type RequestBodyLanguage = ClosedEnum<typeof RequestBodyLanguage>;

export type RequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: RequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type RequestBody5 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequest5Status | undefined;
  type: CreateToolRequestBodyToolsRequest5Type;
  codeTool: RequestBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestStatus
>;

export const CreateToolRequestBodyToolsRequest4Type = {
  Mcp: "mcp",
} as const;
export type CreateToolRequestBodyToolsRequest4Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest4Type
>;

export type Headers = {
  value: string;
  encrypted?: boolean | undefined;
};

export const CreateToolRequestBodyToolsRequest4McpType = {
  Object: "object",
} as const;
export type CreateToolRequestBodyToolsRequest4McpType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest4McpType
>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type InputSchema = {
  type: CreateToolRequestBodyToolsRequest4McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const ConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ConnectionType = ClosedEnum<typeof ConnectionType>;

export type Mcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: Headers } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: InputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ConnectionType;
};

export type RequestBody4 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequestStatus | undefined;
  type: CreateToolRequestBodyToolsRequest4Type;
  mcp: Mcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsStatus
>;

export const CreateToolRequestBodyToolsRequestType = {
  Http: "http",
} as const;
export type CreateToolRequestBodyToolsRequestType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestType
>;

/**
 * The HTTP method to use.
 */
export const CreateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolRequestBodyMethod = ClosedEnum<
  typeof CreateToolRequestBodyMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type RequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolRequestBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type RequestBodyDefaultValue = string | number | boolean;

export type RequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: RequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: RequestBodyArguments } | undefined;
};

export type RequestBody3 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsStatus | undefined;
  type: CreateToolRequestBodyToolsRequestType;
  http: CreateToolRequestBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyStatus = ClosedEnum<
  typeof CreateToolRequestBodyStatus
>;

export const CreateToolRequestBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolRequestBodyToolsType = ClosedEnum<
  typeof CreateToolRequestBodyToolsType
>;

export type RequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type RequestBody2 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyStatus | undefined;
  type: CreateToolRequestBodyToolsType;
  jsonSchema: RequestBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RequestBodyStatus = ClosedEnum<typeof RequestBodyStatus>;

export const CreateToolRequestBodyType = {
  Function: "function",
} as const;
export type CreateToolRequestBodyType = ClosedEnum<
  typeof CreateToolRequestBodyType
>;

export type RequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type RequestBody1 = {
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: RequestBodyStatus | undefined;
  type: CreateToolRequestBodyType;
  function: RequestBodyFunction;
};

/**
 * The tool to create
 */
export type CreateToolRequestBody =
  | RequestBody1
  | RequestBody2
  | RequestBody3
  | RequestBody4
  | RequestBody5;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Status
>;

export const CreateToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType>;

export const ResponseBodyLanguage = {
  Python: "python",
} as const;
export type ResponseBodyLanguage = ClosedEnum<typeof ResponseBodyLanguage>;

export type ResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: ResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type ResponseBody5 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: ResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseStatus
>;

export const CreateToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type CreateToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Type
>;

export type ResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type ResponseBodyInputSchema = {
  type: CreateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const ResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ResponseBodyConnectionType = ClosedEnum<
  typeof ResponseBodyConnectionType
>;

export type ResponseBodyMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: ResponseBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: ResponseBodyInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ResponseBodyConnectionType;
};

export type ResponseBody4 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponse200Type;
  mcp: ResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsStatus
>;

export const CreateToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type CreateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const CreateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolResponseBodyMethod = ClosedEnum<
  typeof CreateToolResponseBodyMethod
>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolResponseBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type ResponseBodyDefaultValue = string | number | boolean;

export type ResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ResponseBodyArguments } | undefined;
};

export type ResponseBody3 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponseType;
  http: CreateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyStatus = ClosedEnum<
  typeof CreateToolResponseBodyStatus
>;

export const CreateToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolResponseBodyToolsType = ClosedEnum<
  typeof CreateToolResponseBodyToolsType
>;

export type ResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type ResponseBody2 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsType;
  jsonSchema: ResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ResponseBodyStatus = ClosedEnum<typeof ResponseBodyStatus>;

export const CreateToolResponseBodyType = {
  Function: "function",
} as const;
export type CreateToolResponseBodyType = ClosedEnum<
  typeof CreateToolResponseBodyType
>;

export type CreateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type ResponseBody1 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: ResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyType;
  function: CreateToolResponseBodyFunction;
};

/**
 * Successfully created the tool.
 */
export type CreateToolResponseBody =
  | ResponseBody1
  | ResponseBody2
  | ResponseBody3
  | ResponseBody4
  | ResponseBody5;

/** @internal */
export const CreateToolRequestBodyToolsRequest5Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Status> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest5Status);

/** @internal */
export const CreateToolRequestBodyToolsRequest5Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Status> =
    CreateToolRequestBodyToolsRequest5Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequest5Status$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequest5Status$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequest5Status$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequest5Status$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequest5Status$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyToolsRequest5Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest5Type,
  );

/** @internal */
export const CreateToolRequestBodyToolsRequest5Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Type> =
    CreateToolRequestBodyToolsRequest5Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequest5Type$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequest5Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequest5Type$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequest5Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequest5Type$outboundSchema;
}

/** @internal */
export const RequestBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = z.nativeEnum(RequestBodyLanguage);

/** @internal */
export const RequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = RequestBodyLanguage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyLanguage$ {
  /** @deprecated use `RequestBodyLanguage$inboundSchema` instead. */
  export const inboundSchema = RequestBodyLanguage$inboundSchema;
  /** @deprecated use `RequestBodyLanguage$outboundSchema` instead. */
  export const outboundSchema = RequestBodyLanguage$outboundSchema;
}

/** @internal */
export const RequestBodyCodeTool$inboundSchema: z.ZodType<
  RequestBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: RequestBodyLanguage$inboundSchema,
  code: z.string(),
});

/** @internal */
export type RequestBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const RequestBodyCodeTool$outboundSchema: z.ZodType<
  RequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: RequestBodyLanguage$outboundSchema,
  code: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyCodeTool$ {
  /** @deprecated use `RequestBodyCodeTool$inboundSchema` instead. */
  export const inboundSchema = RequestBodyCodeTool$inboundSchema;
  /** @deprecated use `RequestBodyCodeTool$outboundSchema` instead. */
  export const outboundSchema = RequestBodyCodeTool$outboundSchema;
  /** @deprecated use `RequestBodyCodeTool$Outbound` instead. */
  export type Outbound = RequestBodyCodeTool$Outbound;
}

export function requestBodyCodeToolToJSON(
  requestBodyCodeTool: RequestBodyCodeTool,
): string {
  return JSON.stringify(
    RequestBodyCodeTool$outboundSchema.parse(requestBodyCodeTool),
  );
}

export function requestBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const RequestBody5$inboundSchema: z.ZodType<
  RequestBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest5Status$inboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest5Type$inboundSchema,
  code_tool: z.lazy(() => RequestBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "code_tool": "codeTool",
  });
});

/** @internal */
export type RequestBody5$Outbound = {
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  type: string;
  code_tool: RequestBodyCodeTool$Outbound;
};

/** @internal */
export const RequestBody5$outboundSchema: z.ZodType<
  RequestBody5$Outbound,
  z.ZodTypeDef,
  RequestBody5
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest5Status$outboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest5Type$outboundSchema,
  codeTool: z.lazy(() => RequestBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody5$ {
  /** @deprecated use `RequestBody5$inboundSchema` instead. */
  export const inboundSchema = RequestBody5$inboundSchema;
  /** @deprecated use `RequestBody5$outboundSchema` instead. */
  export const outboundSchema = RequestBody5$outboundSchema;
  /** @deprecated use `RequestBody5$Outbound` instead. */
  export type Outbound = RequestBody5$Outbound;
}

export function requestBody5ToJSON(requestBody5: RequestBody5): string {
  return JSON.stringify(RequestBody5$outboundSchema.parse(requestBody5));
}

export function requestBody5FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody5' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(CreateToolRequestBodyToolsRequestStatus);

/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> =
    CreateToolRequestBodyToolsRequestStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequestStatus$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequestStatus$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequestStatus$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequestStatus$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequestStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyToolsRequest4Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest4Type,
  );

/** @internal */
export const CreateToolRequestBodyToolsRequest4Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4Type> =
    CreateToolRequestBodyToolsRequest4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequest4Type$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequest4Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequest4Type$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequest4Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequest4Type$outboundSchema;
}

/** @internal */
export const Headers$inboundSchema: z.ZodType<Headers, z.ZodTypeDef, unknown> =
  z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });

/** @internal */
export type Headers$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const Headers$outboundSchema: z.ZodType<
  Headers$Outbound,
  z.ZodTypeDef,
  Headers
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Headers$ {
  /** @deprecated use `Headers$inboundSchema` instead. */
  export const inboundSchema = Headers$inboundSchema;
  /** @deprecated use `Headers$outboundSchema` instead. */
  export const outboundSchema = Headers$outboundSchema;
  /** @deprecated use `Headers$Outbound` instead. */
  export type Outbound = Headers$Outbound;
}

export function headersToJSON(headers: Headers): string {
  return JSON.stringify(Headers$outboundSchema.parse(headers));
}

export function headersFromJSON(
  jsonString: string,
): SafeParseResult<Headers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Headers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Headers' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest4McpType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4McpType> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest4McpType);

/** @internal */
export const CreateToolRequestBodyToolsRequest4McpType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4McpType> =
    CreateToolRequestBodyToolsRequest4McpType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequest4McpType$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequest4McpType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequest4McpType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequest4McpType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequest4McpType$outboundSchema;
}

/** @internal */
export const InputSchema$inboundSchema: z.ZodType<
  InputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequest4McpType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/** @internal */
export type InputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const InputSchema$outboundSchema: z.ZodType<
  InputSchema$Outbound,
  z.ZodTypeDef,
  InputSchema
> = z.object({
  type: CreateToolRequestBodyToolsRequest4McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputSchema$ {
  /** @deprecated use `InputSchema$inboundSchema` instead. */
  export const inboundSchema = InputSchema$inboundSchema;
  /** @deprecated use `InputSchema$outboundSchema` instead. */
  export const outboundSchema = InputSchema$outboundSchema;
  /** @deprecated use `InputSchema$Outbound` instead. */
  export type Outbound = InputSchema$Outbound;
}

export function inputSchemaToJSON(inputSchema: InputSchema): string {
  return JSON.stringify(InputSchema$outboundSchema.parse(inputSchema));
}

export function inputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<InputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSchema' from JSON`,
  );
}

/** @internal */
export const ConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = z.nativeEnum(ConnectionType);

/** @internal */
export const ConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = ConnectionType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConnectionType$ {
  /** @deprecated use `ConnectionType$inboundSchema` instead. */
  export const inboundSchema = ConnectionType$inboundSchema;
  /** @deprecated use `ConnectionType$outboundSchema` instead. */
  export const outboundSchema = ConnectionType$outboundSchema;
}

/** @internal */
export const Mcp$inboundSchema: z.ZodType<Mcp, z.ZodTypeDef, unknown> = z
  .object({
    server_id: z.string(),
    tool_name: z.string(),
    server_url: z.string(),
    headers: z.record(z.lazy(() => Headers$inboundSchema)).optional(),
    input_schema: z.lazy(() => InputSchema$inboundSchema),
    connection_type: ConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_id": "serverId",
      "tool_name": "toolName",
      "server_url": "serverUrl",
      "input_schema": "inputSchema",
      "connection_type": "connectionType",
    });
  });

/** @internal */
export type Mcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: Headers$Outbound } | undefined;
  input_schema: InputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const Mcp$outboundSchema: z.ZodType<Mcp$Outbound, z.ZodTypeDef, Mcp> = z
  .object({
    serverId: z.string(),
    toolName: z.string(),
    serverUrl: z.string(),
    headers: z.record(z.lazy(() => Headers$outboundSchema)).optional(),
    inputSchema: z.lazy(() => InputSchema$outboundSchema),
    connectionType: ConnectionType$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      serverId: "server_id",
      toolName: "tool_name",
      serverUrl: "server_url",
      inputSchema: "input_schema",
      connectionType: "connection_type",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mcp$ {
  /** @deprecated use `Mcp$inboundSchema` instead. */
  export const inboundSchema = Mcp$inboundSchema;
  /** @deprecated use `Mcp$outboundSchema` instead. */
  export const outboundSchema = Mcp$outboundSchema;
  /** @deprecated use `Mcp$Outbound` instead. */
  export type Outbound = Mcp$Outbound;
}

export function mcpToJSON(mcp: Mcp): string {
  return JSON.stringify(Mcp$outboundSchema.parse(mcp));
}

export function mcpFromJSON(
  jsonString: string,
): SafeParseResult<Mcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Mcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Mcp' from JSON`,
  );
}

/** @internal */
export const RequestBody4$inboundSchema: z.ZodType<
  RequestBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyToolsRequest4Type$inboundSchema,
  mcp: z.lazy(() => Mcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});

/** @internal */
export type RequestBody4$Outbound = {
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  type: string;
  mcp: Mcp$Outbound;
};

/** @internal */
export const RequestBody4$outboundSchema: z.ZodType<
  RequestBody4$Outbound,
  z.ZodTypeDef,
  RequestBody4
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest4Type$outboundSchema,
  mcp: z.lazy(() => Mcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody4$ {
  /** @deprecated use `RequestBody4$inboundSchema` instead. */
  export const inboundSchema = RequestBody4$inboundSchema;
  /** @deprecated use `RequestBody4$outboundSchema` instead. */
  export const outboundSchema = RequestBody4$outboundSchema;
  /** @deprecated use `RequestBody4$Outbound` instead. */
  export type Outbound = RequestBody4$Outbound;
}

export function requestBody4ToJSON(requestBody4: RequestBody4): string {
  return JSON.stringify(RequestBody4$outboundSchema.parse(requestBody4));
}

export function requestBody4FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody4' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = z.nativeEnum(CreateToolRequestBodyToolsStatus);

/** @internal */
export const CreateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = CreateToolRequestBodyToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsStatus$ {
  /** @deprecated use `CreateToolRequestBodyToolsStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyToolsStatus$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyToolsStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyToolsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> = z.nativeEnum(
    CreateToolRequestBodyToolsRequestType,
  );

/** @internal */
export const CreateToolRequestBodyToolsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> =
    CreateToolRequestBodyToolsRequestType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequestType$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequestType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequestType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequestType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequestType$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = z.nativeEnum(CreateToolRequestBodyMethod);

/** @internal */
export const CreateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = CreateToolRequestBodyMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyMethod$ {
  /** @deprecated use `CreateToolRequestBodyMethod$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyMethod$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyMethod$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyMethod$outboundSchema;
}

/** @internal */
export const RequestBodyBlueprint$inboundSchema: z.ZodType<
  RequestBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type RequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyBlueprint$outboundSchema: z.ZodType<
  RequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  RequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyBlueprint$ {
  /** @deprecated use `RequestBodyBlueprint$inboundSchema` instead. */
  export const inboundSchema = RequestBodyBlueprint$inboundSchema;
  /** @deprecated use `RequestBodyBlueprint$outboundSchema` instead. */
  export const outboundSchema = RequestBodyBlueprint$outboundSchema;
  /** @deprecated use `RequestBodyBlueprint$Outbound` instead. */
  export type Outbound = RequestBodyBlueprint$Outbound;
}

export function requestBodyBlueprintToJSON(
  requestBodyBlueprint: RequestBodyBlueprint,
): string {
  return JSON.stringify(
    RequestBodyBlueprint$outboundSchema.parse(requestBodyBlueprint),
  );
}

export function requestBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest3Type,
  );

/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> =
    CreateToolRequestBodyToolsRequest3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsRequest3Type$ {
  /** @deprecated use `CreateToolRequestBodyToolsRequest3Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolRequestBodyToolsRequest3Type$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsRequest3Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolRequestBodyToolsRequest3Type$outboundSchema;
}

/** @internal */
export const RequestBodyDefaultValue$inboundSchema: z.ZodType<
  RequestBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type RequestBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const RequestBodyDefaultValue$outboundSchema: z.ZodType<
  RequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  RequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyDefaultValue$ {
  /** @deprecated use `RequestBodyDefaultValue$inboundSchema` instead. */
  export const inboundSchema = RequestBodyDefaultValue$inboundSchema;
  /** @deprecated use `RequestBodyDefaultValue$outboundSchema` instead. */
  export const outboundSchema = RequestBodyDefaultValue$outboundSchema;
  /** @deprecated use `RequestBodyDefaultValue$Outbound` instead. */
  export type Outbound = RequestBodyDefaultValue$Outbound;
}

export function requestBodyDefaultValueToJSON(
  requestBodyDefaultValue: RequestBodyDefaultValue,
): string {
  return JSON.stringify(
    RequestBodyDefaultValue$outboundSchema.parse(requestBodyDefaultValue),
  );
}

export function requestBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const RequestBodyArguments$inboundSchema: z.ZodType<
  RequestBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type RequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const RequestBodyArguments$outboundSchema: z.ZodType<
  RequestBodyArguments$Outbound,
  z.ZodTypeDef,
  RequestBodyArguments
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyArguments$ {
  /** @deprecated use `RequestBodyArguments$inboundSchema` instead. */
  export const inboundSchema = RequestBodyArguments$inboundSchema;
  /** @deprecated use `RequestBodyArguments$outboundSchema` instead. */
  export const outboundSchema = RequestBodyArguments$outboundSchema;
  /** @deprecated use `RequestBodyArguments$Outbound` instead. */
  export type Outbound = RequestBodyArguments$Outbound;
}

export function requestBodyArgumentsToJSON(
  requestBodyArguments: RequestBodyArguments,
): string {
  return JSON.stringify(
    RequestBodyArguments$outboundSchema.parse(requestBodyArguments),
  );
}

export function requestBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyHttp$inboundSchema: z.ZodType<
  CreateToolRequestBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$inboundSchema))
    .optional(),
});

/** @internal */
export type CreateToolRequestBodyHttp$Outbound = {
  blueprint: RequestBodyBlueprint$Outbound;
  arguments?: { [k: string]: RequestBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolRequestBodyHttp$outboundSchema: z.ZodType<
  CreateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyHttp$ {
  /** @deprecated use `CreateToolRequestBodyHttp$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyHttp$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyHttp$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyHttp$outboundSchema;
  /** @deprecated use `CreateToolRequestBodyHttp$Outbound` instead. */
  export type Outbound = CreateToolRequestBodyHttp$Outbound;
}

export function createToolRequestBodyHttpToJSON(
  createToolRequestBodyHttp: CreateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHttp$outboundSchema.parse(createToolRequestBodyHttp),
  );
}

export function createToolRequestBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyHttp' from JSON`,
  );
}

/** @internal */
export const RequestBody3$inboundSchema: z.ZodType<
  RequestBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PNPWP0PMEZG64FX10H"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyToolsRequestType$inboundSchema,
  http: z.lazy(() => CreateToolRequestBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
  });
});

/** @internal */
export type RequestBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  type: string;
  http: CreateToolRequestBodyHttp$Outbound;
};

/** @internal */
export const RequestBody3$outboundSchema: z.ZodType<
  RequestBody3$Outbound,
  z.ZodTypeDef,
  RequestBody3
> = z.object({
  id: z.string().default("01K6DAH8PNPWP0PMEZG64FX10H"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyToolsRequestType$outboundSchema,
  http: z.lazy(() => CreateToolRequestBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody3$ {
  /** @deprecated use `RequestBody3$inboundSchema` instead. */
  export const inboundSchema = RequestBody3$inboundSchema;
  /** @deprecated use `RequestBody3$outboundSchema` instead. */
  export const outboundSchema = RequestBody3$outboundSchema;
  /** @deprecated use `RequestBody3$Outbound` instead. */
  export type Outbound = RequestBody3$Outbound;
}

export function requestBody3ToJSON(requestBody3: RequestBody3): string {
  return JSON.stringify(RequestBody3$outboundSchema.parse(requestBody3));
}

export function requestBody3FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody3' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = z.nativeEnum(CreateToolRequestBodyStatus);

/** @internal */
export const CreateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = CreateToolRequestBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyStatus$ {
  /** @deprecated use `CreateToolRequestBodyStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyStatus$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = z.nativeEnum(CreateToolRequestBodyToolsType);

/** @internal */
export const CreateToolRequestBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = CreateToolRequestBodyToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyToolsType$ {
  /** @deprecated use `CreateToolRequestBodyToolsType$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyToolsType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyToolsType$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyToolsType$outboundSchema;
}

/** @internal */
export const RequestBodyJsonSchema$inboundSchema: z.ZodType<
  RequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type RequestBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const RequestBodyJsonSchema$outboundSchema: z.ZodType<
  RequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyJsonSchema$ {
  /** @deprecated use `RequestBodyJsonSchema$inboundSchema` instead. */
  export const inboundSchema = RequestBodyJsonSchema$inboundSchema;
  /** @deprecated use `RequestBodyJsonSchema$outboundSchema` instead. */
  export const outboundSchema = RequestBodyJsonSchema$outboundSchema;
  /** @deprecated use `RequestBodyJsonSchema$Outbound` instead. */
  export type Outbound = RequestBodyJsonSchema$Outbound;
}

export function requestBodyJsonSchemaToJSON(
  requestBodyJsonSchema: RequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RequestBodyJsonSchema$outboundSchema.parse(requestBodyJsonSchema),
  );
}

export function requestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const RequestBody2$inboundSchema: z.ZodType<
  RequestBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PNQCZ6H7GN622SRFHH"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => RequestBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type RequestBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  type: string;
  json_schema: RequestBodyJsonSchema$Outbound;
};

/** @internal */
export const RequestBody2$outboundSchema: z.ZodType<
  RequestBody2$Outbound,
  z.ZodTypeDef,
  RequestBody2
> = z.object({
  id: z.string().default("01K6DAH8PNQCZ6H7GN622SRFHH"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => RequestBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody2$ {
  /** @deprecated use `RequestBody2$inboundSchema` instead. */
  export const inboundSchema = RequestBody2$inboundSchema;
  /** @deprecated use `RequestBody2$outboundSchema` instead. */
  export const outboundSchema = RequestBody2$outboundSchema;
  /** @deprecated use `RequestBody2$Outbound` instead. */
  export type Outbound = RequestBody2$Outbound;
}

export function requestBody2ToJSON(requestBody2: RequestBody2): string {
  return JSON.stringify(RequestBody2$outboundSchema.parse(requestBody2));
}

export function requestBody2FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody2' from JSON`,
  );
}

/** @internal */
export const RequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = z.nativeEnum(RequestBodyStatus);

/** @internal */
export const RequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = RequestBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyStatus$ {
  /** @deprecated use `RequestBodyStatus$inboundSchema` instead. */
  export const inboundSchema = RequestBodyStatus$inboundSchema;
  /** @deprecated use `RequestBodyStatus$outboundSchema` instead. */
  export const outboundSchema = RequestBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = z.nativeEnum(CreateToolRequestBodyType);

/** @internal */
export const CreateToolRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = CreateToolRequestBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBodyType$ {
  /** @deprecated use `CreateToolRequestBodyType$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBodyType$inboundSchema;
  /** @deprecated use `CreateToolRequestBodyType$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBodyType$outboundSchema;
}

/** @internal */
export const RequestBodyFunction$inboundSchema: z.ZodType<
  RequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type RequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyFunction$outboundSchema: z.ZodType<
  RequestBodyFunction$Outbound,
  z.ZodTypeDef,
  RequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBodyFunction$ {
  /** @deprecated use `RequestBodyFunction$inboundSchema` instead. */
  export const inboundSchema = RequestBodyFunction$inboundSchema;
  /** @deprecated use `RequestBodyFunction$outboundSchema` instead. */
  export const outboundSchema = RequestBodyFunction$outboundSchema;
  /** @deprecated use `RequestBodyFunction$Outbound` instead. */
  export type Outbound = RequestBodyFunction$Outbound;
}

export function requestBodyFunctionToJSON(
  requestBodyFunction: RequestBodyFunction,
): string {
  return JSON.stringify(
    RequestBodyFunction$outboundSchema.parse(requestBodyFunction),
  );
}

export function requestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const RequestBody1$inboundSchema: z.ZodType<
  RequestBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: RequestBodyStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyType$inboundSchema,
  function: z.lazy(() => RequestBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});

/** @internal */
export type RequestBody1$Outbound = {
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  type: string;
  function: RequestBodyFunction$Outbound;
};

/** @internal */
export const RequestBody1$outboundSchema: z.ZodType<
  RequestBody1$Outbound,
  z.ZodTypeDef,
  RequestBody1
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: RequestBodyStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyType$outboundSchema,
  function: z.lazy(() => RequestBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody1$ {
  /** @deprecated use `RequestBody1$inboundSchema` instead. */
  export const inboundSchema = RequestBody1$inboundSchema;
  /** @deprecated use `RequestBody1$outboundSchema` instead. */
  export const outboundSchema = RequestBody1$outboundSchema;
  /** @deprecated use `RequestBody1$Outbound` instead. */
  export type Outbound = RequestBody1$Outbound;
}

export function requestBody1ToJSON(requestBody1: RequestBody1): string {
  return JSON.stringify(RequestBody1$outboundSchema.parse(requestBody1));
}

export function requestBody1FromJSON(
  jsonString: string,
): SafeParseResult<RequestBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody1' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBody$inboundSchema: z.ZodType<
  CreateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBody1$inboundSchema),
  z.lazy(() => RequestBody2$inboundSchema),
  z.lazy(() => RequestBody3$inboundSchema),
  z.lazy(() => RequestBody4$inboundSchema),
  z.lazy(() => RequestBody5$inboundSchema),
]);

/** @internal */
export type CreateToolRequestBody$Outbound =
  | RequestBody1$Outbound
  | RequestBody2$Outbound
  | RequestBody3$Outbound
  | RequestBody4$Outbound
  | RequestBody5$Outbound;

/** @internal */
export const CreateToolRequestBody$outboundSchema: z.ZodType<
  CreateToolRequestBody$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBody
> = z.union([
  z.lazy(() => RequestBody1$outboundSchema),
  z.lazy(() => RequestBody2$outboundSchema),
  z.lazy(() => RequestBody3$outboundSchema),
  z.lazy(() => RequestBody4$outboundSchema),
  z.lazy(() => RequestBody5$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolRequestBody$ {
  /** @deprecated use `CreateToolRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateToolRequestBody$inboundSchema;
  /** @deprecated use `CreateToolRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateToolRequestBody$outboundSchema;
  /** @deprecated use `CreateToolRequestBody$Outbound` instead. */
  export type Outbound = CreateToolRequestBody$Outbound;
}

export function createToolRequestBodyToJSON(
  createToolRequestBody: CreateToolRequestBody,
): string {
  return JSON.stringify(
    CreateToolRequestBody$outboundSchema.parse(createToolRequestBody),
  );
}

export function createToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Status);

/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> =
    CreateToolResponseBodyToolsResponse200Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponse200Status$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponse200Status$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponse200Status$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponse200Status$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponse200Status$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJSONType);

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType
  > = CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponse200ApplicationJSONType$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema;
}

/** @internal */
export const ResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = z.nativeEnum(ResponseBodyLanguage);

/** @internal */
export const ResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = ResponseBodyLanguage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyLanguage$ {
  /** @deprecated use `ResponseBodyLanguage$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyLanguage$inboundSchema;
  /** @deprecated use `ResponseBodyLanguage$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyLanguage$outboundSchema;
}

/** @internal */
export const ResponseBodyCodeTool$inboundSchema: z.ZodType<
  ResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: ResponseBodyLanguage$inboundSchema,
  code: z.string(),
});

/** @internal */
export type ResponseBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const ResponseBodyCodeTool$outboundSchema: z.ZodType<
  ResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: ResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyCodeTool$ {
  /** @deprecated use `ResponseBodyCodeTool$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyCodeTool$inboundSchema;
  /** @deprecated use `ResponseBodyCodeTool$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyCodeTool$outboundSchema;
  /** @deprecated use `ResponseBodyCodeTool$Outbound` instead. */
  export type Outbound = ResponseBodyCodeTool$Outbound;
}

export function responseBodyCodeToolToJSON(
  responseBodyCodeTool: ResponseBodyCodeTool,
): string {
  return JSON.stringify(
    ResponseBodyCodeTool$outboundSchema.parse(responseBodyCodeTool),
  );
}

export function responseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const ResponseBody5$inboundSchema: z.ZodType<
  ResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PMEKSB9YE8EC10EK8T"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => ResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

/** @internal */
export type ResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: ResponseBodyCodeTool$Outbound;
};

/** @internal */
export const ResponseBody5$outboundSchema: z.ZodType<
  ResponseBody5$Outbound,
  z.ZodTypeDef,
  ResponseBody5
> = z.object({
  id: z.string().default("01K6DAH8PMEKSB9YE8EC10EK8T"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => ResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody5$ {
  /** @deprecated use `ResponseBody5$inboundSchema` instead. */
  export const inboundSchema = ResponseBody5$inboundSchema;
  /** @deprecated use `ResponseBody5$outboundSchema` instead. */
  export const outboundSchema = ResponseBody5$outboundSchema;
  /** @deprecated use `ResponseBody5$Outbound` instead. */
  export type Outbound = ResponseBody5$Outbound;
}

export function responseBody5ToJSON(responseBody5: ResponseBody5): string {
  return JSON.stringify(ResponseBody5$outboundSchema.parse(responseBody5));
}

export function responseBody5FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody5' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseStatus);

/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> =
    CreateToolResponseBodyToolsResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponseStatus$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponseStatus$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponseStatus$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponseStatus$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponseStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Type);

/** @internal */
export const CreateToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Type> =
    CreateToolResponseBodyToolsResponse200Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponse200Type$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponse200Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponse200Type$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponse200Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponse200Type$outboundSchema;
}

/** @internal */
export const ResponseBodyHeaders$inboundSchema: z.ZodType<
  ResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/** @internal */
export type ResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const ResponseBodyHeaders$outboundSchema: z.ZodType<
  ResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  ResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyHeaders$ {
  /** @deprecated use `ResponseBodyHeaders$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyHeaders$inboundSchema;
  /** @deprecated use `ResponseBodyHeaders$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyHeaders$outboundSchema;
  /** @deprecated use `ResponseBodyHeaders$Outbound` instead. */
  export type Outbound = ResponseBodyHeaders$Outbound;
}

export function responseBodyHeadersToJSON(
  responseBodyHeaders: ResponseBodyHeaders,
): string {
  return JSON.stringify(
    ResponseBodyHeaders$outboundSchema.parse(responseBodyHeaders),
  );
}

export function responseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson4Type);

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponse200ApplicationJson4Type$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema;
}

/** @internal */
export const ResponseBodyInputSchema$inboundSchema: z.ZodType<
  ResponseBodyInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/** @internal */
export type ResponseBodyInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const ResponseBodyInputSchema$outboundSchema: z.ZodType<
  ResponseBodyInputSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyInputSchema
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyInputSchema$ {
  /** @deprecated use `ResponseBodyInputSchema$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyInputSchema$inboundSchema;
  /** @deprecated use `ResponseBodyInputSchema$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyInputSchema$outboundSchema;
  /** @deprecated use `ResponseBodyInputSchema$Outbound` instead. */
  export type Outbound = ResponseBodyInputSchema$Outbound;
}

export function responseBodyInputSchemaToJSON(
  responseBodyInputSchema: ResponseBodyInputSchema,
): string {
  return JSON.stringify(
    ResponseBodyInputSchema$outboundSchema.parse(responseBodyInputSchema),
  );
}

export function responseBodyInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyInputSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = z.nativeEnum(ResponseBodyConnectionType);

/** @internal */
export const ResponseBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = ResponseBodyConnectionType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyConnectionType$ {
  /** @deprecated use `ResponseBodyConnectionType$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyConnectionType$inboundSchema;
  /** @deprecated use `ResponseBodyConnectionType$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyConnectionType$outboundSchema;
}

/** @internal */
export const ResponseBodyMcp$inboundSchema: z.ZodType<
  ResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_id: z.string(),
  tool_name: z.string(),
  server_url: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$inboundSchema)).optional(),
  input_schema: z.lazy(() => ResponseBodyInputSchema$inboundSchema),
  connection_type: ResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_id": "serverId",
    "tool_name": "toolName",
    "server_url": "serverUrl",
    "input_schema": "inputSchema",
    "connection_type": "connectionType",
  });
});

/** @internal */
export type ResponseBodyMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: ResponseBodyHeaders$Outbound } | undefined;
  input_schema: ResponseBodyInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const ResponseBodyMcp$outboundSchema: z.ZodType<
  ResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  ResponseBodyMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$outboundSchema))
    .optional(),
  inputSchema: z.lazy(() => ResponseBodyInputSchema$outboundSchema),
  connectionType: ResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyMcp$ {
  /** @deprecated use `ResponseBodyMcp$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyMcp$inboundSchema;
  /** @deprecated use `ResponseBodyMcp$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyMcp$outboundSchema;
  /** @deprecated use `ResponseBodyMcp$Outbound` instead. */
  export type Outbound = ResponseBodyMcp$Outbound;
}

export function responseBodyMcpToJSON(
  responseBodyMcp: ResponseBodyMcp,
): string {
  return JSON.stringify(ResponseBodyMcp$outboundSchema.parse(responseBodyMcp));
}

export function responseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const ResponseBody4$inboundSchema: z.ZodType<
  ResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PKXPF2JHSK1WKH2HMT"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => ResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type ResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: ResponseBodyMcp$Outbound;
};

/** @internal */
export const ResponseBody4$outboundSchema: z.ZodType<
  ResponseBody4$Outbound,
  z.ZodTypeDef,
  ResponseBody4
> = z.object({
  id: z.string().default("01K6DAH8PKXPF2JHSK1WKH2HMT"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => ResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody4$ {
  /** @deprecated use `ResponseBody4$inboundSchema` instead. */
  export const inboundSchema = ResponseBody4$inboundSchema;
  /** @deprecated use `ResponseBody4$outboundSchema` instead. */
  export const outboundSchema = ResponseBody4$outboundSchema;
  /** @deprecated use `ResponseBody4$Outbound` instead. */
  export type Outbound = ResponseBody4$Outbound;
}

export function responseBody4ToJSON(responseBody4: ResponseBody4): string {
  return JSON.stringify(ResponseBody4$outboundSchema.parse(responseBody4));
}

export function responseBody4FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody4' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = z.nativeEnum(CreateToolResponseBodyToolsStatus);

/** @internal */
export const CreateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = CreateToolResponseBodyToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsStatus$ {
  /** @deprecated use `CreateToolResponseBodyToolsStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyToolsStatus$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsStatus$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseType);

/** @internal */
export const CreateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> =
    CreateToolResponseBodyToolsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponseType$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponseType$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponseType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponseType$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponseType$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = z.nativeEnum(CreateToolResponseBodyMethod);

/** @internal */
export const CreateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = CreateToolResponseBodyMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyMethod$ {
  /** @deprecated use `CreateToolResponseBodyMethod$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyMethod$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyMethod$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyMethod$outboundSchema;
}

/** @internal */
export const ResponseBodyBlueprint$inboundSchema: z.ZodType<
  ResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type ResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseBodyBlueprint$outboundSchema: z.ZodType<
  ResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  ResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyBlueprint$ {
  /** @deprecated use `ResponseBodyBlueprint$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyBlueprint$inboundSchema;
  /** @deprecated use `ResponseBodyBlueprint$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyBlueprint$outboundSchema;
  /** @deprecated use `ResponseBodyBlueprint$Outbound` instead. */
  export type Outbound = ResponseBodyBlueprint$Outbound;
}

export function responseBodyBlueprintToJSON(
  responseBodyBlueprint: ResponseBodyBlueprint,
): string {
  return JSON.stringify(
    ResponseBodyBlueprint$outboundSchema.parse(responseBodyBlueprint),
  );
}

export function responseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson3Type);

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsResponse200ApplicationJson3Type$ {
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema` instead. */
  export const inboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema` instead. */
  export const outboundSchema =
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema;
}

/** @internal */
export const ResponseBodyDefaultValue$inboundSchema: z.ZodType<
  ResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type ResponseBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const ResponseBodyDefaultValue$outboundSchema: z.ZodType<
  ResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  ResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyDefaultValue$ {
  /** @deprecated use `ResponseBodyDefaultValue$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyDefaultValue$inboundSchema;
  /** @deprecated use `ResponseBodyDefaultValue$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyDefaultValue$outboundSchema;
  /** @deprecated use `ResponseBodyDefaultValue$Outbound` instead. */
  export type Outbound = ResponseBodyDefaultValue$Outbound;
}

export function responseBodyDefaultValueToJSON(
  responseBodyDefaultValue: ResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    ResponseBodyDefaultValue$outboundSchema.parse(responseBodyDefaultValue),
  );
}

export function responseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArguments$inboundSchema: z.ZodType<
  ResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type ResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const ResponseBodyArguments$outboundSchema: z.ZodType<
  ResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  ResponseBodyArguments
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyArguments$ {
  /** @deprecated use `ResponseBodyArguments$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyArguments$inboundSchema;
  /** @deprecated use `ResponseBodyArguments$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyArguments$outboundSchema;
  /** @deprecated use `ResponseBodyArguments$Outbound` instead. */
  export type Outbound = ResponseBodyArguments$Outbound;
}

export function responseBodyArgumentsToJSON(
  responseBodyArguments: ResponseBodyArguments,
): string {
  return JSON.stringify(
    ResponseBodyArguments$outboundSchema.parse(responseBodyArguments),
  );
}

export function responseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHttp$inboundSchema: z.ZodType<
  CreateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$inboundSchema))
    .optional(),
});

/** @internal */
export type CreateToolResponseBodyHttp$Outbound = {
  blueprint: ResponseBodyBlueprint$Outbound;
  arguments?: { [k: string]: ResponseBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolResponseBodyHttp$outboundSchema: z.ZodType<
  CreateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$outboundSchema))
    .optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyHttp$ {
  /** @deprecated use `CreateToolResponseBodyHttp$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyHttp$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyHttp$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyHttp$outboundSchema;
  /** @deprecated use `CreateToolResponseBodyHttp$Outbound` instead. */
  export type Outbound = CreateToolResponseBodyHttp$Outbound;
}

export function createToolResponseBodyHttpToJSON(
  createToolResponseBodyHttp: CreateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    CreateToolResponseBodyHttp$outboundSchema.parse(createToolResponseBodyHttp),
  );
}

export function createToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const ResponseBody3$inboundSchema: z.ZodType<
  ResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PJTRNV0NKR1N95Z5N2"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => CreateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type ResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: CreateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const ResponseBody3$outboundSchema: z.ZodType<
  ResponseBody3$Outbound,
  z.ZodTypeDef,
  ResponseBody3
> = z.object({
  id: z.string().default("01K6DAH8PJTRNV0NKR1N95Z5N2"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => CreateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody3$ {
  /** @deprecated use `ResponseBody3$inboundSchema` instead. */
  export const inboundSchema = ResponseBody3$inboundSchema;
  /** @deprecated use `ResponseBody3$outboundSchema` instead. */
  export const outboundSchema = ResponseBody3$outboundSchema;
  /** @deprecated use `ResponseBody3$Outbound` instead. */
  export type Outbound = ResponseBody3$Outbound;
}

export function responseBody3ToJSON(responseBody3: ResponseBody3): string {
  return JSON.stringify(ResponseBody3$outboundSchema.parse(responseBody3));
}

export function responseBody3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody3' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = z.nativeEnum(CreateToolResponseBodyStatus);

/** @internal */
export const CreateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = CreateToolResponseBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyStatus$ {
  /** @deprecated use `CreateToolResponseBodyStatus$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyStatus$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyStatus$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = z.nativeEnum(CreateToolResponseBodyToolsType);

/** @internal */
export const CreateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = CreateToolResponseBodyToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyToolsType$ {
  /** @deprecated use `CreateToolResponseBodyToolsType$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyToolsType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyToolsType$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyToolsType$outboundSchema;
}

/** @internal */
export const ResponseBodyJsonSchema$inboundSchema: z.ZodType<
  ResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type ResponseBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const ResponseBodyJsonSchema$outboundSchema: z.ZodType<
  ResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyJsonSchema$ {
  /** @deprecated use `ResponseBodyJsonSchema$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyJsonSchema$inboundSchema;
  /** @deprecated use `ResponseBodyJsonSchema$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyJsonSchema$outboundSchema;
  /** @deprecated use `ResponseBodyJsonSchema$Outbound` instead. */
  export type Outbound = ResponseBodyJsonSchema$Outbound;
}

export function responseBodyJsonSchemaToJSON(
  responseBodyJsonSchema: ResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    ResponseBodyJsonSchema$outboundSchema.parse(responseBodyJsonSchema),
  );
}

export function responseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PJDQNVGCDMMS5FZMGX"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => ResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type ResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: ResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  id: z.string().default("01K6DAH8PJDQNVGCDMMS5FZMGX"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => ResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody2$ {
  /** @deprecated use `ResponseBody2$inboundSchema` instead. */
  export const inboundSchema = ResponseBody2$inboundSchema;
  /** @deprecated use `ResponseBody2$outboundSchema` instead. */
  export const outboundSchema = ResponseBody2$outboundSchema;
  /** @deprecated use `ResponseBody2$Outbound` instead. */
  export type Outbound = ResponseBody2$Outbound;
}

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}

export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const ResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = z.nativeEnum(ResponseBodyStatus);

/** @internal */
export const ResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = ResponseBodyStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyStatus$ {
  /** @deprecated use `ResponseBodyStatus$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyStatus$inboundSchema;
  /** @deprecated use `ResponseBodyStatus$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyStatus$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = z.nativeEnum(CreateToolResponseBodyType);

/** @internal */
export const CreateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = CreateToolResponseBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyType$ {
  /** @deprecated use `CreateToolResponseBodyType$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyType$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyType$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyType$outboundSchema;
}

/** @internal */
export const CreateToolResponseBodyFunction$inboundSchema: z.ZodType<
  CreateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type CreateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateToolResponseBodyFunction$outboundSchema: z.ZodType<
  CreateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBodyFunction$ {
  /** @deprecated use `CreateToolResponseBodyFunction$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBodyFunction$inboundSchema;
  /** @deprecated use `CreateToolResponseBodyFunction$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBodyFunction$outboundSchema;
  /** @deprecated use `CreateToolResponseBodyFunction$Outbound` instead. */
  export type Outbound = CreateToolResponseBodyFunction$Outbound;
}

export function createToolResponseBodyFunctionToJSON(
  createToolResponseBodyFunction: CreateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    CreateToolResponseBodyFunction$outboundSchema.parse(
      createToolResponseBodyFunction,
    ),
  );
}

export function createToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const ResponseBody1$inboundSchema: z.ZodType<
  ResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K6DAH8PHZTAFV29JAAEFKPZC"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyType$inboundSchema,
  function: z.lazy(() => CreateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type ResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: CreateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const ResponseBody1$outboundSchema: z.ZodType<
  ResponseBody1$Outbound,
  z.ZodTypeDef,
  ResponseBody1
> = z.object({
  id: z.string().default("01K6DAH8PHZTAFV29JAAEFKPZC"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyType$outboundSchema,
  function: z.lazy(() => CreateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody1$ {
  /** @deprecated use `ResponseBody1$inboundSchema` instead. */
  export const inboundSchema = ResponseBody1$inboundSchema;
  /** @deprecated use `ResponseBody1$outboundSchema` instead. */
  export const outboundSchema = ResponseBody1$outboundSchema;
  /** @deprecated use `ResponseBody1$Outbound` instead. */
  export type Outbound = ResponseBody1$Outbound;
}

export function responseBody1ToJSON(responseBody1: ResponseBody1): string {
  return JSON.stringify(ResponseBody1$outboundSchema.parse(responseBody1));
}

export function responseBody1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBody$inboundSchema: z.ZodType<
  CreateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBody1$inboundSchema),
  z.lazy(() => ResponseBody2$inboundSchema),
  z.lazy(() => ResponseBody3$inboundSchema),
  z.lazy(() => ResponseBody4$inboundSchema),
  z.lazy(() => ResponseBody5$inboundSchema),
]);

/** @internal */
export type CreateToolResponseBody$Outbound =
  | ResponseBody1$Outbound
  | ResponseBody2$Outbound
  | ResponseBody3$Outbound
  | ResponseBody4$Outbound
  | ResponseBody5$Outbound;

/** @internal */
export const CreateToolResponseBody$outboundSchema: z.ZodType<
  CreateToolResponseBody$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBody
> = z.union([
  z.lazy(() => ResponseBody1$outboundSchema),
  z.lazy(() => ResponseBody2$outboundSchema),
  z.lazy(() => ResponseBody3$outboundSchema),
  z.lazy(() => ResponseBody4$outboundSchema),
  z.lazy(() => ResponseBody5$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateToolResponseBody$ {
  /** @deprecated use `CreateToolResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateToolResponseBody$inboundSchema;
  /** @deprecated use `CreateToolResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateToolResponseBody$outboundSchema;
  /** @deprecated use `CreateToolResponseBody$Outbound` instead. */
  export type Outbound = CreateToolResponseBody$Outbound;
}

export function createToolResponseBodyToJSON(
  createToolResponseBody: CreateToolResponseBody,
): string {
  return JSON.stringify(
    CreateToolResponseBody$outboundSchema.parse(createToolResponseBody),
  );
}

export function createToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBody' from JSON`,
  );
}
