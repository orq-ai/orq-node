/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequest5Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequest5Status = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5Status
>;

export const CreateToolRequestBodyToolsRequest5Type = {
  Code: "code",
} as const;
export type CreateToolRequestBodyToolsRequest5Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5Type
>;

export const RequestBodyLanguage = {
  Python: "python",
} as const;
export type RequestBodyLanguage = ClosedEnum<typeof RequestBodyLanguage>;

export type RequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: RequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type RequestBodyCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequest5Status | undefined;
  type: CreateToolRequestBodyToolsRequest5Type;
  codeTool: RequestBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestStatus
>;

export const CreateToolRequestBodyToolsRequest4Type = {
  Mcp: "mcp",
} as const;
export type CreateToolRequestBodyToolsRequest4Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest4Type
>;

export type RequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const CreateToolRequestBodyToolsRequest4McpType = {
  Object: "object",
} as const;
export type CreateToolRequestBodyToolsRequest4McpType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest4McpType
>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type InputSchema = {
  type: CreateToolRequestBodyToolsRequest4McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const ConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ConnectionType = ClosedEnum<typeof ConnectionType>;

export type Mcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: RequestBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: InputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type MCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequestStatus | undefined;
  type: CreateToolRequestBodyToolsRequest4Type;
  mcp: Mcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsStatus
>;

export const CreateToolRequestBodyToolsRequestType = {
  Http: "http",
} as const;
export type CreateToolRequestBodyToolsRequestType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestType
>;

/**
 * The HTTP method to use.
 */
export const CreateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolRequestBodyMethod = ClosedEnum<
  typeof CreateToolRequestBodyMethod
>;

export type CreateToolRequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type RequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolRequestBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: CreateToolRequestBodyHeaders } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type RequestBodyDefaultValue = string | number | boolean;

export type RequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: RequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: RequestBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type RequestBodyHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsStatus | undefined;
  type: CreateToolRequestBodyToolsRequestType;
  http: CreateToolRequestBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyStatus = ClosedEnum<
  typeof CreateToolRequestBodyStatus
>;

export const CreateToolRequestBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolRequestBodyToolsType = ClosedEnum<
  typeof CreateToolRequestBodyToolsType
>;

export type RequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type JSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyStatus | undefined;
  type: CreateToolRequestBodyToolsType;
  jsonSchema: RequestBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RequestBodyStatus = ClosedEnum<typeof RequestBodyStatus>;

export const CreateToolRequestBodyType = {
  Function: "function",
} as const;
export type CreateToolRequestBodyType = ClosedEnum<
  typeof CreateToolRequestBodyType
>;

export type RequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type RequestBodyFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: RequestBodyStatus | undefined;
  type: CreateToolRequestBodyType;
  function: RequestBodyFunction;
};

/**
 * The tool to create
 */
export type CreateToolRequestBody =
  | RequestBodyFunctionTool
  | JSONSchemaTool
  | RequestBodyHTTPTool
  | MCPTool
  | RequestBodyCodeExecutionTool;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Status
>;

export const CreateToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType>;

export const ResponseBodyLanguage = {
  Python: "python",
} as const;
export type ResponseBodyLanguage = ClosedEnum<typeof ResponseBodyLanguage>;

export type ResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: ResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type ResponseBody5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: ResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseStatus
>;

export const CreateToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type CreateToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Type
>;

export type ResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type>;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type ResponseBodyInputSchema = {
  type: CreateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const ResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ResponseBodyConnectionType = ClosedEnum<
  typeof ResponseBodyConnectionType
>;

export type ResponseBodyMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: ResponseBodyHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: ResponseBodyInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ResponseBodyConnectionType;
};

export type ResponseBody4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponse200Type;
  mcp: ResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsStatus
>;

export const CreateToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type CreateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const CreateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolResponseBodyMethod = ClosedEnum<
  typeof CreateToolResponseBodyMethod
>;

export type CreateToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolResponseBodyMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: CreateToolResponseBodyHeaders } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type ResponseBodyDefaultValue = string | number | boolean;

export type ResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ResponseBodyArguments } | undefined;
};

export type ResponseBody3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsResponseType;
  http: CreateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyStatus = ClosedEnum<
  typeof CreateToolResponseBodyStatus
>;

export const CreateToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateToolResponseBodyToolsType = ClosedEnum<
  typeof CreateToolResponseBodyToolsType
>;

export type ResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

export type ResponseBody2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyToolsType;
  jsonSchema: ResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ResponseBodyStatus = ClosedEnum<typeof ResponseBodyStatus>;

export const CreateToolResponseBodyType = {
  Function: "function",
} as const;
export type CreateToolResponseBodyType = ClosedEnum<
  typeof CreateToolResponseBodyType
>;

export type CreateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type ResponseBody1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: ResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: CreateToolResponseBodyType;
  function: CreateToolResponseBodyFunction;
};

/**
 * Successfully created the tool.
 */
export type CreateToolResponseBody =
  | ResponseBody1
  | ResponseBody2
  | ResponseBody3
  | ResponseBody4
  | ResponseBody5;

/** @internal */
export const CreateToolRequestBodyToolsRequest5Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Status> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest5Status);
/** @internal */
export const CreateToolRequestBodyToolsRequest5Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Status> =
    CreateToolRequestBodyToolsRequest5Status$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsRequest5Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest5Type,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequest5Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5Type> =
    CreateToolRequestBodyToolsRequest5Type$inboundSchema;

/** @internal */
export const RequestBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = z.nativeEnum(RequestBodyLanguage);
/** @internal */
export const RequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = RequestBodyLanguage$inboundSchema;

/** @internal */
export const RequestBodyCodeTool$inboundSchema: z.ZodType<
  RequestBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: RequestBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type RequestBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const RequestBodyCodeTool$outboundSchema: z.ZodType<
  RequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: RequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function requestBodyCodeToolToJSON(
  requestBodyCodeTool: RequestBodyCodeTool,
): string {
  return JSON.stringify(
    RequestBodyCodeTool$outboundSchema.parse(requestBodyCodeTool),
  );
}
export function requestBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const RequestBodyCodeExecutionTool$inboundSchema: z.ZodType<
  RequestBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest5Status$inboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest5Type$inboundSchema,
  code_tool: z.lazy(() => RequestBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type RequestBodyCodeExecutionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: string;
  code_tool: RequestBodyCodeTool$Outbound;
};

/** @internal */
export const RequestBodyCodeExecutionTool$outboundSchema: z.ZodType<
  RequestBodyCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeExecutionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest5Status$outboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest5Type$outboundSchema,
  codeTool: z.lazy(() => RequestBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function requestBodyCodeExecutionToolToJSON(
  requestBodyCodeExecutionTool: RequestBodyCodeExecutionTool,
): string {
  return JSON.stringify(
    RequestBodyCodeExecutionTool$outboundSchema.parse(
      requestBodyCodeExecutionTool,
    ),
  );
}
export function requestBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(CreateToolRequestBodyToolsRequestStatus);
/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> =
    CreateToolRequestBodyToolsRequestStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsRequest4Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest4Type,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequest4Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4Type> =
    CreateToolRequestBodyToolsRequest4Type$inboundSchema;

/** @internal */
export const RequestBodyHeaders$inboundSchema: z.ZodType<
  RequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type RequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const RequestBodyHeaders$outboundSchema: z.ZodType<
  RequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  RequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function requestBodyHeadersToJSON(
  requestBodyHeaders: RequestBodyHeaders,
): string {
  return JSON.stringify(
    RequestBodyHeaders$outboundSchema.parse(requestBodyHeaders),
  );
}
export function requestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest4McpType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4McpType> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest4McpType);
/** @internal */
export const CreateToolRequestBodyToolsRequest4McpType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest4McpType> =
    CreateToolRequestBodyToolsRequest4McpType$inboundSchema;

/** @internal */
export const InputSchema$inboundSchema: z.ZodType<
  InputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequest4McpType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type InputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const InputSchema$outboundSchema: z.ZodType<
  InputSchema$Outbound,
  z.ZodTypeDef,
  InputSchema
> = z.object({
  type: CreateToolRequestBodyToolsRequest4McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function inputSchemaToJSON(inputSchema: InputSchema): string {
  return JSON.stringify(InputSchema$outboundSchema.parse(inputSchema));
}
export function inputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<InputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputSchema' from JSON`,
  );
}

/** @internal */
export const ConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = z.nativeEnum(ConnectionType);
/** @internal */
export const ConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = ConnectionType$inboundSchema;

/** @internal */
export const Mcp$inboundSchema: z.ZodType<Mcp, z.ZodTypeDef, unknown> = z
  .object({
    server_id: z.string(),
    tool_name: z.string(),
    server_url: z.string(),
    headers: z.record(z.lazy(() => RequestBodyHeaders$inboundSchema))
      .optional(),
    input_schema: z.lazy(() => InputSchema$inboundSchema),
    connection_type: ConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_id": "serverId",
      "tool_name": "toolName",
      "server_url": "serverUrl",
      "input_schema": "inputSchema",
      "connection_type": "connectionType",
    });
  });
/** @internal */
export type Mcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: RequestBodyHeaders$Outbound } | undefined;
  input_schema: InputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const Mcp$outboundSchema: z.ZodType<Mcp$Outbound, z.ZodTypeDef, Mcp> = z
  .object({
    serverId: z.string(),
    toolName: z.string(),
    serverUrl: z.string(),
    headers: z.record(z.lazy(() => RequestBodyHeaders$outboundSchema))
      .optional(),
    inputSchema: z.lazy(() => InputSchema$outboundSchema),
    connectionType: ConnectionType$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      serverId: "server_id",
      toolName: "tool_name",
      serverUrl: "server_url",
      inputSchema: "input_schema",
      connectionType: "connection_type",
    });
  });

export function mcpToJSON(mcp: Mcp): string {
  return JSON.stringify(Mcp$outboundSchema.parse(mcp));
}
export function mcpFromJSON(
  jsonString: string,
): SafeParseResult<Mcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Mcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Mcp' from JSON`,
  );
}

/** @internal */
export const MCPTool$inboundSchema: z.ZodType<MCPTool, z.ZodTypeDef, unknown> =
  z.object({
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    status: CreateToolRequestBodyToolsRequestStatus$inboundSchema.default(
      "live",
    ),
    type: CreateToolRequestBodyToolsRequest4Type$inboundSchema,
    mcp: z.lazy(() => Mcp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
    });
  });
/** @internal */
export type MCPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: string;
  mcp: Mcp$Outbound;
};

/** @internal */
export const MCPTool$outboundSchema: z.ZodType<
  MCPTool$Outbound,
  z.ZodTypeDef,
  MCPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: CreateToolRequestBodyToolsRequest4Type$outboundSchema,
  mcp: z.lazy(() => Mcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function mcpToolToJSON(mcpTool: MCPTool): string {
  return JSON.stringify(MCPTool$outboundSchema.parse(mcpTool));
}
export function mcpToolFromJSON(
  jsonString: string,
): SafeParseResult<MCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MCPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = z.nativeEnum(CreateToolRequestBodyToolsStatus);
/** @internal */
export const CreateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = CreateToolRequestBodyToolsStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> = z.nativeEnum(
    CreateToolRequestBodyToolsRequestType,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestType> =
    CreateToolRequestBodyToolsRequestType$inboundSchema;

/** @internal */
export const CreateToolRequestBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = z.nativeEnum(CreateToolRequestBodyMethod);
/** @internal */
export const CreateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = CreateToolRequestBodyMethod$inboundSchema;

/** @internal */
export const CreateToolRequestBodyHeaders$inboundSchema: z.ZodType<
  CreateToolRequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type CreateToolRequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const CreateToolRequestBodyHeaders$outboundSchema: z.ZodType<
  CreateToolRequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolRequestBodyHeadersToJSON(
  createToolRequestBodyHeaders: CreateToolRequestBodyHeaders,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHeaders$outboundSchema.parse(
      createToolRequestBodyHeaders,
    ),
  );
}
export function createToolRequestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const RequestBodyBlueprint$inboundSchema: z.ZodType<
  RequestBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$inboundSchema,
  headers: z.record(z.lazy(() => CreateToolRequestBodyHeaders$inboundSchema))
    .optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type RequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: CreateToolRequestBodyHeaders$Outbound } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyBlueprint$outboundSchema: z.ZodType<
  RequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  RequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$outboundSchema,
  headers: z.record(z.lazy(() => CreateToolRequestBodyHeaders$outboundSchema))
    .optional(),
  body: z.record(z.any()).optional(),
});

export function requestBodyBlueprintToJSON(
  requestBodyBlueprint: RequestBodyBlueprint,
): string {
  return JSON.stringify(
    RequestBodyBlueprint$outboundSchema.parse(requestBodyBlueprint),
  );
}
export function requestBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest3Type,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> =
    CreateToolRequestBodyToolsRequest3Type$inboundSchema;

/** @internal */
export const RequestBodyDefaultValue$inboundSchema: z.ZodType<
  RequestBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type RequestBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const RequestBodyDefaultValue$outboundSchema: z.ZodType<
  RequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  RequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function requestBodyDefaultValueToJSON(
  requestBodyDefaultValue: RequestBodyDefaultValue,
): string {
  return JSON.stringify(
    RequestBodyDefaultValue$outboundSchema.parse(requestBodyDefaultValue),
  );
}
export function requestBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const RequestBodyArguments$inboundSchema: z.ZodType<
  RequestBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type RequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const RequestBodyArguments$outboundSchema: z.ZodType<
  RequestBodyArguments$Outbound,
  z.ZodTypeDef,
  RequestBodyArguments
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function requestBodyArgumentsToJSON(
  requestBodyArguments: RequestBodyArguments,
): string {
  return JSON.stringify(
    RequestBodyArguments$outboundSchema.parse(requestBodyArguments),
  );
}
export function requestBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyHttp$inboundSchema: z.ZodType<
  CreateToolRequestBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type CreateToolRequestBodyHttp$Outbound = {
  blueprint: RequestBodyBlueprint$Outbound;
  arguments?: { [k: string]: RequestBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolRequestBodyHttp$outboundSchema: z.ZodType<
  CreateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$outboundSchema))
    .optional(),
});

export function createToolRequestBodyHttpToJSON(
  createToolRequestBodyHttp: CreateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHttp$outboundSchema.parse(createToolRequestBodyHttp),
  );
}
export function createToolRequestBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyHttp' from JSON`,
  );
}

/** @internal */
export const RequestBodyHTTPTool$inboundSchema: z.ZodType<
  RequestBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyToolsRequestType$inboundSchema,
  http: z.lazy(() => CreateToolRequestBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type RequestBodyHTTPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: string;
  http: CreateToolRequestBodyHttp$Outbound;
};

/** @internal */
export const RequestBodyHTTPTool$outboundSchema: z.ZodType<
  RequestBodyHTTPTool$Outbound,
  z.ZodTypeDef,
  RequestBodyHTTPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyToolsRequestType$outboundSchema,
  http: z.lazy(() => CreateToolRequestBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyHTTPToolToJSON(
  requestBodyHTTPTool: RequestBodyHTTPTool,
): string {
  return JSON.stringify(
    RequestBodyHTTPTool$outboundSchema.parse(requestBodyHTTPTool),
  );
}
export function requestBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = z.nativeEnum(CreateToolRequestBodyStatus);
/** @internal */
export const CreateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = CreateToolRequestBodyStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = z.nativeEnum(CreateToolRequestBodyToolsType);
/** @internal */
export const CreateToolRequestBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsType
> = CreateToolRequestBodyToolsType$inboundSchema;

/** @internal */
export const RequestBodyJsonSchema$inboundSchema: z.ZodType<
  RequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});
/** @internal */
export type RequestBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict?: boolean | undefined;
};

/** @internal */
export const RequestBodyJsonSchema$outboundSchema: z.ZodType<
  RequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});

export function requestBodyJsonSchemaToJSON(
  requestBodyJsonSchema: RequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RequestBodyJsonSchema$outboundSchema.parse(requestBodyJsonSchema),
  );
}
export function requestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const JSONSchemaTool$inboundSchema: z.ZodType<
  JSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => RequestBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type JSONSchemaTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: string;
  json_schema: RequestBodyJsonSchema$Outbound;
};

/** @internal */
export const JSONSchemaTool$outboundSchema: z.ZodType<
  JSONSchemaTool$Outbound,
  z.ZodTypeDef,
  JSONSchemaTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => RequestBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function jsonSchemaToolToJSON(jsonSchemaTool: JSONSchemaTool): string {
  return JSON.stringify(JSONSchemaTool$outboundSchema.parse(jsonSchemaTool));
}
export function jsonSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<JSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const RequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = z.nativeEnum(RequestBodyStatus);
/** @internal */
export const RequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = RequestBodyStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = z.nativeEnum(CreateToolRequestBodyType);
/** @internal */
export const CreateToolRequestBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyType
> = CreateToolRequestBodyType$inboundSchema;

/** @internal */
export const RequestBodyFunction$inboundSchema: z.ZodType<
  RequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type RequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyFunction$outboundSchema: z.ZodType<
  RequestBodyFunction$Outbound,
  z.ZodTypeDef,
  RequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function requestBodyFunctionToJSON(
  requestBodyFunction: RequestBodyFunction,
): string {
  return JSON.stringify(
    RequestBodyFunction$outboundSchema.parse(requestBodyFunction),
  );
}
export function requestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const RequestBodyFunctionTool$inboundSchema: z.ZodType<
  RequestBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: RequestBodyStatus$inboundSchema.default("live"),
  type: CreateToolRequestBodyType$inboundSchema,
  function: z.lazy(() => RequestBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type RequestBodyFunctionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: string;
  function: RequestBodyFunction$Outbound;
};

/** @internal */
export const RequestBodyFunctionTool$outboundSchema: z.ZodType<
  RequestBodyFunctionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyFunctionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: RequestBodyStatus$outboundSchema.default("live"),
  type: CreateToolRequestBodyType$outboundSchema,
  function: z.lazy(() => RequestBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyFunctionToolToJSON(
  requestBodyFunctionTool: RequestBodyFunctionTool,
): string {
  return JSON.stringify(
    RequestBodyFunctionTool$outboundSchema.parse(requestBodyFunctionTool),
  );
}
export function requestBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBody$inboundSchema: z.ZodType<
  CreateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBodyFunctionTool$inboundSchema),
  z.lazy(() => JSONSchemaTool$inboundSchema),
  z.lazy(() => RequestBodyHTTPTool$inboundSchema),
  z.lazy(() => MCPTool$inboundSchema),
  z.lazy(() => RequestBodyCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type CreateToolRequestBody$Outbound =
  | RequestBodyFunctionTool$Outbound
  | JSONSchemaTool$Outbound
  | RequestBodyHTTPTool$Outbound
  | MCPTool$Outbound
  | RequestBodyCodeExecutionTool$Outbound;

/** @internal */
export const CreateToolRequestBody$outboundSchema: z.ZodType<
  CreateToolRequestBody$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBody
> = z.union([
  z.lazy(() => RequestBodyFunctionTool$outboundSchema),
  z.lazy(() => JSONSchemaTool$outboundSchema),
  z.lazy(() => RequestBodyHTTPTool$outboundSchema),
  z.lazy(() => MCPTool$outboundSchema),
  z.lazy(() => RequestBodyCodeExecutionTool$outboundSchema),
]);

export function createToolRequestBodyToJSON(
  createToolRequestBody: CreateToolRequestBody,
): string {
  return JSON.stringify(
    CreateToolRequestBody$outboundSchema.parse(createToolRequestBody),
  );
}
export function createToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Status);
/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> =
    CreateToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJSONType);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJSONType
  > = CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const ResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = z.nativeEnum(ResponseBodyLanguage);
/** @internal */
export const ResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = ResponseBodyLanguage$inboundSchema;

/** @internal */
export const ResponseBodyCodeTool$inboundSchema: z.ZodType<
  ResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: ResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type ResponseBodyCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const ResponseBodyCodeTool$outboundSchema: z.ZodType<
  ResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: ResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function responseBodyCodeToolToJSON(
  responseBodyCodeTool: ResponseBodyCodeTool,
): string {
  return JSON.stringify(
    ResponseBodyCodeTool$outboundSchema.parse(responseBodyCodeTool),
  );
}
export function responseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const ResponseBody5$inboundSchema: z.ZodType<
  ResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K9RWC0Q5VWEQ85666B3HF7B6"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => ResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type ResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: ResponseBodyCodeTool$Outbound;
};

/** @internal */
export const ResponseBody5$outboundSchema: z.ZodType<
  ResponseBody5$Outbound,
  z.ZodTypeDef,
  ResponseBody5
> = z.object({
  id: z.string().default("01K9RWC0Q5VWEQ85666B3HF7B6"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => ResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function responseBody5ToJSON(responseBody5: ResponseBody5): string {
  return JSON.stringify(ResponseBody5$outboundSchema.parse(responseBody5));
}
export function responseBody5FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody5' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseStatus);
/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> =
    CreateToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Type> =
    CreateToolResponseBodyToolsResponse200Type$inboundSchema;

/** @internal */
export const ResponseBodyHeaders$inboundSchema: z.ZodType<
  ResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type ResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const ResponseBodyHeaders$outboundSchema: z.ZodType<
  ResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  ResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function responseBodyHeadersToJSON(
  responseBodyHeaders: ResponseBodyHeaders,
): string {
  return JSON.stringify(
    ResponseBodyHeaders$outboundSchema.parse(responseBodyHeaders),
  );
}
export function responseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson4Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const ResponseBodyInputSchema$inboundSchema: z.ZodType<
  ResponseBodyInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type ResponseBodyInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const ResponseBodyInputSchema$outboundSchema: z.ZodType<
  ResponseBodyInputSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyInputSchema
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function responseBodyInputSchemaToJSON(
  responseBodyInputSchema: ResponseBodyInputSchema,
): string {
  return JSON.stringify(
    ResponseBodyInputSchema$outboundSchema.parse(responseBodyInputSchema),
  );
}
export function responseBodyInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyInputSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = z.nativeEnum(ResponseBodyConnectionType);
/** @internal */
export const ResponseBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = ResponseBodyConnectionType$inboundSchema;

/** @internal */
export const ResponseBodyMcp$inboundSchema: z.ZodType<
  ResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_id: z.string(),
  tool_name: z.string(),
  server_url: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$inboundSchema)).optional(),
  input_schema: z.lazy(() => ResponseBodyInputSchema$inboundSchema),
  connection_type: ResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_id": "serverId",
    "tool_name": "toolName",
    "server_url": "serverUrl",
    "input_schema": "inputSchema",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type ResponseBodyMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: ResponseBodyHeaders$Outbound } | undefined;
  input_schema: ResponseBodyInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const ResponseBodyMcp$outboundSchema: z.ZodType<
  ResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  ResponseBodyMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$outboundSchema))
    .optional(),
  inputSchema: z.lazy(() => ResponseBodyInputSchema$outboundSchema),
  connectionType: ResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

export function responseBodyMcpToJSON(
  responseBodyMcp: ResponseBodyMcp,
): string {
  return JSON.stringify(ResponseBodyMcp$outboundSchema.parse(responseBodyMcp));
}
export function responseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const ResponseBody4$inboundSchema: z.ZodType<
  ResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K9RWC0Q05JNRMGG1MVR4B71D"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => ResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: ResponseBodyMcp$Outbound;
};

/** @internal */
export const ResponseBody4$outboundSchema: z.ZodType<
  ResponseBody4$Outbound,
  z.ZodTypeDef,
  ResponseBody4
> = z.object({
  id: z.string().default("01K9RWC0Q05JNRMGG1MVR4B71D"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => ResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBody4ToJSON(responseBody4: ResponseBody4): string {
  return JSON.stringify(ResponseBody4$outboundSchema.parse(responseBody4));
}
export function responseBody4FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody4' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = z.nativeEnum(CreateToolResponseBodyToolsStatus);
/** @internal */
export const CreateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = CreateToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseType);
/** @internal */
export const CreateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseType> =
    CreateToolResponseBodyToolsResponseType$inboundSchema;

/** @internal */
export const CreateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = z.nativeEnum(CreateToolResponseBodyMethod);
/** @internal */
export const CreateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = CreateToolResponseBodyMethod$inboundSchema;

/** @internal */
export const CreateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  CreateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type CreateToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const CreateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  CreateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolResponseBodyHeadersToJSON(
  createToolResponseBodyHeaders: CreateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    CreateToolResponseBodyHeaders$outboundSchema.parse(
      createToolResponseBodyHeaders,
    ),
  );
}
export function createToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const ResponseBodyBlueprint$inboundSchema: z.ZodType<
  ResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$inboundSchema,
  headers: z.record(z.lazy(() => CreateToolResponseBodyHeaders$inboundSchema))
    .optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type ResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: CreateToolResponseBodyHeaders$Outbound } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseBodyBlueprint$outboundSchema: z.ZodType<
  ResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  ResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$outboundSchema,
  headers: z.record(z.lazy(() => CreateToolResponseBodyHeaders$outboundSchema))
    .optional(),
  body: z.record(z.any()).optional(),
});

export function responseBodyBlueprintToJSON(
  responseBodyBlueprint: ResponseBodyBlueprint,
): string {
  return JSON.stringify(
    ResponseBodyBlueprint$outboundSchema.parse(responseBodyBlueprint),
  );
}
export function responseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson3Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const ResponseBodyDefaultValue$inboundSchema: z.ZodType<
  ResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type ResponseBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const ResponseBodyDefaultValue$outboundSchema: z.ZodType<
  ResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  ResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function responseBodyDefaultValueToJSON(
  responseBodyDefaultValue: ResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    ResponseBodyDefaultValue$outboundSchema.parse(responseBodyDefaultValue),
  );
}
export function responseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArguments$inboundSchema: z.ZodType<
  ResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type ResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const ResponseBodyArguments$outboundSchema: z.ZodType<
  ResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  ResponseBodyArguments
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function responseBodyArgumentsToJSON(
  responseBodyArguments: ResponseBodyArguments,
): string {
  return JSON.stringify(
    ResponseBodyArguments$outboundSchema.parse(responseBodyArguments),
  );
}
export function responseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHttp$inboundSchema: z.ZodType<
  CreateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type CreateToolResponseBodyHttp$Outbound = {
  blueprint: ResponseBodyBlueprint$Outbound;
  arguments?: { [k: string]: ResponseBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolResponseBodyHttp$outboundSchema: z.ZodType<
  CreateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$outboundSchema))
    .optional(),
});

export function createToolResponseBodyHttpToJSON(
  createToolResponseBodyHttp: CreateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    CreateToolResponseBodyHttp$outboundSchema.parse(createToolResponseBodyHttp),
  );
}
export function createToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const ResponseBody3$inboundSchema: z.ZodType<
  ResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K9RWC0P5YEPME43CMFQ0NWDV"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => CreateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: CreateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const ResponseBody3$outboundSchema: z.ZodType<
  ResponseBody3$Outbound,
  z.ZodTypeDef,
  ResponseBody3
> = z.object({
  id: z.string().default("01K9RWC0P5YEPME43CMFQ0NWDV"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => CreateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBody3ToJSON(responseBody3: ResponseBody3): string {
  return JSON.stringify(ResponseBody3$outboundSchema.parse(responseBody3));
}
export function responseBody3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody3' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = z.nativeEnum(CreateToolResponseBodyStatus);
/** @internal */
export const CreateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = CreateToolResponseBodyStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = z.nativeEnum(CreateToolResponseBodyToolsType);
/** @internal */
export const CreateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsType
> = CreateToolResponseBodyToolsType$inboundSchema;

/** @internal */
export const ResponseBodyJsonSchema$inboundSchema: z.ZodType<
  ResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});
/** @internal */
export type ResponseBodyJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict?: boolean | undefined;
};

/** @internal */
export const ResponseBodyJsonSchema$outboundSchema: z.ZodType<
  ResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().optional(),
});

export function responseBodyJsonSchemaToJSON(
  responseBodyJsonSchema: ResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    ResponseBodyJsonSchema$outboundSchema.parse(responseBodyJsonSchema),
  );
}
export function responseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K9RWC0NY5X0ZVKVPEA93NPVZ"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => ResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: ResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  id: z.string().default("01K9RWC0NY5X0ZVKVPEA93NPVZ"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => ResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}
export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const ResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = z.nativeEnum(ResponseBodyStatus);
/** @internal */
export const ResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = ResponseBodyStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = z.nativeEnum(CreateToolResponseBodyType);
/** @internal */
export const CreateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyType
> = CreateToolResponseBodyType$inboundSchema;

/** @internal */
export const CreateToolResponseBodyFunction$inboundSchema: z.ZodType<
  CreateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type CreateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateToolResponseBodyFunction$outboundSchema: z.ZodType<
  CreateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

export function createToolResponseBodyFunctionToJSON(
  createToolResponseBodyFunction: CreateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    CreateToolResponseBodyFunction$outboundSchema.parse(
      createToolResponseBodyFunction,
    ),
  );
}
export function createToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const ResponseBody1$inboundSchema: z.ZodType<
  ResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K9RWC0NSXKZDYHS9J1Z7Q7ZB"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: CreateToolResponseBodyType$inboundSchema,
  function: z.lazy(() => CreateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: CreateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const ResponseBody1$outboundSchema: z.ZodType<
  ResponseBody1$Outbound,
  z.ZodTypeDef,
  ResponseBody1
> = z.object({
  id: z.string().default("01K9RWC0NSXKZDYHS9J1Z7Q7ZB"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: CreateToolResponseBodyType$outboundSchema,
  function: z.lazy(() => CreateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBody1ToJSON(responseBody1: ResponseBody1): string {
  return JSON.stringify(ResponseBody1$outboundSchema.parse(responseBody1));
}
export function responseBody1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBody$inboundSchema: z.ZodType<
  CreateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBody1$inboundSchema),
  z.lazy(() => ResponseBody2$inboundSchema),
  z.lazy(() => ResponseBody3$inboundSchema),
  z.lazy(() => ResponseBody4$inboundSchema),
  z.lazy(() => ResponseBody5$inboundSchema),
]);
/** @internal */
export type CreateToolResponseBody$Outbound =
  | ResponseBody1$Outbound
  | ResponseBody2$Outbound
  | ResponseBody3$Outbound
  | ResponseBody4$Outbound
  | ResponseBody5$Outbound;

/** @internal */
export const CreateToolResponseBody$outboundSchema: z.ZodType<
  CreateToolResponseBody$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBody
> = z.union([
  z.lazy(() => ResponseBody1$outboundSchema),
  z.lazy(() => ResponseBody2$outboundSchema),
  z.lazy(() => ResponseBody3$outboundSchema),
  z.lazy(() => ResponseBody4$outboundSchema),
  z.lazy(() => ResponseBody5$outboundSchema),
]);

export function createToolResponseBodyToJSON(
  createToolResponseBody: CreateToolResponseBody,
): string {
  return JSON.stringify(
    CreateToolResponseBody$outboundSchema.parse(createToolResponseBody),
  );
}
export function createToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBody' from JSON`,
  );
}
