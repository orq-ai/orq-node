/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequestStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequestStatus
>;

/**
 * The type must be "object"
 */
export const CreateToolRequestBodyToolsRequest5CodeToolType = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolRequestBodyToolsRequest5CodeToolType = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest5CodeToolType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type CreateToolRequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolRequestBodyToolsRequest5CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const RequestBodyLanguage = {
  Python: "python",
} as const;
export type RequestBodyLanguage = ClosedEnum<typeof RequestBodyLanguage>;

export type RequestBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: CreateToolRequestBodyParameters | undefined;
  language: RequestBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type RequestBodyCodeExecutionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequestStatus | undefined;
  type: "code";
  codeTool: RequestBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsStatus = ClosedEnum<
  typeof CreateToolRequestBodyToolsStatus
>;

export type RequestBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const RequestBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type RequestBodyConnectionType = ClosedEnum<
  typeof RequestBodyConnectionType
>;

export type RequestBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: RequestBodyHeaders } | undefined;
  /**
   * The connection type used by the MCP server
   */
  connectionType: RequestBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type RequestBodyMCPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsStatus | undefined;
  type: "mcp";
  mcp: RequestBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyStatus = ClosedEnum<
  typeof CreateToolRequestBodyStatus
>;

/**
 * The HTTP method to use.
 */
export const CreateToolRequestBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolRequestBodyMethod = ClosedEnum<
  typeof CreateToolRequestBodyMethod
>;

export type CreateToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type CreateToolRequestBodyHeaders = CreateToolHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type RequestBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolRequestBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: CreateToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolRequestBodyToolsRequest3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolRequestBodyToolsRequest3Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest3Type
>;

/**
 * The default value of the argument.
 */
export type RequestBodyDefaultValue = string | number | boolean;

export type RequestBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolRequestBodyToolsRequest3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolRequestBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: RequestBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: RequestBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type RequestBodyHTTPTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyStatus | undefined;
  type: "http";
  http: CreateToolRequestBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RequestBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RequestBodyStatus = ClosedEnum<typeof RequestBodyStatus>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RequestBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RequestBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: RequestBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type JSONSchemaTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: RequestBodyStatus | undefined;
  type: "json_schema";
  jsonSchema: RequestBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolRequestBodyToolsRequest1Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolRequestBodyToolsRequest1Status = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest1Status
>;

/**
 * The type must be "object"
 */
export const CreateToolRequestBodyToolsRequest1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolRequestBodyToolsRequest1Type = ClosedEnum<
  typeof CreateToolRequestBodyToolsRequest1Type
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RequestBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolRequestBodyToolsRequest1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RequestBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RequestBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type RequestBodyFunctionTool = {
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolRequestBodyToolsRequest1Status | undefined;
  type: "function";
  function: RequestBodyFunction;
};

/**
 * The tool to create
 */
export type CreateToolRequestBody =
  | RequestBodyFunctionTool
  | JSONSchemaTool
  | RequestBodyHTTPTool
  | RequestBodyMCPTool
  | RequestBodyCodeExecutionTool;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponse200Status
>;

/**
 * The type must be "object"
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson5Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type CreateToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const ResponseBodyLanguage = {
  Python: "python",
} as const;
export type ResponseBodyLanguage = ClosedEnum<typeof ResponseBodyLanguage>;

export type ResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: CreateToolResponseBodyParameters | undefined;
  language: ResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type ResponseBodyCodeExecutionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: "code";
  codeTool: ResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsResponseStatus
>;

export type ResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type CreateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type>;

export type CreateToolResponseBodySchema = {
  type: CreateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type ResponseBodyTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: CreateToolResponseBodySchema;
};

/**
 * The connection type used by the MCP server
 */
export const ResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ResponseBodyConnectionType = ClosedEnum<
  typeof ResponseBodyConnectionType
>;

export type ResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: ResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<ResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ResponseBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type ResponseBodyMCPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: ResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyToolsStatus = ClosedEnum<
  typeof CreateToolResponseBodyToolsStatus
>;

/**
 * The HTTP method to use.
 */
export const CreateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type CreateToolResponseBodyMethod = ClosedEnum<
  typeof CreateToolResponseBodyMethod
>;

export type CreateToolHeadersTools2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type CreateToolResponseBodyHeaders = CreateToolHeadersTools2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: CreateToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: CreateToolHeadersTools2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type>;

/**
 * The default value of the argument.
 */
export type ResponseBodyDefaultValue = string | number | boolean;

export type ResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type CreateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ResponseBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type ResponseBodyHTTPTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: "http";
  http: CreateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateToolResponseBodyStatus = ClosedEnum<
  typeof CreateToolResponseBodyStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type ResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type ResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: ResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type ResponseBodyJSONSchemaTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: CreateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: ResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ResponseBodyStatus = ClosedEnum<typeof ResponseBodyStatus>;

/**
 * The type must be "object"
 */
export const CreateToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type CreateToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<typeof CreateToolResponseBodyToolsResponse200ApplicationJson1Type>;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type ResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: CreateToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type CreateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: ResponseBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type ResponseBodyFunctionTool = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: ResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: "function";
  function: CreateToolResponseBodyFunction;
};

/**
 * Successfully created the tool.
 */
export type CreateToolResponseBody =
  | ResponseBodyFunctionTool
  | ResponseBodyJSONSchemaTool
  | ResponseBodyHTTPTool
  | ResponseBodyMCPTool
  | ResponseBodyCodeExecutionTool;

/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> = z
    .nativeEnum(CreateToolRequestBodyToolsRequestStatus);
/** @internal */
export const CreateToolRequestBodyToolsRequestStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequestStatus> =
    CreateToolRequestBodyToolsRequestStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsRequest5CodeToolType$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5CodeToolType> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest5CodeToolType);
/** @internal */
export const CreateToolRequestBodyToolsRequest5CodeToolType$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest5CodeToolType> =
    CreateToolRequestBodyToolsRequest5CodeToolType$inboundSchema;

/** @internal */
export const CreateToolRequestBodyParameters$inboundSchema: z.ZodType<
  CreateToolRequestBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: CreateToolRequestBodyToolsRequest5CodeToolType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type CreateToolRequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const CreateToolRequestBodyParameters$outboundSchema: z.ZodType<
  CreateToolRequestBodyParameters$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyParameters
> = z.object({
  type: CreateToolRequestBodyToolsRequest5CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function createToolRequestBodyParametersToJSON(
  createToolRequestBodyParameters: CreateToolRequestBodyParameters,
): string {
  return JSON.stringify(
    CreateToolRequestBodyParameters$outboundSchema.parse(
      createToolRequestBodyParameters,
    ),
  );
}
export function createToolRequestBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyParameters' from JSON`,
  );
}

/** @internal */
export const RequestBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = z.nativeEnum(RequestBodyLanguage);
/** @internal */
export const RequestBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyLanguage
> = RequestBodyLanguage$inboundSchema;

/** @internal */
export const RequestBodyCodeTool$inboundSchema: z.ZodType<
  RequestBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => CreateToolRequestBodyParameters$inboundSchema)
    .optional(),
  language: RequestBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type RequestBodyCodeTool$Outbound = {
  parameters?: CreateToolRequestBodyParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const RequestBodyCodeTool$outboundSchema: z.ZodType<
  RequestBodyCodeTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeTool
> = z.object({
  parameters: z.lazy(() => CreateToolRequestBodyParameters$outboundSchema)
    .optional(),
  language: RequestBodyLanguage$outboundSchema,
  code: z.string(),
});

export function requestBodyCodeToolToJSON(
  requestBodyCodeTool: RequestBodyCodeTool,
): string {
  return JSON.stringify(
    RequestBodyCodeTool$outboundSchema.parse(requestBodyCodeTool),
  );
}
export function requestBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const RequestBodyCodeExecutionTool$inboundSchema: z.ZodType<
  RequestBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$inboundSchema.default("live"),
  type: z.literal("code"),
  code_tool: z.lazy(() => RequestBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type RequestBodyCodeExecutionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "code";
  code_tool: RequestBodyCodeTool$Outbound;
};

/** @internal */
export const RequestBodyCodeExecutionTool$outboundSchema: z.ZodType<
  RequestBodyCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyCodeExecutionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequestStatus$outboundSchema.default(
    "live",
  ),
  type: z.literal("code"),
  codeTool: z.lazy(() => RequestBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    codeTool: "code_tool",
  });
});

export function requestBodyCodeExecutionToolToJSON(
  requestBodyCodeExecutionTool: RequestBodyCodeExecutionTool,
): string {
  return JSON.stringify(
    RequestBodyCodeExecutionTool$outboundSchema.parse(
      requestBodyCodeExecutionTool,
    ),
  );
}
export function requestBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = z.nativeEnum(CreateToolRequestBodyToolsStatus);
/** @internal */
export const CreateToolRequestBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyToolsStatus
> = CreateToolRequestBodyToolsStatus$inboundSchema;

/** @internal */
export const RequestBodyHeaders$inboundSchema: z.ZodType<
  RequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type RequestBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const RequestBodyHeaders$outboundSchema: z.ZodType<
  RequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  RequestBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function requestBodyHeadersToJSON(
  requestBodyHeaders: RequestBodyHeaders,
): string {
  return JSON.stringify(
    RequestBodyHeaders$outboundSchema.parse(requestBodyHeaders),
  );
}
export function requestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const RequestBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyConnectionType
> = z.nativeEnum(RequestBodyConnectionType);
/** @internal */
export const RequestBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyConnectionType
> = RequestBodyConnectionType$inboundSchema;

/** @internal */
export const RequestBodyMcp$inboundSchema: z.ZodType<
  RequestBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => RequestBodyHeaders$inboundSchema)).optional(),
  connection_type: RequestBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type RequestBodyMcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: RequestBodyHeaders$Outbound } | undefined;
  connection_type: string;
};

/** @internal */
export const RequestBodyMcp$outboundSchema: z.ZodType<
  RequestBodyMcp$Outbound,
  z.ZodTypeDef,
  RequestBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => RequestBodyHeaders$outboundSchema)).optional(),
  connectionType: RequestBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function requestBodyMcpToJSON(requestBodyMcp: RequestBodyMcp): string {
  return JSON.stringify(RequestBodyMcp$outboundSchema.parse(requestBodyMcp));
}
export function requestBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyMcp' from JSON`,
  );
}

/** @internal */
export const RequestBodyMCPTool$inboundSchema: z.ZodType<
  RequestBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$inboundSchema.default("live"),
  type: z.literal("mcp"),
  mcp: z.lazy(() => RequestBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type RequestBodyMCPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "mcp";
  mcp: RequestBodyMcp$Outbound;
};

/** @internal */
export const RequestBodyMCPTool$outboundSchema: z.ZodType<
  RequestBodyMCPTool$Outbound,
  z.ZodTypeDef,
  RequestBodyMCPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsStatus$outboundSchema.default("live"),
  type: z.literal("mcp"),
  mcp: z.lazy(() => RequestBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyMCPToolToJSON(
  requestBodyMCPTool: RequestBodyMCPTool,
): string {
  return JSON.stringify(
    RequestBodyMCPTool$outboundSchema.parse(requestBodyMCPTool),
  );
}
export function requestBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = z.nativeEnum(CreateToolRequestBodyStatus);
/** @internal */
export const CreateToolRequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyStatus
> = CreateToolRequestBodyStatus$inboundSchema;

/** @internal */
export const CreateToolRequestBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = z.nativeEnum(CreateToolRequestBodyMethod);
/** @internal */
export const CreateToolRequestBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolRequestBodyMethod
> = CreateToolRequestBodyMethod$inboundSchema;

/** @internal */
export const CreateToolHeaders2$inboundSchema: z.ZodType<
  CreateToolHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type CreateToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const CreateToolHeaders2$outboundSchema: z.ZodType<
  CreateToolHeaders2$Outbound,
  z.ZodTypeDef,
  CreateToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolHeaders2ToJSON(
  createToolHeaders2: CreateToolHeaders2,
): string {
  return JSON.stringify(
    CreateToolHeaders2$outboundSchema.parse(createToolHeaders2),
  );
}
export function createToolHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<CreateToolHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolHeaders2' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyHeaders$inboundSchema: z.ZodType<
  CreateToolRequestBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => CreateToolHeaders2$inboundSchema), z.string()]);
/** @internal */
export type CreateToolRequestBodyHeaders$Outbound =
  | CreateToolHeaders2$Outbound
  | string;

/** @internal */
export const CreateToolRequestBodyHeaders$outboundSchema: z.ZodType<
  CreateToolRequestBodyHeaders$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHeaders
> = z.union([z.lazy(() => CreateToolHeaders2$outboundSchema), z.string()]);

export function createToolRequestBodyHeadersToJSON(
  createToolRequestBodyHeaders: CreateToolRequestBodyHeaders,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHeaders$outboundSchema.parse(
      createToolRequestBodyHeaders,
    ),
  );
}
export function createToolRequestBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyHeaders' from JSON`,
  );
}

/** @internal */
export const RequestBodyBlueprint$inboundSchema: z.ZodType<
  RequestBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type RequestBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: CreateToolHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const RequestBodyBlueprint$outboundSchema: z.ZodType<
  RequestBodyBlueprint$Outbound,
  z.ZodTypeDef,
  RequestBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolRequestBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function requestBodyBlueprintToJSON(
  requestBodyBlueprint: RequestBodyBlueprint,
): string {
  return JSON.stringify(
    RequestBodyBlueprint$outboundSchema.parse(requestBodyBlueprint),
  );
}
export function requestBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest3Type,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequest3Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest3Type> =
    CreateToolRequestBodyToolsRequest3Type$inboundSchema;

/** @internal */
export const RequestBodyDefaultValue$inboundSchema: z.ZodType<
  RequestBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type RequestBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const RequestBodyDefaultValue$outboundSchema: z.ZodType<
  RequestBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  RequestBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function requestBodyDefaultValueToJSON(
  requestBodyDefaultValue: RequestBodyDefaultValue,
): string {
  return JSON.stringify(
    RequestBodyDefaultValue$outboundSchema.parse(requestBodyDefaultValue),
  );
}
export function requestBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const RequestBodyArguments$inboundSchema: z.ZodType<
  RequestBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type RequestBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const RequestBodyArguments$outboundSchema: z.ZodType<
  RequestBodyArguments$Outbound,
  z.ZodTypeDef,
  RequestBodyArguments
> = z.object({
  type: CreateToolRequestBodyToolsRequest3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function requestBodyArgumentsToJSON(
  requestBodyArguments: RequestBodyArguments,
): string {
  return JSON.stringify(
    RequestBodyArguments$outboundSchema.parse(requestBodyArguments),
  );
}
export function requestBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyHttp$inboundSchema: z.ZodType<
  CreateToolRequestBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type CreateToolRequestBodyHttp$Outbound = {
  blueprint: RequestBodyBlueprint$Outbound;
  arguments?: { [k: string]: RequestBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolRequestBodyHttp$outboundSchema: z.ZodType<
  CreateToolRequestBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBodyHttp
> = z.object({
  blueprint: z.lazy(() => RequestBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => RequestBodyArguments$outboundSchema))
    .optional(),
});

export function createToolRequestBodyHttpToJSON(
  createToolRequestBodyHttp: CreateToolRequestBodyHttp,
): string {
  return JSON.stringify(
    CreateToolRequestBodyHttp$outboundSchema.parse(createToolRequestBodyHttp),
  );
}
export function createToolRequestBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBodyHttp' from JSON`,
  );
}

/** @internal */
export const RequestBodyHTTPTool$inboundSchema: z.ZodType<
  RequestBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$inboundSchema.default("live"),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolRequestBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type RequestBodyHTTPTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "http";
  http: CreateToolRequestBodyHttp$Outbound;
};

/** @internal */
export const RequestBodyHTTPTool$outboundSchema: z.ZodType<
  RequestBodyHTTPTool$Outbound,
  z.ZodTypeDef,
  RequestBodyHTTPTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolRequestBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyHTTPToolToJSON(
  requestBodyHTTPTool: RequestBodyHTTPTool,
): string {
  return JSON.stringify(
    RequestBodyHTTPTool$outboundSchema.parse(requestBodyHTTPTool),
  );
}
export function requestBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const RequestBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = z.nativeEnum(RequestBodyStatus);
/** @internal */
export const RequestBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof RequestBodyStatus
> = RequestBodyStatus$inboundSchema;

/** @internal */
export const RequestBodySchema$inboundSchema: z.ZodType<
  RequestBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type RequestBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RequestBodySchema$outboundSchema: z.ZodType<
  RequestBodySchema$Outbound,
  z.ZodTypeDef,
  RequestBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function requestBodySchemaToJSON(
  requestBodySchema: RequestBodySchema,
): string {
  return JSON.stringify(
    RequestBodySchema$outboundSchema.parse(requestBodySchema),
  );
}
export function requestBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodySchema' from JSON`,
  );
}

/** @internal */
export const RequestBodyJsonSchema$inboundSchema: z.ZodType<
  RequestBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => RequestBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type RequestBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: RequestBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const RequestBodyJsonSchema$outboundSchema: z.ZodType<
  RequestBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  RequestBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => RequestBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function requestBodyJsonSchemaToJSON(
  requestBodyJsonSchema: RequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RequestBodyJsonSchema$outboundSchema.parse(requestBodyJsonSchema),
  );
}
export function requestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const JSONSchemaTool$inboundSchema: z.ZodType<
  JSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: RequestBodyStatus$inboundSchema.default("live"),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => RequestBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type JSONSchemaTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "json_schema";
  json_schema: RequestBodyJsonSchema$Outbound;
};

/** @internal */
export const JSONSchemaTool$outboundSchema: z.ZodType<
  JSONSchemaTool$Outbound,
  z.ZodTypeDef,
  JSONSchemaTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: RequestBodyStatus$outboundSchema.default("live"),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => RequestBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function jsonSchemaToolToJSON(jsonSchemaTool: JSONSchemaTool): string {
  return JSON.stringify(JSONSchemaTool$outboundSchema.parse(jsonSchemaTool));
}
export function jsonSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<JSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBodyToolsRequest1Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Status> = z
    .nativeEnum(CreateToolRequestBodyToolsRequest1Status);
/** @internal */
export const CreateToolRequestBodyToolsRequest1Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Status> =
    CreateToolRequestBodyToolsRequest1Status$inboundSchema;

/** @internal */
export const CreateToolRequestBodyToolsRequest1Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Type> = z.nativeEnum(
    CreateToolRequestBodyToolsRequest1Type,
  );
/** @internal */
export const CreateToolRequestBodyToolsRequest1Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolRequestBodyToolsRequest1Type> =
    CreateToolRequestBodyToolsRequest1Type$inboundSchema;

/** @internal */
export const RequestBodyParameters$inboundSchema: z.ZodType<
  RequestBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: CreateToolRequestBodyToolsRequest1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type RequestBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RequestBodyParameters$outboundSchema: z.ZodType<
  RequestBodyParameters$Outbound,
  z.ZodTypeDef,
  RequestBodyParameters
> = z.object({
  type: CreateToolRequestBodyToolsRequest1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function requestBodyParametersToJSON(
  requestBodyParameters: RequestBodyParameters,
): string {
  return JSON.stringify(
    RequestBodyParameters$outboundSchema.parse(requestBodyParameters),
  );
}
export function requestBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyParameters' from JSON`,
  );
}

/** @internal */
export const RequestBodyFunction$inboundSchema: z.ZodType<
  RequestBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RequestBodyParameters$inboundSchema).optional(),
});
/** @internal */
export type RequestBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: RequestBodyParameters$Outbound | undefined;
};

/** @internal */
export const RequestBodyFunction$outboundSchema: z.ZodType<
  RequestBodyFunction$Outbound,
  z.ZodTypeDef,
  RequestBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RequestBodyParameters$outboundSchema).optional(),
});

export function requestBodyFunctionToJSON(
  requestBodyFunction: RequestBodyFunction,
): string {
  return JSON.stringify(
    RequestBodyFunction$outboundSchema.parse(requestBodyFunction),
  );
}
export function requestBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunction' from JSON`,
  );
}

/** @internal */
export const RequestBodyFunctionTool$inboundSchema: z.ZodType<
  RequestBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest1Status$inboundSchema.default(
    "live",
  ),
  type: z.literal("function"),
  function: z.lazy(() => RequestBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type RequestBodyFunctionTool$Outbound = {
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  status: string;
  type: "function";
  function: RequestBodyFunction$Outbound;
};

/** @internal */
export const RequestBodyFunctionTool$outboundSchema: z.ZodType<
  RequestBodyFunctionTool$Outbound,
  z.ZodTypeDef,
  RequestBodyFunctionTool
> = z.object({
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  status: CreateToolRequestBodyToolsRequest1Status$outboundSchema.default(
    "live",
  ),
  type: z.literal("function"),
  function: z.lazy(() => RequestBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function requestBodyFunctionToolToJSON(
  requestBodyFunctionTool: RequestBodyFunctionTool,
): string {
  return JSON.stringify(
    RequestBodyFunctionTool$outboundSchema.parse(requestBodyFunctionTool),
  );
}
export function requestBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<RequestBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolRequestBody$inboundSchema: z.ZodType<
  CreateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RequestBodyFunctionTool$inboundSchema),
  z.lazy(() => JSONSchemaTool$inboundSchema),
  z.lazy(() => RequestBodyHTTPTool$inboundSchema),
  z.lazy(() => RequestBodyMCPTool$inboundSchema),
  z.lazy(() => RequestBodyCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type CreateToolRequestBody$Outbound =
  | RequestBodyFunctionTool$Outbound
  | JSONSchemaTool$Outbound
  | RequestBodyHTTPTool$Outbound
  | RequestBodyMCPTool$Outbound
  | RequestBodyCodeExecutionTool$Outbound;

/** @internal */
export const CreateToolRequestBody$outboundSchema: z.ZodType<
  CreateToolRequestBody$Outbound,
  z.ZodTypeDef,
  CreateToolRequestBody
> = z.union([
  z.lazy(() => RequestBodyFunctionTool$outboundSchema),
  z.lazy(() => JSONSchemaTool$outboundSchema),
  z.lazy(() => RequestBodyHTTPTool$outboundSchema),
  z.lazy(() => RequestBodyMCPTool$outboundSchema),
  z.lazy(() => RequestBodyCodeExecutionTool$outboundSchema),
]);

export function createToolRequestBodyToJSON(
  createToolRequestBody: CreateToolRequestBody,
): string {
  return JSON.stringify(
    CreateToolRequestBody$outboundSchema.parse(createToolRequestBody),
  );
}
export function createToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(CreateToolResponseBodyToolsResponse200Status);
/** @internal */
export const CreateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponse200Status> =
    CreateToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson5Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema;

/** @internal */
export const CreateToolResponseBodyParameters$inboundSchema: z.ZodType<
  CreateToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      CreateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type CreateToolResponseBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const CreateToolResponseBodyParameters$outboundSchema: z.ZodType<
  CreateToolResponseBodyParameters$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyParameters
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function createToolResponseBodyParametersToJSON(
  createToolResponseBodyParameters: CreateToolResponseBodyParameters,
): string {
  return JSON.stringify(
    CreateToolResponseBodyParameters$outboundSchema.parse(
      createToolResponseBodyParameters,
    ),
  );
}
export function createToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const ResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = z.nativeEnum(ResponseBodyLanguage);
/** @internal */
export const ResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyLanguage
> = ResponseBodyLanguage$inboundSchema;

/** @internal */
export const ResponseBodyCodeTool$inboundSchema: z.ZodType<
  ResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => CreateToolResponseBodyParameters$inboundSchema)
    .optional(),
  language: ResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type ResponseBodyCodeTool$Outbound = {
  parameters?: CreateToolResponseBodyParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const ResponseBodyCodeTool$outboundSchema: z.ZodType<
  ResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyCodeTool
> = z.object({
  parameters: z.lazy(() => CreateToolResponseBodyParameters$outboundSchema)
    .optional(),
  language: ResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function responseBodyCodeToolToJSON(
  responseBodyCodeTool: ResponseBodyCodeTool,
): string {
  return JSON.stringify(
    ResponseBodyCodeTool$outboundSchema.parse(responseBodyCodeTool),
  );
}
export function responseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const ResponseBodyCodeExecutionTool$inboundSchema: z.ZodType<
  ResponseBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KEVXWAV61PG8H55G9CYEMKX6"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => ResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type ResponseBodyCodeExecutionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "code";
  code_tool: ResponseBodyCodeTool$Outbound;
};

/** @internal */
export const ResponseBodyCodeExecutionTool$outboundSchema: z.ZodType<
  ResponseBodyCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyCodeExecutionTool
> = z.object({
  id: z.string().default("tool_01KEVXWAV61PG8H55G9CYEMKX6"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: z.literal("code"),
  codeTool: z.lazy(() => ResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function responseBodyCodeExecutionToolToJSON(
  responseBodyCodeExecutionTool: ResponseBodyCodeExecutionTool,
): string {
  return JSON.stringify(
    ResponseBodyCodeExecutionTool$outboundSchema.parse(
      responseBodyCodeExecutionTool,
    ),
  );
}
export function responseBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(CreateToolResponseBodyToolsResponseStatus);
/** @internal */
export const CreateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof CreateToolResponseBodyToolsResponseStatus> =
    CreateToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const ResponseBodyHeaders$inboundSchema: z.ZodType<
  ResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type ResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const ResponseBodyHeaders$outboundSchema: z.ZodType<
  ResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  ResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function responseBodyHeadersToJSON(
  responseBodyHeaders: ResponseBodyHeaders,
): string {
  return JSON.stringify(
    ResponseBodyHeaders$outboundSchema.parse(responseBodyHeaders),
  );
}
export function responseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson4Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const CreateToolResponseBodySchema$inboundSchema: z.ZodType<
  CreateToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type CreateToolResponseBodySchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const CreateToolResponseBodySchema$outboundSchema: z.ZodType<
  CreateToolResponseBodySchema$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodySchema
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function createToolResponseBodySchemaToJSON(
  createToolResponseBodySchema: CreateToolResponseBodySchema,
): string {
  return JSON.stringify(
    CreateToolResponseBodySchema$outboundSchema.parse(
      createToolResponseBodySchema,
    ),
  );
}
export function createToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyTools$inboundSchema: z.ZodType<
  ResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KEVXWAV3NHEZVSERMEDDK85M"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => CreateToolResponseBodySchema$inboundSchema),
});
/** @internal */
export type ResponseBodyTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: CreateToolResponseBodySchema$Outbound;
};

/** @internal */
export const ResponseBodyTools$outboundSchema: z.ZodType<
  ResponseBodyTools$Outbound,
  z.ZodTypeDef,
  ResponseBodyTools
> = z.object({
  id: z.string().default("01KEVXWAV3NHEZVSERMEDDK85M"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => CreateToolResponseBodySchema$outboundSchema),
});

export function responseBodyToolsToJSON(
  responseBodyTools: ResponseBodyTools,
): string {
  return JSON.stringify(
    ResponseBodyTools$outboundSchema.parse(responseBodyTools),
  );
}
export function responseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const ResponseBodyConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = z.nativeEnum(ResponseBodyConnectionType);
/** @internal */
export const ResponseBodyConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyConnectionType
> = ResponseBodyConnectionType$inboundSchema;

/** @internal */
export const ResponseBodyMcp$inboundSchema: z.ZodType<
  ResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$inboundSchema)).optional(),
  tools: z.array(z.lazy(() => ResponseBodyTools$inboundSchema)),
  connection_type: ResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type ResponseBodyMcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: ResponseBodyHeaders$Outbound } | undefined;
  tools: Array<ResponseBodyTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const ResponseBodyMcp$outboundSchema: z.ZodType<
  ResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  ResponseBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => ResponseBodyHeaders$outboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => ResponseBodyTools$outboundSchema)),
  connectionType: ResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function responseBodyMcpToJSON(
  responseBodyMcp: ResponseBodyMcp,
): string {
  return JSON.stringify(ResponseBodyMcp$outboundSchema.parse(responseBodyMcp));
}
export function responseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const ResponseBodyMCPTool$inboundSchema: z.ZodType<
  ResponseBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KEVXWAV1M65C6JKPKAATF4J4"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => ResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBodyMCPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "mcp";
  mcp: ResponseBodyMcp$Outbound;
};

/** @internal */
export const ResponseBodyMCPTool$outboundSchema: z.ZodType<
  ResponseBodyMCPTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyMCPTool
> = z.object({
  id: z.string().default("tool_01KEVXWAV1M65C6JKPKAATF4J4"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => ResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBodyMCPToolToJSON(
  responseBodyMCPTool: ResponseBodyMCPTool,
): string {
  return JSON.stringify(
    ResponseBodyMCPTool$outboundSchema.parse(responseBodyMCPTool),
  );
}
export function responseBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = z.nativeEnum(CreateToolResponseBodyToolsStatus);
/** @internal */
export const CreateToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyToolsStatus
> = CreateToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = z.nativeEnum(CreateToolResponseBodyMethod);
/** @internal */
export const CreateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyMethod
> = CreateToolResponseBodyMethod$inboundSchema;

/** @internal */
export const CreateToolHeadersTools2$inboundSchema: z.ZodType<
  CreateToolHeadersTools2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type CreateToolHeadersTools2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const CreateToolHeadersTools2$outboundSchema: z.ZodType<
  CreateToolHeadersTools2$Outbound,
  z.ZodTypeDef,
  CreateToolHeadersTools2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function createToolHeadersTools2ToJSON(
  createToolHeadersTools2: CreateToolHeadersTools2,
): string {
  return JSON.stringify(
    CreateToolHeadersTools2$outboundSchema.parse(createToolHeadersTools2),
  );
}
export function createToolHeadersTools2FromJSON(
  jsonString: string,
): SafeParseResult<CreateToolHeadersTools2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolHeadersTools2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolHeadersTools2' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  CreateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => CreateToolHeadersTools2$inboundSchema), z.string()]);
/** @internal */
export type CreateToolResponseBodyHeaders$Outbound =
  | CreateToolHeadersTools2$Outbound
  | string;

/** @internal */
export const CreateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  CreateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyHeaders
> = z.union([z.lazy(() => CreateToolHeadersTools2$outboundSchema), z.string()]);

export function createToolResponseBodyHeadersToJSON(
  createToolResponseBodyHeaders: CreateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    CreateToolResponseBodyHeaders$outboundSchema.parse(
      createToolResponseBodyHeaders,
    ),
  );
}
export function createToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const ResponseBodyBlueprint$inboundSchema: z.ZodType<
  ResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeadersTools2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type ResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: CreateToolHeadersTools2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const ResponseBodyBlueprint$outboundSchema: z.ZodType<
  ResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  ResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: CreateToolResponseBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => CreateToolHeadersTools2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function responseBodyBlueprintToJSON(
  responseBodyBlueprint: ResponseBodyBlueprint,
): string {
  return JSON.stringify(
    ResponseBodyBlueprint$outboundSchema.parse(responseBodyBlueprint),
  );
}
export function responseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson3Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const ResponseBodyDefaultValue$inboundSchema: z.ZodType<
  ResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type ResponseBodyDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const ResponseBodyDefaultValue$outboundSchema: z.ZodType<
  ResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  ResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function responseBodyDefaultValueToJSON(
  responseBodyDefaultValue: ResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    ResponseBodyDefaultValue$outboundSchema.parse(responseBodyDefaultValue),
  );
}
export function responseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyArguments$inboundSchema: z.ZodType<
  ResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type ResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const ResponseBodyArguments$outboundSchema: z.ZodType<
  ResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  ResponseBodyArguments
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function responseBodyArgumentsToJSON(
  responseBodyArguments: ResponseBodyArguments,
): string {
  return JSON.stringify(
    ResponseBodyArguments$outboundSchema.parse(responseBodyArguments),
  );
}
export function responseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyHttp$inboundSchema: z.ZodType<
  CreateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type CreateToolResponseBodyHttp$Outbound = {
  blueprint: ResponseBodyBlueprint$Outbound;
  arguments?: { [k: string]: ResponseBodyArguments$Outbound } | undefined;
};

/** @internal */
export const CreateToolResponseBodyHttp$outboundSchema: z.ZodType<
  CreateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => ResponseBodyBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => ResponseBodyArguments$outboundSchema))
    .optional(),
});

export function createToolResponseBodyHttpToJSON(
  createToolResponseBodyHttp: CreateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    CreateToolResponseBodyHttp$outboundSchema.parse(createToolResponseBodyHttp),
  );
}
export function createToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const ResponseBodyHTTPTool$inboundSchema: z.ZodType<
  ResponseBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KEVXWATXEVWFKZ12YD3E85F3"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBodyHTTPTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "http";
  http: CreateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const ResponseBodyHTTPTool$outboundSchema: z.ZodType<
  ResponseBodyHTTPTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyHTTPTool
> = z.object({
  id: z.string().default("tool_01KEVXWATXEVWFKZ12YD3E85F3"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => CreateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBodyHTTPToolToJSON(
  responseBodyHTTPTool: ResponseBodyHTTPTool,
): string {
  return JSON.stringify(
    ResponseBodyHTTPTool$outboundSchema.parse(responseBodyHTTPTool),
  );
}
export function responseBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = z.nativeEnum(CreateToolResponseBodyStatus);
/** @internal */
export const CreateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateToolResponseBodyStatus
> = CreateToolResponseBodyStatus$inboundSchema;

/** @internal */
export const ResponseBodySchema$inboundSchema: z.ZodType<
  ResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type ResponseBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const ResponseBodySchema$outboundSchema: z.ZodType<
  ResponseBodySchema$Outbound,
  z.ZodTypeDef,
  ResponseBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function responseBodySchemaToJSON(
  responseBodySchema: ResponseBodySchema,
): string {
  return JSON.stringify(
    ResponseBodySchema$outboundSchema.parse(responseBodySchema),
  );
}
export function responseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyJsonSchema$inboundSchema: z.ZodType<
  ResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => ResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type ResponseBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: ResponseBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const ResponseBodyJsonSchema$outboundSchema: z.ZodType<
  ResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => ResponseBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function responseBodyJsonSchemaToJSON(
  responseBodyJsonSchema: ResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    ResponseBodyJsonSchema$outboundSchema.parse(responseBodyJsonSchema),
  );
}
export function responseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodyJSONSchemaTool$inboundSchema: z.ZodType<
  ResponseBodyJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KEVXWATV6YZ6MVSWGYNHKW9T"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => ResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ResponseBodyJSONSchemaTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "json_schema";
  json_schema: ResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const ResponseBodyJSONSchemaTool$outboundSchema: z.ZodType<
  ResponseBodyJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyJSONSchemaTool
> = z.object({
  id: z.string().default("tool_01KEVXWATV6YZ6MVSWGYNHKW9T"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: CreateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => ResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function responseBodyJSONSchemaToolToJSON(
  responseBodyJSONSchemaTool: ResponseBodyJSONSchemaTool,
): string {
  return JSON.stringify(
    ResponseBodyJSONSchemaTool$outboundSchema.parse(responseBodyJSONSchemaTool),
  );
}
export function responseBodyJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const ResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = z.nativeEnum(ResponseBodyStatus);
/** @internal */
export const ResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof ResponseBodyStatus
> = ResponseBodyStatus$inboundSchema;

/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(CreateToolResponseBodyToolsResponse200ApplicationJson1Type);
/** @internal */
export const CreateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = CreateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema;

/** @internal */
export const ResponseBodyParameters$inboundSchema: z.ZodType<
  ResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      CreateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type ResponseBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const ResponseBodyParameters$outboundSchema: z.ZodType<
  ResponseBodyParameters$Outbound,
  z.ZodTypeDef,
  ResponseBodyParameters
> = z.object({
  type:
    CreateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function responseBodyParametersToJSON(
  responseBodyParameters: ResponseBodyParameters,
): string {
  return JSON.stringify(
    ResponseBodyParameters$outboundSchema.parse(responseBodyParameters),
  );
}
export function responseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBodyFunction$inboundSchema: z.ZodType<
  CreateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => ResponseBodyParameters$inboundSchema).optional(),
});
/** @internal */
export type CreateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: ResponseBodyParameters$Outbound | undefined;
};

/** @internal */
export const CreateToolResponseBodyFunction$outboundSchema: z.ZodType<
  CreateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => ResponseBodyParameters$outboundSchema).optional(),
});

export function createToolResponseBodyFunctionToJSON(
  createToolResponseBodyFunction: CreateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    CreateToolResponseBodyFunction$outboundSchema.parse(
      createToolResponseBodyFunction,
    ),
  );
}
export function createToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const ResponseBodyFunctionTool$inboundSchema: z.ZodType<
  ResponseBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KEVXWATS8PXP072H4J6CTA7R"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => CreateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type ResponseBodyFunctionTool$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: "function";
  function: CreateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const ResponseBodyFunctionTool$outboundSchema: z.ZodType<
  ResponseBodyFunctionTool$Outbound,
  z.ZodTypeDef,
  ResponseBodyFunctionTool
> = z.object({
  id: z.string().default("tool_01KEVXWATS8PXP072H4J6CTA7R"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: ResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => CreateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function responseBodyFunctionToolToJSON(
  responseBodyFunctionTool: ResponseBodyFunctionTool,
): string {
  return JSON.stringify(
    ResponseBodyFunctionTool$outboundSchema.parse(responseBodyFunctionTool),
  );
}
export function responseBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateToolResponseBody$inboundSchema: z.ZodType<
  CreateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseBodyFunctionTool$inboundSchema),
  z.lazy(() => ResponseBodyJSONSchemaTool$inboundSchema),
  z.lazy(() => ResponseBodyHTTPTool$inboundSchema),
  z.lazy(() => ResponseBodyMCPTool$inboundSchema),
  z.lazy(() => ResponseBodyCodeExecutionTool$inboundSchema),
]);
/** @internal */
export type CreateToolResponseBody$Outbound =
  | ResponseBodyFunctionTool$Outbound
  | ResponseBodyJSONSchemaTool$Outbound
  | ResponseBodyHTTPTool$Outbound
  | ResponseBodyMCPTool$Outbound
  | ResponseBodyCodeExecutionTool$Outbound;

/** @internal */
export const CreateToolResponseBody$outboundSchema: z.ZodType<
  CreateToolResponseBody$Outbound,
  z.ZodTypeDef,
  CreateToolResponseBody
> = z.union([
  z.lazy(() => ResponseBodyFunctionTool$outboundSchema),
  z.lazy(() => ResponseBodyJSONSchemaTool$outboundSchema),
  z.lazy(() => ResponseBodyHTTPTool$outboundSchema),
  z.lazy(() => ResponseBodyMCPTool$outboundSchema),
  z.lazy(() => ResponseBodyCodeExecutionTool$outboundSchema),
]);

export function createToolResponseBodyToJSON(
  createToolResponseBody: CreateToolResponseBody,
): string {
  return JSON.stringify(
    CreateToolResponseBody$outboundSchema.parse(createToolResponseBody),
  );
}
export function createToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateToolResponseBody' from JSON`,
  );
}
