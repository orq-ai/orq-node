/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const Voice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type Voice = ClosedEnum<typeof Voice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const Format = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type Format = ClosedEnum<typeof Format>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: Voice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: Format;
};

export type ResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type JSONSchema = {
  type: "json_schema";
  jsonSchema: ResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type JSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type Text = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ResponseFormat = Text | JSONObject | JSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const ReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type ReasoningEffort = ClosedEnum<typeof ReasoningEffort>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type Stop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type Thinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ToolChoiceType = ClosedEnum<typeof ToolChoiceType>;

export type ToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type ToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ToolChoiceType | undefined;
  function: ToolChoiceFunction;
};

export const ToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ToolChoice1 = ClosedEnum<typeof ToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ToolChoice = ToolChoice2 | ToolChoice1;

export const Modalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type Modalities = ClosedEnum<typeof Modalities>;

/**
 * The key of the guardrail.
 */
export const Id1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type Id1 = ClosedEnum<typeof Id1>;

export type Id = Id1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type ExecuteOn = ClosedEnum<typeof ExecuteOn>;

export type Guardrails = {
  id: Id1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: ExecuteOn;
};

export type Fallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type Retry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const ModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type ModelConfigurationType = ClosedEnum<typeof ModelConfigurationType>;

/**
 * Cache configuration for the request.
 */
export type Cache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: ModelConfigurationType;
};

export const LoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type LoadBalancerType = ClosedEnum<typeof LoadBalancerType>;

export type LoadBalancer1 = {
  type: LoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type LoadBalancer = LoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type Timeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type ParametersT = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?: Text | JSONObject | JSONSchema | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: ReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ToolChoice2 | ToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<Modalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<Guardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<Fallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: Retry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: Cache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<LoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: Timeout | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type ModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type ModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: ParametersT | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: ModelConfigurationRetry | undefined;
};

/**
 * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
 */
export type ModelConfiguration = ModelConfiguration2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const FallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type FallbackModelConfigurationVoice = ClosedEnum<
  typeof FallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const FallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type FallbackModelConfigurationFormat = ClosedEnum<
  typeof FallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type FallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: FallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: FallbackModelConfigurationFormat;
};

export type CreateAgentRequestResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: CreateAgentRequestResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type FallbackModelConfigurationResponseFormat =
  | ResponseFormatText
  | ResponseFormatJSONObject
  | CreateAgentRequestResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const FallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type FallbackModelConfigurationReasoningEffort = ClosedEnum<
  typeof FallbackModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type FallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type FallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type FallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceType
>;

export type CreateAgentRequestToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceType | undefined;
  function: CreateAgentRequestToolChoiceFunction;
};

export const CreateAgentRequestToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoice1 = ClosedEnum<
  typeof CreateAgentRequestToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type FallbackModelConfigurationToolChoice =
  | CreateAgentRequestToolChoice2
  | CreateAgentRequestToolChoice1;

export const FallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type FallbackModelConfigurationModalities = ClosedEnum<
  typeof FallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const CreateAgentRequestId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type CreateAgentRequestId1 = ClosedEnum<typeof CreateAgentRequestId1>;

export type FallbackModelConfigurationId = CreateAgentRequestId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const FallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type FallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof FallbackModelConfigurationExecuteOn
>;

export type FallbackModelConfigurationGuardrails = {
  id: CreateAgentRequestId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: FallbackModelConfigurationExecuteOn;
};

export type FallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type FallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const FallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type FallbackModelConfigurationType = ClosedEnum<
  typeof FallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type FallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: FallbackModelConfigurationType;
};

export const CreateAgentRequestLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateAgentRequestLoadBalancerType = ClosedEnum<
  typeof CreateAgentRequestLoadBalancerType
>;

export type CreateAgentRequestLoadBalancer1 = {
  type: CreateAgentRequestLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type FallbackModelConfigurationLoadBalancer =
  CreateAgentRequestLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type FallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type FallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: FallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ResponseFormatText
    | ResponseFormatJSONObject
    | CreateAgentRequestResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: FallbackModelConfigurationReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: FallbackModelConfigurationStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoice2
    | CreateAgentRequestToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<FallbackModelConfigurationModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<FallbackModelConfigurationGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<FallbackModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: FallbackModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: FallbackModelConfigurationCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateAgentRequestLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: FallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type CreateAgentRequestFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type FallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: FallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: CreateAgentRequestFallbackModelConfigurationRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type FallbackModelConfiguration = FallbackModelConfiguration2 | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

/**
 * MCP tool type
 */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type =
  {
    Mcp: "mcp",
  } as const;
/**
 * MCP tool type
 */
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
  >;

/**
 * Executes tools from Model Context Protocol (MCP) servers. Specify the parent MCP tool using "key" or "id", and the specific nested tool using "tool_id".
 */
export type MCPTool = {
  /**
   * MCP tool type
   */
  type?:
    | CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
    | undefined;
  /**
   * The key of the parent MCP tool
   */
  key?: string | undefined;
  /**
   * The ID of the parent MCP tool
   */
  id?: string | undefined;
  /**
   * The ID of the specific nested tool within the MCP server
   */
  toolId: string;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * JSON Schema tool type
 */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type =
  {
    JsonSchema: "json_schema",
  } as const;
/**
 * JSON Schema tool type
 */
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
  >;

/**
 * Enforces structured output format using JSON Schema. Must reference a pre-created JSON Schema tool by key or id.
 */
export type JSONSchemaTool = {
  /**
   * JSON Schema tool type
   */
  type?:
    | CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
    | undefined;
  /**
   * The key of the pre-created JSON Schema tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created JSON Schema tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Function tool type
 */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
/**
 * Function tool type
 */
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type FunctionTool = {
  /**
   * Function tool type
   */
  type?:
    | CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    | undefined;
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Code execution tool type
 */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
/**
 * Code execution tool type
 */
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type CodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type?:
    | CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    | undefined;
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * HTTP tool type
 */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
/**
 * HTTP tool type
 */
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type HTTPTool = {
  /**
   * HTTP tool type
   */
  type?:
    | CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    | undefined;
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type CurrentDateTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type QueryKnowledgeBaseTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type RetrieveKnowledgeBasesTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type DeleteMemoryDocumentTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Lists available memory stores
 */
export type RetrieveMemoryStoresTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  >;

/**
 * Writes information to agent memory stores
 */
export type WriteMemoryStoreTool = {
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType =
  {
    QueryMemoryStore: "query_memory_store",
  } as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType =
  ClosedEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType
  >;

/**
 * Queries agent memory stores for context
 */
export type QueryMemoryStoreTool = {
  type: CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsRequestType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsRequestType = ClosedEnum<
  typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestType
>;

/**
 * Retrieves available agents in the system
 */
export type RetrieveAgentsTool = {
  type: CreateAgentRequestAgentToolInputCRUDAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDAgentsType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type CreateAgentRequestAgentToolInputCRUDAgentsType = ClosedEnum<
  typeof CreateAgentRequestAgentToolInputCRUDAgentsType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type CallSubAgentTool = {
  type: CreateAgentRequestAgentToolInputCRUDAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentRequestAgentToolInputCRUDType = {
  WebScraper: "web_scraper",
} as const;
export type CreateAgentRequestAgentToolInputCRUDType = ClosedEnum<
  typeof CreateAgentRequestAgentToolInputCRUDType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type WebScraperTool = {
  type: CreateAgentRequestAgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const AgentToolInputCRUDType = {
  GoogleSearch: "google_search",
} as const;
export type AgentToolInputCRUDType = ClosedEnum<typeof AgentToolInputCRUDType>;

/**
 * Performs Google searches to retrieve web content
 */
export type GoogleSearchTool = {
  type: AgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function, JSON Schema, MCP) must reference pre-created tools by key or id.
 */
export type AgentToolInputCRUD =
  | GoogleSearchTool
  | WebScraperTool
  | CallSubAgentTool
  | RetrieveAgentsTool
  | QueryMemoryStoreTool
  | WriteMemoryStoreTool
  | RetrieveMemoryStoresTool
  | DeleteMemoryDocumentTool
  | RetrieveKnowledgeBasesTool
  | QueryKnowledgeBaseTool
  | CurrentDateTool
  | MCPTool
  | HTTPTool
  | CodeExecutionTool
  | FunctionTool
  | JSONSchemaTool;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestExecuteOn = ClosedEnum<
  typeof CreateAgentRequestExecuteOn
>;

export type Evaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestAgentsExecuteOn = ClosedEnum<
  typeof CreateAgentRequestAgentsExecuteOn
>;

export type CreateAgentRequestGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestAgentsExecuteOn;
};

/**
 * Configuration settings for the agent's behavior
 */
export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | GoogleSearchTool
      | WebScraperTool
      | CallSubAgentTool
      | RetrieveAgentsTool
      | QueryMemoryStoreTool
      | WriteMemoryStoreTool
      | RetrieveMemoryStoresTool
      | DeleteMemoryDocumentTool
      | RetrieveKnowledgeBasesTool
      | QueryKnowledgeBaseTool
      | CurrentDateTool
      | MCPTool
      | HTTPTool
      | CodeExecutionTool
      | FunctionTool
      | JSONSchemaTool
    >
    | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<Evaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<CreateAgentRequestGuardrails> | undefined;
};

export type KnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type TeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export const Source = {
  Internal: "internal",
  External: "external",
  Experiment: "experiment",
} as const;
export type Source = ClosedEnum<typeof Source>;

export type CreateAgentRequestRequestBody = {
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  /**
   * agent display name within the workspace
   */
  displayName?: string | undefined;
  /**
   * The role or function of the agent
   */
  role: string;
  /**
   * A brief description of what the agent does
   */
  description: string;
  /**
   * Detailed instructions that guide the agent's behavior
   */
  instructions: string;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * The path where the agent will be stored in the project structure. The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * @remarks
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
   */
  model: ModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?: Array<FallbackModelConfiguration2 | string> | undefined;
  /**
   * Configuration settings for the agent's behavior
   */
  settings: Settings;
  /**
   * Optional array of memory store identifiers for the agent to access. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Optional array of knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<KnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<TeamOfAgents> | undefined;
  variables?: { [k: string]: any } | undefined;
  source?: Source | undefined;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateAgentRequestStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateAgentRequestStatus = ClosedEnum<
  typeof CreateAgentRequestStatus
>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const CreateAgentRequestToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type CreateAgentRequestToolApprovalRequired = ClosedEnum<
  typeof CreateAgentRequestToolApprovalRequired
>;

export type Conditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type CreateAgentRequestTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval: boolean;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<Conditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout: number;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestAgentsResponseExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestAgentsResponseExecuteOn = ClosedEnum<
  typeof CreateAgentRequestAgentsResponseExecuteOn
>;

export type CreateAgentRequestEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestAgentsResponseExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const CreateAgentRequestAgentsResponse201ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type CreateAgentRequestAgentsResponse201ExecuteOn = ClosedEnum<
  typeof CreateAgentRequestAgentsResponse201ExecuteOn
>;

export type CreateAgentRequestAgentsGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: CreateAgentRequestAgentsResponse201ExecuteOn;
};

export type CreateAgentRequestSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations: number;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime: number;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired: CreateAgentRequestToolApprovalRequired;
  tools?: Array<CreateAgentRequestTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<CreateAgentRequestEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<CreateAgentRequestAgentsGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentRequestVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentRequestVoice = ClosedEnum<
  typeof CreateAgentRequestVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentRequestFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentRequestFormat = ClosedEnum<
  typeof CreateAgentRequestFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentRequestAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentRequestVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentRequestFormat;
};

export type CreateAgentRequestResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatAgentsResponse201JSONSchema = {
  type: "json_schema";
  jsonSchema: CreateAgentRequestResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentRequestResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentRequestResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentRequestResponseFormat =
  | CreateAgentRequestResponseFormatText
  | CreateAgentRequestResponseFormatJSONObject
  | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const CreateAgentRequestReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type CreateAgentRequestReasoningEffort = ClosedEnum<
  typeof CreateAgentRequestReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentRequestStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentRequestStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type CreateAgentRequestThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceAgentsType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsType
>;

export type CreateAgentRequestToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceAgentsType | undefined;
  function: CreateAgentRequestToolChoiceAgentsFunction;
};

export const CreateAgentRequestToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoiceAgents1 = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentRequestToolChoice =
  | CreateAgentRequestToolChoiceAgents2
  | CreateAgentRequestToolChoiceAgents1;

export const CreateAgentRequestModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentRequestModalities = ClosedEnum<
  typeof CreateAgentRequestModalities
>;

/**
 * The key of the guardrail.
 */
export const CreateAgentRequestIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type CreateAgentRequestIdAgents1 = ClosedEnum<
  typeof CreateAgentRequestIdAgents1
>;

export type CreateAgentRequestId = CreateAgentRequestIdAgents1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn =
  ClosedEnum<
    typeof CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn
  >;

export type CreateAgentRequestAgentsResponseGuardrails = {
  id: CreateAgentRequestIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn;
};

export type CreateAgentRequestFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateAgentRequestAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateAgentRequestType = {
  ExactMatch: "exact_match",
} as const;
export type CreateAgentRequestType = ClosedEnum<typeof CreateAgentRequestType>;

/**
 * Cache configuration for the request.
 */
export type CreateAgentRequestCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: CreateAgentRequestType;
};

export const CreateAgentRequestLoadBalancerAgentsType = {
  WeightBased: "weight_based",
} as const;
export type CreateAgentRequestLoadBalancerAgentsType = ClosedEnum<
  typeof CreateAgentRequestLoadBalancerAgentsType
>;

export type CreateAgentRequestLoadBalancerAgents1 = {
  type: CreateAgentRequestLoadBalancerAgentsType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type CreateAgentRequestLoadBalancer =
  CreateAgentRequestLoadBalancerAgents1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateAgentRequestTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type CreateAgentRequestParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentRequestAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentRequestResponseFormatText
    | CreateAgentRequestResponseFormatJSONObject
    | CreateAgentRequestResponseFormatAgentsResponse201JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: CreateAgentRequestReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateAgentRequestStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoiceAgents2
    | CreateAgentRequestToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateAgentRequestModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<CreateAgentRequestAgentsResponseGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateAgentRequestFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateAgentRequestAgentsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateAgentRequestCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateAgentRequestLoadBalancerAgents1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateAgentRequestTimeout | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type CreateAgentRequestRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentRequestFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentRequestFallbackModelConfigurationVoice = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentRequestFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentRequestFallbackModelConfigurationFormat = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentRequestFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentRequestFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentRequestFallbackModelConfigurationFormat;
};

export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict: boolean;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema =
  {
    type: "json_schema";
    jsonSchema:
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema;
  };

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentRequestResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentRequestResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentRequestFallbackModelConfigurationResponseFormat =
  | CreateAgentRequestResponseFormatAgentsText
  | CreateAgentRequestResponseFormatAgentsJSONObject
  | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const CreateAgentRequestFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type CreateAgentRequestFallbackModelConfigurationReasoningEffort =
  ClosedEnum<
    typeof CreateAgentRequestFallbackModelConfigurationReasoningEffort
  >;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentRequestFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentRequestFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type CreateAgentRequestFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentRequestToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentRequestToolChoiceAgentsResponseType = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsResponseType
>;

export type CreateAgentRequestToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateAgentRequestToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentRequestToolChoiceAgentsResponseType | undefined;
  function: CreateAgentRequestToolChoiceAgentsResponseFunction;
};

export const CreateAgentRequestToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentRequestToolChoiceAgentsResponse1 = ClosedEnum<
  typeof CreateAgentRequestToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentRequestFallbackModelConfigurationToolChoice =
  | CreateAgentRequestToolChoiceAgentsResponse2
  | CreateAgentRequestToolChoiceAgentsResponse1;

export const CreateAgentRequestFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentRequestFallbackModelConfigurationModalities = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const CreateAgentRequestIdAgentsResponse1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type CreateAgentRequestIdAgentsResponse1 = ClosedEnum<
  typeof CreateAgentRequestIdAgentsResponse1
>;

export type CreateAgentRequestFallbackModelConfigurationId =
  | CreateAgentRequestIdAgentsResponse1
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const CreateAgentRequestFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type CreateAgentRequestFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationExecuteOn
>;

export type CreateAgentRequestFallbackModelConfigurationGuardrails = {
  id: CreateAgentRequestIdAgentsResponse1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: CreateAgentRequestFallbackModelConfigurationExecuteOn;
};

export type CreateAgentRequestFallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateAgentRequestFallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type CreateAgentRequestFallbackModelConfigurationType = ClosedEnum<
  typeof CreateAgentRequestFallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type CreateAgentRequestFallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: CreateAgentRequestFallbackModelConfigurationType;
};

export const CreateAgentRequestLoadBalancerAgentsResponseType = {
  WeightBased: "weight_based",
} as const;
export type CreateAgentRequestLoadBalancerAgentsResponseType = ClosedEnum<
  typeof CreateAgentRequestLoadBalancerAgentsResponseType
>;

export type CreateAgentRequestLoadBalancerAgentsResponse1 = {
  type: CreateAgentRequestLoadBalancerAgentsResponseType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type CreateAgentRequestFallbackModelConfigurationLoadBalancer =
  CreateAgentRequestLoadBalancerAgentsResponse1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateAgentRequestFallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type CreateAgentRequestFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentRequestFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentRequestResponseFormatAgentsText
    | CreateAgentRequestResponseFormatAgentsJSONObject
    | CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | CreateAgentRequestFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | CreateAgentRequestFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentRequestToolChoiceAgentsResponse2
    | CreateAgentRequestToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<CreateAgentRequestFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<CreateAgentRequestFallbackModelConfigurationGuardrails>
    | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?:
    | Array<CreateAgentRequestFallbackModelConfigurationFallbacks>
    | undefined;
  /**
   * Retry configuration for the request
   */
  retry?:
    | CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry
    | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateAgentRequestFallbackModelConfigurationCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?:
    | Array<CreateAgentRequestLoadBalancerAgentsResponse1>
    | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateAgentRequestFallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type CreateAgentRequestFallbackModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type CreateAgentRequestFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?:
    | CreateAgentRequestFallbackModelConfigurationParameters
    | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: CreateAgentRequestFallbackModelConfigurationAgentsRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type CreateAgentRequestFallbackModelConfiguration =
  | CreateAgentRequestFallbackModelConfiguration2
  | string;

export type Model = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: CreateAgentRequestParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: CreateAgentRequestRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<CreateAgentRequestFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type CreateAgentRequestTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type Metrics = {
  totalCost: number;
};

export type CreateAgentRequestKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const CreateAgentRequestSource = {
  Internal: "internal",
  External: "external",
  Experiment: "experiment",
} as const;
export type CreateAgentRequestSource = ClosedEnum<
  typeof CreateAgentRequestSource
>;

/**
 * Agent successfully created and ready for use. Returns the complete agent manifest including the generated ID, configuration, and all settings.
 */
export type CreateAgentRequestResponseBody = {
  id: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  displayName: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateAgentRequestStatus;
  settings?: CreateAgentRequestSettings | undefined;
  model: Model;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<CreateAgentRequestTeamOfAgents>;
  metrics?: Metrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<CreateAgentRequestKnowledgeBases> | undefined;
  source?: CreateAgentRequestSource | undefined;
};

/** @internal */
export const Voice$outboundSchema: z.ZodNativeEnum<typeof Voice> = z.nativeEnum(
  Voice,
);

/** @internal */
export const Format$outboundSchema: z.ZodNativeEnum<typeof Format> = z
  .nativeEnum(Format);

/** @internal */
export type ModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ModelConfigurationAudio$outboundSchema: z.ZodType<
  ModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  ModelConfigurationAudio
> = z.object({
  voice: Voice$outboundSchema,
  format: Format$outboundSchema,
});

export function modelConfigurationAudioToJSON(
  modelConfigurationAudio: ModelConfigurationAudio,
): string {
  return JSON.stringify(
    ModelConfigurationAudio$outboundSchema.parse(modelConfigurationAudio),
  );
}

/** @internal */
export type ResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const ResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});

export function responseFormatJsonSchemaToJSON(
  responseFormatJsonSchema: ResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ResponseFormatJsonSchema$outboundSchema.parse(responseFormatJsonSchema),
  );
}

/** @internal */
export type JSONSchema$Outbound = {
  type: "json_schema";
  json_schema: ResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const JSONSchema$outboundSchema: z.ZodType<
  JSONSchema$Outbound,
  z.ZodTypeDef,
  JSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() => ResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function jsonSchemaToJSON(jsonSchema: JSONSchema): string {
  return JSON.stringify(JSONSchema$outboundSchema.parse(jsonSchema));
}

/** @internal */
export type JSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const JSONObject$outboundSchema: z.ZodType<
  JSONObject$Outbound,
  z.ZodTypeDef,
  JSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function jsonObjectToJSON(jsonObject: JSONObject): string {
  return JSON.stringify(JSONObject$outboundSchema.parse(jsonObject));
}

/** @internal */
export type Text$Outbound = {
  type: "text";
};

/** @internal */
export const Text$outboundSchema: z.ZodType<Text$Outbound, z.ZodTypeDef, Text> =
  z.object({
    type: z.literal("text"),
  });

export function textToJSON(text: Text): string {
  return JSON.stringify(Text$outboundSchema.parse(text));
}

/** @internal */
export type ResponseFormat$Outbound =
  | Text$Outbound
  | JSONObject$Outbound
  | JSONSchema$Outbound;

/** @internal */
export const ResponseFormat$outboundSchema: z.ZodType<
  ResponseFormat$Outbound,
  z.ZodTypeDef,
  ResponseFormat
> = z.union([
  z.lazy(() => Text$outboundSchema),
  z.lazy(() => JSONObject$outboundSchema),
  z.lazy(() => JSONSchema$outboundSchema),
]);

export function responseFormatToJSON(responseFormat: ResponseFormat): string {
  return JSON.stringify(ResponseFormat$outboundSchema.parse(responseFormat));
}

/** @internal */
export const ReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof ReasoningEffort
> = z.nativeEnum(ReasoningEffort);

/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}

/** @internal */
export type StreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamOptions$outboundSchema: z.ZodType<
  StreamOptions$Outbound,
  z.ZodTypeDef,
  StreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamOptionsToJSON(streamOptions: StreamOptions): string {
  return JSON.stringify(StreamOptions$outboundSchema.parse(streamOptions));
}

/** @internal */
export type Thinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const Thinking$outboundSchema: z.ZodType<
  Thinking$Outbound,
  z.ZodTypeDef,
  Thinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function thinkingToJSON(thinking: Thinking): string {
  return JSON.stringify(Thinking$outboundSchema.parse(thinking));
}

/** @internal */
export const ToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = z.nativeEnum(ToolChoiceType);

/** @internal */
export type ToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const ToolChoiceFunction$outboundSchema: z.ZodType<
  ToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function toolChoiceFunctionToJSON(
  toolChoiceFunction: ToolChoiceFunction,
): string {
  return JSON.stringify(
    ToolChoiceFunction$outboundSchema.parse(toolChoiceFunction),
  );
}

/** @internal */
export type ToolChoice2$Outbound = {
  type?: string | undefined;
  function: ToolChoiceFunction$Outbound;
};

/** @internal */
export const ToolChoice2$outboundSchema: z.ZodType<
  ToolChoice2$Outbound,
  z.ZodTypeDef,
  ToolChoice2
> = z.object({
  type: ToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$outboundSchema),
});

export function toolChoice2ToJSON(toolChoice2: ToolChoice2): string {
  return JSON.stringify(ToolChoice2$outboundSchema.parse(toolChoice2));
}

/** @internal */
export const ToolChoice1$outboundSchema: z.ZodNativeEnum<typeof ToolChoice1> = z
  .nativeEnum(ToolChoice1);

/** @internal */
export type ToolChoice$Outbound = ToolChoice2$Outbound | string;

/** @internal */
export const ToolChoice$outboundSchema: z.ZodType<
  ToolChoice$Outbound,
  z.ZodTypeDef,
  ToolChoice
> = z.union([
  z.lazy(() => ToolChoice2$outboundSchema),
  ToolChoice1$outboundSchema,
]);

export function toolChoiceToJSON(toolChoice: ToolChoice): string {
  return JSON.stringify(ToolChoice$outboundSchema.parse(toolChoice));
}

/** @internal */
export const Modalities$outboundSchema: z.ZodNativeEnum<typeof Modalities> = z
  .nativeEnum(Modalities);

/** @internal */
export const Id1$outboundSchema: z.ZodNativeEnum<typeof Id1> = z.nativeEnum(
  Id1,
);

/** @internal */
export type Id$Outbound = string | string;

/** @internal */
export const Id$outboundSchema: z.ZodType<Id$Outbound, z.ZodTypeDef, Id> = z
  .union([Id1$outboundSchema, z.string()]);

export function idToJSON(id: Id): string {
  return JSON.stringify(Id$outboundSchema.parse(id));
}

/** @internal */
export const ExecuteOn$outboundSchema: z.ZodNativeEnum<typeof ExecuteOn> = z
  .nativeEnum(ExecuteOn);

/** @internal */
export type Guardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const Guardrails$outboundSchema: z.ZodType<
  Guardrails$Outbound,
  z.ZodTypeDef,
  Guardrails
> = z.object({
  id: z.union([Id1$outboundSchema, z.string()]),
  executeOn: ExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function guardrailsToJSON(guardrails: Guardrails): string {
  return JSON.stringify(Guardrails$outboundSchema.parse(guardrails));
}

/** @internal */
export type Fallbacks$Outbound = {
  model: string;
};

/** @internal */
export const Fallbacks$outboundSchema: z.ZodType<
  Fallbacks$Outbound,
  z.ZodTypeDef,
  Fallbacks
> = z.object({
  model: z.string(),
});

export function fallbacksToJSON(fallbacks: Fallbacks): string {
  return JSON.stringify(Fallbacks$outboundSchema.parse(fallbacks));
}

/** @internal */
export type Retry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const Retry$outboundSchema: z.ZodType<
  Retry$Outbound,
  z.ZodTypeDef,
  Retry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function retryToJSON(retry: Retry): string {
  return JSON.stringify(Retry$outboundSchema.parse(retry));
}

/** @internal */
export const ModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationType
> = z.nativeEnum(ModelConfigurationType);

/** @internal */
export type Cache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const Cache$outboundSchema: z.ZodType<
  Cache$Outbound,
  z.ZodTypeDef,
  Cache
> = z.object({
  ttl: z.number().default(1800),
  type: ModelConfigurationType$outboundSchema,
});

export function cacheToJSON(cache: Cache): string {
  return JSON.stringify(Cache$outboundSchema.parse(cache));
}

/** @internal */
export const LoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof LoadBalancerType
> = z.nativeEnum(LoadBalancerType);

/** @internal */
export type LoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const LoadBalancer1$outboundSchema: z.ZodType<
  LoadBalancer1$Outbound,
  z.ZodTypeDef,
  LoadBalancer1
> = z.object({
  type: LoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function loadBalancer1ToJSON(loadBalancer1: LoadBalancer1): string {
  return JSON.stringify(LoadBalancer1$outboundSchema.parse(loadBalancer1));
}

/** @internal */
export type LoadBalancer$Outbound = LoadBalancer1$Outbound;

/** @internal */
export const LoadBalancer$outboundSchema: z.ZodType<
  LoadBalancer$Outbound,
  z.ZodTypeDef,
  LoadBalancer
> = z.lazy(() => LoadBalancer1$outboundSchema);

export function loadBalancerToJSON(loadBalancer: LoadBalancer): string {
  return JSON.stringify(LoadBalancer$outboundSchema.parse(loadBalancer));
}

/** @internal */
export type Timeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const Timeout$outboundSchema: z.ZodType<
  Timeout$Outbound,
  z.ZodTypeDef,
  Timeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function timeoutToJSON(timeout: Timeout): string {
  return JSON.stringify(Timeout$outboundSchema.parse(timeout));
}

/** @internal */
export type ParametersT$Outbound = {
  audio?: ModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | Text$Outbound
    | JSONObject$Outbound
    | JSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: StreamOptions$Outbound | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<Guardrails$Outbound> | undefined;
  fallbacks?: Array<Fallbacks$Outbound> | undefined;
  retry?: Retry$Outbound | undefined;
  cache?: Cache$Outbound | undefined;
  load_balancer?: Array<LoadBalancer1$Outbound> | undefined;
  timeout?: Timeout$Outbound | undefined;
};

/** @internal */
export const ParametersT$outboundSchema: z.ZodType<
  ParametersT$Outbound,
  z.ZodTypeDef,
  ParametersT
> = z.object({
  audio: z.nullable(z.lazy(() => ModelConfigurationAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => Text$outboundSchema),
    z.lazy(() => JSONObject$outboundSchema),
    z.lazy(() => JSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: ReasoningEffort$outboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => StreamOptions$outboundSchema))
    .optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ToolChoice2$outboundSchema),
    ToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$outboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => Guardrails$outboundSchema)).optional(),
  fallbacks: z.array(z.lazy(() => Fallbacks$outboundSchema)).optional(),
  retry: z.lazy(() => Retry$outboundSchema).optional(),
  cache: z.lazy(() => Cache$outboundSchema).optional(),
  loadBalancer: z.array(z.lazy(() => LoadBalancer1$outboundSchema)).optional(),
  timeout: z.lazy(() => Timeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function parametersToJSON(parametersT: ParametersT): string {
  return JSON.stringify(ParametersT$outboundSchema.parse(parametersT));
}

/** @internal */
export type ModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const ModelConfigurationRetry$outboundSchema: z.ZodType<
  ModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  ModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function modelConfigurationRetryToJSON(
  modelConfigurationRetry: ModelConfigurationRetry,
): string {
  return JSON.stringify(
    ModelConfigurationRetry$outboundSchema.parse(modelConfigurationRetry),
  );
}

/** @internal */
export type ModelConfiguration2$Outbound = {
  id: string;
  parameters?: ParametersT$Outbound | undefined;
  retry?: ModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const ModelConfiguration2$outboundSchema: z.ZodType<
  ModelConfiguration2$Outbound,
  z.ZodTypeDef,
  ModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ParametersT$outboundSchema).optional(),
  retry: z.lazy(() => ModelConfigurationRetry$outboundSchema).optional(),
});

export function modelConfiguration2ToJSON(
  modelConfiguration2: ModelConfiguration2,
): string {
  return JSON.stringify(
    ModelConfiguration2$outboundSchema.parse(modelConfiguration2),
  );
}

/** @internal */
export type ModelConfiguration$Outbound = ModelConfiguration2$Outbound | string;

/** @internal */
export const ModelConfiguration$outboundSchema: z.ZodType<
  ModelConfiguration$Outbound,
  z.ZodTypeDef,
  ModelConfiguration
> = z.union([z.lazy(() => ModelConfiguration2$outboundSchema), z.string()]);

export function modelConfigurationToJSON(
  modelConfiguration: ModelConfiguration,
): string {
  return JSON.stringify(
    ModelConfiguration$outboundSchema.parse(modelConfiguration),
  );
}

/** @internal */
export const FallbackModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationVoice
> = z.nativeEnum(FallbackModelConfigurationVoice);

/** @internal */
export const FallbackModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationFormat
> = z.nativeEnum(FallbackModelConfigurationFormat);

/** @internal */
export type FallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const FallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  FallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationAudio
> = z.object({
  voice: FallbackModelConfigurationVoice$outboundSchema,
  format: FallbackModelConfigurationFormat$outboundSchema,
});

export function fallbackModelConfigurationAudioToJSON(
  fallbackModelConfigurationAudio: FallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    FallbackModelConfigurationAudio$outboundSchema.parse(
      fallbackModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsJsonSchemaToJSON(
  createAgentRequestResponseFormatAgentsJsonSchema:
    CreateAgentRequestResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema.parse(
      createAgentRequestResponseFormatAgentsJsonSchema,
    ),
  );
}

/** @internal */
export type CreateAgentRequestResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: CreateAgentRequestResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentRequestResponseFormatJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestResponseFormatJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentRequestResponseFormatJSONSchemaToJSON(
  createAgentRequestResponseFormatJSONSchema:
    CreateAgentRequestResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentRequestResponseFormatJSONSchema$outboundSchema.parse(
      createAgentRequestResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type ResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const ResponseFormatJSONObject$outboundSchema: z.ZodType<
  ResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  ResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function responseFormatJSONObjectToJSON(
  responseFormatJSONObject: ResponseFormatJSONObject,
): string {
  return JSON.stringify(
    ResponseFormatJSONObject$outboundSchema.parse(responseFormatJSONObject),
  );
}

/** @internal */
export type ResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const ResponseFormatText$outboundSchema: z.ZodType<
  ResponseFormatText$Outbound,
  z.ZodTypeDef,
  ResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function responseFormatTextToJSON(
  responseFormatText: ResponseFormatText,
): string {
  return JSON.stringify(
    ResponseFormatText$outboundSchema.parse(responseFormatText),
  );
}

/** @internal */
export type FallbackModelConfigurationResponseFormat$Outbound =
  | ResponseFormatText$Outbound
  | ResponseFormatJSONObject$Outbound
  | CreateAgentRequestResponseFormatJSONSchema$Outbound;

/** @internal */
export const FallbackModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  FallbackModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => ResponseFormatText$outboundSchema),
  z.lazy(() => ResponseFormatJSONObject$outboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$outboundSchema),
]);

export function fallbackModelConfigurationResponseFormatToJSON(
  fallbackModelConfigurationResponseFormat:
    FallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    FallbackModelConfigurationResponseFormat$outboundSchema.parse(
      fallbackModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const FallbackModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationReasoningEffort> = z
    .nativeEnum(FallbackModelConfigurationReasoningEffort);

/** @internal */
export type FallbackModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const FallbackModelConfigurationStop$outboundSchema: z.ZodType<
  FallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function fallbackModelConfigurationStopToJSON(
  fallbackModelConfigurationStop: FallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStop$outboundSchema.parse(
      fallbackModelConfigurationStop,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const FallbackModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  FallbackModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function fallbackModelConfigurationStreamOptionsToJSON(
  fallbackModelConfigurationStreamOptions:
    FallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStreamOptions$outboundSchema.parse(
      fallbackModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const FallbackModelConfigurationThinking$outboundSchema: z.ZodType<
  FallbackModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function fallbackModelConfigurationThinkingToJSON(
  fallbackModelConfigurationThinking: FallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    FallbackModelConfigurationThinking$outboundSchema.parse(
      fallbackModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoiceType
> = z.nativeEnum(CreateAgentRequestToolChoiceType);

/** @internal */
export type CreateAgentRequestToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateAgentRequestToolChoiceFunction$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function createAgentRequestToolChoiceFunctionToJSON(
  createAgentRequestToolChoiceFunction: CreateAgentRequestToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoiceFunction$outboundSchema.parse(
      createAgentRequestToolChoiceFunction,
    ),
  );
}

/** @internal */
export type CreateAgentRequestToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateAgentRequestToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateAgentRequestToolChoice2$outboundSchema: z.ZodType<
  CreateAgentRequestToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestToolChoice2
> = z.object({
  type: CreateAgentRequestToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentRequestToolChoiceFunction$outboundSchema),
});

export function createAgentRequestToolChoice2ToJSON(
  createAgentRequestToolChoice2: CreateAgentRequestToolChoice2,
): string {
  return JSON.stringify(
    CreateAgentRequestToolChoice2$outboundSchema.parse(
      createAgentRequestToolChoice2,
    ),
  );
}

/** @internal */
export const CreateAgentRequestToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoice1
> = z.nativeEnum(CreateAgentRequestToolChoice1);

/** @internal */
export type FallbackModelConfigurationToolChoice$Outbound =
  | CreateAgentRequestToolChoice2$Outbound
  | string;

/** @internal */
export const FallbackModelConfigurationToolChoice$outboundSchema: z.ZodType<
  FallbackModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationToolChoice
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoice2$outboundSchema),
  CreateAgentRequestToolChoice1$outboundSchema,
]);

export function fallbackModelConfigurationToolChoiceToJSON(
  fallbackModelConfigurationToolChoice: FallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    FallbackModelConfigurationToolChoice$outboundSchema.parse(
      fallbackModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const FallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationModalities> = z.nativeEnum(
    FallbackModelConfigurationModalities,
  );

/** @internal */
export const CreateAgentRequestId1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestId1
> = z.nativeEnum(CreateAgentRequestId1);

/** @internal */
export type FallbackModelConfigurationId$Outbound = string | string;

/** @internal */
export const FallbackModelConfigurationId$outboundSchema: z.ZodType<
  FallbackModelConfigurationId$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationId
> = z.union([CreateAgentRequestId1$outboundSchema, z.string()]);

export function fallbackModelConfigurationIdToJSON(
  fallbackModelConfigurationId: FallbackModelConfigurationId,
): string {
  return JSON.stringify(
    FallbackModelConfigurationId$outboundSchema.parse(
      fallbackModelConfigurationId,
    ),
  );
}

/** @internal */
export const FallbackModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationExecuteOn> = z.nativeEnum(
    FallbackModelConfigurationExecuteOn,
  );

/** @internal */
export type FallbackModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const FallbackModelConfigurationGuardrails$outboundSchema: z.ZodType<
  FallbackModelConfigurationGuardrails$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationGuardrails
> = z.object({
  id: z.union([CreateAgentRequestId1$outboundSchema, z.string()]),
  executeOn: FallbackModelConfigurationExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function fallbackModelConfigurationGuardrailsToJSON(
  fallbackModelConfigurationGuardrails: FallbackModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    FallbackModelConfigurationGuardrails$outboundSchema.parse(
      fallbackModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const FallbackModelConfigurationFallbacks$outboundSchema: z.ZodType<
  FallbackModelConfigurationFallbacks$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationFallbacks
> = z.object({
  model: z.string(),
});

export function fallbackModelConfigurationFallbacksToJSON(
  fallbackModelConfigurationFallbacks: FallbackModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    FallbackModelConfigurationFallbacks$outboundSchema.parse(
      fallbackModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const FallbackModelConfigurationRetry$outboundSchema: z.ZodType<
  FallbackModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function fallbackModelConfigurationRetryToJSON(
  fallbackModelConfigurationRetry: FallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    FallbackModelConfigurationRetry$outboundSchema.parse(
      fallbackModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const FallbackModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationType
> = z.nativeEnum(FallbackModelConfigurationType);

/** @internal */
export type FallbackModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const FallbackModelConfigurationCache$outboundSchema: z.ZodType<
  FallbackModelConfigurationCache$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationCache
> = z.object({
  ttl: z.number().default(1800),
  type: FallbackModelConfigurationType$outboundSchema,
});

export function fallbackModelConfigurationCacheToJSON(
  fallbackModelConfigurationCache: FallbackModelConfigurationCache,
): string {
  return JSON.stringify(
    FallbackModelConfigurationCache$outboundSchema.parse(
      fallbackModelConfigurationCache,
    ),
  );
}

/** @internal */
export const CreateAgentRequestLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestLoadBalancerType
> = z.nativeEnum(CreateAgentRequestLoadBalancerType);

/** @internal */
export type CreateAgentRequestLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const CreateAgentRequestLoadBalancer1$outboundSchema: z.ZodType<
  CreateAgentRequestLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestLoadBalancer1
> = z.object({
  type: CreateAgentRequestLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createAgentRequestLoadBalancer1ToJSON(
  createAgentRequestLoadBalancer1: CreateAgentRequestLoadBalancer1,
): string {
  return JSON.stringify(
    CreateAgentRequestLoadBalancer1$outboundSchema.parse(
      createAgentRequestLoadBalancer1,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationLoadBalancer$Outbound =
  CreateAgentRequestLoadBalancer1$Outbound;

/** @internal */
export const FallbackModelConfigurationLoadBalancer$outboundSchema: z.ZodType<
  FallbackModelConfigurationLoadBalancer$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationLoadBalancer
> = z.lazy(() => CreateAgentRequestLoadBalancer1$outboundSchema);

export function fallbackModelConfigurationLoadBalancerToJSON(
  fallbackModelConfigurationLoadBalancer:
    FallbackModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    FallbackModelConfigurationLoadBalancer$outboundSchema.parse(
      fallbackModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const FallbackModelConfigurationTimeout$outboundSchema: z.ZodType<
  FallbackModelConfigurationTimeout$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function fallbackModelConfigurationTimeoutToJSON(
  fallbackModelConfigurationTimeout: FallbackModelConfigurationTimeout,
): string {
  return JSON.stringify(
    FallbackModelConfigurationTimeout$outboundSchema.parse(
      fallbackModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type FallbackModelConfigurationParameters$Outbound = {
  audio?: FallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | ResponseFormatText$Outbound
    | ResponseFormatJSONObject$Outbound
    | CreateAgentRequestResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | FallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentRequestToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<FallbackModelConfigurationGuardrails$Outbound> | undefined;
  fallbacks?: Array<FallbackModelConfigurationFallbacks$Outbound> | undefined;
  retry?: FallbackModelConfigurationRetry$Outbound | undefined;
  cache?: FallbackModelConfigurationCache$Outbound | undefined;
  load_balancer?: Array<CreateAgentRequestLoadBalancer1$Outbound> | undefined;
  timeout?: FallbackModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const FallbackModelConfigurationParameters$outboundSchema: z.ZodType<
  FallbackModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => FallbackModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => ResponseFormatText$outboundSchema),
    z.lazy(() => ResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: FallbackModelConfigurationReasoningEffort$outboundSchema
    .optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => FallbackModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentRequestToolChoice2$outboundSchema),
    CreateAgentRequestToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(FallbackModelConfigurationModalities$outboundSchema),
  ).optional(),
  guardrails: z.array(
    z.lazy(() => FallbackModelConfigurationGuardrails$outboundSchema),
  ).optional(),
  fallbacks: z.array(
    z.lazy(() => FallbackModelConfigurationFallbacks$outboundSchema),
  ).optional(),
  retry: z.lazy(() => FallbackModelConfigurationRetry$outboundSchema)
    .optional(),
  cache: z.lazy(() => FallbackModelConfigurationCache$outboundSchema)
    .optional(),
  loadBalancer: z.array(
    z.lazy(() => CreateAgentRequestLoadBalancer1$outboundSchema),
  ).optional(),
  timeout: z.lazy(() => FallbackModelConfigurationTimeout$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function fallbackModelConfigurationParametersToJSON(
  fallbackModelConfigurationParameters: FallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    FallbackModelConfigurationParameters$outboundSchema.parse(
      fallbackModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type CreateAgentRequestFallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationRetry$outboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationRetry$Outbound,
    z.ZodTypeDef,
    CreateAgentRequestFallbackModelConfigurationRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function createAgentRequestFallbackModelConfigurationRetryToJSON(
  createAgentRequestFallbackModelConfigurationRetry:
    CreateAgentRequestFallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    CreateAgentRequestFallbackModelConfigurationRetry$outboundSchema.parse(
      createAgentRequestFallbackModelConfigurationRetry,
    ),
  );
}

/** @internal */
export type FallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?: FallbackModelConfigurationParameters$Outbound | undefined;
  retry?:
    | CreateAgentRequestFallbackModelConfigurationRetry$Outbound
    | undefined;
};

/** @internal */
export const FallbackModelConfiguration2$outboundSchema: z.ZodType<
  FallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => FallbackModelConfigurationParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() =>
    CreateAgentRequestFallbackModelConfigurationRetry$outboundSchema
  ).optional(),
});

export function fallbackModelConfiguration2ToJSON(
  fallbackModelConfiguration2: FallbackModelConfiguration2,
): string {
  return JSON.stringify(
    FallbackModelConfiguration2$outboundSchema.parse(
      fallbackModelConfiguration2,
    ),
  );
}

/** @internal */
export type FallbackModelConfiguration$Outbound =
  | FallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const FallbackModelConfiguration$outboundSchema: z.ZodType<
  FallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration
> = z.union([
  z.lazy(() => FallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function fallbackModelConfigurationToJSON(
  fallbackModelConfiguration: FallbackModelConfiguration,
): string {
  return JSON.stringify(
    FallbackModelConfiguration$outboundSchema.parse(fallbackModelConfiguration),
  );
}

/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type,
  );

/** @internal */
export type MCPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  tool_id: string;
  requires_approval: boolean;
};

/** @internal */
export const MCPTool$outboundSchema: z.ZodType<
  MCPTool$Outbound,
  z.ZodTypeDef,
  MCPTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type$outboundSchema
      .default("mcp"),
  key: z.string().optional(),
  id: z.string().optional(),
  toolId: z.string(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requiresApproval: "requires_approval",
  });
});

export function mcpToolToJSON(mcpTool: MCPTool): string {
  return JSON.stringify(MCPTool$outboundSchema.parse(mcpTool));
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type,
  );

/** @internal */
export type JSONSchemaTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const JSONSchemaTool$outboundSchema: z.ZodType<
  JSONSchemaTool$Outbound,
  z.ZodTypeDef,
  JSONSchemaTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type$outboundSchema
      .default("json_schema"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function jsonSchemaToolToJSON(jsonSchemaTool: JSONSchemaTool): string {
  return JSON.stringify(JSONSchemaTool$outboundSchema.parse(jsonSchemaTool));
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type,
  );

/** @internal */
export type FunctionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const FunctionTool$outboundSchema: z.ZodType<
  FunctionTool$Outbound,
  z.ZodTypeDef,
  FunctionTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema
      .default("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function functionToolToJSON(functionTool: FunctionTool): string {
  return JSON.stringify(FunctionTool$outboundSchema.parse(functionTool));
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type,
  );

/** @internal */
export type CodeExecutionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const CodeExecutionTool$outboundSchema: z.ZodType<
  CodeExecutionTool$Outbound,
  z.ZodTypeDef,
  CodeExecutionTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema
      .default("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function codeExecutionToolToJSON(
  codeExecutionTool: CodeExecutionTool,
): string {
  return JSON.stringify(
    CodeExecutionTool$outboundSchema.parse(codeExecutionTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type,
  );

/** @internal */
export type HTTPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const HTTPTool$outboundSchema: z.ZodType<
  HTTPTool$Outbound,
  z.ZodTypeDef,
  HTTPTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema
      .default("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function httpToolToJSON(httpTool: HTTPTool): string {
  return JSON.stringify(HTTPTool$outboundSchema.parse(httpTool));
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type,
  );

/** @internal */
export type CurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CurrentDateTool$outboundSchema: z.ZodType<
  CurrentDateTool$Outbound,
  z.ZodTypeDef,
  CurrentDateTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function currentDateToolToJSON(
  currentDateTool: CurrentDateTool,
): string {
  return JSON.stringify(CurrentDateTool$outboundSchema.parse(currentDateTool));
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type,
  );

/** @internal */
export type QueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  QueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  QueryKnowledgeBaseTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryKnowledgeBaseToolToJSON(
  queryKnowledgeBaseTool: QueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    QueryKnowledgeBaseTool$outboundSchema.parse(queryKnowledgeBaseTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type,
  );

/** @internal */
export type RetrieveKnowledgeBasesTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveKnowledgeBasesTool$outboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool$Outbound,
  z.ZodTypeDef,
  RetrieveKnowledgeBasesTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveKnowledgeBasesToolToJSON(
  retrieveKnowledgeBasesTool: RetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    RetrieveKnowledgeBasesTool$outboundSchema.parse(retrieveKnowledgeBasesTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type,
  );

/** @internal */
export type DeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const DeleteMemoryDocumentTool$outboundSchema: z.ZodType<
  DeleteMemoryDocumentTool$Outbound,
  z.ZodTypeDef,
  DeleteMemoryDocumentTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function deleteMemoryDocumentToolToJSON(
  deleteMemoryDocumentTool: DeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    DeleteMemoryDocumentTool$outboundSchema.parse(deleteMemoryDocumentTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType,
  );

/** @internal */
export type RetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveMemoryStoresTool$outboundSchema: z.ZodType<
  RetrieveMemoryStoresTool$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoresTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveMemoryStoresToolToJSON(
  retrieveMemoryStoresTool: RetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    RetrieveMemoryStoresTool$outboundSchema.parse(retrieveMemoryStoresTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType,
  );

/** @internal */
export type WriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WriteMemoryStoreTool$outboundSchema: z.ZodType<
  WriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  WriteMemoryStoreTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function writeMemoryStoreToolToJSON(
  writeMemoryStoreTool: WriteMemoryStoreTool,
): string {
  return JSON.stringify(
    WriteMemoryStoreTool$outboundSchema.parse(writeMemoryStoreTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType
  > = z.nativeEnum(
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType,
  );

/** @internal */
export type QueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryMemoryStoreTool$outboundSchema: z.ZodType<
  QueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  QueryMemoryStoreTool
> = z.object({
  type:
    CreateAgentRequestAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryMemoryStoreToolToJSON(
  queryMemoryStoreTool: QueryMemoryStoreTool,
): string {
  return JSON.stringify(
    QueryMemoryStoreTool$outboundSchema.parse(queryMemoryStoreTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentToolInputCRUDAgentsRequestType
  > = z.nativeEnum(CreateAgentRequestAgentToolInputCRUDAgentsRequestType);

/** @internal */
export type RetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveAgentsTool$outboundSchema: z.ZodType<
  RetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  RetrieveAgentsTool
> = z.object({
  type: CreateAgentRequestAgentToolInputCRUDAgentsRequestType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveAgentsToolToJSON(
  retrieveAgentsTool: RetrieveAgentsTool,
): string {
  return JSON.stringify(
    RetrieveAgentsTool$outboundSchema.parse(retrieveAgentsTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentToolInputCRUDAgentsType> = z
    .nativeEnum(CreateAgentRequestAgentToolInputCRUDAgentsType);

/** @internal */
export type CallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CallSubAgentTool$outboundSchema: z.ZodType<
  CallSubAgentTool$Outbound,
  z.ZodTypeDef,
  CallSubAgentTool
> = z.object({
  type: CreateAgentRequestAgentToolInputCRUDAgentsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function callSubAgentToolToJSON(
  callSubAgentTool: CallSubAgentTool,
): string {
  return JSON.stringify(
    CallSubAgentTool$outboundSchema.parse(callSubAgentTool),
  );
}

/** @internal */
export const CreateAgentRequestAgentToolInputCRUDType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentToolInputCRUDType> = z
    .nativeEnum(CreateAgentRequestAgentToolInputCRUDType);

/** @internal */
export type WebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WebScraperTool$outboundSchema: z.ZodType<
  WebScraperTool$Outbound,
  z.ZodTypeDef,
  WebScraperTool
> = z.object({
  type: CreateAgentRequestAgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function webScraperToolToJSON(webScraperTool: WebScraperTool): string {
  return JSON.stringify(WebScraperTool$outboundSchema.parse(webScraperTool));
}

/** @internal */
export const AgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputCRUDType
> = z.nativeEnum(AgentToolInputCRUDType);

/** @internal */
export type GoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const GoogleSearchTool$outboundSchema: z.ZodType<
  GoogleSearchTool$Outbound,
  z.ZodTypeDef,
  GoogleSearchTool
> = z.object({
  type: AgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function googleSearchToolToJSON(
  googleSearchTool: GoogleSearchTool,
): string {
  return JSON.stringify(
    GoogleSearchTool$outboundSchema.parse(googleSearchTool),
  );
}

/** @internal */
export type AgentToolInputCRUD$Outbound =
  | GoogleSearchTool$Outbound
  | WebScraperTool$Outbound
  | CallSubAgentTool$Outbound
  | RetrieveAgentsTool$Outbound
  | QueryMemoryStoreTool$Outbound
  | WriteMemoryStoreTool$Outbound
  | RetrieveMemoryStoresTool$Outbound
  | DeleteMemoryDocumentTool$Outbound
  | RetrieveKnowledgeBasesTool$Outbound
  | QueryKnowledgeBaseTool$Outbound
  | CurrentDateTool$Outbound
  | MCPTool$Outbound
  | HTTPTool$Outbound
  | CodeExecutionTool$Outbound
  | FunctionTool$Outbound
  | JSONSchemaTool$Outbound;

/** @internal */
export const AgentToolInputCRUD$outboundSchema: z.ZodType<
  AgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUD
> = z.union([
  z.lazy(() => GoogleSearchTool$outboundSchema),
  z.lazy(() => WebScraperTool$outboundSchema),
  z.lazy(() => CallSubAgentTool$outboundSchema),
  z.lazy(() => RetrieveAgentsTool$outboundSchema),
  z.lazy(() => QueryMemoryStoreTool$outboundSchema),
  z.lazy(() => WriteMemoryStoreTool$outboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => CurrentDateTool$outboundSchema),
  z.lazy(() => MCPTool$outboundSchema),
  z.lazy(() => HTTPTool$outboundSchema),
  z.lazy(() => CodeExecutionTool$outboundSchema),
  z.lazy(() => FunctionTool$outboundSchema),
  z.lazy(() => JSONSchemaTool$outboundSchema),
]);

export function agentToolInputCRUDToJSON(
  agentToolInputCRUD: AgentToolInputCRUD,
): string {
  return JSON.stringify(
    AgentToolInputCRUD$outboundSchema.parse(agentToolInputCRUD),
  );
}

/** @internal */
export const CreateAgentRequestExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestExecuteOn
> = z.nativeEnum(CreateAgentRequestExecuteOn);

/** @internal */
export type Evaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const Evaluators$outboundSchema: z.ZodType<
  Evaluators$Outbound,
  z.ZodTypeDef,
  Evaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: CreateAgentRequestExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function evaluatorsToJSON(evaluators: Evaluators): string {
  return JSON.stringify(Evaluators$outboundSchema.parse(evaluators));
}

/** @internal */
export const CreateAgentRequestAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestAgentsExecuteOn
> = z.nativeEnum(CreateAgentRequestAgentsExecuteOn);

/** @internal */
export type CreateAgentRequestGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const CreateAgentRequestGuardrails$outboundSchema: z.ZodType<
  CreateAgentRequestGuardrails$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: CreateAgentRequestAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function createAgentRequestGuardrailsToJSON(
  createAgentRequestGuardrails: CreateAgentRequestGuardrails,
): string {
  return JSON.stringify(
    CreateAgentRequestGuardrails$outboundSchema.parse(
      createAgentRequestGuardrails,
    ),
  );
}

/** @internal */
export type Settings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | GoogleSearchTool$Outbound
      | WebScraperTool$Outbound
      | CallSubAgentTool$Outbound
      | RetrieveAgentsTool$Outbound
      | QueryMemoryStoreTool$Outbound
      | WriteMemoryStoreTool$Outbound
      | RetrieveMemoryStoresTool$Outbound
      | DeleteMemoryDocumentTool$Outbound
      | RetrieveKnowledgeBasesTool$Outbound
      | QueryKnowledgeBaseTool$Outbound
      | CurrentDateTool$Outbound
      | MCPTool$Outbound
      | HTTPTool$Outbound
      | CodeExecutionTool$Outbound
      | FunctionTool$Outbound
      | JSONSchemaTool$Outbound
    >
    | undefined;
  evaluators?: Array<Evaluators$Outbound> | undefined;
  guardrails?: Array<CreateAgentRequestGuardrails$Outbound> | undefined;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$outboundSchema),
      z.lazy(() => WebScraperTool$outboundSchema),
      z.lazy(() => CallSubAgentTool$outboundSchema),
      z.lazy(() => RetrieveAgentsTool$outboundSchema),
      z.lazy(() => QueryMemoryStoreTool$outboundSchema),
      z.lazy(() => WriteMemoryStoreTool$outboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => CurrentDateTool$outboundSchema),
      z.lazy(() => MCPTool$outboundSchema),
      z.lazy(() => HTTPTool$outboundSchema),
      z.lazy(() => CodeExecutionTool$outboundSchema),
      z.lazy(() => FunctionTool$outboundSchema),
      z.lazy(() => JSONSchemaTool$outboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => Evaluators$outboundSchema)).optional(),
  guardrails: z.array(z.lazy(() => CreateAgentRequestGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}

/** @internal */
export type KnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const KnowledgeBases$outboundSchema: z.ZodType<
  KnowledgeBases$Outbound,
  z.ZodTypeDef,
  KnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function knowledgeBasesToJSON(knowledgeBases: KnowledgeBases): string {
  return JSON.stringify(KnowledgeBases$outboundSchema.parse(knowledgeBases));
}

/** @internal */
export type TeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const TeamOfAgents$outboundSchema: z.ZodType<
  TeamOfAgents$Outbound,
  z.ZodTypeDef,
  TeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function teamOfAgentsToJSON(teamOfAgents: TeamOfAgents): string {
  return JSON.stringify(TeamOfAgents$outboundSchema.parse(teamOfAgents));
}

/** @internal */
export const Source$outboundSchema: z.ZodNativeEnum<typeof Source> = z
  .nativeEnum(Source);

/** @internal */
export type CreateAgentRequestRequestBody$Outbound = {
  key: string;
  display_name?: string | undefined;
  role: string;
  description: string;
  instructions: string;
  system_prompt?: string | undefined;
  path: string;
  model: ModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<FallbackModelConfiguration2$Outbound | string>
    | undefined;
  settings: Settings$Outbound;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<KnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<TeamOfAgents$Outbound> | undefined;
  variables?: { [k: string]: any } | undefined;
  source?: string | undefined;
};

/** @internal */
export const CreateAgentRequestRequestBody$outboundSchema: z.ZodType<
  CreateAgentRequestRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestRequestBody
> = z.object({
  key: z.string(),
  displayName: z.string().optional(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  systemPrompt: z.string().optional(),
  path: z.string(),
  model: z.union([
    z.lazy(() => ModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => FallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => Settings$outboundSchema),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => KnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => TeamOfAgents$outboundSchema)).optional(),
  variables: z.record(z.any()).optional(),
  source: Source$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function createAgentRequestRequestBodyToJSON(
  createAgentRequestRequestBody: CreateAgentRequestRequestBody,
): string {
  return JSON.stringify(
    CreateAgentRequestRequestBody$outboundSchema.parse(
      createAgentRequestRequestBody,
    ),
  );
}

/** @internal */
export const CreateAgentRequestStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestStatus
> = z.nativeEnum(CreateAgentRequestStatus);

/** @internal */
export const CreateAgentRequestToolApprovalRequired$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolApprovalRequired> = z.nativeEnum(
    CreateAgentRequestToolApprovalRequired,
  );

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestTools$inboundSchema: z.ZodType<
  CreateAgentRequestTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => Conditions$inboundSchema)).optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});

export function createAgentRequestToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestTools' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsResponseExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentsResponseExecuteOn> = z
    .nativeEnum(CreateAgentRequestAgentsResponseExecuteOn);

/** @internal */
export const CreateAgentRequestEvaluators$inboundSchema: z.ZodType<
  CreateAgentRequestEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: CreateAgentRequestAgentsResponseExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function createAgentRequestEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestEvaluators' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsResponse201ExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestAgentsResponse201ExecuteOn> = z
    .nativeEnum(CreateAgentRequestAgentsResponse201ExecuteOn);

/** @internal */
export const CreateAgentRequestAgentsGuardrails$inboundSchema: z.ZodType<
  CreateAgentRequestAgentsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: CreateAgentRequestAgentsResponse201ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function createAgentRequestAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestAgentsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestAgentsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestSettings$inboundSchema: z.ZodType<
  CreateAgentRequestSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: CreateAgentRequestToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => CreateAgentRequestTools$inboundSchema))
    .optional(),
  evaluators: z.array(z.lazy(() => CreateAgentRequestEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => CreateAgentRequestAgentsGuardrails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});

export function createAgentRequestSettingsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestSettings' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestVoice
> = z.nativeEnum(CreateAgentRequestVoice);

/** @internal */
export const CreateAgentRequestFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestFormat
> = z.nativeEnum(CreateAgentRequestFormat);

/** @internal */
export const CreateAgentRequestAudio$inboundSchema: z.ZodType<
  CreateAgentRequestAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateAgentRequestVoice$inboundSchema,
  format: CreateAgentRequestFormat$inboundSchema,
});

export function createAgentRequestAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function createAgentRequestResponseFormatAgentsResponse201JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201JSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatJSONObject$inboundSchema:
  z.ZodType<CreateAgentRequestResponseFormatJSONObject, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("json_object"),
    });

export function createAgentRequestResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatText$inboundSchema: z.ZodType<
  CreateAgentRequestResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function createAgentRequestResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatText' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormat$inboundSchema: z.ZodType<
  CreateAgentRequestResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentRequestResponseFormatText$inboundSchema),
  z.lazy(() => CreateAgentRequestResponseFormatJSONObject$inboundSchema),
  z.lazy(() =>
    CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
  ),
]);

export function createAgentRequestResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestReasoningEffort
> = z.nativeEnum(CreateAgentRequestReasoningEffort);

/** @internal */
export const CreateAgentRequestStop$inboundSchema: z.ZodType<
  CreateAgentRequestStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function createAgentRequestStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestStreamOptions$inboundSchema: z.ZodType<
  CreateAgentRequestStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function createAgentRequestStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestThinking$inboundSchema: z.ZodType<
  CreateAgentRequestThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function createAgentRequestThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsType> = z.nativeEnum(
    CreateAgentRequestToolChoiceAgentsType,
  );

/** @internal */
export const CreateAgentRequestToolChoiceAgentsFunction$inboundSchema:
  z.ZodType<CreateAgentRequestToolChoiceAgentsFunction, z.ZodTypeDef, unknown> =
    z.object({
      name: z.string(),
    });

export function createAgentRequestToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgents2$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentRequestToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentRequestToolChoiceAgentsFunction$inboundSchema
  ),
});

export function createAgentRequestToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestToolChoiceAgents1
> = z.nativeEnum(CreateAgentRequestToolChoiceAgents1);

/** @internal */
export const CreateAgentRequestToolChoice$inboundSchema: z.ZodType<
  CreateAgentRequestToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentRequestToolChoiceAgents2$inboundSchema),
  CreateAgentRequestToolChoiceAgents1$inboundSchema,
]);

export function createAgentRequestToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestModalities
> = z.nativeEnum(CreateAgentRequestModalities);

/** @internal */
export const CreateAgentRequestIdAgents1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestIdAgents1
> = z.nativeEnum(CreateAgentRequestIdAgents1);

/** @internal */
export const CreateAgentRequestId$inboundSchema: z.ZodType<
  CreateAgentRequestId,
  z.ZodTypeDef,
  unknown
> = z.union([CreateAgentRequestIdAgents1$inboundSchema, z.string()]);

export function createAgentRequestIdFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestId' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn
  > = z.nativeEnum(CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn);

/** @internal */
export const CreateAgentRequestAgentsResponseGuardrails$inboundSchema:
  z.ZodType<CreateAgentRequestAgentsResponseGuardrails, z.ZodTypeDef, unknown> =
    z.object({
      id: z.union([CreateAgentRequestIdAgents1$inboundSchema, z.string()]),
      execute_on:
        CreateAgentRequestAgentsResponse201ApplicationJSONExecuteOn$inboundSchema,
    }).transform((v) => {
      return remap$(v, {
        "execute_on": "executeOn",
      });
    });

export function createAgentRequestAgentsResponseGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestAgentsResponseGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestAgentsResponseGuardrails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestAgentsResponseGuardrails' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbacks$inboundSchema: z.ZodType<
  CreateAgentRequestFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function createAgentRequestFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbacks' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestAgentsRetry$inboundSchema: z.ZodType<
  CreateAgentRequestAgentsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function createAgentRequestAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestAgentsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestAgentsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestAgentsRetry' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestType
> = z.nativeEnum(CreateAgentRequestType);

/** @internal */
export const CreateAgentRequestCache$inboundSchema: z.ZodType<
  CreateAgentRequestCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: CreateAgentRequestType$inboundSchema,
});

export function createAgentRequestCacheFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestCache' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestLoadBalancerAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestLoadBalancerAgentsType> = z
    .nativeEnum(CreateAgentRequestLoadBalancerAgentsType);

/** @internal */
export const CreateAgentRequestLoadBalancerAgents1$inboundSchema: z.ZodType<
  CreateAgentRequestLoadBalancerAgents1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentRequestLoadBalancerAgentsType$inboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createAgentRequestLoadBalancerAgents1FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestLoadBalancerAgents1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestLoadBalancerAgents1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestLoadBalancerAgents1' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestLoadBalancer$inboundSchema: z.ZodType<
  CreateAgentRequestLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => CreateAgentRequestLoadBalancerAgents1$inboundSchema);

export function createAgentRequestLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestLoadBalancer' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestTimeout$inboundSchema: z.ZodType<
  CreateAgentRequestTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function createAgentRequestTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestTimeout' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestParameters$inboundSchema: z.ZodType<
  CreateAgentRequestParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentRequestAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentRequestResponseFormatText$inboundSchema),
    z.lazy(() => CreateAgentRequestResponseFormatJSONObject$inboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201JSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: CreateAgentRequestReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateAgentRequestStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgents2$inboundSchema),
    CreateAgentRequestToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentRequestModalities$inboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => CreateAgentRequestAgentsResponseGuardrails$inboundSchema),
  ).optional(),
  fallbacks: z.array(z.lazy(() => CreateAgentRequestFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => CreateAgentRequestAgentsRetry$inboundSchema).optional(),
  cache: z.lazy(() => CreateAgentRequestCache$inboundSchema).optional(),
  load_balancer: z.array(
    z.lazy(() => CreateAgentRequestLoadBalancerAgents1$inboundSchema),
  ).optional(),
  timeout: z.lazy(() => CreateAgentRequestTimeout$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function createAgentRequestParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestRetry$inboundSchema: z.ZodType<
  CreateAgentRequestRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function createAgentRequestRetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestRetry' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationVoice> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationVoice);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationFormat> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationFormat);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: CreateAgentRequestFallbackModelConfigurationVoice$inboundSchema,
    format: CreateAgentRequestFallbackModelConfigurationFormat$inboundSchema,
  });

export function createAgentRequestFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function createAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    CreateAgentRequestResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });

export function createAgentRequestResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestResponseFormatAgentsText$inboundSchema:
  z.ZodType<CreateAgentRequestResponseFormatAgentsText, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("text"),
    });

export function createAgentRequestResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestResponseFormatAgentsText,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestResponseFormatAgentsText$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestResponseFormatAgentsText$inboundSchema),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema
    ),
    z.lazy(() =>
      CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
    ),
  ]);

export function createAgentRequestFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationReasoningEffort$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationReasoningEffort
  > = z.nativeEnum(CreateAgentRequestFallbackModelConfigurationReasoningEffort);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);

export function createAgentRequestFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });

export function createAgentRequestFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);

export function createAgentRequestFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponseType> = z
    .nativeEnum(CreateAgentRequestToolChoiceAgentsResponseType);

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });

export function createAgentRequestToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema:
  z.ZodType<
    CreateAgentRequestToolChoiceAgentsResponse2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateAgentRequestToolChoiceAgentsResponseType$inboundSchema
      .optional(),
    function: z.lazy(() =>
      CreateAgentRequestToolChoiceAgentsResponseFunction$inboundSchema
    ),
  });

export function createAgentRequestToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestToolChoiceAgentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestToolChoiceAgentsResponse1> = z
    .nativeEnum(CreateAgentRequestToolChoiceAgentsResponse1);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema),
    CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema,
  ]);

export function createAgentRequestFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationToolChoice$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationModalities
  > = z.nativeEnum(CreateAgentRequestFallbackModelConfigurationModalities);

/** @internal */
export const CreateAgentRequestIdAgentsResponse1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestIdAgentsResponse1
> = z.nativeEnum(CreateAgentRequestIdAgentsResponse1);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationId$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationId,
    z.ZodTypeDef,
    unknown
  > = z.union([CreateAgentRequestIdAgentsResponse1$inboundSchema, z.string()]);

export function createAgentRequestFallbackModelConfigurationIdFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationId' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationExecuteOn$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentRequestFallbackModelConfigurationExecuteOn
  > = z.nativeEnum(CreateAgentRequestFallbackModelConfigurationExecuteOn);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationGuardrails$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationGuardrails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.union([
      CreateAgentRequestIdAgentsResponse1$inboundSchema,
      z.string(),
    ]),
    execute_on:
      CreateAgentRequestFallbackModelConfigurationExecuteOn$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "execute_on": "executeOn",
    });
  });

export function createAgentRequestFallbackModelConfigurationGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationGuardrails$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationGuardrails' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationFallbacks$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationFallbacks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });

export function createAgentRequestFallbackModelConfigurationFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationFallbacks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationFallbacks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationFallbacks' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });

export function createAgentRequestFallbackModelConfigurationAgentsResponseRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestFallbackModelConfigurationType> = z
    .nativeEnum(CreateAgentRequestFallbackModelConfigurationType);

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationCache$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationCache,
    z.ZodTypeDef,
    unknown
  > = z.object({
    ttl: z.number().default(1800),
    type: CreateAgentRequestFallbackModelConfigurationType$inboundSchema,
  });

export function createAgentRequestFallbackModelConfigurationCacheFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationCache,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationCache$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationCache' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestLoadBalancerAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentRequestLoadBalancerAgentsResponseType> = z
    .nativeEnum(CreateAgentRequestLoadBalancerAgentsResponseType);

/** @internal */
export const CreateAgentRequestLoadBalancerAgentsResponse1$inboundSchema:
  z.ZodType<
    CreateAgentRequestLoadBalancerAgentsResponse1,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateAgentRequestLoadBalancerAgentsResponseType$inboundSchema,
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function createAgentRequestLoadBalancerAgentsResponse1FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestLoadBalancerAgentsResponse1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestLoadBalancerAgentsResponse1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestLoadBalancerAgentsResponse1' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationLoadBalancer$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationLoadBalancer,
    z.ZodTypeDef,
    unknown
  > = z.lazy(() => CreateAgentRequestLoadBalancerAgentsResponse1$inboundSchema);

export function createAgentRequestFallbackModelConfigurationLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationLoadBalancer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationLoadBalancer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationLoadBalancer' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationTimeout$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationTimeout,
    z.ZodTypeDef,
    unknown
  > = z.object({
    call_timeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "call_timeout": "callTimeout",
    });
  });

export function createAgentRequestFallbackModelConfigurationTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationTimeout,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationTimeout$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationTimeout' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationAudio$inboundSchema
      ),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => CreateAgentRequestResponseFormatAgentsText$inboundSchema),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsJSONObject$inboundSchema
      ),
      z.lazy(() =>
        CreateAgentRequestResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort:
      CreateAgentRequestFallbackModelConfigurationReasoningEffort$inboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => CreateAgentRequestToolChoiceAgentsResponse2$inboundSchema),
      CreateAgentRequestToolChoiceAgentsResponse1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        CreateAgentRequestFallbackModelConfigurationModalities$inboundSchema,
      ),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationGuardrails$inboundSchema
      ),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() =>
        CreateAgentRequestFallbackModelConfigurationFallbacks$inboundSchema
      ),
    ).optional(),
    retry: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationAgentsResponseRetry$inboundSchema
    ).optional(),
    cache: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationCache$inboundSchema
    ).optional(),
    load_balancer: z.array(
      z.lazy(() => CreateAgentRequestLoadBalancerAgentsResponse1$inboundSchema),
    ).optional(),
    timeout: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationTimeout$inboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
      "load_balancer": "loadBalancer",
    });
  });

export function createAgentRequestFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfigurationAgentsRetry$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfigurationAgentsRetry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });

export function createAgentRequestFallbackModelConfigurationAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfigurationAgentsRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfigurationAgentsRetry$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestFallbackModelConfigurationAgentsRetry' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration2$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationParameters$inboundSchema
    ).optional(),
    retry: z.lazy(() =>
      CreateAgentRequestFallbackModelConfigurationAgentsRetry$inboundSchema
    ).optional(),
  });

export function createAgentRequestFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestFallbackModelConfiguration$inboundSchema:
  z.ZodType<
    CreateAgentRequestFallbackModelConfiguration,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentRequestFallbackModelConfiguration2$inboundSchema),
    z.string(),
  ]);

export function createAgentRequestFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentRequestFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentRequestFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentRequestFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const Model$inboundSchema: z.ZodType<Model, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    integration_id: z.nullable(z.string()).optional(),
    parameters: z.lazy(() => CreateAgentRequestParameters$inboundSchema)
      .optional(),
    retry: z.lazy(() => CreateAgentRequestRetry$inboundSchema).optional(),
    fallback_models: z.nullable(
      z.array(z.union([
        z.lazy(() =>
          CreateAgentRequestFallbackModelConfiguration2$inboundSchema
        ),
        z.string(),
      ])),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "integration_id": "integrationId",
      "fallback_models": "fallbackModels",
    });
  });

export function modelFromJSON(
  jsonString: string,
): SafeParseResult<Model, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Model$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Model' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestTeamOfAgents$inboundSchema: z.ZodType<
  CreateAgentRequestTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function createAgentRequestTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const Metrics$inboundSchema: z.ZodType<Metrics, z.ZodTypeDef, unknown> =
  z.object({
    total_cost: z.number().default(0),
  }).transform((v) => {
    return remap$(v, {
      "total_cost": "totalCost",
    });
  });

export function metricsFromJSON(
  jsonString: string,
): SafeParseResult<Metrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metrics' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestKnowledgeBases$inboundSchema: z.ZodType<
  CreateAgentRequestKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});

export function createAgentRequestKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestSource$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentRequestSource
> = z.nativeEnum(CreateAgentRequestSource);

/** @internal */
export const CreateAgentRequestResponseBody$inboundSchema: z.ZodType<
  CreateAgentRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentRequestStatus$inboundSchema,
  settings: z.lazy(() => CreateAgentRequestSettings$inboundSchema).optional(),
  model: z.lazy(() => Model$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => CreateAgentRequestTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => Metrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => CreateAgentRequestKnowledgeBases$inboundSchema),
  ).optional(),
  source: CreateAgentRequestSource$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});

export function createAgentRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestResponseBody' from JSON`,
  );
}
