/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export const CreateTranslationResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export type CreateTranslationResponseFormat = ClosedEnum<
  typeof CreateTranslationResponseFormat
>;

/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export const CreateTranslationTimestampsGranularity = {
  None: "none",
  Word: "word",
  Character: "character",
} as const;
/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export type CreateTranslationTimestampsGranularity = ClosedEnum<
  typeof CreateTranslationTimestampsGranularity
>;

export type CreateTranslationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateTranslationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateTranslationLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateTranslationLoadBalancerType = ClosedEnum<
  typeof CreateTranslationLoadBalancerType
>;

export type CreateTranslationLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateTranslationLoadBalancer1 = {
  type: CreateTranslationLoadBalancerType;
  models: Array<CreateTranslationLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type CreateTranslationLoadBalancer = CreateTranslationLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateTranslationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateTranslationRouterAudioTranslationsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateTranslationRouterAudioTranslationsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const CreateTranslationLoadBalancerRouterAudioTranslationsType = {
  WeightBased: "weight_based",
} as const;
export type CreateTranslationLoadBalancerRouterAudioTranslationsType =
  ClosedEnum<typeof CreateTranslationLoadBalancerRouterAudioTranslationsType>;

export type CreateTranslationLoadBalancerRouterAudioTranslationsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateTranslationLoadBalancerRouterAudioTranslations1 = {
  type: CreateTranslationLoadBalancerRouterAudioTranslationsType;
  models: Array<CreateTranslationLoadBalancerRouterAudioTranslationsModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateTranslationRouterAudioTranslationsLoadBalancer =
  CreateTranslationLoadBalancerRouterAudioTranslations1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateTranslationRouterAudioTranslationsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateTranslationOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?:
    | Array<CreateTranslationRouterAudioTranslationsFallbacks>
    | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateTranslationRouterAudioTranslationsRetry | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: components.PublicContact | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?:
    | CreateTranslationLoadBalancerRouterAudioTranslations1
    | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateTranslationRouterAudioTranslationsTimeout | undefined;
};

export type CreateTranslationFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Translates audio into English.
 */
export type CreateTranslationRequestBody = {
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
   */
  prompt?: string | undefined;
  /**
   * When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
   */
  enableLogging?: boolean | undefined;
  /**
   * Whether to annotate which speaker is currently talking in the uploaded file.
   */
  diarize?: boolean | undefined;
  /**
   * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
   */
  responseFormat?: CreateTranslationResponseFormat | undefined;
  /**
   * Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
   */
  tagAudioEvents?: boolean | undefined;
  /**
   * The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
   */
  numSpeakers?: number | undefined;
  /**
   * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
   */
  timestampsGranularity?: CreateTranslationTimestampsGranularity | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number | undefined;
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateTranslationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateTranslationRetry | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: CreateTranslationLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateTranslationTimeout | undefined;
  orq?: CreateTranslationOrq | undefined;
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file?: CreateTranslationFile | Blob | undefined;
};

export type ResponseBodyWords = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

export type ResponseBodySegments = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avgLogprob: number;
  compressionRatio: number;
  noSpeechProb: number;
};

export type CreateTranslationResponseBody2 = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<ResponseBodyWords> | undefined;
  segments?: Array<ResponseBodySegments> | undefined;
};

export type CreateTranslationResponseBody1 = {
  text: string;
};

/**
 * Returns the translated text
 */
export type CreateTranslationResponseBody =
  | CreateTranslationResponseBody1
  | CreateTranslationResponseBody2
  | string;

/** @internal */
export const CreateTranslationResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranslationResponseFormat
> = z.nativeEnum(CreateTranslationResponseFormat);

/** @internal */
export const CreateTranslationTimestampsGranularity$outboundSchema:
  z.ZodNativeEnum<typeof CreateTranslationTimestampsGranularity> = z.nativeEnum(
    CreateTranslationTimestampsGranularity,
  );

/** @internal */
export type CreateTranslationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateTranslationFallbacks$outboundSchema: z.ZodType<
  CreateTranslationFallbacks$Outbound,
  z.ZodTypeDef,
  CreateTranslationFallbacks
> = z.object({
  model: z.string(),
});

export function createTranslationFallbacksToJSON(
  createTranslationFallbacks: CreateTranslationFallbacks,
): string {
  return JSON.stringify(
    CreateTranslationFallbacks$outboundSchema.parse(createTranslationFallbacks),
  );
}

/** @internal */
export type CreateTranslationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateTranslationRetry$outboundSchema: z.ZodType<
  CreateTranslationRetry$Outbound,
  z.ZodTypeDef,
  CreateTranslationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createTranslationRetryToJSON(
  createTranslationRetry: CreateTranslationRetry,
): string {
  return JSON.stringify(
    CreateTranslationRetry$outboundSchema.parse(createTranslationRetry),
  );
}

/** @internal */
export const CreateTranslationLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranslationLoadBalancerType
> = z.nativeEnum(CreateTranslationLoadBalancerType);

/** @internal */
export type CreateTranslationLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateTranslationLoadBalancerModels$outboundSchema: z.ZodType<
  CreateTranslationLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateTranslationLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createTranslationLoadBalancerModelsToJSON(
  createTranslationLoadBalancerModels: CreateTranslationLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancerModels$outboundSchema.parse(
      createTranslationLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateTranslationLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateTranslationLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateTranslationLoadBalancer1$outboundSchema: z.ZodType<
  CreateTranslationLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateTranslationLoadBalancer1
> = z.object({
  type: CreateTranslationLoadBalancerType$outboundSchema,
  models: z.array(
    z.lazy(() => CreateTranslationLoadBalancerModels$outboundSchema),
  ),
});

export function createTranslationLoadBalancer1ToJSON(
  createTranslationLoadBalancer1: CreateTranslationLoadBalancer1,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancer1$outboundSchema.parse(
      createTranslationLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateTranslationLoadBalancer$Outbound =
  CreateTranslationLoadBalancer1$Outbound;

/** @internal */
export const CreateTranslationLoadBalancer$outboundSchema: z.ZodType<
  CreateTranslationLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateTranslationLoadBalancer
> = z.lazy(() => CreateTranslationLoadBalancer1$outboundSchema);

export function createTranslationLoadBalancerToJSON(
  createTranslationLoadBalancer: CreateTranslationLoadBalancer,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancer$outboundSchema.parse(
      createTranslationLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateTranslationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateTranslationTimeout$outboundSchema: z.ZodType<
  CreateTranslationTimeout$Outbound,
  z.ZodTypeDef,
  CreateTranslationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createTranslationTimeoutToJSON(
  createTranslationTimeout: CreateTranslationTimeout,
): string {
  return JSON.stringify(
    CreateTranslationTimeout$outboundSchema.parse(createTranslationTimeout),
  );
}

/** @internal */
export type CreateTranslationRouterAudioTranslationsFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateTranslationRouterAudioTranslationsFallbacks$outboundSchema:
  z.ZodType<
    CreateTranslationRouterAudioTranslationsFallbacks$Outbound,
    z.ZodTypeDef,
    CreateTranslationRouterAudioTranslationsFallbacks
  > = z.object({
    model: z.string(),
  });

export function createTranslationRouterAudioTranslationsFallbacksToJSON(
  createTranslationRouterAudioTranslationsFallbacks:
    CreateTranslationRouterAudioTranslationsFallbacks,
): string {
  return JSON.stringify(
    CreateTranslationRouterAudioTranslationsFallbacks$outboundSchema.parse(
      createTranslationRouterAudioTranslationsFallbacks,
    ),
  );
}

/** @internal */
export type CreateTranslationRouterAudioTranslationsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateTranslationRouterAudioTranslationsRetry$outboundSchema:
  z.ZodType<
    CreateTranslationRouterAudioTranslationsRetry$Outbound,
    z.ZodTypeDef,
    CreateTranslationRouterAudioTranslationsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function createTranslationRouterAudioTranslationsRetryToJSON(
  createTranslationRouterAudioTranslationsRetry:
    CreateTranslationRouterAudioTranslationsRetry,
): string {
  return JSON.stringify(
    CreateTranslationRouterAudioTranslationsRetry$outboundSchema.parse(
      createTranslationRouterAudioTranslationsRetry,
    ),
  );
}

/** @internal */
export const CreateTranslationLoadBalancerRouterAudioTranslationsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateTranslationLoadBalancerRouterAudioTranslationsType
  > = z.nativeEnum(CreateTranslationLoadBalancerRouterAudioTranslationsType);

/** @internal */
export type CreateTranslationLoadBalancerRouterAudioTranslationsModels$Outbound =
  {
    model: string;
    weight: number;
  };

/** @internal */
export const CreateTranslationLoadBalancerRouterAudioTranslationsModels$outboundSchema:
  z.ZodType<
    CreateTranslationLoadBalancerRouterAudioTranslationsModels$Outbound,
    z.ZodTypeDef,
    CreateTranslationLoadBalancerRouterAudioTranslationsModels
  > = z.object({
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function createTranslationLoadBalancerRouterAudioTranslationsModelsToJSON(
  createTranslationLoadBalancerRouterAudioTranslationsModels:
    CreateTranslationLoadBalancerRouterAudioTranslationsModels,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancerRouterAudioTranslationsModels$outboundSchema
      .parse(createTranslationLoadBalancerRouterAudioTranslationsModels),
  );
}

/** @internal */
export type CreateTranslationLoadBalancerRouterAudioTranslations1$Outbound = {
  type: string;
  models: Array<
    CreateTranslationLoadBalancerRouterAudioTranslationsModels$Outbound
  >;
};

/** @internal */
export const CreateTranslationLoadBalancerRouterAudioTranslations1$outboundSchema:
  z.ZodType<
    CreateTranslationLoadBalancerRouterAudioTranslations1$Outbound,
    z.ZodTypeDef,
    CreateTranslationLoadBalancerRouterAudioTranslations1
  > = z.object({
    type:
      CreateTranslationLoadBalancerRouterAudioTranslationsType$outboundSchema,
    models: z.array(
      z.lazy(() =>
        CreateTranslationLoadBalancerRouterAudioTranslationsModels$outboundSchema
      ),
    ),
  });

export function createTranslationLoadBalancerRouterAudioTranslations1ToJSON(
  createTranslationLoadBalancerRouterAudioTranslations1:
    CreateTranslationLoadBalancerRouterAudioTranslations1,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancerRouterAudioTranslations1$outboundSchema.parse(
      createTranslationLoadBalancerRouterAudioTranslations1,
    ),
  );
}

/** @internal */
export type CreateTranslationRouterAudioTranslationsLoadBalancer$Outbound =
  CreateTranslationLoadBalancerRouterAudioTranslations1$Outbound;

/** @internal */
export const CreateTranslationRouterAudioTranslationsLoadBalancer$outboundSchema:
  z.ZodType<
    CreateTranslationRouterAudioTranslationsLoadBalancer$Outbound,
    z.ZodTypeDef,
    CreateTranslationRouterAudioTranslationsLoadBalancer
  > = z.lazy(() =>
    CreateTranslationLoadBalancerRouterAudioTranslations1$outboundSchema
  );

export function createTranslationRouterAudioTranslationsLoadBalancerToJSON(
  createTranslationRouterAudioTranslationsLoadBalancer:
    CreateTranslationRouterAudioTranslationsLoadBalancer,
): string {
  return JSON.stringify(
    CreateTranslationRouterAudioTranslationsLoadBalancer$outboundSchema.parse(
      createTranslationRouterAudioTranslationsLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateTranslationRouterAudioTranslationsTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateTranslationRouterAudioTranslationsTimeout$outboundSchema:
  z.ZodType<
    CreateTranslationRouterAudioTranslationsTimeout$Outbound,
    z.ZodTypeDef,
    CreateTranslationRouterAudioTranslationsTimeout
  > = z.object({
    callTimeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      callTimeout: "call_timeout",
    });
  });

export function createTranslationRouterAudioTranslationsTimeoutToJSON(
  createTranslationRouterAudioTranslationsTimeout:
    CreateTranslationRouterAudioTranslationsTimeout,
): string {
  return JSON.stringify(
    CreateTranslationRouterAudioTranslationsTimeout$outboundSchema.parse(
      createTranslationRouterAudioTranslationsTimeout,
    ),
  );
}

/** @internal */
export type CreateTranslationOrq$Outbound = {
  name?: string | undefined;
  fallbacks?:
    | Array<CreateTranslationRouterAudioTranslationsFallbacks$Outbound>
    | undefined;
  retry?: CreateTranslationRouterAudioTranslationsRetry$Outbound | undefined;
  identity?: components.PublicIdentity$Outbound | undefined;
  contact?: components.PublicContact$Outbound | undefined;
  load_balancer?:
    | CreateTranslationLoadBalancerRouterAudioTranslations1$Outbound
    | undefined;
  timeout?:
    | CreateTranslationRouterAudioTranslationsTimeout$Outbound
    | undefined;
};

/** @internal */
export const CreateTranslationOrq$outboundSchema: z.ZodType<
  CreateTranslationOrq$Outbound,
  z.ZodTypeDef,
  CreateTranslationOrq
> = z.object({
  name: z.string().optional(),
  fallbacks: z.array(
    z.lazy(() =>
      CreateTranslationRouterAudioTranslationsFallbacks$outboundSchema
    ),
  ).optional(),
  retry: z.lazy(() =>
    CreateTranslationRouterAudioTranslationsRetry$outboundSchema
  ).optional(),
  identity: components.PublicIdentity$outboundSchema.optional(),
  contact: components.PublicContact$outboundSchema.optional(),
  loadBalancer: z.lazy(() =>
    CreateTranslationLoadBalancerRouterAudioTranslations1$outboundSchema
  ).optional(),
  timeout: z.lazy(() =>
    CreateTranslationRouterAudioTranslationsTimeout$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createTranslationOrqToJSON(
  createTranslationOrq: CreateTranslationOrq,
): string {
  return JSON.stringify(
    CreateTranslationOrq$outboundSchema.parse(createTranslationOrq),
  );
}

/** @internal */
export type CreateTranslationFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const CreateTranslationFile$outboundSchema: z.ZodType<
  CreateTranslationFile$Outbound,
  z.ZodTypeDef,
  CreateTranslationFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

export function createTranslationFileToJSON(
  createTranslationFile: CreateTranslationFile,
): string {
  return JSON.stringify(
    CreateTranslationFile$outboundSchema.parse(createTranslationFile),
  );
}

/** @internal */
export type CreateTranslationRequestBody$Outbound = {
  model: string;
  prompt?: string | undefined;
  enable_logging: boolean;
  diarize: boolean;
  response_format?: string | undefined;
  tag_audio_events: boolean;
  num_speakers?: number | undefined;
  timestamps_granularity: string;
  temperature?: number | undefined;
  name?: string | undefined;
  fallbacks?: Array<CreateTranslationFallbacks$Outbound> | undefined;
  retry?: CreateTranslationRetry$Outbound | undefined;
  load_balancer?: CreateTranslationLoadBalancer1$Outbound | undefined;
  timeout?: CreateTranslationTimeout$Outbound | undefined;
  orq?: CreateTranslationOrq$Outbound | undefined;
  file?: CreateTranslationFile$Outbound | Blob | undefined;
};

/** @internal */
export const CreateTranslationRequestBody$outboundSchema: z.ZodType<
  CreateTranslationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateTranslationRequestBody
> = z.object({
  model: z.string(),
  prompt: z.string().optional(),
  enableLogging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  responseFormat: CreateTranslationResponseFormat$outboundSchema.optional(),
  tagAudioEvents: z.boolean().default(true),
  numSpeakers: z.number().optional(),
  timestampsGranularity: CreateTranslationTimestampsGranularity$outboundSchema
    .default("word"),
  temperature: z.number().optional(),
  name: z.string().optional(),
  fallbacks: z.array(z.lazy(() => CreateTranslationFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => CreateTranslationRetry$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateTranslationLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateTranslationTimeout$outboundSchema).optional(),
  orq: z.lazy(() => CreateTranslationOrq$outboundSchema).optional(),
  file: z.lazy(() => CreateTranslationFile$outboundSchema).or(blobLikeSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    enableLogging: "enable_logging",
    responseFormat: "response_format",
    tagAudioEvents: "tag_audio_events",
    numSpeakers: "num_speakers",
    timestampsGranularity: "timestamps_granularity",
    loadBalancer: "load_balancer",
  });
});

export function createTranslationRequestBodyToJSON(
  createTranslationRequestBody: CreateTranslationRequestBody,
): string {
  return JSON.stringify(
    CreateTranslationRequestBody$outboundSchema.parse(
      createTranslationRequestBody,
    ),
  );
}

/** @internal */
export const ResponseBodyWords$inboundSchema: z.ZodType<
  ResponseBodyWords,
  z.ZodTypeDef,
  unknown
> = z.object({
  word: z.string().optional(),
  start: z.number().optional(),
  end: z.number().optional(),
});

export function responseBodyWordsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyWords, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyWords$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyWords' from JSON`,
  );
}

/** @internal */
export const ResponseBodySegments$inboundSchema: z.ZodType<
  ResponseBodySegments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avg_logprob: z.number(),
  compression_ratio: z.number(),
  no_speech_prob: z.number(),
}).transform((v) => {
  return remap$(v, {
    "avg_logprob": "avgLogprob",
    "compression_ratio": "compressionRatio",
    "no_speech_prob": "noSpeechProb",
  });
});

export function responseBodySegmentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySegments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySegments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySegments' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody2$inboundSchema: z.ZodType<
  CreateTranslationResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => ResponseBodyWords$inboundSchema)).optional(),
  segments: z.array(z.lazy(() => ResponseBodySegments$inboundSchema))
    .optional(),
});

export function createTranslationResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody2' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody1$inboundSchema: z.ZodType<
  CreateTranslationResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
});

export function createTranslationResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody$inboundSchema: z.ZodType<
  CreateTranslationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateTranslationResponseBody1$inboundSchema),
  z.lazy(() => CreateTranslationResponseBody2$inboundSchema),
  z.string(),
]);

export function createTranslationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody' from JSON`,
  );
}
