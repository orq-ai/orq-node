/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export const CreateTranslationResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export type CreateTranslationResponseFormat = ClosedEnum<
  typeof CreateTranslationResponseFormat
>;

/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export const CreateTranslationTimestampsGranularity = {
  None: "none",
  Word: "word",
  Character: "character",
} as const;
/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export type CreateTranslationTimestampsGranularity = ClosedEnum<
  typeof CreateTranslationTimestampsGranularity
>;

export type CreateTranslationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type CreateTranslationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateTranslationContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

export const CreateTranslationLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateTranslationLoadBalancerType = ClosedEnum<
  typeof CreateTranslationLoadBalancerType
>;

export type CreateTranslationLoadBalancer1 = {
  type: CreateTranslationLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateTranslationLoadBalancer = CreateTranslationLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateTranslationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateTranslationOrq = {
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateTranslationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateTranslationRetry | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateTranslationContact | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateTranslationLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateTranslationTimeout | undefined;
};

export type CreateTranslationFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Translates audio into English.
 */
export type CreateTranslationRequestBody = {
  /**
   * ID of the model to use
   */
  model: string;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
   */
  prompt?: string | undefined;
  /**
   * When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
   */
  enableLogging?: boolean | undefined;
  /**
   * Whether to annotate which speaker is currently talking in the uploaded file.
   */
  diarize?: boolean | undefined;
  /**
   * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
   */
  responseFormat?: CreateTranslationResponseFormat | undefined;
  /**
   * Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
   */
  tagAudioEvents?: boolean | undefined;
  /**
   * The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
   */
  numSpeakers?: number | undefined;
  /**
   * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
   */
  timestampsGranularity?: CreateTranslationTimestampsGranularity | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number | undefined;
  orq?: CreateTranslationOrq | undefined;
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file?: CreateTranslationFile | Blob | undefined;
};

export type ResponseBodyWords = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

export type ResponseBodySegments = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avgLogprob: number;
  compressionRatio: number;
  noSpeechProb: number;
};

export type CreateTranslationResponseBody2 = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<ResponseBodyWords> | undefined;
  segments?: Array<ResponseBodySegments> | undefined;
};

export type CreateTranslationResponseBody1 = {
  text: string;
};

/**
 * Returns the translated text
 */
export type CreateTranslationResponseBody =
  | CreateTranslationResponseBody1
  | CreateTranslationResponseBody2
  | string;

/** @internal */
export const CreateTranslationResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranslationResponseFormat
> = z.nativeEnum(CreateTranslationResponseFormat);

/** @internal */
export const CreateTranslationTimestampsGranularity$outboundSchema:
  z.ZodNativeEnum<typeof CreateTranslationTimestampsGranularity> = z.nativeEnum(
    CreateTranslationTimestampsGranularity,
  );

/** @internal */
export type CreateTranslationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateTranslationFallbacks$outboundSchema: z.ZodType<
  CreateTranslationFallbacks$Outbound,
  z.ZodTypeDef,
  CreateTranslationFallbacks
> = z.object({
  model: z.string(),
});

export function createTranslationFallbacksToJSON(
  createTranslationFallbacks: CreateTranslationFallbacks,
): string {
  return JSON.stringify(
    CreateTranslationFallbacks$outboundSchema.parse(createTranslationFallbacks),
  );
}

/** @internal */
export type CreateTranslationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateTranslationRetry$outboundSchema: z.ZodType<
  CreateTranslationRetry$Outbound,
  z.ZodTypeDef,
  CreateTranslationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createTranslationRetryToJSON(
  createTranslationRetry: CreateTranslationRetry,
): string {
  return JSON.stringify(
    CreateTranslationRetry$outboundSchema.parse(createTranslationRetry),
  );
}

/** @internal */
export type CreateTranslationContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateTranslationContact$outboundSchema: z.ZodType<
  CreateTranslationContact$Outbound,
  z.ZodTypeDef,
  CreateTranslationContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createTranslationContactToJSON(
  createTranslationContact: CreateTranslationContact,
): string {
  return JSON.stringify(
    CreateTranslationContact$outboundSchema.parse(createTranslationContact),
  );
}

/** @internal */
export const CreateTranslationLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranslationLoadBalancerType
> = z.nativeEnum(CreateTranslationLoadBalancerType);

/** @internal */
export type CreateTranslationLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const CreateTranslationLoadBalancer1$outboundSchema: z.ZodType<
  CreateTranslationLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateTranslationLoadBalancer1
> = z.object({
  type: CreateTranslationLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createTranslationLoadBalancer1ToJSON(
  createTranslationLoadBalancer1: CreateTranslationLoadBalancer1,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancer1$outboundSchema.parse(
      createTranslationLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateTranslationLoadBalancer$Outbound =
  CreateTranslationLoadBalancer1$Outbound;

/** @internal */
export const CreateTranslationLoadBalancer$outboundSchema: z.ZodType<
  CreateTranslationLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateTranslationLoadBalancer
> = z.lazy(() => CreateTranslationLoadBalancer1$outboundSchema);

export function createTranslationLoadBalancerToJSON(
  createTranslationLoadBalancer: CreateTranslationLoadBalancer,
): string {
  return JSON.stringify(
    CreateTranslationLoadBalancer$outboundSchema.parse(
      createTranslationLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateTranslationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateTranslationTimeout$outboundSchema: z.ZodType<
  CreateTranslationTimeout$Outbound,
  z.ZodTypeDef,
  CreateTranslationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createTranslationTimeoutToJSON(
  createTranslationTimeout: CreateTranslationTimeout,
): string {
  return JSON.stringify(
    CreateTranslationTimeout$outboundSchema.parse(createTranslationTimeout),
  );
}

/** @internal */
export type CreateTranslationOrq$Outbound = {
  fallbacks?: Array<CreateTranslationFallbacks$Outbound> | undefined;
  retry?: CreateTranslationRetry$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateTranslationContact$Outbound | undefined;
  load_balancer?: Array<CreateTranslationLoadBalancer1$Outbound> | undefined;
  timeout?: CreateTranslationTimeout$Outbound | undefined;
};

/** @internal */
export const CreateTranslationOrq$outboundSchema: z.ZodType<
  CreateTranslationOrq$Outbound,
  z.ZodTypeDef,
  CreateTranslationOrq
> = z.object({
  fallbacks: z.array(z.lazy(() => CreateTranslationFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => CreateTranslationRetry$outboundSchema).optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateTranslationContact$outboundSchema).optional(),
  loadBalancer: z.array(
    z.lazy(() => CreateTranslationLoadBalancer1$outboundSchema),
  ).optional(),
  timeout: z.lazy(() => CreateTranslationTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createTranslationOrqToJSON(
  createTranslationOrq: CreateTranslationOrq,
): string {
  return JSON.stringify(
    CreateTranslationOrq$outboundSchema.parse(createTranslationOrq),
  );
}

/** @internal */
export type CreateTranslationFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const CreateTranslationFile$outboundSchema: z.ZodType<
  CreateTranslationFile$Outbound,
  z.ZodTypeDef,
  CreateTranslationFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

export function createTranslationFileToJSON(
  createTranslationFile: CreateTranslationFile,
): string {
  return JSON.stringify(
    CreateTranslationFile$outboundSchema.parse(createTranslationFile),
  );
}

/** @internal */
export type CreateTranslationRequestBody$Outbound = {
  model: string;
  prompt?: string | undefined;
  enable_logging: boolean;
  diarize: boolean;
  response_format?: string | undefined;
  tag_audio_events: boolean;
  num_speakers?: number | undefined;
  timestamps_granularity: string;
  temperature?: number | undefined;
  orq?: CreateTranslationOrq$Outbound | undefined;
  file?: CreateTranslationFile$Outbound | Blob | undefined;
};

/** @internal */
export const CreateTranslationRequestBody$outboundSchema: z.ZodType<
  CreateTranslationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateTranslationRequestBody
> = z.object({
  model: z.string(),
  prompt: z.string().optional(),
  enableLogging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  responseFormat: CreateTranslationResponseFormat$outboundSchema.optional(),
  tagAudioEvents: z.boolean().default(true),
  numSpeakers: z.number().optional(),
  timestampsGranularity: CreateTranslationTimestampsGranularity$outboundSchema
    .default("word"),
  temperature: z.number().optional(),
  orq: z.lazy(() => CreateTranslationOrq$outboundSchema).optional(),
  file: z.lazy(() => CreateTranslationFile$outboundSchema).or(blobLikeSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    enableLogging: "enable_logging",
    responseFormat: "response_format",
    tagAudioEvents: "tag_audio_events",
    numSpeakers: "num_speakers",
    timestampsGranularity: "timestamps_granularity",
  });
});

export function createTranslationRequestBodyToJSON(
  createTranslationRequestBody: CreateTranslationRequestBody,
): string {
  return JSON.stringify(
    CreateTranslationRequestBody$outboundSchema.parse(
      createTranslationRequestBody,
    ),
  );
}

/** @internal */
export const ResponseBodyWords$inboundSchema: z.ZodType<
  ResponseBodyWords,
  z.ZodTypeDef,
  unknown
> = z.object({
  word: z.string().optional(),
  start: z.number().optional(),
  end: z.number().optional(),
});

export function responseBodyWordsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyWords, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyWords$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyWords' from JSON`,
  );
}

/** @internal */
export const ResponseBodySegments$inboundSchema: z.ZodType<
  ResponseBodySegments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avg_logprob: z.number(),
  compression_ratio: z.number(),
  no_speech_prob: z.number(),
}).transform((v) => {
  return remap$(v, {
    "avg_logprob": "avgLogprob",
    "compression_ratio": "compressionRatio",
    "no_speech_prob": "noSpeechProb",
  });
});

export function responseBodySegmentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySegments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySegments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySegments' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody2$inboundSchema: z.ZodType<
  CreateTranslationResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => ResponseBodyWords$inboundSchema)).optional(),
  segments: z.array(z.lazy(() => ResponseBodySegments$inboundSchema))
    .optional(),
});

export function createTranslationResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody2' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody1$inboundSchema: z.ZodType<
  CreateTranslationResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
});

export function createTranslationResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody1' from JSON`,
  );
}

/** @internal */
export const CreateTranslationResponseBody$inboundSchema: z.ZodType<
  CreateTranslationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateTranslationResponseBody1$inboundSchema),
  z.lazy(() => CreateTranslationResponseBody2$inboundSchema),
  z.string(),
]);

export function createTranslationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateTranslationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranslationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranslationResponseBody' from JSON`,
  );
}
