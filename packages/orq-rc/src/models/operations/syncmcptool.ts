/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type SyncMcpToolRequest = {
  /**
   * The ID of the MCP tool to sync
   */
  toolId: string;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType>;

/**
 * The type must be "object"
 */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type SyncMcpToolResponseBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const SyncMcpToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type SyncMcpToolResponseBodyLanguage = ClosedEnum<
  typeof SyncMcpToolResponseBodyLanguage
>;

export type SyncMcpToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: SyncMcpToolResponseBodyToolsParameters | undefined;
  language: SyncMcpToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type SyncMcpToolResponseBodyToolsResponseSyncResult = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

export type SyncMcpToolResponseBody5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?:
    | SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus
    | undefined;
  versionHash?: string | undefined;
  type: SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: SyncMcpToolResponseBodyCodeTool;
  syncResult: SyncMcpToolResponseBodyToolsResponseSyncResult;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const SyncMcpToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type SyncMcpToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsResponse200Status
>;

export const SyncMcpToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type SyncMcpToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsResponse200Type
>;

export type SyncMcpToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type
  >;

export type SyncMcpToolResponseBodyToolsSchema = {
  type: SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type SyncMcpToolResponseBodyTools = {
  name: string;
  description?: string | undefined;
  schema: SyncMcpToolResponseBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const SyncMcpToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type SyncMcpToolResponseBodyConnectionType = ClosedEnum<
  typeof SyncMcpToolResponseBodyConnectionType
>;

export type SyncMcpToolResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: SyncMcpToolResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<SyncMcpToolResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: SyncMcpToolResponseBodyConnectionType;
};

export type SyncMcpToolResponseBodyToolsSyncResult = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

export type SyncMcpToolResponseBody4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: SyncMcpToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: SyncMcpToolResponseBodyToolsResponse200Type;
  mcp: SyncMcpToolResponseBodyMcp;
  syncResult: SyncMcpToolResponseBodyToolsSyncResult;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const SyncMcpToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type SyncMcpToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsResponseStatus
>;

export const SyncMcpToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type SyncMcpToolResponseBodyToolsResponseType = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const SyncMcpToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type SyncMcpToolResponseBodyMethod = ClosedEnum<
  typeof SyncMcpToolResponseBodyMethod
>;

export type SyncMcpToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type SyncMcpToolResponseBodyToolsHeaders = SyncMcpToolHeaders2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type SyncMcpToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: SyncMcpToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: SyncMcpToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type
  >;

/**
 * The default value of the argument.
 */
export type SyncMcpToolResponseBodyDefaultValue = string | number | boolean;

export type SyncMcpToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type SyncMcpToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: SyncMcpToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: SyncMcpToolResponseBodyArguments } | undefined;
};

export type SyncMcpToolResponseBodySyncResult = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

export type SyncMcpToolResponseBody3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: SyncMcpToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: SyncMcpToolResponseBodyToolsResponseType;
  http: SyncMcpToolResponseBodyHttp;
  syncResult: SyncMcpToolResponseBodySyncResult;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const SyncMcpToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type SyncMcpToolResponseBodyToolsStatus = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsStatus
>;

export const SyncMcpToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type SyncMcpToolResponseBodyToolsType = ClosedEnum<
  typeof SyncMcpToolResponseBodyToolsType
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type SyncMcpToolResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type SyncMcpToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: SyncMcpToolResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

export type ResponseBodySyncResult = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

export type SyncMcpToolResponseBody2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: SyncMcpToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: SyncMcpToolResponseBodyToolsType;
  jsonSchema: SyncMcpToolResponseBodyJsonSchema;
  syncResult: ResponseBodySyncResult;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const SyncMcpToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type SyncMcpToolResponseBodyStatus = ClosedEnum<
  typeof SyncMcpToolResponseBodyStatus
>;

export const SyncMcpToolResponseBodyType = {
  Function: "function",
} as const;
export type SyncMcpToolResponseBodyType = ClosedEnum<
  typeof SyncMcpToolResponseBodyType
>;

/**
 * The type must be "object"
 */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type SyncMcpToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type SyncMcpToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: SyncMcpToolResponseBodyParameters | undefined;
};

export type SyncResult = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

export type SyncMcpToolResponseBody1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: SyncMcpToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: SyncMcpToolResponseBodyType;
  function: SyncMcpToolResponseBodyFunction;
  syncResult: SyncResult;
};

/**
 * Successfully synced MCP tool.
 */
export type SyncMcpToolResponseBody =
  | SyncMcpToolResponseBody1
  | SyncMcpToolResponseBody2
  | SyncMcpToolResponseBody3
  | SyncMcpToolResponseBody4
  | SyncMcpToolResponseBody5;

/** @internal */
export const SyncMcpToolRequest$inboundSchema: z.ZodType<
  SyncMcpToolRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tool_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
  });
});
/** @internal */
export type SyncMcpToolRequest$Outbound = {
  tool_id: string;
};

/** @internal */
export const SyncMcpToolRequest$outboundSchema: z.ZodType<
  SyncMcpToolRequest$Outbound,
  z.ZodTypeDef,
  SyncMcpToolRequest
> = z.object({
  toolId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
  });
});

export function syncMcpToolRequestToJSON(
  syncMcpToolRequest: SyncMcpToolRequest,
): string {
  return JSON.stringify(
    SyncMcpToolRequest$outboundSchema.parse(syncMcpToolRequest),
  );
}
export function syncMcpToolRequestFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolRequest' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus,
  );
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus
  > =
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType
  > = SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type
  > = SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsParameters$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type SyncMcpToolResponseBodyToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const SyncMcpToolResponseBodyToolsParameters$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsParameters$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyToolsParameters
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function syncMcpToolResponseBodyToolsParametersToJSON(
  syncMcpToolResponseBodyToolsParameters:
    SyncMcpToolResponseBodyToolsParameters,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyToolsParameters$outboundSchema.parse(
      syncMcpToolResponseBodyToolsParameters,
    ),
  );
}
export function syncMcpToolResponseBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyToolsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyToolsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyLanguage
> = z.nativeEnum(SyncMcpToolResponseBodyLanguage);
/** @internal */
export const SyncMcpToolResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyLanguage
> = SyncMcpToolResponseBodyLanguage$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => SyncMcpToolResponseBodyToolsParameters$inboundSchema)
    .optional(),
  language: SyncMcpToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type SyncMcpToolResponseBodyCodeTool$Outbound = {
  parameters?: SyncMcpToolResponseBodyToolsParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const SyncMcpToolResponseBodyCodeTool$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyCodeTool
> = z.object({
  parameters: z.lazy(() =>
    SyncMcpToolResponseBodyToolsParameters$outboundSchema
  ).optional(),
  language: SyncMcpToolResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function syncMcpToolResponseBodyCodeToolToJSON(
  syncMcpToolResponseBodyCodeTool: SyncMcpToolResponseBodyCodeTool,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyCodeTool$outboundSchema.parse(
      syncMcpToolResponseBodyCodeTool,
    ),
  );
}
export function syncMcpToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponseSyncResult$inboundSchema:
  z.ZodType<
    SyncMcpToolResponseBodyToolsResponseSyncResult,
    z.ZodTypeDef,
    unknown
  > = z.object({
    toolsTotal: z.number(),
    toolsAdded: z.number(),
    toolsRemoved: z.number(),
    errors: z.array(z.string()),
  });
/** @internal */
export type SyncMcpToolResponseBodyToolsResponseSyncResult$Outbound = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

/** @internal */
export const SyncMcpToolResponseBodyToolsResponseSyncResult$outboundSchema:
  z.ZodType<
    SyncMcpToolResponseBodyToolsResponseSyncResult$Outbound,
    z.ZodTypeDef,
    SyncMcpToolResponseBodyToolsResponseSyncResult
  > = z.object({
    toolsTotal: z.number(),
    toolsAdded: z.number(),
    toolsRemoved: z.number(),
    errors: z.array(z.string()),
  });

export function syncMcpToolResponseBodyToolsResponseSyncResultToJSON(
  syncMcpToolResponseBodyToolsResponseSyncResult:
    SyncMcpToolResponseBodyToolsResponseSyncResult,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyToolsResponseSyncResult$outboundSchema.parse(
      syncMcpToolResponseBodyToolsResponseSyncResult,
    ),
  );
}
export function syncMcpToolResponseBodyToolsResponseSyncResultFromJSON(
  jsonString: string,
): SafeParseResult<
  SyncMcpToolResponseBodyToolsResponseSyncResult,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyToolsResponseSyncResult$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'SyncMcpToolResponseBodyToolsResponseSyncResult' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody5$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1CXJJEW253GFC72GSPBA98"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => SyncMcpToolResponseBodyCodeTool$inboundSchema),
  syncResult: z.lazy(() =>
    SyncMcpToolResponseBodyToolsResponseSyncResult$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type SyncMcpToolResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: SyncMcpToolResponseBodyCodeTool$Outbound;
  syncResult: SyncMcpToolResponseBodyToolsResponseSyncResult$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBody5$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody5$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody5
> = z.object({
  id: z.string().default("tool_01KA1CXJJEW253GFC72GSPBA98"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema
      .default("live"),
  versionHash: z.string().optional(),
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => SyncMcpToolResponseBodyCodeTool$outboundSchema),
  syncResult: z.lazy(() =>
    SyncMcpToolResponseBodyToolsResponseSyncResult$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function syncMcpToolResponseBody5ToJSON(
  syncMcpToolResponseBody5: SyncMcpToolResponseBody5,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody5$outboundSchema.parse(syncMcpToolResponseBody5),
  );
}
export function syncMcpToolResponseBody5FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody5' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(SyncMcpToolResponseBodyToolsResponse200Status);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponse200Status> =
    SyncMcpToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(SyncMcpToolResponseBodyToolsResponse200Type);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponse200Type> =
    SyncMcpToolResponseBodyToolsResponse200Type$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyHeaders$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type SyncMcpToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const SyncMcpToolResponseBodyHeaders$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function syncMcpToolResponseBodyHeadersToJSON(
  syncMcpToolResponseBodyHeaders: SyncMcpToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyHeaders$outboundSchema.parse(
      syncMcpToolResponseBodyHeaders,
    ),
  );
}
export function syncMcpToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type
  > = SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsSchema$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type SyncMcpToolResponseBodyToolsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyToolsSchema$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsSchema$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyToolsSchema
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function syncMcpToolResponseBodyToolsSchemaToJSON(
  syncMcpToolResponseBodyToolsSchema: SyncMcpToolResponseBodyToolsSchema,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyToolsSchema$outboundSchema.parse(
      syncMcpToolResponseBodyToolsSchema,
    ),
  );
}
export function syncMcpToolResponseBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyTools$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => SyncMcpToolResponseBodyToolsSchema$inboundSchema),
});
/** @internal */
export type SyncMcpToolResponseBodyTools$Outbound = {
  name: string;
  description?: string | undefined;
  schema: SyncMcpToolResponseBodyToolsSchema$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBodyTools$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyTools$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyTools
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => SyncMcpToolResponseBodyToolsSchema$outboundSchema),
});

export function syncMcpToolResponseBodyToolsToJSON(
  syncMcpToolResponseBodyTools: SyncMcpToolResponseBodyTools,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyTools$outboundSchema.parse(
      syncMcpToolResponseBodyTools,
    ),
  );
}
export function syncMcpToolResponseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyConnectionType> = z.nativeEnum(
    SyncMcpToolResponseBodyConnectionType,
  );
/** @internal */
export const SyncMcpToolResponseBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyConnectionType> =
    SyncMcpToolResponseBodyConnectionType$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyMcp$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => SyncMcpToolResponseBodyHeaders$inboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => SyncMcpToolResponseBodyTools$inboundSchema)),
  connection_type: SyncMcpToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type SyncMcpToolResponseBodyMcp$Outbound = {
  server_url: string;
  headers?:
    | { [k: string]: SyncMcpToolResponseBodyHeaders$Outbound }
    | undefined;
  tools: Array<SyncMcpToolResponseBodyTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const SyncMcpToolResponseBodyMcp$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => SyncMcpToolResponseBodyHeaders$outboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => SyncMcpToolResponseBodyTools$outboundSchema)),
  connectionType: SyncMcpToolResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function syncMcpToolResponseBodyMcpToJSON(
  syncMcpToolResponseBodyMcp: SyncMcpToolResponseBodyMcp,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyMcp$outboundSchema.parse(syncMcpToolResponseBodyMcp),
  );
}
export function syncMcpToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsSyncResult$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsSyncResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});
/** @internal */
export type SyncMcpToolResponseBodyToolsSyncResult$Outbound = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

/** @internal */
export const SyncMcpToolResponseBodyToolsSyncResult$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsSyncResult$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyToolsSyncResult
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});

export function syncMcpToolResponseBodyToolsSyncResultToJSON(
  syncMcpToolResponseBodyToolsSyncResult:
    SyncMcpToolResponseBodyToolsSyncResult,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyToolsSyncResult$outboundSchema.parse(
      syncMcpToolResponseBodyToolsSyncResult,
    ),
  );
}
export function syncMcpToolResponseBodyToolsSyncResultFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyToolsSyncResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyToolsSyncResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyToolsSyncResult' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody4$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1CXJJCVS4H9FASFJ8AJDK9"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => SyncMcpToolResponseBodyMcp$inboundSchema),
  syncResult: z.lazy(() =>
    SyncMcpToolResponseBodyToolsSyncResult$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type SyncMcpToolResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: SyncMcpToolResponseBodyMcp$Outbound;
  syncResult: SyncMcpToolResponseBodyToolsSyncResult$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBody4$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody4$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody4
> = z.object({
  id: z.string().default("tool_01KA1CXJJCVS4H9FASFJ8AJDK9"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsResponse200Status$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => SyncMcpToolResponseBodyMcp$outboundSchema),
  syncResult: z.lazy(() =>
    SyncMcpToolResponseBodyToolsSyncResult$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function syncMcpToolResponseBody4ToJSON(
  syncMcpToolResponseBody4: SyncMcpToolResponseBody4,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody4$outboundSchema.parse(syncMcpToolResponseBody4),
  );
}
export function syncMcpToolResponseBody4FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody4' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(SyncMcpToolResponseBodyToolsResponseStatus);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponseStatus> =
    SyncMcpToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponseType> = z
    .nativeEnum(SyncMcpToolResponseBodyToolsResponseType);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof SyncMcpToolResponseBodyToolsResponseType> =
    SyncMcpToolResponseBodyToolsResponseType$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyMethod
> = z.nativeEnum(SyncMcpToolResponseBodyMethod);
/** @internal */
export const SyncMcpToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyMethod
> = SyncMcpToolResponseBodyMethod$inboundSchema;

/** @internal */
export const SyncMcpToolHeaders2$inboundSchema: z.ZodType<
  SyncMcpToolHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type SyncMcpToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const SyncMcpToolHeaders2$outboundSchema: z.ZodType<
  SyncMcpToolHeaders2$Outbound,
  z.ZodTypeDef,
  SyncMcpToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function syncMcpToolHeaders2ToJSON(
  syncMcpToolHeaders2: SyncMcpToolHeaders2,
): string {
  return JSON.stringify(
    SyncMcpToolHeaders2$outboundSchema.parse(syncMcpToolHeaders2),
  );
}
export function syncMcpToolHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolHeaders2' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsHeaders$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => SyncMcpToolHeaders2$inboundSchema), z.string()]);
/** @internal */
export type SyncMcpToolResponseBodyToolsHeaders$Outbound =
  | SyncMcpToolHeaders2$Outbound
  | string;

/** @internal */
export const SyncMcpToolResponseBodyToolsHeaders$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyToolsHeaders$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyToolsHeaders
> = z.union([z.lazy(() => SyncMcpToolHeaders2$outboundSchema), z.string()]);

export function syncMcpToolResponseBodyToolsHeadersToJSON(
  syncMcpToolResponseBodyToolsHeaders: SyncMcpToolResponseBodyToolsHeaders,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyToolsHeaders$outboundSchema.parse(
      syncMcpToolResponseBodyToolsHeaders,
    ),
  );
}
export function syncMcpToolResponseBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: SyncMcpToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => SyncMcpToolHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type SyncMcpToolResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: SyncMcpToolHeaders2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyBlueprint$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: SyncMcpToolResponseBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => SyncMcpToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function syncMcpToolResponseBodyBlueprintToJSON(
  syncMcpToolResponseBodyBlueprint: SyncMcpToolResponseBodyBlueprint,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyBlueprint$outboundSchema.parse(
      syncMcpToolResponseBodyBlueprint,
    ),
  );
}
export function syncMcpToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type
  > = SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type SyncMcpToolResponseBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const SyncMcpToolResponseBodyDefaultValue$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function syncMcpToolResponseBodyDefaultValueToJSON(
  syncMcpToolResponseBodyDefaultValue: SyncMcpToolResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyDefaultValue$outboundSchema.parse(
      syncMcpToolResponseBodyDefaultValue,
    ),
  );
}
export function syncMcpToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      SyncMcpToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyArguments$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type SyncMcpToolResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyArguments$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyArguments
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function syncMcpToolResponseBodyArgumentsToJSON(
  syncMcpToolResponseBodyArguments: SyncMcpToolResponseBodyArguments,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyArguments$outboundSchema.parse(
      syncMcpToolResponseBodyArguments,
    ),
  );
}
export function syncMcpToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyHttp$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => SyncMcpToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => SyncMcpToolResponseBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type SyncMcpToolResponseBodyHttp$Outbound = {
  blueprint: SyncMcpToolResponseBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: SyncMcpToolResponseBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyHttp$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => SyncMcpToolResponseBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => SyncMcpToolResponseBodyArguments$outboundSchema),
  ).optional(),
});

export function syncMcpToolResponseBodyHttpToJSON(
  syncMcpToolResponseBodyHttp: SyncMcpToolResponseBodyHttp,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyHttp$outboundSchema.parse(
      syncMcpToolResponseBodyHttp,
    ),
  );
}
export function syncMcpToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodySyncResult$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodySyncResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});
/** @internal */
export type SyncMcpToolResponseBodySyncResult$Outbound = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

/** @internal */
export const SyncMcpToolResponseBodySyncResult$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodySyncResult$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodySyncResult
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});

export function syncMcpToolResponseBodySyncResultToJSON(
  syncMcpToolResponseBodySyncResult: SyncMcpToolResponseBodySyncResult,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodySyncResult$outboundSchema.parse(
      syncMcpToolResponseBodySyncResult,
    ),
  );
}
export function syncMcpToolResponseBodySyncResultFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodySyncResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodySyncResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodySyncResult' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody3$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1CXJJA52Z3DVTAFT5NE2T4"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => SyncMcpToolResponseBodyHttp$inboundSchema),
  syncResult: z.lazy(() => SyncMcpToolResponseBodySyncResult$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type SyncMcpToolResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: SyncMcpToolResponseBodyHttp$Outbound;
  syncResult: SyncMcpToolResponseBodySyncResult$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBody3$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody3$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody3
> = z.object({
  id: z.string().default("tool_01KA1CXJJA52Z3DVTAFT5NE2T4"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => SyncMcpToolResponseBodyHttp$outboundSchema),
  syncResult: z.lazy(() => SyncMcpToolResponseBodySyncResult$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function syncMcpToolResponseBody3ToJSON(
  syncMcpToolResponseBody3: SyncMcpToolResponseBody3,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody3$outboundSchema.parse(syncMcpToolResponseBody3),
  );
}
export function syncMcpToolResponseBody3FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody3' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyToolsStatus
> = z.nativeEnum(SyncMcpToolResponseBodyToolsStatus);
/** @internal */
export const SyncMcpToolResponseBodyToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyToolsStatus
> = SyncMcpToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyToolsType
> = z.nativeEnum(SyncMcpToolResponseBodyToolsType);
/** @internal */
export const SyncMcpToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyToolsType
> = SyncMcpToolResponseBodyToolsType$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodySchema$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type SyncMcpToolResponseBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const SyncMcpToolResponseBodySchema$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodySchema$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function syncMcpToolResponseBodySchemaToJSON(
  syncMcpToolResponseBodySchema: SyncMcpToolResponseBodySchema,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodySchema$outboundSchema.parse(
      syncMcpToolResponseBodySchema,
    ),
  );
}
export function syncMcpToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => SyncMcpToolResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type SyncMcpToolResponseBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: SyncMcpToolResponseBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyJsonSchema$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => SyncMcpToolResponseBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function syncMcpToolResponseBodyJsonSchemaToJSON(
  syncMcpToolResponseBodyJsonSchema: SyncMcpToolResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyJsonSchema$outboundSchema.parse(
      syncMcpToolResponseBodyJsonSchema,
    ),
  );
}
export function syncMcpToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseBodySyncResult$inboundSchema: z.ZodType<
  ResponseBodySyncResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});
/** @internal */
export type ResponseBodySyncResult$Outbound = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

/** @internal */
export const ResponseBodySyncResult$outboundSchema: z.ZodType<
  ResponseBodySyncResult$Outbound,
  z.ZodTypeDef,
  ResponseBodySyncResult
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});

export function responseBodySyncResultToJSON(
  responseBodySyncResult: ResponseBodySyncResult,
): string {
  return JSON.stringify(
    ResponseBodySyncResult$outboundSchema.parse(responseBodySyncResult),
  );
}
export function responseBodySyncResultFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySyncResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySyncResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySyncResult' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody2$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1CXJJ9P0TEAJK4Y1P7M47G"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => SyncMcpToolResponseBodyJsonSchema$inboundSchema),
  syncResult: z.lazy(() => ResponseBodySyncResult$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type SyncMcpToolResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: SyncMcpToolResponseBodyJsonSchema$Outbound;
  syncResult: ResponseBodySyncResult$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBody2$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody2$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody2
> = z.object({
  id: z.string().default("tool_01KA1CXJJ9P0TEAJK4Y1P7M47G"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: SyncMcpToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => SyncMcpToolResponseBodyJsonSchema$outboundSchema),
  syncResult: z.lazy(() => ResponseBodySyncResult$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function syncMcpToolResponseBody2ToJSON(
  syncMcpToolResponseBody2: SyncMcpToolResponseBody2,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody2$outboundSchema.parse(syncMcpToolResponseBody2),
  );
}
export function syncMcpToolResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody2' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyStatus
> = z.nativeEnum(SyncMcpToolResponseBodyStatus);
/** @internal */
export const SyncMcpToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyStatus
> = SyncMcpToolResponseBodyStatus$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyType
> = z.nativeEnum(SyncMcpToolResponseBodyType);
/** @internal */
export const SyncMcpToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof SyncMcpToolResponseBodyType
> = SyncMcpToolResponseBodyType$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type);
/** @internal */
export const SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema:
  z.ZodNativeEnum<
    typeof SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type
  > = SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema;

/** @internal */
export const SyncMcpToolResponseBodyParameters$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type SyncMcpToolResponseBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const SyncMcpToolResponseBodyParameters$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyParameters$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyParameters
> = z.object({
  type:
    SyncMcpToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function syncMcpToolResponseBodyParametersToJSON(
  syncMcpToolResponseBodyParameters: SyncMcpToolResponseBodyParameters,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyParameters$outboundSchema.parse(
      syncMcpToolResponseBodyParameters,
    ),
  );
}
export function syncMcpToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBodyFunction$inboundSchema: z.ZodType<
  SyncMcpToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => SyncMcpToolResponseBodyParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type SyncMcpToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: SyncMcpToolResponseBodyParameters$Outbound | undefined;
};

/** @internal */
export const SyncMcpToolResponseBodyFunction$outboundSchema: z.ZodType<
  SyncMcpToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => SyncMcpToolResponseBodyParameters$outboundSchema)
    .optional(),
});

export function syncMcpToolResponseBodyFunctionToJSON(
  syncMcpToolResponseBodyFunction: SyncMcpToolResponseBodyFunction,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBodyFunction$outboundSchema.parse(
      syncMcpToolResponseBodyFunction,
    ),
  );
}
export function syncMcpToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const SyncResult$inboundSchema: z.ZodType<
  SyncResult,
  z.ZodTypeDef,
  unknown
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});
/** @internal */
export type SyncResult$Outbound = {
  toolsTotal: number;
  toolsAdded: number;
  toolsRemoved: number;
  errors: Array<string>;
};

/** @internal */
export const SyncResult$outboundSchema: z.ZodType<
  SyncResult$Outbound,
  z.ZodTypeDef,
  SyncResult
> = z.object({
  toolsTotal: z.number(),
  toolsAdded: z.number(),
  toolsRemoved: z.number(),
  errors: z.array(z.string()),
});

export function syncResultToJSON(syncResult: SyncResult): string {
  return JSON.stringify(SyncResult$outboundSchema.parse(syncResult));
}
export function syncResultFromJSON(
  jsonString: string,
): SafeParseResult<SyncResult, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncResult$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncResult' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody1$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1CXJJ7B6SR2C9A2607H85C"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: SyncMcpToolResponseBodyType$inboundSchema,
  function: z.lazy(() => SyncMcpToolResponseBodyFunction$inboundSchema),
  syncResult: z.lazy(() => SyncResult$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type SyncMcpToolResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: SyncMcpToolResponseBodyFunction$Outbound;
  syncResult: SyncResult$Outbound;
};

/** @internal */
export const SyncMcpToolResponseBody1$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody1$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody1
> = z.object({
  id: z.string().default("tool_01KA1CXJJ7B6SR2C9A2607H85C"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: SyncMcpToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: SyncMcpToolResponseBodyType$outboundSchema,
  function: z.lazy(() => SyncMcpToolResponseBodyFunction$outboundSchema),
  syncResult: z.lazy(() => SyncResult$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function syncMcpToolResponseBody1ToJSON(
  syncMcpToolResponseBody1: SyncMcpToolResponseBody1,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody1$outboundSchema.parse(syncMcpToolResponseBody1),
  );
}
export function syncMcpToolResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody1' from JSON`,
  );
}

/** @internal */
export const SyncMcpToolResponseBody$inboundSchema: z.ZodType<
  SyncMcpToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SyncMcpToolResponseBody1$inboundSchema),
  z.lazy(() => SyncMcpToolResponseBody2$inboundSchema),
  z.lazy(() => SyncMcpToolResponseBody3$inboundSchema),
  z.lazy(() => SyncMcpToolResponseBody4$inboundSchema),
  z.lazy(() => SyncMcpToolResponseBody5$inboundSchema),
]);
/** @internal */
export type SyncMcpToolResponseBody$Outbound =
  | SyncMcpToolResponseBody1$Outbound
  | SyncMcpToolResponseBody2$Outbound
  | SyncMcpToolResponseBody3$Outbound
  | SyncMcpToolResponseBody4$Outbound
  | SyncMcpToolResponseBody5$Outbound;

/** @internal */
export const SyncMcpToolResponseBody$outboundSchema: z.ZodType<
  SyncMcpToolResponseBody$Outbound,
  z.ZodTypeDef,
  SyncMcpToolResponseBody
> = z.union([
  z.lazy(() => SyncMcpToolResponseBody1$outboundSchema),
  z.lazy(() => SyncMcpToolResponseBody2$outboundSchema),
  z.lazy(() => SyncMcpToolResponseBody3$outboundSchema),
  z.lazy(() => SyncMcpToolResponseBody4$outboundSchema),
  z.lazy(() => SyncMcpToolResponseBody5$outboundSchema),
]);

export function syncMcpToolResponseBodyToJSON(
  syncMcpToolResponseBody: SyncMcpToolResponseBody,
): string {
  return JSON.stringify(
    SyncMcpToolResponseBody$outboundSchema.parse(syncMcpToolResponseBody),
  );
}
export function syncMcpToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<SyncMcpToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SyncMcpToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SyncMcpToolResponseBody' from JSON`,
  );
}
