/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ParseChunkingRequestChunkingRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ParseChunkingRequestChunkingRequestReturnType = ClosedEnum<
  typeof ParseChunkingRequestChunkingRequestReturnType
>;

export const AgenticChunker = {
  Agentic: "agentic",
} as const;
export type AgenticChunker = ClosedEnum<typeof AgenticChunker>;

/**
 * Agentic LLM-powered chunker that uses AI to determine optimal split points. Best for complex documents requiring intelligent segmentation.
 */
export type AgenticChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ParseChunkingRequestChunkingRequestReturnType | undefined;
  strategy: AgenticChunker;
  /**
   * Model to use for chunking. (Available models)[https://docs.orq.ai/docs/proxy/supported-models#chat-models]
   */
  model: string;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Size of candidate splits for LLM evaluation
   */
  candidateSize?: number | undefined;
  /**
   * Minimum characters allowed per chunk
   */
  minCharactersPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ParseChunkingRequestChunkingReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ParseChunkingRequestChunkingReturnType = ClosedEnum<
  typeof ParseChunkingRequestChunkingReturnType
>;

export const SemanticChunker = {
  Semantic: "semantic",
} as const;
export type SemanticChunker = ClosedEnum<typeof SemanticChunker>;

export const Threshold2 = {
  Auto: "auto",
} as const;
export type Threshold2 = ClosedEnum<typeof Threshold2>;

/**
 * Similarity threshold for grouping (0-1) or "auto" for automatic detection
 */
export type Threshold = number | Threshold2;

/**
 * Chunking mode: window-based or sentence-based similarity
 */
export const Mode = {
  Window: "window",
  Sentence: "sentence",
} as const;
/**
 * Chunking mode: window-based or sentence-based similarity
 */
export type Mode = ClosedEnum<typeof Mode>;

/**
 * Groups semantically similar sentences using embeddings. Excellent for maintaining topic coherence and context within chunks.
 */
export type SemanticChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ParseChunkingRequestChunkingReturnType | undefined;
  strategy: SemanticChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Similarity threshold for grouping (0-1) or "auto" for automatic detection
   */
  threshold?: number | Threshold2 | undefined;
  /**
   * Embedding model to use for semantic similarity. (Available embedding models)[https://docs.orq.ai/docs/proxy/supported-models#embedding-models]
   */
  embeddingModel: string;
  /**
   * Number of dimensions for the embedding output. Required for text-embedding-3 models. Supported range: 256-3072 for text-embedding-3-large, 256-1536 for text-embedding-3-small.
   */
  dimensions?: number | undefined;
  /**
   * Maximum number of tokens per embedding request. Default is 8191 for text-embedding-3 models.
   */
  maxTokens?: number | undefined;
  /**
   * Chunking mode: window-based or sentence-based similarity
   */
  mode?: Mode | undefined;
  /**
   * Window size for similarity comparison
   */
  similarityWindow?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ParseChunkingRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ParseChunkingRequestReturnType = ClosedEnum<
  typeof ParseChunkingRequestReturnType
>;

export const RecursiveChunker = {
  Recursive: "recursive",
} as const;
export type RecursiveChunker = ClosedEnum<typeof RecursiveChunker>;

/**
 * Recursively splits text using a hierarchy of separators (paragraphs, sentences, words). Versatile general-purpose chunker that preserves document structure.
 */
export type RecursiveChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ParseChunkingRequestReturnType | undefined;
  strategy: RecursiveChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Hierarchy of separators to use for splitting
   */
  separators?: Array<string> | undefined;
  /**
   * Minimum characters allowed per chunk
   */
  minCharactersPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkingRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkingRequestReturnType = ClosedEnum<
  typeof ChunkingRequestReturnType
>;

export const SentenceChunker = {
  Sentence: "sentence",
} as const;
export type SentenceChunker = ClosedEnum<typeof SentenceChunker>;

/**
 * Splits text at sentence boundaries while respecting token limits. Ideal for maintaining semantic coherence and readability.
 */
export type SentenceChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ChunkingRequestReturnType | undefined;
  strategy: SentenceChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Number of overlapping tokens between chunks
   */
  chunkOverlap?: number | undefined;
  /**
   * Minimum number of sentences per chunk
   */
  minSentencesPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ReturnTypeT = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ReturnTypeT = ClosedEnum<typeof ReturnTypeT>;

export const TokenChunker = {
  Token: "token",
} as const;
export type TokenChunker = ClosedEnum<typeof TokenChunker>;

/**
 * Splits text based on token count. Best for ensuring chunks fit within LLM context windows and maintaining consistent chunk sizes for embedding models.
 */
export type TokenChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ReturnTypeT | undefined;
  strategy: TokenChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Number of tokens to overlap between chunks
   */
  chunkOverlap?: number | undefined;
};

/**
 * Request payload for text chunking with strategy-specific configuration
 */
export type ParseChunkingRequest =
  | SemanticChunkerStrategy
  | AgenticChunkerStrategy
  | TokenChunkerStrategy
  | SentenceChunkerStrategy
  | RecursiveChunkerStrategy;

export type ParseMetadata = {
  startIndex: number | null;
  endIndex: number | null;
  tokenCount: number | null;
};

export type Chunks = {
  /**
   * The text content of the chunk
   */
  text: string;
  /**
   * The position index of this chunk in the sequence
   */
  index: number;
  metadata?: ParseMetadata | undefined;
};

/**
 * Text successfully chunked
 */
export type ParseResponseBody = {
  chunks: Array<Chunks>;
};

/** @internal */
export const ParseChunkingRequestChunkingRequestReturnType$inboundSchema:
  z.ZodNativeEnum<typeof ParseChunkingRequestChunkingRequestReturnType> = z
    .nativeEnum(ParseChunkingRequestChunkingRequestReturnType);
/** @internal */
export const ParseChunkingRequestChunkingRequestReturnType$outboundSchema:
  z.ZodNativeEnum<typeof ParseChunkingRequestChunkingRequestReturnType> =
    ParseChunkingRequestChunkingRequestReturnType$inboundSchema;

/** @internal */
export const AgenticChunker$inboundSchema: z.ZodNativeEnum<
  typeof AgenticChunker
> = z.nativeEnum(AgenticChunker);
/** @internal */
export const AgenticChunker$outboundSchema: z.ZodNativeEnum<
  typeof AgenticChunker
> = AgenticChunker$inboundSchema;

/** @internal */
export const AgenticChunkerStrategy$inboundSchema: z.ZodType<
  AgenticChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ParseChunkingRequestChunkingRequestReturnType$inboundSchema
    .default("chunks"),
  strategy: AgenticChunker$inboundSchema,
  model: z.string(),
  chunk_size: z.number().int().default(1024),
  candidate_size: z.number().int().default(128),
  min_characters_per_chunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "candidate_size": "candidateSize",
    "min_characters_per_chunk": "minCharactersPerChunk",
  });
});
/** @internal */
export type AgenticChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  model: string;
  chunk_size: number;
  candidate_size: number;
  min_characters_per_chunk: number;
};

/** @internal */
export const AgenticChunkerStrategy$outboundSchema: z.ZodType<
  AgenticChunkerStrategy$Outbound,
  z.ZodTypeDef,
  AgenticChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ParseChunkingRequestChunkingRequestReturnType$outboundSchema
    .default("chunks"),
  strategy: AgenticChunker$outboundSchema,
  model: z.string(),
  chunkSize: z.number().int().default(1024),
  candidateSize: z.number().int().default(128),
  minCharactersPerChunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    candidateSize: "candidate_size",
    minCharactersPerChunk: "min_characters_per_chunk",
  });
});

export function agenticChunkerStrategyToJSON(
  agenticChunkerStrategy: AgenticChunkerStrategy,
): string {
  return JSON.stringify(
    AgenticChunkerStrategy$outboundSchema.parse(agenticChunkerStrategy),
  );
}
export function agenticChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<AgenticChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgenticChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgenticChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ParseChunkingRequestChunkingReturnType$inboundSchema:
  z.ZodNativeEnum<typeof ParseChunkingRequestChunkingReturnType> = z.nativeEnum(
    ParseChunkingRequestChunkingReturnType,
  );
/** @internal */
export const ParseChunkingRequestChunkingReturnType$outboundSchema:
  z.ZodNativeEnum<typeof ParseChunkingRequestChunkingReturnType> =
    ParseChunkingRequestChunkingReturnType$inboundSchema;

/** @internal */
export const SemanticChunker$inboundSchema: z.ZodNativeEnum<
  typeof SemanticChunker
> = z.nativeEnum(SemanticChunker);
/** @internal */
export const SemanticChunker$outboundSchema: z.ZodNativeEnum<
  typeof SemanticChunker
> = SemanticChunker$inboundSchema;

/** @internal */
export const Threshold2$inboundSchema: z.ZodNativeEnum<typeof Threshold2> = z
  .nativeEnum(Threshold2);
/** @internal */
export const Threshold2$outboundSchema: z.ZodNativeEnum<typeof Threshold2> =
  Threshold2$inboundSchema;

/** @internal */
export const Threshold$inboundSchema: z.ZodType<
  Threshold,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), Threshold2$inboundSchema]);
/** @internal */
export type Threshold$Outbound = number | string;

/** @internal */
export const Threshold$outboundSchema: z.ZodType<
  Threshold$Outbound,
  z.ZodTypeDef,
  Threshold
> = z.union([z.number(), Threshold2$outboundSchema]);

export function thresholdToJSON(threshold: Threshold): string {
  return JSON.stringify(Threshold$outboundSchema.parse(threshold));
}
export function thresholdFromJSON(
  jsonString: string,
): SafeParseResult<Threshold, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Threshold$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Threshold' from JSON`,
  );
}

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);
/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/** @internal */
export const SemanticChunkerStrategy$inboundSchema: z.ZodType<
  SemanticChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ParseChunkingRequestChunkingReturnType$inboundSchema.default(
    "chunks",
  ),
  strategy: SemanticChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  threshold: z.union([z.number(), Threshold2$inboundSchema]).optional(),
  embedding_model: z.string(),
  dimensions: z.number().int().optional(),
  max_tokens: z.number().int().optional(),
  mode: Mode$inboundSchema.default("window"),
  similarity_window: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "embedding_model": "embeddingModel",
    "max_tokens": "maxTokens",
    "similarity_window": "similarityWindow",
  });
});
/** @internal */
export type SemanticChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  threshold?: number | string | undefined;
  embedding_model: string;
  dimensions?: number | undefined;
  max_tokens?: number | undefined;
  mode: string;
  similarity_window: number;
};

/** @internal */
export const SemanticChunkerStrategy$outboundSchema: z.ZodType<
  SemanticChunkerStrategy$Outbound,
  z.ZodTypeDef,
  SemanticChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ParseChunkingRequestChunkingReturnType$outboundSchema.default(
    "chunks",
  ),
  strategy: SemanticChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  threshold: z.union([z.number(), Threshold2$outboundSchema]).optional(),
  embeddingModel: z.string(),
  dimensions: z.number().int().optional(),
  maxTokens: z.number().int().optional(),
  mode: Mode$outboundSchema.default("window"),
  similarityWindow: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    embeddingModel: "embedding_model",
    maxTokens: "max_tokens",
    similarityWindow: "similarity_window",
  });
});

export function semanticChunkerStrategyToJSON(
  semanticChunkerStrategy: SemanticChunkerStrategy,
): string {
  return JSON.stringify(
    SemanticChunkerStrategy$outboundSchema.parse(semanticChunkerStrategy),
  );
}
export function semanticChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<SemanticChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SemanticChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SemanticChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ParseChunkingRequestReturnType$inboundSchema: z.ZodNativeEnum<
  typeof ParseChunkingRequestReturnType
> = z.nativeEnum(ParseChunkingRequestReturnType);
/** @internal */
export const ParseChunkingRequestReturnType$outboundSchema: z.ZodNativeEnum<
  typeof ParseChunkingRequestReturnType
> = ParseChunkingRequestReturnType$inboundSchema;

/** @internal */
export const RecursiveChunker$inboundSchema: z.ZodNativeEnum<
  typeof RecursiveChunker
> = z.nativeEnum(RecursiveChunker);
/** @internal */
export const RecursiveChunker$outboundSchema: z.ZodNativeEnum<
  typeof RecursiveChunker
> = RecursiveChunker$inboundSchema;

/** @internal */
export const RecursiveChunkerStrategy$inboundSchema: z.ZodType<
  RecursiveChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ParseChunkingRequestReturnType$inboundSchema.default("chunks"),
  strategy: RecursiveChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  separators: z.array(z.string()).optional(),
  min_characters_per_chunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "min_characters_per_chunk": "minCharactersPerChunk",
  });
});
/** @internal */
export type RecursiveChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  separators?: Array<string> | undefined;
  min_characters_per_chunk: number;
};

/** @internal */
export const RecursiveChunkerStrategy$outboundSchema: z.ZodType<
  RecursiveChunkerStrategy$Outbound,
  z.ZodTypeDef,
  RecursiveChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ParseChunkingRequestReturnType$outboundSchema.default("chunks"),
  strategy: RecursiveChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  separators: z.array(z.string()).optional(),
  minCharactersPerChunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    minCharactersPerChunk: "min_characters_per_chunk",
  });
});

export function recursiveChunkerStrategyToJSON(
  recursiveChunkerStrategy: RecursiveChunkerStrategy,
): string {
  return JSON.stringify(
    RecursiveChunkerStrategy$outboundSchema.parse(recursiveChunkerStrategy),
  );
}
export function recursiveChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<RecursiveChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecursiveChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecursiveChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkingRequestReturnType$inboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestReturnType
> = z.nativeEnum(ChunkingRequestReturnType);
/** @internal */
export const ChunkingRequestReturnType$outboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestReturnType
> = ChunkingRequestReturnType$inboundSchema;

/** @internal */
export const SentenceChunker$inboundSchema: z.ZodNativeEnum<
  typeof SentenceChunker
> = z.nativeEnum(SentenceChunker);
/** @internal */
export const SentenceChunker$outboundSchema: z.ZodNativeEnum<
  typeof SentenceChunker
> = SentenceChunker$inboundSchema;

/** @internal */
export const SentenceChunkerStrategy$inboundSchema: z.ZodType<
  SentenceChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ChunkingRequestReturnType$inboundSchema.default("chunks"),
  strategy: SentenceChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  chunk_overlap: z.number().int().default(0),
  min_sentences_per_chunk: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "chunk_overlap": "chunkOverlap",
    "min_sentences_per_chunk": "minSentencesPerChunk",
  });
});
/** @internal */
export type SentenceChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  chunk_overlap: number;
  min_sentences_per_chunk: number;
};

/** @internal */
export const SentenceChunkerStrategy$outboundSchema: z.ZodType<
  SentenceChunkerStrategy$Outbound,
  z.ZodTypeDef,
  SentenceChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ChunkingRequestReturnType$outboundSchema.default("chunks"),
  strategy: SentenceChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  chunkOverlap: z.number().int().default(0),
  minSentencesPerChunk: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    chunkOverlap: "chunk_overlap",
    minSentencesPerChunk: "min_sentences_per_chunk",
  });
});

export function sentenceChunkerStrategyToJSON(
  sentenceChunkerStrategy: SentenceChunkerStrategy,
): string {
  return JSON.stringify(
    SentenceChunkerStrategy$outboundSchema.parse(sentenceChunkerStrategy),
  );
}
export function sentenceChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<SentenceChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentenceChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentenceChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ReturnTypeT$inboundSchema: z.ZodNativeEnum<typeof ReturnTypeT> = z
  .nativeEnum(ReturnTypeT);
/** @internal */
export const ReturnTypeT$outboundSchema: z.ZodNativeEnum<typeof ReturnTypeT> =
  ReturnTypeT$inboundSchema;

/** @internal */
export const TokenChunker$inboundSchema: z.ZodNativeEnum<typeof TokenChunker> =
  z.nativeEnum(TokenChunker);
/** @internal */
export const TokenChunker$outboundSchema: z.ZodNativeEnum<typeof TokenChunker> =
  TokenChunker$inboundSchema;

/** @internal */
export const TokenChunkerStrategy$inboundSchema: z.ZodType<
  TokenChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ReturnTypeT$inboundSchema.default("chunks"),
  strategy: TokenChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  chunk_overlap: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "chunk_overlap": "chunkOverlap",
  });
});
/** @internal */
export type TokenChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  chunk_overlap: number;
};

/** @internal */
export const TokenChunkerStrategy$outboundSchema: z.ZodType<
  TokenChunkerStrategy$Outbound,
  z.ZodTypeDef,
  TokenChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ReturnTypeT$outboundSchema.default("chunks"),
  strategy: TokenChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  chunkOverlap: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    chunkOverlap: "chunk_overlap",
  });
});

export function tokenChunkerStrategyToJSON(
  tokenChunkerStrategy: TokenChunkerStrategy,
): string {
  return JSON.stringify(
    TokenChunkerStrategy$outboundSchema.parse(tokenChunkerStrategy),
  );
}
export function tokenChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<TokenChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TokenChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TokenChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ParseChunkingRequest$inboundSchema: z.ZodType<
  ParseChunkingRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SemanticChunkerStrategy$inboundSchema),
  z.lazy(() => AgenticChunkerStrategy$inboundSchema),
  z.lazy(() => TokenChunkerStrategy$inboundSchema),
  z.lazy(() => SentenceChunkerStrategy$inboundSchema),
  z.lazy(() => RecursiveChunkerStrategy$inboundSchema),
]);
/** @internal */
export type ParseChunkingRequest$Outbound =
  | SemanticChunkerStrategy$Outbound
  | AgenticChunkerStrategy$Outbound
  | TokenChunkerStrategy$Outbound
  | SentenceChunkerStrategy$Outbound
  | RecursiveChunkerStrategy$Outbound;

/** @internal */
export const ParseChunkingRequest$outboundSchema: z.ZodType<
  ParseChunkingRequest$Outbound,
  z.ZodTypeDef,
  ParseChunkingRequest
> = z.union([
  z.lazy(() => SemanticChunkerStrategy$outboundSchema),
  z.lazy(() => AgenticChunkerStrategy$outboundSchema),
  z.lazy(() => TokenChunkerStrategy$outboundSchema),
  z.lazy(() => SentenceChunkerStrategy$outboundSchema),
  z.lazy(() => RecursiveChunkerStrategy$outboundSchema),
]);

export function parseChunkingRequestToJSON(
  parseChunkingRequest: ParseChunkingRequest,
): string {
  return JSON.stringify(
    ParseChunkingRequest$outboundSchema.parse(parseChunkingRequest),
  );
}
export function parseChunkingRequestFromJSON(
  jsonString: string,
): SafeParseResult<ParseChunkingRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParseChunkingRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParseChunkingRequest' from JSON`,
  );
}

/** @internal */
export const ParseMetadata$inboundSchema: z.ZodType<
  ParseMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  start_index: z.nullable(z.number()),
  end_index: z.nullable(z.number()),
  token_count: z.nullable(z.number()),
}).transform((v) => {
  return remap$(v, {
    "start_index": "startIndex",
    "end_index": "endIndex",
    "token_count": "tokenCount",
  });
});
/** @internal */
export type ParseMetadata$Outbound = {
  start_index: number | null;
  end_index: number | null;
  token_count: number | null;
};

/** @internal */
export const ParseMetadata$outboundSchema: z.ZodType<
  ParseMetadata$Outbound,
  z.ZodTypeDef,
  ParseMetadata
> = z.object({
  startIndex: z.nullable(z.number()),
  endIndex: z.nullable(z.number()),
  tokenCount: z.nullable(z.number()),
}).transform((v) => {
  return remap$(v, {
    startIndex: "start_index",
    endIndex: "end_index",
    tokenCount: "token_count",
  });
});

export function parseMetadataToJSON(parseMetadata: ParseMetadata): string {
  return JSON.stringify(ParseMetadata$outboundSchema.parse(parseMetadata));
}
export function parseMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ParseMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParseMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParseMetadata' from JSON`,
  );
}

/** @internal */
export const Chunks$inboundSchema: z.ZodType<Chunks, z.ZodTypeDef, unknown> = z
  .object({
    text: z.string(),
    index: z.number(),
    metadata: z.lazy(() => ParseMetadata$inboundSchema).optional(),
  });
/** @internal */
export type Chunks$Outbound = {
  text: string;
  index: number;
  metadata?: ParseMetadata$Outbound | undefined;
};

/** @internal */
export const Chunks$outboundSchema: z.ZodType<
  Chunks$Outbound,
  z.ZodTypeDef,
  Chunks
> = z.object({
  text: z.string(),
  index: z.number(),
  metadata: z.lazy(() => ParseMetadata$outboundSchema).optional(),
});

export function chunksToJSON(chunks: Chunks): string {
  return JSON.stringify(Chunks$outboundSchema.parse(chunks));
}
export function chunksFromJSON(
  jsonString: string,
): SafeParseResult<Chunks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Chunks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Chunks' from JSON`,
  );
}

/** @internal */
export const ParseResponseBody$inboundSchema: z.ZodType<
  ParseResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  chunks: z.array(z.lazy(() => Chunks$inboundSchema)),
});
/** @internal */
export type ParseResponseBody$Outbound = {
  chunks: Array<Chunks$Outbound>;
};

/** @internal */
export const ParseResponseBody$outboundSchema: z.ZodType<
  ParseResponseBody$Outbound,
  z.ZodTypeDef,
  ParseResponseBody
> = z.object({
  chunks: z.array(z.lazy(() => Chunks$outboundSchema)),
});

export function parseResponseBodyToJSON(
  parseResponseBody: ParseResponseBody,
): string {
  return JSON.stringify(
    ParseResponseBody$outboundSchema.parse(parseResponseBody),
  );
}
export function parseResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ParseResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParseResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParseResponseBody' from JSON`,
  );
}
