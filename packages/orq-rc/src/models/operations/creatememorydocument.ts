/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateMemoryDocumentRequestBody = {
  /**
   * The content of the memory document
   */
  text: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization of documents within a memory collection. Clients can add arbitrary string metadata to enable future filtering based on their specific needs (e.g., document type, source, topic, relevance score, or any custom taxonomy). This enables powerful querying and retrieval strategies.
   */
  metadata?: { [k: string]: string } | undefined;
};

export type CreateMemoryDocumentRequest = {
  /**
   * The unique key identifier of the memory store
   */
  memoryStoreKey: string;
  /**
   * The unique identifier of the memory
   */
  memoryId: string;
  requestBody?: CreateMemoryDocumentRequestBody | undefined;
};

/**
 * Memory document successfully created.
 */
export type CreateMemoryDocumentResponseBody = {
  id: string;
  memoryId: string;
  storeId: string;
  text: string;
  created: string;
  updated: string;
  createdById?: string | undefined;
  updatedById?: string | undefined;
  workspaceId: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization. Clients can add arbitrary string metadata to enable future filtering of memory documents based on their specific needs (e.g., document type, source, topic, relevance score, or any custom taxonomy).
   */
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const CreateMemoryDocumentRequestBody$inboundSchema: z.ZodType<
  CreateMemoryDocumentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.record(z.string()).optional(),
});
/** @internal */
export type CreateMemoryDocumentRequestBody$Outbound = {
  text: string;
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const CreateMemoryDocumentRequestBody$outboundSchema: z.ZodType<
  CreateMemoryDocumentRequestBody$Outbound,
  z.ZodTypeDef,
  CreateMemoryDocumentRequestBody
> = z.object({
  text: z.string(),
  metadata: z.record(z.string()).optional(),
});

export function createMemoryDocumentRequestBodyToJSON(
  createMemoryDocumentRequestBody: CreateMemoryDocumentRequestBody,
): string {
  return JSON.stringify(
    CreateMemoryDocumentRequestBody$outboundSchema.parse(
      createMemoryDocumentRequestBody,
    ),
  );
}
export function createMemoryDocumentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateMemoryDocumentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateMemoryDocumentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateMemoryDocumentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateMemoryDocumentRequest$inboundSchema: z.ZodType<
  CreateMemoryDocumentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  memory_store_key: z.string(),
  memory_id: z.string(),
  RequestBody: z.lazy(() => CreateMemoryDocumentRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "memory_store_key": "memoryStoreKey",
    "memory_id": "memoryId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateMemoryDocumentRequest$Outbound = {
  memory_store_key: string;
  memory_id: string;
  RequestBody?: CreateMemoryDocumentRequestBody$Outbound | undefined;
};

/** @internal */
export const CreateMemoryDocumentRequest$outboundSchema: z.ZodType<
  CreateMemoryDocumentRequest$Outbound,
  z.ZodTypeDef,
  CreateMemoryDocumentRequest
> = z.object({
  memoryStoreKey: z.string(),
  memoryId: z.string(),
  requestBody: z.lazy(() => CreateMemoryDocumentRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    memoryStoreKey: "memory_store_key",
    memoryId: "memory_id",
    requestBody: "RequestBody",
  });
});

export function createMemoryDocumentRequestToJSON(
  createMemoryDocumentRequest: CreateMemoryDocumentRequest,
): string {
  return JSON.stringify(
    CreateMemoryDocumentRequest$outboundSchema.parse(
      createMemoryDocumentRequest,
    ),
  );
}
export function createMemoryDocumentRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateMemoryDocumentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateMemoryDocumentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateMemoryDocumentRequest' from JSON`,
  );
}

/** @internal */
export const CreateMemoryDocumentResponseBody$inboundSchema: z.ZodType<
  CreateMemoryDocumentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  memory_id: z.string(),
  store_id: z.string(),
  text: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  workspace_id: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "memory_id": "memoryId",
    "store_id": "storeId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "workspace_id": "workspaceId",
  });
});
/** @internal */
export type CreateMemoryDocumentResponseBody$Outbound = {
  _id: string;
  memory_id: string;
  store_id: string;
  text: string;
  created: string;
  updated: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  workspace_id: string;
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const CreateMemoryDocumentResponseBody$outboundSchema: z.ZodType<
  CreateMemoryDocumentResponseBody$Outbound,
  z.ZodTypeDef,
  CreateMemoryDocumentResponseBody
> = z.object({
  id: z.string(),
  memoryId: z.string(),
  storeId: z.string(),
  text: z.string(),
  created: z.string(),
  updated: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  workspaceId: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    memoryId: "memory_id",
    storeId: "store_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    workspaceId: "workspace_id",
  });
});

export function createMemoryDocumentResponseBodyToJSON(
  createMemoryDocumentResponseBody: CreateMemoryDocumentResponseBody,
): string {
  return JSON.stringify(
    CreateMemoryDocumentResponseBody$outboundSchema.parse(
      createMemoryDocumentResponseBody,
    ),
  );
}
export function createMemoryDocumentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateMemoryDocumentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateMemoryDocumentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateMemoryDocumentResponseBody' from JSON`,
  );
}
