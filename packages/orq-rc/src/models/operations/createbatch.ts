/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The time frame within which the batch should be processed. Currently only 24h is supported.
 */
export const CompletionWindow = {
  TwentyFourh: "24h",
} as const;
/**
 * The time frame within which the batch should be processed. Currently only 24h is supported.
 */
export type CompletionWindow = ClosedEnum<typeof CompletionWindow>;

export type CreateBatchRequestBody = {
  /**
   * The ID of an uploaded file that contains requests for the new batch.
   *
   * @remarks
   *
   * See [upload file](https://docs.orq.ai/reference/fileupload-1) for how to upload a file.
   *
   * Your input file must be formatted as a [JSONL](https://jsonlines.org/) file, and must be uploaded with the purpose batch. The file can contain up to 50,000 requests, and can be up to 200 MB in size.
   */
  inputFileId: string;
  /**
   * The endpoint to be used for all requests in the batch. Currently `/v1/chat/completions`, `/v1/embeddings`, and `/v1/completions` are supported. Note that `/v1/embeddings` batches are also restricted to a maximum of 50,000 embedding inputs across all requests in the batch.
   */
  endpoint: string;
  /**
   * The time frame within which the batch should be processed. Currently only 24h is supported.
   */
  completionWindow: CompletionWindow;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.
   *
   * @remarks
   *
   * Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * The object type, which is always batch.
 */
export const CreateBatchObject = {
  Batch: "batch",
} as const;
/**
 * The object type, which is always batch.
 */
export type CreateBatchObject = ClosedEnum<typeof CreateBatchObject>;

/**
 * Errors associated with the batch.
 */
export type Errors = {};

/**
 * The request counts for different statuses within the batch.
 */
export type RequestCounts = {
  /**
   * Total number of requests in the batch.
   */
  total: number;
  /**
   * Number of requests that have been completed successfully.
   */
  completed: number;
  /**
   * Number of requests that have failed.
   */
  failed: number;
};

/**
 * A list of paginated Batch objects.
 */
export type CreateBatchResponseBody = {
  /**
   * The ID of the batch job.
   */
  id: string;
  /**
   * The object type, which is always batch.
   */
  object: CreateBatchObject;
  /**
   * The OpenAI API endpoint used by the batch.
   */
  endpoint: string;
  /**
   * Errors associated with the batch.
   */
  errors: Errors;
  /**
   * The ID of the input file for the batch.
   */
  inputFileId: string;
  /**
   * The time frame within which the batch should be processed.
   */
  completionWindow: string;
  /**
   * The current status of the batch.
   */
  status: string;
  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  outputFileId: string | null;
  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  errorFileId: string | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  createdAt: number;
  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  inProgressAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expiresAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizingAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completedAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failedAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expiredAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancellingAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelledAt: number | null;
  /**
   * The request counts for different statuses within the batch.
   */
  requestCounts: RequestCounts;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.
   *
   * @remarks
   *
   * Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CompletionWindow$inboundSchema: z.ZodNativeEnum<
  typeof CompletionWindow
> = z.nativeEnum(CompletionWindow);

/** @internal */
export const CompletionWindow$outboundSchema: z.ZodNativeEnum<
  typeof CompletionWindow
> = CompletionWindow$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CompletionWindow$ {
  /** @deprecated use `CompletionWindow$inboundSchema` instead. */
  export const inboundSchema = CompletionWindow$inboundSchema;
  /** @deprecated use `CompletionWindow$outboundSchema` instead. */
  export const outboundSchema = CompletionWindow$outboundSchema;
}

/** @internal */
export const CreateBatchRequestBody$inboundSchema: z.ZodType<
  CreateBatchRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_file_id: z.string(),
  endpoint: z.string(),
  completion_window: CompletionWindow$inboundSchema,
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "input_file_id": "inputFileId",
    "completion_window": "completionWindow",
  });
});

/** @internal */
export type CreateBatchRequestBody$Outbound = {
  input_file_id: string;
  endpoint: string;
  completion_window: string;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateBatchRequestBody$outboundSchema: z.ZodType<
  CreateBatchRequestBody$Outbound,
  z.ZodTypeDef,
  CreateBatchRequestBody
> = z.object({
  inputFileId: z.string(),
  endpoint: z.string(),
  completionWindow: CompletionWindow$outboundSchema,
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    inputFileId: "input_file_id",
    completionWindow: "completion_window",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateBatchRequestBody$ {
  /** @deprecated use `CreateBatchRequestBody$inboundSchema` instead. */
  export const inboundSchema = CreateBatchRequestBody$inboundSchema;
  /** @deprecated use `CreateBatchRequestBody$outboundSchema` instead. */
  export const outboundSchema = CreateBatchRequestBody$outboundSchema;
  /** @deprecated use `CreateBatchRequestBody$Outbound` instead. */
  export type Outbound = CreateBatchRequestBody$Outbound;
}

export function createBatchRequestBodyToJSON(
  createBatchRequestBody: CreateBatchRequestBody,
): string {
  return JSON.stringify(
    CreateBatchRequestBody$outboundSchema.parse(createBatchRequestBody),
  );
}

export function createBatchRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateBatchRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateBatchRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateBatchRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateBatchObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateBatchObject
> = z.nativeEnum(CreateBatchObject);

/** @internal */
export const CreateBatchObject$outboundSchema: z.ZodNativeEnum<
  typeof CreateBatchObject
> = CreateBatchObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateBatchObject$ {
  /** @deprecated use `CreateBatchObject$inboundSchema` instead. */
  export const inboundSchema = CreateBatchObject$inboundSchema;
  /** @deprecated use `CreateBatchObject$outboundSchema` instead. */
  export const outboundSchema = CreateBatchObject$outboundSchema;
}

/** @internal */
export const Errors$inboundSchema: z.ZodType<Errors, z.ZodTypeDef, unknown> = z
  .object({});

/** @internal */
export type Errors$Outbound = {};

/** @internal */
export const Errors$outboundSchema: z.ZodType<
  Errors$Outbound,
  z.ZodTypeDef,
  Errors
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Errors$ {
  /** @deprecated use `Errors$inboundSchema` instead. */
  export const inboundSchema = Errors$inboundSchema;
  /** @deprecated use `Errors$outboundSchema` instead. */
  export const outboundSchema = Errors$outboundSchema;
  /** @deprecated use `Errors$Outbound` instead. */
  export type Outbound = Errors$Outbound;
}

export function errorsToJSON(errors: Errors): string {
  return JSON.stringify(Errors$outboundSchema.parse(errors));
}

export function errorsFromJSON(
  jsonString: string,
): SafeParseResult<Errors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Errors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Errors' from JSON`,
  );
}

/** @internal */
export const RequestCounts$inboundSchema: z.ZodType<
  RequestCounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/** @internal */
export type RequestCounts$Outbound = {
  total: number;
  completed: number;
  failed: number;
};

/** @internal */
export const RequestCounts$outboundSchema: z.ZodType<
  RequestCounts$Outbound,
  z.ZodTypeDef,
  RequestCounts
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestCounts$ {
  /** @deprecated use `RequestCounts$inboundSchema` instead. */
  export const inboundSchema = RequestCounts$inboundSchema;
  /** @deprecated use `RequestCounts$outboundSchema` instead. */
  export const outboundSchema = RequestCounts$outboundSchema;
  /** @deprecated use `RequestCounts$Outbound` instead. */
  export type Outbound = RequestCounts$Outbound;
}

export function requestCountsToJSON(requestCounts: RequestCounts): string {
  return JSON.stringify(RequestCounts$outboundSchema.parse(requestCounts));
}

export function requestCountsFromJSON(
  jsonString: string,
): SafeParseResult<RequestCounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestCounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestCounts' from JSON`,
  );
}

/** @internal */
export const CreateBatchResponseBody$inboundSchema: z.ZodType<
  CreateBatchResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: CreateBatchObject$inboundSchema,
  endpoint: z.string(),
  errors: z.lazy(() => Errors$inboundSchema),
  input_file_id: z.string(),
  completion_window: z.string(),
  status: z.string(),
  output_file_id: z.nullable(z.string()),
  error_file_id: z.nullable(z.string()),
  created_at: z.number().int(),
  in_progress_at: z.nullable(z.number().int()),
  expires_at: z.nullable(z.number().int()),
  finalizing_at: z.nullable(z.number().int()),
  completed_at: z.nullable(z.number().int()),
  failed_at: z.nullable(z.number().int()),
  expired_at: z.nullable(z.number().int()),
  cancelling_at: z.nullable(z.number().int()),
  cancelled_at: z.nullable(z.number().int()),
  request_counts: z.lazy(() => RequestCounts$inboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "input_file_id": "inputFileId",
    "completion_window": "completionWindow",
    "output_file_id": "outputFileId",
    "error_file_id": "errorFileId",
    "created_at": "createdAt",
    "in_progress_at": "inProgressAt",
    "expires_at": "expiresAt",
    "finalizing_at": "finalizingAt",
    "completed_at": "completedAt",
    "failed_at": "failedAt",
    "expired_at": "expiredAt",
    "cancelling_at": "cancellingAt",
    "cancelled_at": "cancelledAt",
    "request_counts": "requestCounts",
  });
});

/** @internal */
export type CreateBatchResponseBody$Outbound = {
  id: string;
  object: string;
  endpoint: string;
  errors: Errors$Outbound;
  input_file_id: string;
  completion_window: string;
  status: string;
  output_file_id: string | null;
  error_file_id: string | null;
  created_at: number;
  in_progress_at: number | null;
  expires_at: number | null;
  finalizing_at: number | null;
  completed_at: number | null;
  failed_at: number | null;
  expired_at: number | null;
  cancelling_at: number | null;
  cancelled_at: number | null;
  request_counts: RequestCounts$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateBatchResponseBody$outboundSchema: z.ZodType<
  CreateBatchResponseBody$Outbound,
  z.ZodTypeDef,
  CreateBatchResponseBody
> = z.object({
  id: z.string(),
  object: CreateBatchObject$outboundSchema,
  endpoint: z.string(),
  errors: z.lazy(() => Errors$outboundSchema),
  inputFileId: z.string(),
  completionWindow: z.string(),
  status: z.string(),
  outputFileId: z.nullable(z.string()),
  errorFileId: z.nullable(z.string()),
  createdAt: z.number().int(),
  inProgressAt: z.nullable(z.number().int()),
  expiresAt: z.nullable(z.number().int()),
  finalizingAt: z.nullable(z.number().int()),
  completedAt: z.nullable(z.number().int()),
  failedAt: z.nullable(z.number().int()),
  expiredAt: z.nullable(z.number().int()),
  cancellingAt: z.nullable(z.number().int()),
  cancelledAt: z.nullable(z.number().int()),
  requestCounts: z.lazy(() => RequestCounts$outboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    inputFileId: "input_file_id",
    completionWindow: "completion_window",
    outputFileId: "output_file_id",
    errorFileId: "error_file_id",
    createdAt: "created_at",
    inProgressAt: "in_progress_at",
    expiresAt: "expires_at",
    finalizingAt: "finalizing_at",
    completedAt: "completed_at",
    failedAt: "failed_at",
    expiredAt: "expired_at",
    cancellingAt: "cancelling_at",
    cancelledAt: "cancelled_at",
    requestCounts: "request_counts",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateBatchResponseBody$ {
  /** @deprecated use `CreateBatchResponseBody$inboundSchema` instead. */
  export const inboundSchema = CreateBatchResponseBody$inboundSchema;
  /** @deprecated use `CreateBatchResponseBody$outboundSchema` instead. */
  export const outboundSchema = CreateBatchResponseBody$outboundSchema;
  /** @deprecated use `CreateBatchResponseBody$Outbound` instead. */
  export type Outbound = CreateBatchResponseBody$Outbound;
}

export function createBatchResponseBodyToJSON(
  createBatchResponseBody: CreateBatchResponseBody,
): string {
  return JSON.stringify(
    CreateBatchResponseBody$outboundSchema.parse(createBatchResponseBody),
  );
}

export function createBatchResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateBatchResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateBatchResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateBatchResponseBody' from JSON`,
  );
}
