/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const Voice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type Voice = ClosedEnum<typeof Voice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ModelConfigurationFormat = ClosedEnum<
  typeof ModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: Voice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ModelConfigurationFormat;
};

export const CreateAgentResponseFormatAgentsType = {
  JsonSchema: "json_schema",
} as const;
export type CreateAgentResponseFormatAgentsType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsType
>;

export type ResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type JSONSchema = {
  type: CreateAgentResponseFormatAgentsType;
  jsonSchema: ResponseFormatJsonSchema;
};

export const CreateAgentResponseFormatType = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatType = ClosedEnum<
  typeof CreateAgentResponseFormatType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type JSONObject = {
  type: CreateAgentResponseFormatType;
};

export const ResponseFormatType = {
  Text: "text",
} as const;
export type ResponseFormatType = ClosedEnum<typeof ResponseFormatType>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type Text = {
  type: ResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type ResponseFormat = JSONSchema | Text | JSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type Stop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const ModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type ModelConfigurationType = ClosedEnum<typeof ModelConfigurationType>;

export type Thinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: ModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ToolChoiceType = ClosedEnum<typeof ToolChoiceType>;

export type ToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type ToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ToolChoiceType | undefined;
  function: ToolChoiceFunction;
};

export const ToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ToolChoice1 = ClosedEnum<typeof ToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ToolChoice = ToolChoice2 | ToolChoice1;

export const Modalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type Modalities = ClosedEnum<typeof Modalities>;

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type ParametersT = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?: JSONSchema | Text | JSONObject | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: StreamOptions | null | undefined;
  thinking?: Thinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: ToolChoice2 | ToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<Modalities> | null | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters.
 */
export type ModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: ParametersT | undefined;
};

/**
 * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters.
 */
export type ModelConfiguration = ModelConfiguration2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const FallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type FallbackModelConfigurationVoice = ClosedEnum<
  typeof FallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const FallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type FallbackModelConfigurationFormat = ClosedEnum<
  typeof FallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type FallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: FallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: FallbackModelConfigurationFormat;
};

export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  {
    JsonSchema: "json_schema",
  } as const;
export type CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  >;

export type CreateAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentResponseFormatJSONSchema = {
  type: CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType;
  jsonSchema: CreateAgentResponseFormatAgentsJsonSchema;
};

export const CreateAgentResponseFormatAgentsRequestRequestBodyType = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatAgentsRequestRequestBodyType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ResponseFormatJSONObject = {
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType;
};

export const CreateAgentResponseFormatAgentsRequestType = {
  Text: "text",
} as const;
export type CreateAgentResponseFormatAgentsRequestType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsRequestType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ResponseFormatText = {
  type: CreateAgentResponseFormatAgentsRequestType;
};

/**
 * An object specifying the format that the model must output
 */
export type FallbackModelConfigurationResponseFormat =
  | CreateAgentResponseFormatJSONSchema
  | ResponseFormatText
  | ResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type FallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type FallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const FallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type FallbackModelConfigurationType = ClosedEnum<
  typeof FallbackModelConfigurationType
>;

export type FallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: FallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceType = ClosedEnum<
  typeof CreateAgentToolChoiceType
>;

export type CreateAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceType | undefined;
  function: CreateAgentToolChoiceFunction;
};

export const CreateAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoice1 = ClosedEnum<typeof CreateAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type FallbackModelConfigurationToolChoice =
  | CreateAgentToolChoice2
  | CreateAgentToolChoice1;

export const FallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type FallbackModelConfigurationModalities = ClosedEnum<
  typeof FallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type FallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: FallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormatJSONSchema
    | ResponseFormatText
    | ResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: FallbackModelConfigurationStreamOptions | null | undefined;
  thinking?: FallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: CreateAgentToolChoice2 | CreateAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<FallbackModelConfigurationModalities> | null | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type FallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: FallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type FallbackModelConfiguration = FallbackModelConfiguration2 | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

/**
 * Function tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
/**
 * Function tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type FunctionTool = {
  /**
   * Function tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type;
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Code execution tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
/**
 * Code execution tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type CodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type;
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * HTTP tool type
 */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
/**
 * HTTP tool type
 */
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type HTTPTool = {
  /**
   * HTTP tool type
   */
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type;
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type CurrentDateTool = {
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type QueryKnowledgeBaseTool = {
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type RetrieveKnowledgeBasesTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type DeleteMemoryDocumentTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Lists available memory stores
 */
export type RetrieveMemoryStoresTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  >;

/**
 * Writes information to agent memory stores
 */
export type WriteMemoryStoreTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType = {
  QueryMemoryStore: "query_memory_store",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType =
  ClosedEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType>;

/**
 * Queries agent memory stores for context
 */
export type QueryMemoryStoreTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsRequestType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsRequestType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDAgentsRequestType
>;

/**
 * Retrieves available agents in the system
 */
export type RetrieveAgentsTool = {
  type: CreateAgentAgentToolInputCRUDAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDAgentsType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type CreateAgentAgentToolInputCRUDAgentsType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDAgentsType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type CallSubAgentTool = {
  type: CreateAgentAgentToolInputCRUDAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const CreateAgentAgentToolInputCRUDType = {
  WebScraper: "web_scraper",
} as const;
export type CreateAgentAgentToolInputCRUDType = ClosedEnum<
  typeof CreateAgentAgentToolInputCRUDType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type WebScraperTool = {
  type: CreateAgentAgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const AgentToolInputCRUDType = {
  GoogleSearch: "google_search",
} as const;
export type AgentToolInputCRUDType = ClosedEnum<typeof AgentToolInputCRUDType>;

/**
 * Performs Google searches to retrieve web content
 */
export type GoogleSearchTool = {
  type: AgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function) must reference pre-created tools by key or id.
 */
export type AgentToolInputCRUD =
  | GoogleSearchTool
  | WebScraperTool
  | CallSubAgentTool
  | RetrieveAgentsTool
  | QueryMemoryStoreTool
  | WriteMemoryStoreTool
  | RetrieveMemoryStoresTool
  | DeleteMemoryDocumentTool
  | RetrieveKnowledgeBasesTool
  | QueryKnowledgeBaseTool
  | CurrentDateTool
  | HTTPTool
  | CodeExecutionTool
  | FunctionTool;

/**
 * Configuration settings for the agent's behavior
 */
export type Settings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | GoogleSearchTool
      | WebScraperTool
      | CallSubAgentTool
      | RetrieveAgentsTool
      | QueryMemoryStoreTool
      | WriteMemoryStoreTool
      | RetrieveMemoryStoresTool
      | DeleteMemoryDocumentTool
      | RetrieveKnowledgeBasesTool
      | QueryKnowledgeBaseTool
      | CurrentDateTool
      | HTTPTool
      | CodeExecutionTool
      | FunctionTool
    >
    | undefined;
};

export type KnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type TeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type CreateAgentRequestBody = {
  /**
   * The path where the agent will be stored in the project structure. The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * @remarks
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  /**
   * The role or function of the agent
   */
  role: string;
  /**
   * A brief description of what the agent does
   */
  description: string;
  /**
   * Detailed instructions that guide the agent's behavior
   */
  instructions: string;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters.
   */
  model: ModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?: Array<FallbackModelConfiguration2 | string> | undefined;
  /**
   * Configuration settings for the agent's behavior
   */
  settings: Settings;
  /**
   * Optional array of memory store identifiers for the agent to access. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Optional array of knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<KnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<TeamOfAgents> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const CreateAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type CreateAgentStatus = ClosedEnum<typeof CreateAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const CreateAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type CreateAgentToolApprovalRequired = ClosedEnum<
  typeof CreateAgentToolApprovalRequired
>;

export type Conditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type CreateAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<Conditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

export type CreateAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: CreateAgentToolApprovalRequired | undefined;
  tools?: Array<CreateAgentTools> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentVoice = ClosedEnum<typeof CreateAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentFormat = ClosedEnum<typeof CreateAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentFormat;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType = {
  JsonSchema: "json_schema",
} as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  >;

export type CreateAgentResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentResponseFormatAgentsResponse201JSONSchema = {
  type: CreateAgentResponseFormatAgentsResponse201ApplicationJSONType;
  jsonSchema: CreateAgentResponseFormatAgentsResponseJsonSchema;
};

export const CreateAgentResponseFormatAgentsResponse201Type = {
  JsonObject: "json_object",
} as const;
export type CreateAgentResponseFormatAgentsResponse201Type = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsResponse201Type
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentResponseFormatJSONObject = {
  type: CreateAgentResponseFormatAgentsResponse201Type;
};

export const CreateAgentResponseFormatAgentsResponseType = {
  Text: "text",
} as const;
export type CreateAgentResponseFormatAgentsResponseType = ClosedEnum<
  typeof CreateAgentResponseFormatAgentsResponseType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentResponseFormatText = {
  type: CreateAgentResponseFormatAgentsResponseType;
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentResponseFormat =
  | CreateAgentResponseFormatAgentsResponse201JSONSchema
  | CreateAgentResponseFormatText
  | CreateAgentResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentType = ClosedEnum<typeof CreateAgentType>;

export type CreateAgentThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceAgentsType = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsType
>;

export type CreateAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceAgentsType | undefined;
  function: CreateAgentToolChoiceAgentsFunction;
};

export const CreateAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoiceAgents1 = ClosedEnum<
  typeof CreateAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentToolChoice =
  | CreateAgentToolChoiceAgents2
  | CreateAgentToolChoiceAgents1;

export const CreateAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentModalities = ClosedEnum<typeof CreateAgentModalities>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type CreateAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormatAgentsResponse201JSONSchema
    | CreateAgentResponseFormatText
    | CreateAgentResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateAgentStreamOptions | null | undefined;
  thinking?: CreateAgentThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentToolChoiceAgents2
    | CreateAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateAgentModalities> | null | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof CreateAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof CreateAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateAgentFallbackModelConfigurationFormat;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType =
  {
    JsonSchema: "json_schema",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  >;

export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict?: boolean | undefined;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema =
  {
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType;
    jsonSchema:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema;
  };

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType =
  {
    JsonObject: "json_object",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  >;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateAgentResponseFormatAgentsJSONObject = {
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType;
};

export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  {
    Text: "text",
  } as const;
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  >;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateAgentResponseFormatAgentsText = {
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType;
};

/**
 * An object specifying the format that the model must output
 */
export type CreateAgentFallbackModelConfigurationResponseFormat =
  | CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
  | CreateAgentResponseFormatAgentsText
  | CreateAgentResponseFormatAgentsJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const CreateAgentFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type CreateAgentFallbackModelConfigurationType = ClosedEnum<
  typeof CreateAgentFallbackModelConfigurationType
>;

export type CreateAgentFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: CreateAgentFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateAgentToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateAgentToolChoiceAgentsResponseType = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsResponseType
>;

export type CreateAgentToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type CreateAgentToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateAgentToolChoiceAgentsResponseType | undefined;
  function: CreateAgentToolChoiceAgentsResponseFunction;
};

export const CreateAgentToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateAgentToolChoiceAgentsResponse1 = ClosedEnum<
  typeof CreateAgentToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateAgentFallbackModelConfigurationToolChoice =
  | CreateAgentToolChoiceAgentsResponse2
  | CreateAgentToolChoiceAgentsResponse1;

export const CreateAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof CreateAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type CreateAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
    | CreateAgentResponseFormatAgentsText
    | CreateAgentResponseFormatAgentsJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | CreateAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: CreateAgentFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateAgentToolChoiceAgentsResponse2
    | CreateAgentToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<CreateAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type CreateAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: CreateAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type CreateAgentFallbackModelConfiguration =
  | CreateAgentFallbackModelConfiguration2
  | string;

export type CreateAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: CreateAgentParameters | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<CreateAgentFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type CreateAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type Metrics = {
  totalCost?: number | undefined;
};

export type CreateAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const CreateAgentCollapsedConfigurationSections = {
  Information: "information",
  Model: "model",
  Tools: "tools",
  Context: "context",
  RuntimeConstraints: "runtime_constraints",
} as const;
export type CreateAgentCollapsedConfigurationSections = ClosedEnum<
  typeof CreateAgentCollapsedConfigurationSections
>;

/**
 * Agent created successfully
 */
export type CreateAgentResponseBody = {
  id: string;
  key: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: CreateAgentStatus;
  settings?: CreateAgentSettings | undefined;
  model: CreateAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<CreateAgentTeamOfAgents>;
  metrics?: Metrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<CreateAgentKnowledgeBases> | undefined;
  /**
   * List of collapsed sections in configuration. Duplicates are not allowed.
   */
  collapsedConfigurationSections?:
    | Array<CreateAgentCollapsedConfigurationSections>
    | undefined;
};

/** @internal */
export const Voice$inboundSchema: z.ZodNativeEnum<typeof Voice> = z.nativeEnum(
  Voice,
);
/** @internal */
export const Voice$outboundSchema: z.ZodNativeEnum<typeof Voice> =
  Voice$inboundSchema;

/** @internal */
export const ModelConfigurationFormat$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationFormat
> = z.nativeEnum(ModelConfigurationFormat);
/** @internal */
export const ModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationFormat
> = ModelConfigurationFormat$inboundSchema;

/** @internal */
export const ModelConfigurationAudio$inboundSchema: z.ZodType<
  ModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: Voice$inboundSchema,
  format: ModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type ModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const ModelConfigurationAudio$outboundSchema: z.ZodType<
  ModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  ModelConfigurationAudio
> = z.object({
  voice: Voice$outboundSchema,
  format: ModelConfigurationFormat$outboundSchema,
});

export function modelConfigurationAudioToJSON(
  modelConfigurationAudio: ModelConfigurationAudio,
): string {
  return JSON.stringify(
    ModelConfigurationAudio$outboundSchema.parse(modelConfigurationAudio),
  );
}
export function modelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatAgentsType
> = z.nativeEnum(CreateAgentResponseFormatAgentsType);
/** @internal */
export const CreateAgentResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsType> =
    CreateAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const ResponseFormatJsonSchema$inboundSchema: z.ZodType<
  ResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type ResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const ResponseFormatJsonSchema$outboundSchema: z.ZodType<
  ResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  ResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function responseFormatJsonSchemaToJSON(
  responseFormatJsonSchema: ResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    ResponseFormatJsonSchema$outboundSchema.parse(responseFormatJsonSchema),
  );
}
export function responseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const JSONSchema$inboundSchema: z.ZodType<
  JSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsType$inboundSchema,
  json_schema: z.lazy(() => ResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type JSONSchema$Outbound = {
  type: string;
  json_schema: ResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const JSONSchema$outboundSchema: z.ZodType<
  JSONSchema$Outbound,
  z.ZodTypeDef,
  JSONSchema
> = z.object({
  type: CreateAgentResponseFormatAgentsType$outboundSchema,
  jsonSchema: z.lazy(() => ResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function jsonSchemaToJSON(jsonSchema: JSONSchema): string {
  return JSON.stringify(JSONSchema$outboundSchema.parse(jsonSchema));
}
export function jsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<JSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatType
> = z.nativeEnum(CreateAgentResponseFormatType);
/** @internal */
export const CreateAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseFormatType
> = CreateAgentResponseFormatType$inboundSchema;

/** @internal */
export const JSONObject$inboundSchema: z.ZodType<
  JSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type JSONObject$Outbound = {
  type: string;
};

/** @internal */
export const JSONObject$outboundSchema: z.ZodType<
  JSONObject$Outbound,
  z.ZodTypeDef,
  JSONObject
> = z.object({
  type: CreateAgentResponseFormatType$outboundSchema,
});

export function jsonObjectToJSON(jsonObject: JSONObject): string {
  return JSON.stringify(JSONObject$outboundSchema.parse(jsonObject));
}
export function jsonObjectFromJSON(
  jsonString: string,
): SafeParseResult<JSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => JSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'JSONObject' from JSON`,
  );
}

/** @internal */
export const ResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormatType
> = z.nativeEnum(ResponseFormatType);
/** @internal */
export const ResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof ResponseFormatType
> = ResponseFormatType$inboundSchema;

/** @internal */
export const Text$inboundSchema: z.ZodType<Text, z.ZodTypeDef, unknown> = z
  .object({
    type: ResponseFormatType$inboundSchema,
  });
/** @internal */
export type Text$Outbound = {
  type: string;
};

/** @internal */
export const Text$outboundSchema: z.ZodType<Text$Outbound, z.ZodTypeDef, Text> =
  z.object({
    type: ResponseFormatType$outboundSchema,
  });

export function textToJSON(text: Text): string {
  return JSON.stringify(Text$outboundSchema.parse(text));
}
export function textFromJSON(
  jsonString: string,
): SafeParseResult<Text, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Text$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Text' from JSON`,
  );
}

/** @internal */
export const ResponseFormat$inboundSchema: z.ZodType<
  ResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => JSONSchema$inboundSchema),
  z.lazy(() => Text$inboundSchema),
  z.lazy(() => JSONObject$inboundSchema),
]);
/** @internal */
export type ResponseFormat$Outbound =
  | JSONSchema$Outbound
  | Text$Outbound
  | JSONObject$Outbound;

/** @internal */
export const ResponseFormat$outboundSchema: z.ZodType<
  ResponseFormat$Outbound,
  z.ZodTypeDef,
  ResponseFormat
> = z.union([
  z.lazy(() => JSONSchema$outboundSchema),
  z.lazy(() => Text$outboundSchema),
  z.lazy(() => JSONObject$outboundSchema),
]);

export function responseFormatToJSON(responseFormat: ResponseFormat): string {
  return JSON.stringify(ResponseFormat$outboundSchema.parse(responseFormat));
}
export function responseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat' from JSON`,
  );
}

/** @internal */
export const Stop$inboundSchema: z.ZodType<Stop, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.array(z.string())]);
/** @internal */
export type Stop$Outbound = string | Array<string>;

/** @internal */
export const Stop$outboundSchema: z.ZodType<Stop$Outbound, z.ZodTypeDef, Stop> =
  z.union([z.string(), z.array(z.string())]);

export function stopToJSON(stop: Stop): string {
  return JSON.stringify(Stop$outboundSchema.parse(stop));
}
export function stopFromJSON(
  jsonString: string,
): SafeParseResult<Stop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Stop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Stop' from JSON`,
  );
}

/** @internal */
export const StreamOptions$inboundSchema: z.ZodType<
  StreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type StreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamOptions$outboundSchema: z.ZodType<
  StreamOptions$Outbound,
  z.ZodTypeDef,
  StreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function streamOptionsToJSON(streamOptions: StreamOptions): string {
  return JSON.stringify(StreamOptions$outboundSchema.parse(streamOptions));
}
export function streamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<StreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamOptions' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationType
> = z.nativeEnum(ModelConfigurationType);
/** @internal */
export const ModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationType
> = ModelConfigurationType$inboundSchema;

/** @internal */
export const Thinking$inboundSchema: z.ZodType<
  Thinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type Thinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const Thinking$outboundSchema: z.ZodType<
  Thinking$Outbound,
  z.ZodTypeDef,
  Thinking
> = z.object({
  type: ModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function thinkingToJSON(thinking: Thinking): string {
  return JSON.stringify(Thinking$outboundSchema.parse(thinking));
}
export function thinkingFromJSON(
  jsonString: string,
): SafeParseResult<Thinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thinking' from JSON`,
  );
}

/** @internal */
export const ToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = z.nativeEnum(ToolChoiceType);
/** @internal */
export const ToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof ToolChoiceType
> = ToolChoiceType$inboundSchema;

/** @internal */
export const ToolChoiceFunction$inboundSchema: z.ZodType<
  ToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type ToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const ToolChoiceFunction$outboundSchema: z.ZodType<
  ToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  ToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function toolChoiceFunctionToJSON(
  toolChoiceFunction: ToolChoiceFunction,
): string {
  return JSON.stringify(
    ToolChoiceFunction$outboundSchema.parse(toolChoiceFunction),
  );
}
export function toolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ToolChoice2$inboundSchema: z.ZodType<
  ToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$inboundSchema),
});
/** @internal */
export type ToolChoice2$Outbound = {
  type?: string | undefined;
  function: ToolChoiceFunction$Outbound;
};

/** @internal */
export const ToolChoice2$outboundSchema: z.ZodType<
  ToolChoice2$Outbound,
  z.ZodTypeDef,
  ToolChoice2
> = z.object({
  type: ToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => ToolChoiceFunction$outboundSchema),
});

export function toolChoice2ToJSON(toolChoice2: ToolChoice2): string {
  return JSON.stringify(ToolChoice2$outboundSchema.parse(toolChoice2));
}
export function toolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice2' from JSON`,
  );
}

/** @internal */
export const ToolChoice1$inboundSchema: z.ZodNativeEnum<typeof ToolChoice1> = z
  .nativeEnum(ToolChoice1);
/** @internal */
export const ToolChoice1$outboundSchema: z.ZodNativeEnum<typeof ToolChoice1> =
  ToolChoice1$inboundSchema;

/** @internal */
export const ToolChoice$inboundSchema: z.ZodType<
  ToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ToolChoice2$inboundSchema),
  ToolChoice1$inboundSchema,
]);
/** @internal */
export type ToolChoice$Outbound = ToolChoice2$Outbound | string;

/** @internal */
export const ToolChoice$outboundSchema: z.ZodType<
  ToolChoice$Outbound,
  z.ZodTypeDef,
  ToolChoice
> = z.union([
  z.lazy(() => ToolChoice2$outboundSchema),
  ToolChoice1$outboundSchema,
]);

export function toolChoiceToJSON(toolChoice: ToolChoice): string {
  return JSON.stringify(ToolChoice$outboundSchema.parse(toolChoice));
}
export function toolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolChoice' from JSON`,
  );
}

/** @internal */
export const Modalities$inboundSchema: z.ZodNativeEnum<typeof Modalities> = z
  .nativeEnum(Modalities);
/** @internal */
export const Modalities$outboundSchema: z.ZodNativeEnum<typeof Modalities> =
  Modalities$inboundSchema;

/** @internal */
export const ParametersT$inboundSchema: z.ZodType<
  ParametersT,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ModelConfigurationAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => JSONSchema$inboundSchema),
    z.lazy(() => Text$inboundSchema),
    z.lazy(() => JSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(z.lazy(() => StreamOptions$inboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ToolChoice2$inboundSchema),
    ToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type ParametersT$Outbound = {
  audio?: ModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | JSONSchema$Outbound
    | Text$Outbound
    | JSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: StreamOptions$Outbound | null | undefined;
  thinking?: Thinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: ToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const ParametersT$outboundSchema: z.ZodType<
  ParametersT$Outbound,
  z.ZodTypeDef,
  ParametersT
> = z.object({
  audio: z.nullable(z.lazy(() => ModelConfigurationAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => JSONSchema$outboundSchema),
    z.lazy(() => Text$outboundSchema),
    z.lazy(() => JSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => StreamOptions$outboundSchema))
    .optional(),
  thinking: z.lazy(() => Thinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => ToolChoice2$outboundSchema),
    ToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(Modalities$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function parametersToJSON(parametersT: ParametersT): string {
  return JSON.stringify(ParametersT$outboundSchema.parse(parametersT));
}
export function parametersFromJSON(
  jsonString: string,
): SafeParseResult<ParametersT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ParametersT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ParametersT' from JSON`,
  );
}

/** @internal */
export const ModelConfiguration2$inboundSchema: z.ZodType<
  ModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ParametersT$inboundSchema).optional(),
});
/** @internal */
export type ModelConfiguration2$Outbound = {
  id: string;
  parameters?: ParametersT$Outbound | undefined;
};

/** @internal */
export const ModelConfiguration2$outboundSchema: z.ZodType<
  ModelConfiguration2$Outbound,
  z.ZodTypeDef,
  ModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ParametersT$outboundSchema).optional(),
});

export function modelConfiguration2ToJSON(
  modelConfiguration2: ModelConfiguration2,
): string {
  return JSON.stringify(
    ModelConfiguration2$outboundSchema.parse(modelConfiguration2),
  );
}
export function modelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<ModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const ModelConfiguration$inboundSchema: z.ZodType<
  ModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => ModelConfiguration2$inboundSchema), z.string()]);
/** @internal */
export type ModelConfiguration$Outbound = ModelConfiguration2$Outbound | string;

/** @internal */
export const ModelConfiguration$outboundSchema: z.ZodType<
  ModelConfiguration$Outbound,
  z.ZodTypeDef,
  ModelConfiguration
> = z.union([z.lazy(() => ModelConfiguration2$outboundSchema), z.string()]);

export function modelConfigurationToJSON(
  modelConfiguration: ModelConfiguration,
): string {
  return JSON.stringify(
    ModelConfiguration$outboundSchema.parse(modelConfiguration),
  );
}
export function modelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfiguration' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationVoice$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationVoice
> = z.nativeEnum(FallbackModelConfigurationVoice);
/** @internal */
export const FallbackModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationVoice
> = FallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const FallbackModelConfigurationFormat$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationFormat
> = z.nativeEnum(FallbackModelConfigurationFormat);
/** @internal */
export const FallbackModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationFormat
> = FallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const FallbackModelConfigurationAudio$inboundSchema: z.ZodType<
  FallbackModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: FallbackModelConfigurationVoice$inboundSchema,
  format: FallbackModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type FallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const FallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  FallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationAudio
> = z.object({
  voice: FallbackModelConfigurationVoice$outboundSchema,
  format: FallbackModelConfigurationFormat$outboundSchema,
});

export function fallbackModelConfigurationAudioToJSON(
  fallbackModelConfigurationAudio: FallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    FallbackModelConfigurationAudio$outboundSchema.parse(
      fallbackModelConfigurationAudio,
    ),
  );
}
export function fallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > =
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type CreateAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function createAgentResponseFormatAgentsJsonSchemaToJSON(
  createAgentResponseFormatAgentsJsonSchema:
    CreateAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      createAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function createAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatJSONSchema$inboundSchema: z.ZodType<
  CreateAgentResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema,
  json_schema: z.lazy(() =>
    CreateAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type CreateAgentResponseFormatJSONSchema$Outbound = {
  type: string;
  json_schema: CreateAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  CreateAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatJSONSchema
> = z.object({
  type:
    CreateAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema,
  jsonSchema: z.lazy(() =>
    CreateAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function createAgentResponseFormatJSONSchemaToJSON(
  createAgentResponseFormatJSONSchema: CreateAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatJSONSchema$outboundSchema.parse(
      createAgentResponseFormatJSONSchema,
    ),
  );
}
export function createAgentResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
  > = z.nativeEnum(CreateAgentResponseFormatAgentsRequestRequestBodyType);
/** @internal */
export const CreateAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsRequestRequestBodyType
  > = CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const ResponseFormatJSONObject$inboundSchema: z.ZodType<
  ResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema,
});
/** @internal */
export type ResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormatJSONObject$outboundSchema: z.ZodType<
  ResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  ResponseFormatJSONObject
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema,
});

export function responseFormatJSONObjectToJSON(
  responseFormatJSONObject: ResponseFormatJSONObject,
): string {
  return JSON.stringify(
    ResponseFormatJSONObject$outboundSchema.parse(responseFormatJSONObject),
  );
}
export function responseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsRequestType> = z
    .nativeEnum(CreateAgentResponseFormatAgentsRequestType);
/** @internal */
export const CreateAgentResponseFormatAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsRequestType> =
    CreateAgentResponseFormatAgentsRequestType$inboundSchema;

/** @internal */
export const ResponseFormatText$inboundSchema: z.ZodType<
  ResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestType$inboundSchema,
});
/** @internal */
export type ResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormatText$outboundSchema: z.ZodType<
  ResponseFormatText$Outbound,
  z.ZodTypeDef,
  ResponseFormatText
> = z.object({
  type: CreateAgentResponseFormatAgentsRequestType$outboundSchema,
});

export function responseFormatTextToJSON(
  responseFormatText: ResponseFormatText,
): string {
  return JSON.stringify(
    ResponseFormatText$outboundSchema.parse(responseFormatText),
  );
}
export function responseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormatText' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationResponseFormat$inboundSchema: z.ZodType<
  FallbackModelConfigurationResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentResponseFormatJSONSchema$inboundSchema),
  z.lazy(() => ResponseFormatText$inboundSchema),
  z.lazy(() => ResponseFormatJSONObject$inboundSchema),
]);
/** @internal */
export type FallbackModelConfigurationResponseFormat$Outbound =
  | CreateAgentResponseFormatJSONSchema$Outbound
  | ResponseFormatText$Outbound
  | ResponseFormatJSONObject$Outbound;

/** @internal */
export const FallbackModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  FallbackModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => CreateAgentResponseFormatJSONSchema$outboundSchema),
  z.lazy(() => ResponseFormatText$outboundSchema),
  z.lazy(() => ResponseFormatJSONObject$outboundSchema),
]);

export function fallbackModelConfigurationResponseFormatToJSON(
  fallbackModelConfigurationResponseFormat:
    FallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    FallbackModelConfigurationResponseFormat$outboundSchema.parse(
      fallbackModelConfigurationResponseFormat,
    ),
  );
}
export function fallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  FallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationStop$inboundSchema: z.ZodType<
  FallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type FallbackModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const FallbackModelConfigurationStop$outboundSchema: z.ZodType<
  FallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function fallbackModelConfigurationStopToJSON(
  fallbackModelConfigurationStop: FallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStop$outboundSchema.parse(
      fallbackModelConfigurationStop,
    ),
  );
}
export function fallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationStreamOptions$inboundSchema: z.ZodType<
  FallbackModelConfigurationStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type FallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const FallbackModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  FallbackModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function fallbackModelConfigurationStreamOptionsToJSON(
  fallbackModelConfigurationStreamOptions:
    FallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    FallbackModelConfigurationStreamOptions$outboundSchema.parse(
      fallbackModelConfigurationStreamOptions,
    ),
  );
}
export function fallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  FallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'FallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationType
> = z.nativeEnum(FallbackModelConfigurationType);
/** @internal */
export const FallbackModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof FallbackModelConfigurationType
> = FallbackModelConfigurationType$inboundSchema;

/** @internal */
export const FallbackModelConfigurationThinking$inboundSchema: z.ZodType<
  FallbackModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: FallbackModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type FallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const FallbackModelConfigurationThinking$outboundSchema: z.ZodType<
  FallbackModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationThinking
> = z.object({
  type: FallbackModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function fallbackModelConfigurationThinkingToJSON(
  fallbackModelConfigurationThinking: FallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    FallbackModelConfigurationThinking$outboundSchema.parse(
      fallbackModelConfigurationThinking,
    ),
  );
}
export function fallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceType
> = z.nativeEnum(CreateAgentToolChoiceType);
/** @internal */
export const CreateAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceType
> = CreateAgentToolChoiceType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceFunction$inboundSchema: z.ZodType<
  CreateAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type CreateAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceFunction$outboundSchema: z.ZodType<
  CreateAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function createAgentToolChoiceFunctionToJSON(
  createAgentToolChoiceFunction: CreateAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceFunction$outboundSchema.parse(
      createAgentToolChoiceFunction,
    ),
  );
}
export function createAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoice2$inboundSchema: z.ZodType<
  CreateAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type CreateAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoice2$outboundSchema: z.ZodType<
  CreateAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoice2
> = z.object({
  type: CreateAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceFunction$outboundSchema),
});

export function createAgentToolChoice2ToJSON(
  createAgentToolChoice2: CreateAgentToolChoice2,
): string {
  return JSON.stringify(
    CreateAgentToolChoice2$outboundSchema.parse(createAgentToolChoice2),
  );
}
export function createAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoice1
> = z.nativeEnum(CreateAgentToolChoice1);
/** @internal */
export const CreateAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoice1
> = CreateAgentToolChoice1$inboundSchema;

/** @internal */
export const FallbackModelConfigurationToolChoice$inboundSchema: z.ZodType<
  FallbackModelConfigurationToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentToolChoice2$inboundSchema),
  CreateAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type FallbackModelConfigurationToolChoice$Outbound =
  | CreateAgentToolChoice2$Outbound
  | string;

/** @internal */
export const FallbackModelConfigurationToolChoice$outboundSchema: z.ZodType<
  FallbackModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationToolChoice
> = z.union([
  z.lazy(() => CreateAgentToolChoice2$outboundSchema),
  CreateAgentToolChoice1$outboundSchema,
]);

export function fallbackModelConfigurationToolChoiceToJSON(
  fallbackModelConfigurationToolChoice: FallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    FallbackModelConfigurationToolChoice$outboundSchema.parse(
      fallbackModelConfigurationToolChoice,
    ),
  );
}
export function fallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationModalities> = z.nativeEnum(
    FallbackModelConfigurationModalities,
  );
/** @internal */
export const FallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof FallbackModelConfigurationModalities> =
    FallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const FallbackModelConfigurationParameters$inboundSchema: z.ZodType<
  FallbackModelConfigurationParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => FallbackModelConfigurationAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateAgentResponseFormatJSONSchema$inboundSchema),
    z.lazy(() => ResponseFormatText$inboundSchema),
    z.lazy(() => ResponseFormatJSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => FallbackModelConfigurationStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelConfigurationThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentToolChoice2$inboundSchema),
    CreateAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(FallbackModelConfigurationModalities$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type FallbackModelConfigurationParameters$Outbound = {
  audio?: FallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormatJSONSchema$Outbound
    | ResponseFormatText$Outbound
    | ResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | FallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: FallbackModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const FallbackModelConfigurationParameters$outboundSchema: z.ZodType<
  FallbackModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  FallbackModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => FallbackModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateAgentResponseFormatJSONSchema$outboundSchema),
    z.lazy(() => ResponseFormatText$outboundSchema),
    z.lazy(() => ResponseFormatJSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => FallbackModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => FallbackModelConfigurationThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentToolChoice2$outboundSchema),
    CreateAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(FallbackModelConfigurationModalities$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function fallbackModelConfigurationParametersToJSON(
  fallbackModelConfigurationParameters: FallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    FallbackModelConfigurationParameters$outboundSchema.parse(
      fallbackModelConfigurationParameters,
    ),
  );
}
export function fallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfigurationParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      FallbackModelConfigurationParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfiguration2$inboundSchema: z.ZodType<
  FallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => FallbackModelConfigurationParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type FallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?: FallbackModelConfigurationParameters$Outbound | undefined;
};

/** @internal */
export const FallbackModelConfiguration2$outboundSchema: z.ZodType<
  FallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => FallbackModelConfigurationParameters$outboundSchema)
    .optional(),
});

export function fallbackModelConfiguration2ToJSON(
  fallbackModelConfiguration2: FallbackModelConfiguration2,
): string {
  return JSON.stringify(
    FallbackModelConfiguration2$outboundSchema.parse(
      fallbackModelConfiguration2,
    ),
  );
}
export function fallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const FallbackModelConfiguration$inboundSchema: z.ZodType<
  FallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type FallbackModelConfiguration$Outbound =
  | FallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const FallbackModelConfiguration$outboundSchema: z.ZodType<
  FallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  FallbackModelConfiguration
> = z.union([
  z.lazy(() => FallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function fallbackModelConfigurationToJSON(
  fallbackModelConfiguration: FallbackModelConfiguration,
): string {
  return JSON.stringify(
    FallbackModelConfiguration$outboundSchema.parse(fallbackModelConfiguration),
  );
}
export function fallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<FallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);
/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = ToolApprovalRequired$inboundSchema;

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema;

/** @internal */
export const FunctionTool$inboundSchema: z.ZodType<
  FunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type FunctionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const FunctionTool$outboundSchema: z.ZodType<
  FunctionTool$Outbound,
  z.ZodTypeDef,
  FunctionTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function functionToolToJSON(functionTool: FunctionTool): string {
  return JSON.stringify(FunctionTool$outboundSchema.parse(functionTool));
}
export function functionToolFromJSON(
  jsonString: string,
): SafeParseResult<FunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema;

/** @internal */
export const CodeExecutionTool$inboundSchema: z.ZodType<
  CodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CodeExecutionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const CodeExecutionTool$outboundSchema: z.ZodType<
  CodeExecutionTool$Outbound,
  z.ZodTypeDef,
  CodeExecutionTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function codeExecutionToolToJSON(
  codeExecutionTool: CodeExecutionTool,
): string {
  return JSON.stringify(
    CodeExecutionTool$outboundSchema.parse(codeExecutionTool),
  );
}
export function codeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<CodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema;

/** @internal */
export const HTTPTool$inboundSchema: z.ZodType<
  HTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$inboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type HTTPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const HTTPTool$outboundSchema: z.ZodType<
  HTTPTool$Outbound,
  z.ZodTypeDef,
  HTTPTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema,
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function httpToolToJSON(httpTool: HTTPTool): string {
  return JSON.stringify(HTTPTool$outboundSchema.parse(httpTool));
}
export function httpToolFromJSON(
  jsonString: string,
): SafeParseResult<HTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HTTPTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema;

/** @internal */
export const CurrentDateTool$inboundSchema: z.ZodType<
  CurrentDateTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CurrentDateTool$outboundSchema: z.ZodType<
  CurrentDateTool$Outbound,
  z.ZodTypeDef,
  CurrentDateTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function currentDateToolToJSON(
  currentDateTool: CurrentDateTool,
): string {
  return JSON.stringify(CurrentDateTool$outboundSchema.parse(currentDateTool));
}
export function currentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<CurrentDateTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CurrentDateTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CurrentDateTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema;

/** @internal */
export const QueryKnowledgeBaseTool$inboundSchema: z.ZodType<
  QueryKnowledgeBaseTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  QueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  QueryKnowledgeBaseTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryKnowledgeBaseToolToJSON(
  queryKnowledgeBaseTool: QueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    QueryKnowledgeBaseTool$outboundSchema.parse(queryKnowledgeBaseTool),
  );
}
export function queryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryKnowledgeBaseTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryKnowledgeBaseTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema;

/** @internal */
export const RetrieveKnowledgeBasesTool$inboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveKnowledgeBasesTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveKnowledgeBasesTool$outboundSchema: z.ZodType<
  RetrieveKnowledgeBasesTool$Outbound,
  z.ZodTypeDef,
  RetrieveKnowledgeBasesTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveKnowledgeBasesToolToJSON(
  retrieveKnowledgeBasesTool: RetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    RetrieveKnowledgeBasesTool$outboundSchema.parse(retrieveKnowledgeBasesTool),
  );
}
export function retrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveKnowledgeBasesTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveKnowledgeBasesTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema;

/** @internal */
export const DeleteMemoryDocumentTool$inboundSchema: z.ZodType<
  DeleteMemoryDocumentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type DeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const DeleteMemoryDocumentTool$outboundSchema: z.ZodType<
  DeleteMemoryDocumentTool$Outbound,
  z.ZodTypeDef,
  DeleteMemoryDocumentTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function deleteMemoryDocumentToolToJSON(
  deleteMemoryDocumentTool: DeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    DeleteMemoryDocumentTool$outboundSchema.parse(deleteMemoryDocumentTool),
  );
}
export function deleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<DeleteMemoryDocumentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeleteMemoryDocumentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema;

/** @internal */
export const RetrieveMemoryStoresTool$inboundSchema: z.ZodType<
  RetrieveMemoryStoresTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveMemoryStoresTool$outboundSchema: z.ZodType<
  RetrieveMemoryStoresTool$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryStoresTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveMemoryStoresToolToJSON(
  retrieveMemoryStoresTool: RetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    RetrieveMemoryStoresTool$outboundSchema.parse(retrieveMemoryStoresTool),
  );
}
export function retrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryStoresTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryStoresTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType,
  );
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > =
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema;

/** @internal */
export const WriteMemoryStoreTool$inboundSchema: z.ZodType<
  WriteMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WriteMemoryStoreTool$outboundSchema: z.ZodType<
  WriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  WriteMemoryStoreTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function writeMemoryStoreToolToJSON(
  writeMemoryStoreTool: WriteMemoryStoreTool,
): string {
  return JSON.stringify(
    WriteMemoryStoreTool$outboundSchema.parse(writeMemoryStoreTool),
  );
}
export function writeMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<WriteMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WriteMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
  > = z.nativeEnum(CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
  > = CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const QueryMemoryStoreTool$inboundSchema: z.ZodType<
  QueryMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type QueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const QueryMemoryStoreTool$outboundSchema: z.ZodType<
  QueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  QueryMemoryStoreTool
> = z.object({
  type:
    CreateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function queryMemoryStoreToolToJSON(
  queryMemoryStoreTool: QueryMemoryStoreTool,
): string {
  return JSON.stringify(
    QueryMemoryStoreTool$outboundSchema.parse(queryMemoryStoreTool),
  );
}
export function queryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<QueryMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => QueryMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'QueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestType> = z
    .nativeEnum(CreateAgentAgentToolInputCRUDAgentsRequestType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsRequestType> =
    CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema;

/** @internal */
export const RetrieveAgentsTool$inboundSchema: z.ZodType<
  RetrieveAgentsTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type RetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const RetrieveAgentsTool$outboundSchema: z.ZodType<
  RetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  RetrieveAgentsTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function retrieveAgentsToolToJSON(
  retrieveAgentsTool: RetrieveAgentsTool,
): string {
  return JSON.stringify(
    RetrieveAgentsTool$outboundSchema.parse(retrieveAgentsTool),
  );
}
export function retrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveAgentsTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveAgentsTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsType> = z
    .nativeEnum(CreateAgentAgentToolInputCRUDAgentsType);
/** @internal */
export const CreateAgentAgentToolInputCRUDAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentAgentToolInputCRUDAgentsType> =
    CreateAgentAgentToolInputCRUDAgentsType$inboundSchema;

/** @internal */
export const CallSubAgentTool$inboundSchema: z.ZodType<
  CallSubAgentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const CallSubAgentTool$outboundSchema: z.ZodType<
  CallSubAgentTool$Outbound,
  z.ZodTypeDef,
  CallSubAgentTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDAgentsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function callSubAgentToolToJSON(
  callSubAgentTool: CallSubAgentTool,
): string {
  return JSON.stringify(
    CallSubAgentTool$outboundSchema.parse(callSubAgentTool),
  );
}
export function callSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<CallSubAgentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CallSubAgentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const CreateAgentAgentToolInputCRUDType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentAgentToolInputCRUDType
> = z.nativeEnum(CreateAgentAgentToolInputCRUDType);
/** @internal */
export const CreateAgentAgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentAgentToolInputCRUDType
> = CreateAgentAgentToolInputCRUDType$inboundSchema;

/** @internal */
export const WebScraperTool$inboundSchema: z.ZodType<
  WebScraperTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentAgentToolInputCRUDType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type WebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const WebScraperTool$outboundSchema: z.ZodType<
  WebScraperTool$Outbound,
  z.ZodTypeDef,
  WebScraperTool
> = z.object({
  type: CreateAgentAgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function webScraperToolToJSON(webScraperTool: WebScraperTool): string {
  return JSON.stringify(WebScraperTool$outboundSchema.parse(webScraperTool));
}
export function webScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<WebScraperTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => WebScraperTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'WebScraperTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDType$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputCRUDType
> = z.nativeEnum(AgentToolInputCRUDType);
/** @internal */
export const AgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputCRUDType
> = AgentToolInputCRUDType$inboundSchema;

/** @internal */
export const GoogleSearchTool$inboundSchema: z.ZodType<
  GoogleSearchTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AgentToolInputCRUDType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type GoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const GoogleSearchTool$outboundSchema: z.ZodType<
  GoogleSearchTool$Outbound,
  z.ZodTypeDef,
  GoogleSearchTool
> = z.object({
  type: AgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function googleSearchToolToJSON(
  googleSearchTool: GoogleSearchTool,
): string {
  return JSON.stringify(
    GoogleSearchTool$outboundSchema.parse(googleSearchTool),
  );
}
export function googleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<GoogleSearchTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GoogleSearchTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUD$inboundSchema: z.ZodType<
  AgentToolInputCRUD,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GoogleSearchTool$inboundSchema),
  z.lazy(() => WebScraperTool$inboundSchema),
  z.lazy(() => CallSubAgentTool$inboundSchema),
  z.lazy(() => RetrieveAgentsTool$inboundSchema),
  z.lazy(() => QueryMemoryStoreTool$inboundSchema),
  z.lazy(() => WriteMemoryStoreTool$inboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
  z.lazy(() => CurrentDateTool$inboundSchema),
  z.lazy(() => HTTPTool$inboundSchema),
  z.lazy(() => CodeExecutionTool$inboundSchema),
  z.lazy(() => FunctionTool$inboundSchema),
]);
/** @internal */
export type AgentToolInputCRUD$Outbound =
  | GoogleSearchTool$Outbound
  | WebScraperTool$Outbound
  | CallSubAgentTool$Outbound
  | RetrieveAgentsTool$Outbound
  | QueryMemoryStoreTool$Outbound
  | WriteMemoryStoreTool$Outbound
  | RetrieveMemoryStoresTool$Outbound
  | DeleteMemoryDocumentTool$Outbound
  | RetrieveKnowledgeBasesTool$Outbound
  | QueryKnowledgeBaseTool$Outbound
  | CurrentDateTool$Outbound
  | HTTPTool$Outbound
  | CodeExecutionTool$Outbound
  | FunctionTool$Outbound;

/** @internal */
export const AgentToolInputCRUD$outboundSchema: z.ZodType<
  AgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUD
> = z.union([
  z.lazy(() => GoogleSearchTool$outboundSchema),
  z.lazy(() => WebScraperTool$outboundSchema),
  z.lazy(() => CallSubAgentTool$outboundSchema),
  z.lazy(() => RetrieveAgentsTool$outboundSchema),
  z.lazy(() => QueryMemoryStoreTool$outboundSchema),
  z.lazy(() => WriteMemoryStoreTool$outboundSchema),
  z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => CurrentDateTool$outboundSchema),
  z.lazy(() => HTTPTool$outboundSchema),
  z.lazy(() => CodeExecutionTool$outboundSchema),
  z.lazy(() => FunctionTool$outboundSchema),
]);

export function agentToolInputCRUDToJSON(
  agentToolInputCRUD: AgentToolInputCRUD,
): string {
  return JSON.stringify(
    AgentToolInputCRUD$outboundSchema.parse(agentToolInputCRUD),
  );
}
export function agentToolInputCRUDFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUD, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUD$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUD' from JSON`,
  );
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$inboundSchema),
      z.lazy(() => WebScraperTool$inboundSchema),
      z.lazy(() => CallSubAgentTool$inboundSchema),
      z.lazy(() => RetrieveAgentsTool$inboundSchema),
      z.lazy(() => QueryMemoryStoreTool$inboundSchema),
      z.lazy(() => WriteMemoryStoreTool$inboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$inboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$inboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$inboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$inboundSchema),
      z.lazy(() => CurrentDateTool$inboundSchema),
      z.lazy(() => HTTPTool$inboundSchema),
      z.lazy(() => CodeExecutionTool$inboundSchema),
      z.lazy(() => FunctionTool$inboundSchema),
    ]),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type Settings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | GoogleSearchTool$Outbound
      | WebScraperTool$Outbound
      | CallSubAgentTool$Outbound
      | RetrieveAgentsTool$Outbound
      | QueryMemoryStoreTool$Outbound
      | WriteMemoryStoreTool$Outbound
      | RetrieveMemoryStoresTool$Outbound
      | DeleteMemoryDocumentTool$Outbound
      | RetrieveKnowledgeBasesTool$Outbound
      | QueryKnowledgeBaseTool$Outbound
      | CurrentDateTool$Outbound
      | HTTPTool$Outbound
      | CodeExecutionTool$Outbound
      | FunctionTool$Outbound
    >
    | undefined;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => GoogleSearchTool$outboundSchema),
      z.lazy(() => WebScraperTool$outboundSchema),
      z.lazy(() => CallSubAgentTool$outboundSchema),
      z.lazy(() => RetrieveAgentsTool$outboundSchema),
      z.lazy(() => QueryMemoryStoreTool$outboundSchema),
      z.lazy(() => WriteMemoryStoreTool$outboundSchema),
      z.lazy(() => RetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => DeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => RetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => QueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => CurrentDateTool$outboundSchema),
      z.lazy(() => HTTPTool$outboundSchema),
      z.lazy(() => CodeExecutionTool$outboundSchema),
      z.lazy(() => FunctionTool$outboundSchema),
    ]),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}
export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const KnowledgeBases$inboundSchema: z.ZodType<
  KnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type KnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const KnowledgeBases$outboundSchema: z.ZodType<
  KnowledgeBases$Outbound,
  z.ZodTypeDef,
  KnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function knowledgeBasesToJSON(knowledgeBases: KnowledgeBases): string {
  return JSON.stringify(KnowledgeBases$outboundSchema.parse(knowledgeBases));
}
export function knowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeBases' from JSON`,
  );
}

/** @internal */
export const TeamOfAgents$inboundSchema: z.ZodType<
  TeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type TeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const TeamOfAgents$outboundSchema: z.ZodType<
  TeamOfAgents$Outbound,
  z.ZodTypeDef,
  TeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function teamOfAgentsToJSON(teamOfAgents: TeamOfAgents): string {
  return JSON.stringify(TeamOfAgents$outboundSchema.parse(teamOfAgents));
}
export function teamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<TeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamOfAgents' from JSON`,
  );
}

/** @internal */
export const CreateAgentRequestBody$inboundSchema: z.ZodType<
  CreateAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  path: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  system_prompt: z.string().optional(),
  model: z.union([z.lazy(() => ModelConfiguration2$inboundSchema), z.string()]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => FallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => Settings$inboundSchema),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(z.lazy(() => KnowledgeBases$inboundSchema))
    .optional(),
  team_of_agents: z.array(z.lazy(() => TeamOfAgents$inboundSchema)).optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "system_prompt": "systemPrompt",
    "fallback_models": "fallbackModels",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});
/** @internal */
export type CreateAgentRequestBody$Outbound = {
  path: string;
  key: string;
  role: string;
  description: string;
  instructions: string;
  system_prompt?: string | undefined;
  model: ModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<FallbackModelConfiguration2$Outbound | string>
    | undefined;
  settings: Settings$Outbound;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<KnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<TeamOfAgents$Outbound> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/** @internal */
export const CreateAgentRequestBody$outboundSchema: z.ZodType<
  CreateAgentRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentRequestBody
> = z.object({
  path: z.string(),
  key: z.string(),
  role: z.string(),
  description: z.string(),
  instructions: z.string(),
  systemPrompt: z.string().optional(),
  model: z.union([
    z.lazy(() => ModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => FallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => Settings$outboundSchema),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => KnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => TeamOfAgents$outboundSchema)).optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function createAgentRequestBodyToJSON(
  createAgentRequestBody: CreateAgentRequestBody,
): string {
  return JSON.stringify(
    CreateAgentRequestBody$outboundSchema.parse(createAgentRequestBody),
  );
}
export function createAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentStatus
> = z.nativeEnum(CreateAgentStatus);
/** @internal */
export const CreateAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentStatus
> = CreateAgentStatus$inboundSchema;

/** @internal */
export const CreateAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolApprovalRequired
> = z.nativeEnum(CreateAgentToolApprovalRequired);
/** @internal */
export const CreateAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolApprovalRequired
> = CreateAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const Conditions$inboundSchema: z.ZodType<
  Conditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type Conditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const Conditions$outboundSchema: z.ZodType<
  Conditions$Outbound,
  z.ZodTypeDef,
  Conditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function conditionsToJSON(conditions: Conditions): string {
  return JSON.stringify(Conditions$outboundSchema.parse(conditions));
}
export function conditionsFromJSON(
  jsonString: string,
): SafeParseResult<Conditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conditions' from JSON`,
  );
}

/** @internal */
export const CreateAgentTools$inboundSchema: z.ZodType<
  CreateAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => Conditions$inboundSchema)).optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CreateAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<Conditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const CreateAgentTools$outboundSchema: z.ZodType<
  CreateAgentTools$Outbound,
  z.ZodTypeDef,
  CreateAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => Conditions$outboundSchema)).optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function createAgentToolsToJSON(
  createAgentTools: CreateAgentTools,
): string {
  return JSON.stringify(
    CreateAgentTools$outboundSchema.parse(createAgentTools),
  );
}
export function createAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentTools' from JSON`,
  );
}

/** @internal */
export const CreateAgentSettings$inboundSchema: z.ZodType<
  CreateAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: CreateAgentToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => CreateAgentTools$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type CreateAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<CreateAgentTools$Outbound> | undefined;
};

/** @internal */
export const CreateAgentSettings$outboundSchema: z.ZodType<
  CreateAgentSettings$Outbound,
  z.ZodTypeDef,
  CreateAgentSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: CreateAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => CreateAgentTools$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function createAgentSettingsToJSON(
  createAgentSettings: CreateAgentSettings,
): string {
  return JSON.stringify(
    CreateAgentSettings$outboundSchema.parse(createAgentSettings),
  );
}
export function createAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentSettings' from JSON`,
  );
}

/** @internal */
export const CreateAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentVoice
> = z.nativeEnum(CreateAgentVoice);
/** @internal */
export const CreateAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentVoice
> = CreateAgentVoice$inboundSchema;

/** @internal */
export const CreateAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFormat
> = z.nativeEnum(CreateAgentFormat);
/** @internal */
export const CreateAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentFormat
> = CreateAgentFormat$inboundSchema;

/** @internal */
export const CreateAgentAudio$inboundSchema: z.ZodType<
  CreateAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateAgentVoice$inboundSchema,
  format: CreateAgentFormat$inboundSchema,
});
/** @internal */
export type CreateAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentAudio$outboundSchema: z.ZodType<
  CreateAgentAudio$Outbound,
  z.ZodTypeDef,
  CreateAgentAudio
> = z.object({
  voice: CreateAgentVoice$outboundSchema,
  format: CreateAgentFormat$outboundSchema,
});

export function createAgentAudioToJSON(
  createAgentAudio: CreateAgentAudio,
): string {
  return JSON.stringify(
    CreateAgentAudio$outboundSchema.parse(createAgentAudio),
  );
}
export function createAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });
/** @internal */
export type CreateAgentResponseFormatAgentsResponseJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function createAgentResponseFormatAgentsResponseJsonSchemaToJSON(
  createAgentResponseFormatAgentsResponseJsonSchema:
    CreateAgentResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema.parse(
      createAgentResponseFormatAgentsResponseJsonSchema,
    ),
  );
}
export function createAgentResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema,
    json_schema: z.lazy(() =>
      CreateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreateAgentResponseFormatAgentsResponse201JSONSchema$Outbound = {
  type: string;
  json_schema: CreateAgentResponseFormatAgentsResponseJsonSchema$Outbound;
};

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201JSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsResponse201JSONSchema
  > = z.object({
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema,
    jsonSchema: z.lazy(() =>
      CreateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentResponseFormatAgentsResponse201JSONSchemaToJSON(
  createAgentResponseFormatAgentsResponse201JSONSchema:
    CreateAgentResponseFormatAgentsResponse201JSONSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema.parse(
      createAgentResponseFormatAgentsResponse201JSONSchema,
    ),
  );
}
export function createAgentResponseFormatAgentsResponse201JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse201JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse201JSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponse201Type> = z
    .nativeEnum(CreateAgentResponseFormatAgentsResponse201Type);
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponse201Type> =
    CreateAgentResponseFormatAgentsResponse201Type$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  CreateAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsResponse201Type$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  CreateAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatJSONObject
> = z.object({
  type: CreateAgentResponseFormatAgentsResponse201Type$outboundSchema,
});

export function createAgentResponseFormatJSONObjectToJSON(
  createAgentResponseFormatJSONObject: CreateAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatJSONObject$outboundSchema.parse(
      createAgentResponseFormatJSONObject,
    ),
  );
}
export function createAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponseType> = z
    .nativeEnum(CreateAgentResponseFormatAgentsResponseType);
/** @internal */
export const CreateAgentResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseFormatAgentsResponseType> =
    CreateAgentResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatText$inboundSchema: z.ZodType<
  CreateAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentResponseFormatAgentsResponseType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatText$outboundSchema: z.ZodType<
  CreateAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatText
> = z.object({
  type: CreateAgentResponseFormatAgentsResponseType$outboundSchema,
});

export function createAgentResponseFormatTextToJSON(
  createAgentResponseFormatText: CreateAgentResponseFormatText,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatText$outboundSchema.parse(
      createAgentResponseFormatText,
    ),
  );
}
export function createAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormat$inboundSchema: z.ZodType<
  CreateAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() =>
    CreateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema
  ),
  z.lazy(() => CreateAgentResponseFormatText$inboundSchema),
  z.lazy(() => CreateAgentResponseFormatJSONObject$inboundSchema),
]);
/** @internal */
export type CreateAgentResponseFormat$Outbound =
  | CreateAgentResponseFormatAgentsResponse201JSONSchema$Outbound
  | CreateAgentResponseFormatText$Outbound
  | CreateAgentResponseFormatJSONObject$Outbound;

/** @internal */
export const CreateAgentResponseFormat$outboundSchema: z.ZodType<
  CreateAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormat
> = z.union([
  z.lazy(() =>
    CreateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema
  ),
  z.lazy(() => CreateAgentResponseFormatText$outboundSchema),
  z.lazy(() => CreateAgentResponseFormatJSONObject$outboundSchema),
]);

export function createAgentResponseFormatToJSON(
  createAgentResponseFormat: CreateAgentResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentResponseFormat$outboundSchema.parse(createAgentResponseFormat),
  );
}
export function createAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentStop$inboundSchema: z.ZodType<
  CreateAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentStop$Outbound = string | Array<string>;

/** @internal */
export const CreateAgentStop$outboundSchema: z.ZodType<
  CreateAgentStop$Outbound,
  z.ZodTypeDef,
  CreateAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function createAgentStopToJSON(
  createAgentStop: CreateAgentStop,
): string {
  return JSON.stringify(CreateAgentStop$outboundSchema.parse(createAgentStop));
}
export function createAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentStreamOptions$inboundSchema: z.ZodType<
  CreateAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type CreateAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateAgentStreamOptions$outboundSchema: z.ZodType<
  CreateAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createAgentStreamOptionsToJSON(
  createAgentStreamOptions: CreateAgentStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentStreamOptions$outboundSchema.parse(createAgentStreamOptions),
  );
}
export function createAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentType
> = z.nativeEnum(CreateAgentType);
/** @internal */
export const CreateAgentType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentType
> = CreateAgentType$inboundSchema;

/** @internal */
export const CreateAgentThinking$inboundSchema: z.ZodType<
  CreateAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type CreateAgentThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const CreateAgentThinking$outboundSchema: z.ZodType<
  CreateAgentThinking$Outbound,
  z.ZodTypeDef,
  CreateAgentThinking
> = z.object({
  type: CreateAgentType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function createAgentThinkingToJSON(
  createAgentThinking: CreateAgentThinking,
): string {
  return JSON.stringify(
    CreateAgentThinking$outboundSchema.parse(createAgentThinking),
  );
}
export function createAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgentsType
> = z.nativeEnum(CreateAgentToolChoiceAgentsType);
/** @internal */
export const CreateAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgentsType
> = CreateAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type CreateAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function createAgentToolChoiceAgentsFunctionToJSON(
  createAgentToolChoiceAgentsFunction: CreateAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsFunction$outboundSchema.parse(
      createAgentToolChoiceAgentsFunction,
    ),
  );
}
export function createAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type CreateAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgents2
> = z.object({
  type: CreateAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => CreateAgentToolChoiceAgentsFunction$outboundSchema),
});

export function createAgentToolChoiceAgents2ToJSON(
  createAgentToolChoiceAgents2: CreateAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgents2$outboundSchema.parse(
      createAgentToolChoiceAgents2,
    ),
  );
}
export function createAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgents1
> = z.nativeEnum(CreateAgentToolChoiceAgents1);
/** @internal */
export const CreateAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentToolChoiceAgents1
> = CreateAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const CreateAgentToolChoice$inboundSchema: z.ZodType<
  CreateAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgents2$inboundSchema),
  CreateAgentToolChoiceAgents1$inboundSchema,
]);
/** @internal */
export type CreateAgentToolChoice$Outbound =
  | CreateAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const CreateAgentToolChoice$outboundSchema: z.ZodType<
  CreateAgentToolChoice$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoice
> = z.union([
  z.lazy(() => CreateAgentToolChoiceAgents2$outboundSchema),
  CreateAgentToolChoiceAgents1$outboundSchema,
]);

export function createAgentToolChoiceToJSON(
  createAgentToolChoice: CreateAgentToolChoice,
): string {
  return JSON.stringify(
    CreateAgentToolChoice$outboundSchema.parse(createAgentToolChoice),
  );
}
export function createAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModalities
> = z.nativeEnum(CreateAgentModalities);
/** @internal */
export const CreateAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentModalities
> = CreateAgentModalities$inboundSchema;

/** @internal */
export const CreateAgentParameters$inboundSchema: z.ZodType<
  CreateAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema
    ),
    z.lazy(() => CreateAgentResponseFormatText$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatJSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateAgentStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgents2$inboundSchema),
    CreateAgentToolChoiceAgents1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type CreateAgentParameters$Outbound = {
  audio?: CreateAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormatAgentsResponse201JSONSchema$Outbound
    | CreateAgentResponseFormatText$Outbound
    | CreateAgentResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: CreateAgentStreamOptions$Outbound | null | undefined;
  thinking?: CreateAgentThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: CreateAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const CreateAgentParameters$outboundSchema: z.ZodType<
  CreateAgentParameters$Outbound,
  z.ZodTypeDef,
  CreateAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => CreateAgentAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema
    ),
    z.lazy(() => CreateAgentResponseFormatText$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatJSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateAgentStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => CreateAgentThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => CreateAgentToolChoiceAgents2$outboundSchema),
    CreateAgentToolChoiceAgents1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateAgentModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function createAgentParametersToJSON(
  createAgentParameters: CreateAgentParameters,
): string {
  return JSON.stringify(
    CreateAgentParameters$outboundSchema.parse(createAgentParameters),
  );
}
export function createAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(CreateAgentFallbackModelConfigurationVoice);
/** @internal */
export const CreateAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationVoice> =
    CreateAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(CreateAgentFallbackModelConfigurationFormat);
/** @internal */
export const CreateAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationFormat> =
    CreateAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<CreateAgentFallbackModelConfigurationAudio, z.ZodTypeDef, unknown> =
    z.object({
      voice: CreateAgentFallbackModelConfigurationVoice$inboundSchema,
      format: CreateAgentFallbackModelConfigurationFormat$inboundSchema,
    });
/** @internal */
export type CreateAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: CreateAgentFallbackModelConfigurationVoice$outboundSchema,
    format: CreateAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function createAgentFallbackModelConfigurationAudioToJSON(
  createAgentFallbackModelConfigurationAudio:
    CreateAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      createAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function createAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });
/** @internal */
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict?: boolean | undefined;
  };

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function createAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchemaToJSON(
  createAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema
      .parse(
        createAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
      ),
  );
}
export function createAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$inboundSchema,
    json_schema: z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound =
  {
    type: string;
    json_schema:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$Outbound;
  };

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema
  > = z.object({
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelFallbackModelsType$outboundSchema,
    jsonSchema: z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONJSONSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchemaToJSON(
  createAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
      .parse(
        createAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
      ),
  );
}
export function createAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsJSONObject$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgentsJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    CreateAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    CreateAgentResponseFormatAgentsJSONObject
  > = z.object({
    type:
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyModelType$outboundSchema,
  });

export function createAgentResponseFormatAgentsJSONObjectToJSON(
  createAgentResponseFormatAgentsJSONObject:
    CreateAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      createAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function createAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType,
  );
/** @internal */
export const CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > =
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const CreateAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema,
});
/** @internal */
export type CreateAgentResponseFormatAgentsText$Outbound = {
  type: string;
};

/** @internal */
export const CreateAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  CreateAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseFormatAgentsText
> = z.object({
  type:
    CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema,
});

export function createAgentResponseFormatAgentsTextToJSON(
  createAgentResponseFormatAgentsText: CreateAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    CreateAgentResponseFormatAgentsText$outboundSchema.parse(
      createAgentResponseFormatAgentsText,
    ),
  );
}
export function createAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
    ),
    z.lazy(() => CreateAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsJSONObject$inboundSchema),
  ]);
/** @internal */
export type CreateAgentFallbackModelConfigurationResponseFormat$Outbound =
  | CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound
  | CreateAgentResponseFormatAgentsText$Outbound
  | CreateAgentResponseFormatAgentsJSONObject$Outbound;

/** @internal */
export const CreateAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() =>
      CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
    ),
    z.lazy(() => CreateAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => CreateAgentResponseFormatAgentsJSONObject$outboundSchema),
  ]);

export function createAgentFallbackModelConfigurationResponseFormatToJSON(
  createAgentFallbackModelConfigurationResponseFormat:
    CreateAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      createAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function createAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationStop$inboundSchema: z.ZodType<
  CreateAgentFallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const CreateAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function createAgentFallbackModelConfigurationStopToJSON(
  createAgentFallbackModelConfigurationStop:
    CreateAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationStop$outboundSchema.parse(
      createAgentFallbackModelConfigurationStop,
    ),
  );
}
export function createAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type CreateAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function createAgentFallbackModelConfigurationStreamOptionsToJSON(
  createAgentFallbackModelConfigurationStreamOptions:
    CreateAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      createAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function createAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationType> = z
    .nativeEnum(CreateAgentFallbackModelConfigurationType);
/** @internal */
export const CreateAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationType> =
    CreateAgentFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: CreateAgentFallbackModelConfigurationType$inboundSchema,
    budget_tokens: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "budget_tokens": "budgetTokens",
    });
  });
/** @internal */
export type CreateAgentFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const CreateAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationThinking
  > = z.object({
    type: CreateAgentFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
    });
  });

export function createAgentFallbackModelConfigurationThinkingToJSON(
  createAgentFallbackModelConfigurationThinking:
    CreateAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      createAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function createAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponseType> = z
    .nativeEnum(CreateAgentToolChoiceAgentsResponseType);
/** @internal */
export const CreateAgentToolChoiceAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponseType> =
    CreateAgentToolChoiceAgentsResponseType$inboundSchema;

/** @internal */
export const CreateAgentToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    CreateAgentToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string().optional(),
  });
/** @internal */
export type CreateAgentToolChoiceAgentsResponseFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const CreateAgentToolChoiceAgentsResponseFunction$outboundSchema:
  z.ZodType<
    CreateAgentToolChoiceAgentsResponseFunction$Outbound,
    z.ZodTypeDef,
    CreateAgentToolChoiceAgentsResponseFunction
  > = z.object({
    name: z.string().optional(),
  });

export function createAgentToolChoiceAgentsResponseFunctionToJSON(
  createAgentToolChoiceAgentsResponseFunction:
    CreateAgentToolChoiceAgentsResponseFunction,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsResponseFunction$outboundSchema.parse(
      createAgentToolChoiceAgentsResponseFunction,
    ),
  );
}
export function createAgentToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponse2$inboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateAgentToolChoiceAgentsResponseType$inboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentToolChoiceAgentsResponseFunction$inboundSchema
  ),
});
/** @internal */
export type CreateAgentToolChoiceAgentsResponse2$Outbound = {
  type?: string | undefined;
  function: CreateAgentToolChoiceAgentsResponseFunction$Outbound;
};

/** @internal */
export const CreateAgentToolChoiceAgentsResponse2$outboundSchema: z.ZodType<
  CreateAgentToolChoiceAgentsResponse2$Outbound,
  z.ZodTypeDef,
  CreateAgentToolChoiceAgentsResponse2
> = z.object({
  type: CreateAgentToolChoiceAgentsResponseType$outboundSchema.optional(),
  function: z.lazy(() =>
    CreateAgentToolChoiceAgentsResponseFunction$outboundSchema
  ),
});

export function createAgentToolChoiceAgentsResponse2ToJSON(
  createAgentToolChoiceAgentsResponse2: CreateAgentToolChoiceAgentsResponse2,
): string {
  return JSON.stringify(
    CreateAgentToolChoiceAgentsResponse2$outboundSchema.parse(
      createAgentToolChoiceAgentsResponse2,
    ),
  );
}
export function createAgentToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentToolChoiceAgentsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentToolChoiceAgentsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const CreateAgentToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponse1> = z.nativeEnum(
    CreateAgentToolChoiceAgentsResponse1,
  );
/** @internal */
export const CreateAgentToolChoiceAgentsResponse1$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentToolChoiceAgentsResponse1> =
    CreateAgentToolChoiceAgentsResponse1$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => CreateAgentToolChoiceAgentsResponse2$inboundSchema),
    CreateAgentToolChoiceAgentsResponse1$inboundSchema,
  ]);
/** @internal */
export type CreateAgentFallbackModelConfigurationToolChoice$Outbound =
  | CreateAgentToolChoiceAgentsResponse2$Outbound
  | string;

/** @internal */
export const CreateAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => CreateAgentToolChoiceAgentsResponse2$outboundSchema),
    CreateAgentToolChoiceAgentsResponse1$outboundSchema,
  ]);

export function createAgentFallbackModelConfigurationToolChoiceToJSON(
  createAgentFallbackModelConfigurationToolChoice:
    CreateAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      createAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function createAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(CreateAgentFallbackModelConfigurationModalities);
/** @internal */
export const CreateAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentFallbackModelConfigurationModalities> =
    CreateAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const CreateAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => CreateAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$inboundSchema
      ),
      z.lazy(() => CreateAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => CreateAgentResponseFormatAgentsJSONObject$inboundSchema),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        CreateAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      CreateAgentFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => CreateAgentToolChoiceAgentsResponse2$inboundSchema),
      CreateAgentToolChoiceAgentsResponse1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(CreateAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type CreateAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | CreateAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$Outbound
    | CreateAgentResponseFormatAgentsText$Outbound
    | CreateAgentResponseFormatAgentsJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | CreateAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: CreateAgentFallbackModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | CreateAgentToolChoiceAgentsResponse2$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const CreateAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    CreateAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    CreateAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => CreateAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        CreateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyJSONSchema$outboundSchema
      ),
      z.lazy(() => CreateAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => CreateAgentResponseFormatAgentsJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        CreateAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      CreateAgentFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => CreateAgentToolChoiceAgentsResponse2$outboundSchema),
      CreateAgentToolChoiceAgentsResponse1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(CreateAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function createAgentFallbackModelConfigurationParametersToJSON(
  createAgentFallbackModelConfigurationParameters:
    CreateAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      createAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function createAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  CreateAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    CreateAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type CreateAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | CreateAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const CreateAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  CreateAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    CreateAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
});

export function createAgentFallbackModelConfiguration2ToJSON(
  createAgentFallbackModelConfiguration2:
    CreateAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfiguration2$outboundSchema.parse(
      createAgentFallbackModelConfiguration2,
    ),
  );
}
export function createAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const CreateAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  CreateAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type CreateAgentFallbackModelConfiguration$Outbound =
  | CreateAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const CreateAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  CreateAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  CreateAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => CreateAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function createAgentFallbackModelConfigurationToJSON(
  createAgentFallbackModelConfiguration: CreateAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    CreateAgentFallbackModelConfiguration$outboundSchema.parse(
      createAgentFallbackModelConfiguration,
    ),
  );
}
export function createAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentFallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentFallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const CreateAgentModel$inboundSchema: z.ZodType<
  CreateAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentParameters$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => CreateAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type CreateAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: CreateAgentParameters$Outbound | undefined;
  fallback_models?:
    | Array<CreateAgentFallbackModelConfiguration2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const CreateAgentModel$outboundSchema: z.ZodType<
  CreateAgentModel$Outbound,
  z.ZodTypeDef,
  CreateAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateAgentParameters$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => CreateAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function createAgentModelToJSON(
  createAgentModel: CreateAgentModel,
): string {
  return JSON.stringify(
    CreateAgentModel$outboundSchema.parse(createAgentModel),
  );
}
export function createAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentModel' from JSON`,
  );
}

/** @internal */
export const CreateAgentTeamOfAgents$inboundSchema: z.ZodType<
  CreateAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type CreateAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const CreateAgentTeamOfAgents$outboundSchema: z.ZodType<
  CreateAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  CreateAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function createAgentTeamOfAgentsToJSON(
  createAgentTeamOfAgents: CreateAgentTeamOfAgents,
): string {
  return JSON.stringify(
    CreateAgentTeamOfAgents$outboundSchema.parse(createAgentTeamOfAgents),
  );
}
export function createAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const Metrics$inboundSchema: z.ZodType<Metrics, z.ZodTypeDef, unknown> =
  z.object({
    total_cost: z.number().default(0),
  }).transform((v) => {
    return remap$(v, {
      "total_cost": "totalCost",
    });
  });
/** @internal */
export type Metrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const Metrics$outboundSchema: z.ZodType<
  Metrics$Outbound,
  z.ZodTypeDef,
  Metrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function metricsToJSON(metrics: Metrics): string {
  return JSON.stringify(Metrics$outboundSchema.parse(metrics));
}
export function metricsFromJSON(
  jsonString: string,
): SafeParseResult<Metrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metrics' from JSON`,
  );
}

/** @internal */
export const CreateAgentKnowledgeBases$inboundSchema: z.ZodType<
  CreateAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type CreateAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const CreateAgentKnowledgeBases$outboundSchema: z.ZodType<
  CreateAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function createAgentKnowledgeBasesToJSON(
  createAgentKnowledgeBases: CreateAgentKnowledgeBases,
): string {
  return JSON.stringify(
    CreateAgentKnowledgeBases$outboundSchema.parse(createAgentKnowledgeBases),
  );
}
export function createAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const CreateAgentCollapsedConfigurationSections$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentCollapsedConfigurationSections> = z
    .nativeEnum(CreateAgentCollapsedConfigurationSections);
/** @internal */
export const CreateAgentCollapsedConfigurationSections$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentCollapsedConfigurationSections> =
    CreateAgentCollapsedConfigurationSections$inboundSchema;

/** @internal */
export const CreateAgentResponseBody$inboundSchema: z.ZodType<
  CreateAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentStatus$inboundSchema,
  settings: z.lazy(() => CreateAgentSettings$inboundSchema).optional(),
  model: z.lazy(() => CreateAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => CreateAgentTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => Metrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => CreateAgentKnowledgeBases$inboundSchema),
  ).optional(),
  collapsed_configuration_sections: z.array(
    CreateAgentCollapsedConfigurationSections$inboundSchema,
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
    "collapsed_configuration_sections": "collapsedConfigurationSections",
  });
});
/** @internal */
export type CreateAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: CreateAgentSettings$Outbound | undefined;
  model: CreateAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<CreateAgentTeamOfAgents$Outbound>;
  metrics?: Metrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<CreateAgentKnowledgeBases$Outbound> | undefined;
  collapsed_configuration_sections?: Array<string> | undefined;
};

/** @internal */
export const CreateAgentResponseBody$outboundSchema: z.ZodType<
  CreateAgentResponseBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: CreateAgentStatus$outboundSchema,
  settings: z.lazy(() => CreateAgentSettings$outboundSchema).optional(),
  model: z.lazy(() => CreateAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(z.lazy(() => CreateAgentTeamOfAgents$outboundSchema)),
  metrics: z.lazy(() => Metrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => CreateAgentKnowledgeBases$outboundSchema),
  ).optional(),
  collapsedConfigurationSections: z.array(
    CreateAgentCollapsedConfigurationSections$outboundSchema,
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
    collapsedConfigurationSections: "collapsed_configuration_sections",
  });
});

export function createAgentResponseBodyToJSON(
  createAgentResponseBody: CreateAgentResponseBody,
): string {
  return JSON.stringify(
    CreateAgentResponseBody$outboundSchema.parse(createAgentResponseBody),
  );
}
export function createAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseBody' from JSON`,
  );
}
