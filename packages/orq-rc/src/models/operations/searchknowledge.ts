/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export const SearchType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export type SearchType = ClosedEnum<typeof SearchType>;

/**
 * Exists
 */
export type SearchKnowledgeOrExists = {
  exists: boolean;
};

export type SearchKnowledgeOrKnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledgeOrNin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledgeOrKnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledgeOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledgeOrLte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledgeOrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledgeOrGte = {
  gte: number;
};

export type SearchKnowledgeOr3 = {
  gt: number;
};

export type SearchKnowledgeOrKnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledgeOrNe = {
  ne: string | number | boolean;
};

export type SearchKnowledgeOrKnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledgeOrEq = {
  eq: string | number | boolean;
};

export type SearchKnowledgeFilterByOr =
  | SearchKnowledgeOrEq
  | SearchKnowledgeOrNe
  | SearchKnowledgeOr3
  | SearchKnowledgeOrGte
  | SearchKnowledgeOrLt
  | SearchKnowledgeOrLte
  | SearchKnowledgeOrIn
  | SearchKnowledgeOrNin
  | SearchKnowledgeOrExists;

/**
 * Or
 */
export type FilterByOr = {
  or: Array<
    {
      [k: string]:
        | SearchKnowledgeOrEq
        | SearchKnowledgeOrNe
        | SearchKnowledgeOr3
        | SearchKnowledgeOrGte
        | SearchKnowledgeOrLt
        | SearchKnowledgeOrLte
        | SearchKnowledgeOrIn
        | SearchKnowledgeOrNin
        | SearchKnowledgeOrExists;
    }
  >;
};

/**
 * Exists
 */
export type SearchKnowledgeAndExists = {
  exists: boolean;
};

export type SearchKnowledgeAndKnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledgeAndNin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledgeAndKnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledgeAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledgeAndLte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledgeAndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledgeAndGte = {
  gte: number;
};

export type SearchKnowledgeAnd3 = {
  gt: number;
};

export type SearchKnowledgeAndKnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledgeAndNe = {
  ne: string | number | boolean;
};

export type SearchKnowledgeAndKnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledgeAndEq = {
  eq: string | number | boolean;
};

export type SearchKnowledgeFilterByAnd =
  | SearchKnowledgeAndEq
  | SearchKnowledgeAndNe
  | SearchKnowledgeAnd3
  | SearchKnowledgeAndGte
  | SearchKnowledgeAndLt
  | SearchKnowledgeAndLte
  | SearchKnowledgeAndIn
  | SearchKnowledgeAndNin
  | SearchKnowledgeAndExists;

/**
 * And
 */
export type FilterByAnd = {
  and: Array<
    {
      [k: string]:
        | SearchKnowledgeAndEq
        | SearchKnowledgeAndNe
        | SearchKnowledgeAnd3
        | SearchKnowledgeAndGte
        | SearchKnowledgeAndLt
        | SearchKnowledgeAndLte
        | SearchKnowledgeAndIn
        | SearchKnowledgeAndNin
        | SearchKnowledgeAndExists;
    }
  >;
};

/**
 * Exists
 */
export type SearchKnowledge1Exists = {
  exists: boolean;
};

export type SearchKnowledge1KnowledgeNin = string | number | boolean;

/**
 * Not in
 */
export type SearchKnowledge1Nin = {
  nin: Array<string | number | boolean>;
};

export type SearchKnowledge1KnowledgeIn = string | number | boolean;

/**
 * In
 */
export type SearchKnowledge1In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type SearchKnowledge1Lte = {
  lte: number;
};

/**
 * Less than
 */
export type SearchKnowledge1Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type SearchKnowledge1Gte = {
  gte: number;
};

export type SearchKnowledge13 = {
  gt: number;
};

export type SearchKnowledge1KnowledgeNe = string | number | boolean;

/**
 * Not equal to
 */
export type SearchKnowledge1Ne = {
  ne: string | number | boolean;
};

export type SearchKnowledge1KnowledgeEq = string | number | boolean;

/**
 * Equal to
 */
export type SearchKnowledge1Eq = {
  eq: string | number | boolean;
};

export type FilterBy1 =
  | SearchKnowledge1Eq
  | SearchKnowledge1Ne
  | SearchKnowledge13
  | SearchKnowledge1Gte
  | SearchKnowledge1Lt
  | SearchKnowledge1Lte
  | SearchKnowledge1In
  | SearchKnowledge1Nin
  | SearchKnowledge1Exists;

/**
 * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
 */
export type FilterBy = FilterByAnd | FilterByOr | {
  [k: string]:
    | SearchKnowledge1Eq
    | SearchKnowledge1Ne
    | SearchKnowledge13
    | SearchKnowledge1Gte
    | SearchKnowledge1Lt
    | SearchKnowledge1Lte
    | SearchKnowledge1In
    | SearchKnowledge1Nin
    | SearchKnowledge1Exists;
};

/**
 * Additional search options
 */
export type SearchOptions = {
  /**
   * Whether to include the vector in the chunk
   */
  includeVectors?: boolean | undefined;
  /**
   * Whether to include the metadata in the chunk
   */
  includeMetadata?: boolean | undefined;
  /**
   * Whether to include the scores in the chunk
   */
  includeScores?: boolean | undefined;
};

/**
 * A search request for chunks in a knowledge base
 */
export type SearchKnowledgeRequestBody = {
  /**
   * The query to use to search the knowledge base
   */
  query: string;
  /**
   * The number of results to return. If not provided, will default to the knowledge base configured `top_k`
   */
  topK?: number | undefined;
  /**
   * The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`
   */
  threshold?: number | undefined;
  /**
   * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
   */
  searchType?: SearchType | undefined;
  /**
   * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
   */
  filterBy?: FilterByAnd | FilterByOr | {
    [k: string]:
      | SearchKnowledge1Eq
      | SearchKnowledge1Ne
      | SearchKnowledge13
      | SearchKnowledge1Gte
      | SearchKnowledge1Lt
      | SearchKnowledge1Lte
      | SearchKnowledge1In
      | SearchKnowledge1Nin
      | SearchKnowledge1Exists;
  } | undefined;
  /**
   * Additional search options
   */
  searchOptions?: SearchOptions | undefined;
};

export type SearchKnowledgeRequest = {
  /**
   * The unique identifier or key of the knowledge base
   */
  knowledgeId: string;
  /**
   * A search request for chunks in a knowledge base
   */
  requestBody?: SearchKnowledgeRequestBody | undefined;
};

export type Scores = {
  rerankScore?: number | undefined;
  searchScore?: number | undefined;
};

export type Matches = {
  id: string;
  text: string;
  vector?: Array<number> | undefined;
  metadata?: { [k: string]: any } | undefined;
  scores?: Scores | undefined;
};

/**
 * Search knowledge base
 */
export type SearchKnowledgeResponseBody = {
  matches: Array<Matches>;
};

/** @internal */
export const SearchType$inboundSchema: z.ZodNativeEnum<typeof SearchType> = z
  .nativeEnum(SearchType);

/** @internal */
export const SearchType$outboundSchema: z.ZodNativeEnum<typeof SearchType> =
  SearchType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchType$ {
  /** @deprecated use `SearchType$inboundSchema` instead. */
  export const inboundSchema = SearchType$inboundSchema;
  /** @deprecated use `SearchType$outboundSchema` instead. */
  export const outboundSchema = SearchType$outboundSchema;
}

/** @internal */
export const SearchKnowledgeOrExists$inboundSchema: z.ZodType<
  SearchKnowledgeOrExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});

/** @internal */
export type SearchKnowledgeOrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledgeOrExists$outboundSchema: z.ZodType<
  SearchKnowledgeOrExists$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrExists
> = z.object({
  exists: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrExists$ {
  /** @deprecated use `SearchKnowledgeOrExists$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrExists$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrExists$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrExists$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrExists$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrExists$Outbound;
}

export function searchKnowledgeOrExistsToJSON(
  searchKnowledgeOrExists: SearchKnowledgeOrExists,
): string {
  return JSON.stringify(
    SearchKnowledgeOrExists$outboundSchema.parse(searchKnowledgeOrExists),
  );
}

export function searchKnowledgeOrExistsFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrExists' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrKnowledgeNin$inboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeOrKnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrKnowledgeNin$ {
  /** @deprecated use `SearchKnowledgeOrKnowledgeNin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrKnowledgeNin$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeNin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrKnowledgeNin$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeNin$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrKnowledgeNin$Outbound;
}

export function searchKnowledgeOrKnowledgeNinToJSON(
  searchKnowledgeOrKnowledgeNin: SearchKnowledgeOrKnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeNin$outboundSchema.parse(
      searchKnowledgeOrKnowledgeNin,
    ),
  );
}

export function searchKnowledgeOrKnowledgeNinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrKnowledgeNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrKnowledgeNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrKnowledgeNin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrNin$inboundSchema: z.ZodType<
  SearchKnowledgeOrNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledgeOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeOrNin$outboundSchema: z.ZodType<
  SearchKnowledgeOrNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrNin$ {
  /** @deprecated use `SearchKnowledgeOrNin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrNin$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrNin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrNin$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrNin$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrNin$Outbound;
}

export function searchKnowledgeOrNinToJSON(
  searchKnowledgeOrNin: SearchKnowledgeOrNin,
): string {
  return JSON.stringify(
    SearchKnowledgeOrNin$outboundSchema.parse(searchKnowledgeOrNin),
  );
}

export function searchKnowledgeOrNinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrNin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrKnowledgeIn$inboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeOrKnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrKnowledgeIn$ {
  /** @deprecated use `SearchKnowledgeOrKnowledgeIn$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrKnowledgeIn$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeIn$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrKnowledgeIn$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeIn$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrKnowledgeIn$Outbound;
}

export function searchKnowledgeOrKnowledgeInToJSON(
  searchKnowledgeOrKnowledgeIn: SearchKnowledgeOrKnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeIn$outboundSchema.parse(
      searchKnowledgeOrKnowledgeIn,
    ),
  );
}

export function searchKnowledgeOrKnowledgeInFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrKnowledgeIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrKnowledgeIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrKnowledgeIn' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrIn$inboundSchema: z.ZodType<
  SearchKnowledgeOrIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledgeOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeOrIn$outboundSchema: z.ZodType<
  SearchKnowledgeOrIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrIn$ {
  /** @deprecated use `SearchKnowledgeOrIn$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrIn$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrIn$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrIn$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrIn$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrIn$Outbound;
}

export function searchKnowledgeOrInToJSON(
  searchKnowledgeOrIn: SearchKnowledgeOrIn,
): string {
  return JSON.stringify(
    SearchKnowledgeOrIn$outboundSchema.parse(searchKnowledgeOrIn),
  );
}

export function searchKnowledgeOrInFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrIn' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrLte$inboundSchema: z.ZodType<
  SearchKnowledgeOrLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});

/** @internal */
export type SearchKnowledgeOrLte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledgeOrLte$outboundSchema: z.ZodType<
  SearchKnowledgeOrLte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrLte
> = z.object({
  lte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrLte$ {
  /** @deprecated use `SearchKnowledgeOrLte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrLte$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrLte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrLte$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrLte$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrLte$Outbound;
}

export function searchKnowledgeOrLteToJSON(
  searchKnowledgeOrLte: SearchKnowledgeOrLte,
): string {
  return JSON.stringify(
    SearchKnowledgeOrLte$outboundSchema.parse(searchKnowledgeOrLte),
  );
}

export function searchKnowledgeOrLteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrLte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrLt$inboundSchema: z.ZodType<
  SearchKnowledgeOrLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});

/** @internal */
export type SearchKnowledgeOrLt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledgeOrLt$outboundSchema: z.ZodType<
  SearchKnowledgeOrLt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrLt
> = z.object({
  lt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrLt$ {
  /** @deprecated use `SearchKnowledgeOrLt$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrLt$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrLt$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrLt$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrLt$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrLt$Outbound;
}

export function searchKnowledgeOrLtToJSON(
  searchKnowledgeOrLt: SearchKnowledgeOrLt,
): string {
  return JSON.stringify(
    SearchKnowledgeOrLt$outboundSchema.parse(searchKnowledgeOrLt),
  );
}

export function searchKnowledgeOrLtFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrLt' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrGte$inboundSchema: z.ZodType<
  SearchKnowledgeOrGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});

/** @internal */
export type SearchKnowledgeOrGte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledgeOrGte$outboundSchema: z.ZodType<
  SearchKnowledgeOrGte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrGte
> = z.object({
  gte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrGte$ {
  /** @deprecated use `SearchKnowledgeOrGte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrGte$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrGte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrGte$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrGte$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrGte$Outbound;
}

export function searchKnowledgeOrGteToJSON(
  searchKnowledgeOrGte: SearchKnowledgeOrGte,
): string {
  return JSON.stringify(
    SearchKnowledgeOrGte$outboundSchema.parse(searchKnowledgeOrGte),
  );
}

export function searchKnowledgeOrGteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrGte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOr3$inboundSchema: z.ZodType<
  SearchKnowledgeOr3,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});

/** @internal */
export type SearchKnowledgeOr3$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledgeOr3$outboundSchema: z.ZodType<
  SearchKnowledgeOr3$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOr3
> = z.object({
  gt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOr3$ {
  /** @deprecated use `SearchKnowledgeOr3$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOr3$inboundSchema;
  /** @deprecated use `SearchKnowledgeOr3$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOr3$outboundSchema;
  /** @deprecated use `SearchKnowledgeOr3$Outbound` instead. */
  export type Outbound = SearchKnowledgeOr3$Outbound;
}

export function searchKnowledgeOr3ToJSON(
  searchKnowledgeOr3: SearchKnowledgeOr3,
): string {
  return JSON.stringify(
    SearchKnowledgeOr3$outboundSchema.parse(searchKnowledgeOr3),
  );
}

export function searchKnowledgeOr3FromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOr3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOr3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOr3' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrKnowledgeNe$inboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeOrKnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrKnowledgeNe$ {
  /** @deprecated use `SearchKnowledgeOrKnowledgeNe$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrKnowledgeNe$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeNe$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrKnowledgeNe$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeNe$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrKnowledgeNe$Outbound;
}

export function searchKnowledgeOrKnowledgeNeToJSON(
  searchKnowledgeOrKnowledgeNe: SearchKnowledgeOrKnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeNe$outboundSchema.parse(
      searchKnowledgeOrKnowledgeNe,
    ),
  );
}

export function searchKnowledgeOrKnowledgeNeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrKnowledgeNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrKnowledgeNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrKnowledgeNe' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrNe$inboundSchema: z.ZodType<
  SearchKnowledgeOrNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledgeOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeOrNe$outboundSchema: z.ZodType<
  SearchKnowledgeOrNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrNe$ {
  /** @deprecated use `SearchKnowledgeOrNe$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrNe$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrNe$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrNe$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrNe$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrNe$Outbound;
}

export function searchKnowledgeOrNeToJSON(
  searchKnowledgeOrNe: SearchKnowledgeOrNe,
): string {
  return JSON.stringify(
    SearchKnowledgeOrNe$outboundSchema.parse(searchKnowledgeOrNe),
  );
}

export function searchKnowledgeOrNeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrNe' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrKnowledgeEq$inboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeOrKnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeOrKnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledgeOrKnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrKnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrKnowledgeEq$ {
  /** @deprecated use `SearchKnowledgeOrKnowledgeEq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrKnowledgeEq$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeEq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrKnowledgeEq$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrKnowledgeEq$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrKnowledgeEq$Outbound;
}

export function searchKnowledgeOrKnowledgeEqToJSON(
  searchKnowledgeOrKnowledgeEq: SearchKnowledgeOrKnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledgeOrKnowledgeEq$outboundSchema.parse(
      searchKnowledgeOrKnowledgeEq,
    ),
  );
}

export function searchKnowledgeOrKnowledgeEqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrKnowledgeEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrKnowledgeEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrKnowledgeEq' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeOrEq$inboundSchema: z.ZodType<
  SearchKnowledgeOrEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledgeOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeOrEq$outboundSchema: z.ZodType<
  SearchKnowledgeOrEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeOrEq$ {
  /** @deprecated use `SearchKnowledgeOrEq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeOrEq$inboundSchema;
  /** @deprecated use `SearchKnowledgeOrEq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeOrEq$outboundSchema;
  /** @deprecated use `SearchKnowledgeOrEq$Outbound` instead. */
  export type Outbound = SearchKnowledgeOrEq$Outbound;
}

export function searchKnowledgeOrEqToJSON(
  searchKnowledgeOrEq: SearchKnowledgeOrEq,
): string {
  return JSON.stringify(
    SearchKnowledgeOrEq$outboundSchema.parse(searchKnowledgeOrEq),
  );
}

export function searchKnowledgeOrEqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeOrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeOrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeOrEq' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeFilterByOr$inboundSchema: z.ZodType<
  SearchKnowledgeFilterByOr,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SearchKnowledgeOrEq$inboundSchema),
  z.lazy(() => SearchKnowledgeOrNe$inboundSchema),
  z.lazy(() => SearchKnowledgeOr3$inboundSchema),
  z.lazy(() => SearchKnowledgeOrGte$inboundSchema),
  z.lazy(() => SearchKnowledgeOrLt$inboundSchema),
  z.lazy(() => SearchKnowledgeOrLte$inboundSchema),
  z.lazy(() => SearchKnowledgeOrIn$inboundSchema),
  z.lazy(() => SearchKnowledgeOrNin$inboundSchema),
  z.lazy(() => SearchKnowledgeOrExists$inboundSchema),
]);

/** @internal */
export type SearchKnowledgeFilterByOr$Outbound =
  | SearchKnowledgeOrEq$Outbound
  | SearchKnowledgeOrNe$Outbound
  | SearchKnowledgeOr3$Outbound
  | SearchKnowledgeOrGte$Outbound
  | SearchKnowledgeOrLt$Outbound
  | SearchKnowledgeOrLte$Outbound
  | SearchKnowledgeOrIn$Outbound
  | SearchKnowledgeOrNin$Outbound
  | SearchKnowledgeOrExists$Outbound;

/** @internal */
export const SearchKnowledgeFilterByOr$outboundSchema: z.ZodType<
  SearchKnowledgeFilterByOr$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeFilterByOr
> = z.union([
  z.lazy(() => SearchKnowledgeOrEq$outboundSchema),
  z.lazy(() => SearchKnowledgeOrNe$outboundSchema),
  z.lazy(() => SearchKnowledgeOr3$outboundSchema),
  z.lazy(() => SearchKnowledgeOrGte$outboundSchema),
  z.lazy(() => SearchKnowledgeOrLt$outboundSchema),
  z.lazy(() => SearchKnowledgeOrLte$outboundSchema),
  z.lazy(() => SearchKnowledgeOrIn$outboundSchema),
  z.lazy(() => SearchKnowledgeOrNin$outboundSchema),
  z.lazy(() => SearchKnowledgeOrExists$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeFilterByOr$ {
  /** @deprecated use `SearchKnowledgeFilterByOr$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeFilterByOr$inboundSchema;
  /** @deprecated use `SearchKnowledgeFilterByOr$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeFilterByOr$outboundSchema;
  /** @deprecated use `SearchKnowledgeFilterByOr$Outbound` instead. */
  export type Outbound = SearchKnowledgeFilterByOr$Outbound;
}

export function searchKnowledgeFilterByOrToJSON(
  searchKnowledgeFilterByOr: SearchKnowledgeFilterByOr,
): string {
  return JSON.stringify(
    SearchKnowledgeFilterByOr$outboundSchema.parse(searchKnowledgeFilterByOr),
  );
}

export function searchKnowledgeFilterByOrFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeFilterByOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeFilterByOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeFilterByOr' from JSON`,
  );
}

/** @internal */
export const FilterByOr$inboundSchema: z.ZodType<
  FilterByOr,
  z.ZodTypeDef,
  unknown
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeOrEq$inboundSchema),
      z.lazy(() =>
        SearchKnowledgeOrNe$inboundSchema
      ),
      z.lazy(() => SearchKnowledgeOr3$inboundSchema),
      z.lazy(() => SearchKnowledgeOrGte$inboundSchema),
      z.lazy(() => SearchKnowledgeOrLt$inboundSchema),
      z.lazy(() => SearchKnowledgeOrLte$inboundSchema),
      z.lazy(() => SearchKnowledgeOrIn$inboundSchema),
      z.lazy(() => SearchKnowledgeOrNin$inboundSchema),
      z.lazy(() => SearchKnowledgeOrExists$inboundSchema),
    ])),
  ),
});

/** @internal */
export type FilterByOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | SearchKnowledgeOrEq$Outbound
        | SearchKnowledgeOrNe$Outbound
        | SearchKnowledgeOr3$Outbound
        | SearchKnowledgeOrGte$Outbound
        | SearchKnowledgeOrLt$Outbound
        | SearchKnowledgeOrLte$Outbound
        | SearchKnowledgeOrIn$Outbound
        | SearchKnowledgeOrNin$Outbound
        | SearchKnowledgeOrExists$Outbound;
    }
  >;
};

/** @internal */
export const FilterByOr$outboundSchema: z.ZodType<
  FilterByOr$Outbound,
  z.ZodTypeDef,
  FilterByOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeOrEq$outboundSchema),
      z.lazy(() =>
        SearchKnowledgeOrNe$outboundSchema
      ),
      z.lazy(() => SearchKnowledgeOr3$outboundSchema),
      z.lazy(() => SearchKnowledgeOrGte$outboundSchema),
      z.lazy(() => SearchKnowledgeOrLt$outboundSchema),
      z.lazy(() => SearchKnowledgeOrLte$outboundSchema),
      z.lazy(() => SearchKnowledgeOrIn$outboundSchema),
      z.lazy(() => SearchKnowledgeOrNin$outboundSchema),
      z.lazy(() => SearchKnowledgeOrExists$outboundSchema),
    ])),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterByOr$ {
  /** @deprecated use `FilterByOr$inboundSchema` instead. */
  export const inboundSchema = FilterByOr$inboundSchema;
  /** @deprecated use `FilterByOr$outboundSchema` instead. */
  export const outboundSchema = FilterByOr$outboundSchema;
  /** @deprecated use `FilterByOr$Outbound` instead. */
  export type Outbound = FilterByOr$Outbound;
}

export function filterByOrToJSON(filterByOr: FilterByOr): string {
  return JSON.stringify(FilterByOr$outboundSchema.parse(filterByOr));
}

export function filterByOrFromJSON(
  jsonString: string,
): SafeParseResult<FilterByOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterByOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterByOr' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndExists$inboundSchema: z.ZodType<
  SearchKnowledgeAndExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});

/** @internal */
export type SearchKnowledgeAndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledgeAndExists$outboundSchema: z.ZodType<
  SearchKnowledgeAndExists$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndExists
> = z.object({
  exists: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndExists$ {
  /** @deprecated use `SearchKnowledgeAndExists$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndExists$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndExists$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndExists$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndExists$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndExists$Outbound;
}

export function searchKnowledgeAndExistsToJSON(
  searchKnowledgeAndExists: SearchKnowledgeAndExists,
): string {
  return JSON.stringify(
    SearchKnowledgeAndExists$outboundSchema.parse(searchKnowledgeAndExists),
  );
}

export function searchKnowledgeAndExistsFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndExists' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndKnowledgeNin$inboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeAndKnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndKnowledgeNin$ {
  /** @deprecated use `SearchKnowledgeAndKnowledgeNin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndKnowledgeNin$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeNin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndKnowledgeNin$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeNin$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndKnowledgeNin$Outbound;
}

export function searchKnowledgeAndKnowledgeNinToJSON(
  searchKnowledgeAndKnowledgeNin: SearchKnowledgeAndKnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeNin$outboundSchema.parse(
      searchKnowledgeAndKnowledgeNin,
    ),
  );
}

export function searchKnowledgeAndKnowledgeNinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndKnowledgeNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndKnowledgeNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndKnowledgeNin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndNin$inboundSchema: z.ZodType<
  SearchKnowledgeAndNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledgeAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeAndNin$outboundSchema: z.ZodType<
  SearchKnowledgeAndNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndNin$ {
  /** @deprecated use `SearchKnowledgeAndNin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndNin$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndNin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndNin$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndNin$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndNin$Outbound;
}

export function searchKnowledgeAndNinToJSON(
  searchKnowledgeAndNin: SearchKnowledgeAndNin,
): string {
  return JSON.stringify(
    SearchKnowledgeAndNin$outboundSchema.parse(searchKnowledgeAndNin),
  );
}

export function searchKnowledgeAndNinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndNin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndKnowledgeIn$inboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeAndKnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndKnowledgeIn$ {
  /** @deprecated use `SearchKnowledgeAndKnowledgeIn$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndKnowledgeIn$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeIn$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndKnowledgeIn$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeIn$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndKnowledgeIn$Outbound;
}

export function searchKnowledgeAndKnowledgeInToJSON(
  searchKnowledgeAndKnowledgeIn: SearchKnowledgeAndKnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeIn$outboundSchema.parse(
      searchKnowledgeAndKnowledgeIn,
    ),
  );
}

export function searchKnowledgeAndKnowledgeInFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndKnowledgeIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndKnowledgeIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndKnowledgeIn' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndIn$inboundSchema: z.ZodType<
  SearchKnowledgeAndIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledgeAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledgeAndIn$outboundSchema: z.ZodType<
  SearchKnowledgeAndIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndIn$ {
  /** @deprecated use `SearchKnowledgeAndIn$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndIn$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndIn$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndIn$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndIn$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndIn$Outbound;
}

export function searchKnowledgeAndInToJSON(
  searchKnowledgeAndIn: SearchKnowledgeAndIn,
): string {
  return JSON.stringify(
    SearchKnowledgeAndIn$outboundSchema.parse(searchKnowledgeAndIn),
  );
}

export function searchKnowledgeAndInFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndIn' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndLte$inboundSchema: z.ZodType<
  SearchKnowledgeAndLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});

/** @internal */
export type SearchKnowledgeAndLte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledgeAndLte$outboundSchema: z.ZodType<
  SearchKnowledgeAndLte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndLte
> = z.object({
  lte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndLte$ {
  /** @deprecated use `SearchKnowledgeAndLte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndLte$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndLte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndLte$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndLte$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndLte$Outbound;
}

export function searchKnowledgeAndLteToJSON(
  searchKnowledgeAndLte: SearchKnowledgeAndLte,
): string {
  return JSON.stringify(
    SearchKnowledgeAndLte$outboundSchema.parse(searchKnowledgeAndLte),
  );
}

export function searchKnowledgeAndLteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndLte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndLt$inboundSchema: z.ZodType<
  SearchKnowledgeAndLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});

/** @internal */
export type SearchKnowledgeAndLt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledgeAndLt$outboundSchema: z.ZodType<
  SearchKnowledgeAndLt$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndLt
> = z.object({
  lt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndLt$ {
  /** @deprecated use `SearchKnowledgeAndLt$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndLt$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndLt$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndLt$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndLt$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndLt$Outbound;
}

export function searchKnowledgeAndLtToJSON(
  searchKnowledgeAndLt: SearchKnowledgeAndLt,
): string {
  return JSON.stringify(
    SearchKnowledgeAndLt$outboundSchema.parse(searchKnowledgeAndLt),
  );
}

export function searchKnowledgeAndLtFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndLt' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndGte$inboundSchema: z.ZodType<
  SearchKnowledgeAndGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});

/** @internal */
export type SearchKnowledgeAndGte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledgeAndGte$outboundSchema: z.ZodType<
  SearchKnowledgeAndGte$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndGte
> = z.object({
  gte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndGte$ {
  /** @deprecated use `SearchKnowledgeAndGte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndGte$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndGte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndGte$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndGte$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndGte$Outbound;
}

export function searchKnowledgeAndGteToJSON(
  searchKnowledgeAndGte: SearchKnowledgeAndGte,
): string {
  return JSON.stringify(
    SearchKnowledgeAndGte$outboundSchema.parse(searchKnowledgeAndGte),
  );
}

export function searchKnowledgeAndGteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndGte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAnd3$inboundSchema: z.ZodType<
  SearchKnowledgeAnd3,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});

/** @internal */
export type SearchKnowledgeAnd3$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledgeAnd3$outboundSchema: z.ZodType<
  SearchKnowledgeAnd3$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAnd3
> = z.object({
  gt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAnd3$ {
  /** @deprecated use `SearchKnowledgeAnd3$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAnd3$inboundSchema;
  /** @deprecated use `SearchKnowledgeAnd3$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAnd3$outboundSchema;
  /** @deprecated use `SearchKnowledgeAnd3$Outbound` instead. */
  export type Outbound = SearchKnowledgeAnd3$Outbound;
}

export function searchKnowledgeAnd3ToJSON(
  searchKnowledgeAnd3: SearchKnowledgeAnd3,
): string {
  return JSON.stringify(
    SearchKnowledgeAnd3$outboundSchema.parse(searchKnowledgeAnd3),
  );
}

export function searchKnowledgeAnd3FromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAnd3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAnd3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAnd3' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndKnowledgeNe$inboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeAndKnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndKnowledgeNe$ {
  /** @deprecated use `SearchKnowledgeAndKnowledgeNe$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndKnowledgeNe$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeNe$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndKnowledgeNe$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeNe$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndKnowledgeNe$Outbound;
}

export function searchKnowledgeAndKnowledgeNeToJSON(
  searchKnowledgeAndKnowledgeNe: SearchKnowledgeAndKnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeNe$outboundSchema.parse(
      searchKnowledgeAndKnowledgeNe,
    ),
  );
}

export function searchKnowledgeAndKnowledgeNeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndKnowledgeNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndKnowledgeNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndKnowledgeNe' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndNe$inboundSchema: z.ZodType<
  SearchKnowledgeAndNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledgeAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeAndNe$outboundSchema: z.ZodType<
  SearchKnowledgeAndNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndNe$ {
  /** @deprecated use `SearchKnowledgeAndNe$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndNe$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndNe$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndNe$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndNe$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndNe$Outbound;
}

export function searchKnowledgeAndNeToJSON(
  searchKnowledgeAndNe: SearchKnowledgeAndNe,
): string {
  return JSON.stringify(
    SearchKnowledgeAndNe$outboundSchema.parse(searchKnowledgeAndNe),
  );
}

export function searchKnowledgeAndNeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndNe' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndKnowledgeEq$inboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledgeAndKnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledgeAndKnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledgeAndKnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndKnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndKnowledgeEq$ {
  /** @deprecated use `SearchKnowledgeAndKnowledgeEq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndKnowledgeEq$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeEq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndKnowledgeEq$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndKnowledgeEq$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndKnowledgeEq$Outbound;
}

export function searchKnowledgeAndKnowledgeEqToJSON(
  searchKnowledgeAndKnowledgeEq: SearchKnowledgeAndKnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledgeAndKnowledgeEq$outboundSchema.parse(
      searchKnowledgeAndKnowledgeEq,
    ),
  );
}

export function searchKnowledgeAndKnowledgeEqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndKnowledgeEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndKnowledgeEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndKnowledgeEq' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeAndEq$inboundSchema: z.ZodType<
  SearchKnowledgeAndEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledgeAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledgeAndEq$outboundSchema: z.ZodType<
  SearchKnowledgeAndEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeAndEq$ {
  /** @deprecated use `SearchKnowledgeAndEq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeAndEq$inboundSchema;
  /** @deprecated use `SearchKnowledgeAndEq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeAndEq$outboundSchema;
  /** @deprecated use `SearchKnowledgeAndEq$Outbound` instead. */
  export type Outbound = SearchKnowledgeAndEq$Outbound;
}

export function searchKnowledgeAndEqToJSON(
  searchKnowledgeAndEq: SearchKnowledgeAndEq,
): string {
  return JSON.stringify(
    SearchKnowledgeAndEq$outboundSchema.parse(searchKnowledgeAndEq),
  );
}

export function searchKnowledgeAndEqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeAndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeAndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeAndEq' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeFilterByAnd$inboundSchema: z.ZodType<
  SearchKnowledgeFilterByAnd,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SearchKnowledgeAndEq$inboundSchema),
  z.lazy(() => SearchKnowledgeAndNe$inboundSchema),
  z.lazy(() => SearchKnowledgeAnd3$inboundSchema),
  z.lazy(() => SearchKnowledgeAndGte$inboundSchema),
  z.lazy(() => SearchKnowledgeAndLt$inboundSchema),
  z.lazy(() => SearchKnowledgeAndLte$inboundSchema),
  z.lazy(() => SearchKnowledgeAndIn$inboundSchema),
  z.lazy(() => SearchKnowledgeAndNin$inboundSchema),
  z.lazy(() => SearchKnowledgeAndExists$inboundSchema),
]);

/** @internal */
export type SearchKnowledgeFilterByAnd$Outbound =
  | SearchKnowledgeAndEq$Outbound
  | SearchKnowledgeAndNe$Outbound
  | SearchKnowledgeAnd3$Outbound
  | SearchKnowledgeAndGte$Outbound
  | SearchKnowledgeAndLt$Outbound
  | SearchKnowledgeAndLte$Outbound
  | SearchKnowledgeAndIn$Outbound
  | SearchKnowledgeAndNin$Outbound
  | SearchKnowledgeAndExists$Outbound;

/** @internal */
export const SearchKnowledgeFilterByAnd$outboundSchema: z.ZodType<
  SearchKnowledgeFilterByAnd$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeFilterByAnd
> = z.union([
  z.lazy(() => SearchKnowledgeAndEq$outboundSchema),
  z.lazy(() => SearchKnowledgeAndNe$outboundSchema),
  z.lazy(() => SearchKnowledgeAnd3$outboundSchema),
  z.lazy(() => SearchKnowledgeAndGte$outboundSchema),
  z.lazy(() => SearchKnowledgeAndLt$outboundSchema),
  z.lazy(() => SearchKnowledgeAndLte$outboundSchema),
  z.lazy(() => SearchKnowledgeAndIn$outboundSchema),
  z.lazy(() => SearchKnowledgeAndNin$outboundSchema),
  z.lazy(() => SearchKnowledgeAndExists$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeFilterByAnd$ {
  /** @deprecated use `SearchKnowledgeFilterByAnd$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeFilterByAnd$inboundSchema;
  /** @deprecated use `SearchKnowledgeFilterByAnd$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeFilterByAnd$outboundSchema;
  /** @deprecated use `SearchKnowledgeFilterByAnd$Outbound` instead. */
  export type Outbound = SearchKnowledgeFilterByAnd$Outbound;
}

export function searchKnowledgeFilterByAndToJSON(
  searchKnowledgeFilterByAnd: SearchKnowledgeFilterByAnd,
): string {
  return JSON.stringify(
    SearchKnowledgeFilterByAnd$outboundSchema.parse(searchKnowledgeFilterByAnd),
  );
}

export function searchKnowledgeFilterByAndFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeFilterByAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeFilterByAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeFilterByAnd' from JSON`,
  );
}

/** @internal */
export const FilterByAnd$inboundSchema: z.ZodType<
  FilterByAnd,
  z.ZodTypeDef,
  unknown
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeAndEq$inboundSchema),
      z.lazy(() =>
        SearchKnowledgeAndNe$inboundSchema
      ),
      z.lazy(() => SearchKnowledgeAnd3$inboundSchema),
      z.lazy(() => SearchKnowledgeAndGte$inboundSchema),
      z.lazy(() => SearchKnowledgeAndLt$inboundSchema),
      z.lazy(() => SearchKnowledgeAndLte$inboundSchema),
      z.lazy(() => SearchKnowledgeAndIn$inboundSchema),
      z.lazy(() => SearchKnowledgeAndNin$inboundSchema),
      z.lazy(() => SearchKnowledgeAndExists$inboundSchema),
    ])),
  ),
});

/** @internal */
export type FilterByAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | SearchKnowledgeAndEq$Outbound
        | SearchKnowledgeAndNe$Outbound
        | SearchKnowledgeAnd3$Outbound
        | SearchKnowledgeAndGte$Outbound
        | SearchKnowledgeAndLt$Outbound
        | SearchKnowledgeAndLte$Outbound
        | SearchKnowledgeAndIn$Outbound
        | SearchKnowledgeAndNin$Outbound
        | SearchKnowledgeAndExists$Outbound;
    }
  >;
};

/** @internal */
export const FilterByAnd$outboundSchema: z.ZodType<
  FilterByAnd$Outbound,
  z.ZodTypeDef,
  FilterByAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => SearchKnowledgeAndEq$outboundSchema),
      z.lazy(() =>
        SearchKnowledgeAndNe$outboundSchema
      ),
      z.lazy(() => SearchKnowledgeAnd3$outboundSchema),
      z.lazy(() => SearchKnowledgeAndGte$outboundSchema),
      z.lazy(() => SearchKnowledgeAndLt$outboundSchema),
      z.lazy(() => SearchKnowledgeAndLte$outboundSchema),
      z.lazy(() => SearchKnowledgeAndIn$outboundSchema),
      z.lazy(() => SearchKnowledgeAndNin$outboundSchema),
      z.lazy(() => SearchKnowledgeAndExists$outboundSchema),
    ])),
  ),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterByAnd$ {
  /** @deprecated use `FilterByAnd$inboundSchema` instead. */
  export const inboundSchema = FilterByAnd$inboundSchema;
  /** @deprecated use `FilterByAnd$outboundSchema` instead. */
  export const outboundSchema = FilterByAnd$outboundSchema;
  /** @deprecated use `FilterByAnd$Outbound` instead. */
  export type Outbound = FilterByAnd$Outbound;
}

export function filterByAndToJSON(filterByAnd: FilterByAnd): string {
  return JSON.stringify(FilterByAnd$outboundSchema.parse(filterByAnd));
}

export function filterByAndFromJSON(
  jsonString: string,
): SafeParseResult<FilterByAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterByAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterByAnd' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Exists$inboundSchema: z.ZodType<
  SearchKnowledge1Exists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});

/** @internal */
export type SearchKnowledge1Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const SearchKnowledge1Exists$outboundSchema: z.ZodType<
  SearchKnowledge1Exists$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Exists
> = z.object({
  exists: z.boolean(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Exists$ {
  /** @deprecated use `SearchKnowledge1Exists$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Exists$inboundSchema;
  /** @deprecated use `SearchKnowledge1Exists$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Exists$outboundSchema;
  /** @deprecated use `SearchKnowledge1Exists$Outbound` instead. */
  export type Outbound = SearchKnowledge1Exists$Outbound;
}

export function searchKnowledge1ExistsToJSON(
  searchKnowledge1Exists: SearchKnowledge1Exists,
): string {
  return JSON.stringify(
    SearchKnowledge1Exists$outboundSchema.parse(searchKnowledge1Exists),
  );
}

export function searchKnowledge1ExistsFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Exists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Exists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Exists' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1KnowledgeNin$inboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledge1KnowledgeNin$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeNin$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNin$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1KnowledgeNin$ {
  /** @deprecated use `SearchKnowledge1KnowledgeNin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1KnowledgeNin$inboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeNin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1KnowledgeNin$outboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeNin$Outbound` instead. */
  export type Outbound = SearchKnowledge1KnowledgeNin$Outbound;
}

export function searchKnowledge1KnowledgeNinToJSON(
  searchKnowledge1KnowledgeNin: SearchKnowledge1KnowledgeNin,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeNin$outboundSchema.parse(
      searchKnowledge1KnowledgeNin,
    ),
  );
}

export function searchKnowledge1KnowledgeNinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1KnowledgeNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1KnowledgeNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1KnowledgeNin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Nin$inboundSchema: z.ZodType<
  SearchKnowledge1Nin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledge1Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledge1Nin$outboundSchema: z.ZodType<
  SearchKnowledge1Nin$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Nin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Nin$ {
  /** @deprecated use `SearchKnowledge1Nin$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Nin$inboundSchema;
  /** @deprecated use `SearchKnowledge1Nin$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Nin$outboundSchema;
  /** @deprecated use `SearchKnowledge1Nin$Outbound` instead. */
  export type Outbound = SearchKnowledge1Nin$Outbound;
}

export function searchKnowledge1NinToJSON(
  searchKnowledge1Nin: SearchKnowledge1Nin,
): string {
  return JSON.stringify(
    SearchKnowledge1Nin$outboundSchema.parse(searchKnowledge1Nin),
  );
}

export function searchKnowledge1NinFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Nin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Nin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Nin' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1KnowledgeIn$inboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledge1KnowledgeIn$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeIn$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeIn$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1KnowledgeIn$ {
  /** @deprecated use `SearchKnowledge1KnowledgeIn$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1KnowledgeIn$inboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeIn$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1KnowledgeIn$outboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeIn$Outbound` instead. */
  export type Outbound = SearchKnowledge1KnowledgeIn$Outbound;
}

export function searchKnowledge1KnowledgeInToJSON(
  searchKnowledge1KnowledgeIn: SearchKnowledge1KnowledgeIn,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeIn$outboundSchema.parse(
      searchKnowledge1KnowledgeIn,
    ),
  );
}

export function searchKnowledge1KnowledgeInFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1KnowledgeIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1KnowledgeIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1KnowledgeIn' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1In$inboundSchema: z.ZodType<
  SearchKnowledge1In,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/** @internal */
export type SearchKnowledge1In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const SearchKnowledge1In$outboundSchema: z.ZodType<
  SearchKnowledge1In$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1In
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1In$ {
  /** @deprecated use `SearchKnowledge1In$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1In$inboundSchema;
  /** @deprecated use `SearchKnowledge1In$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1In$outboundSchema;
  /** @deprecated use `SearchKnowledge1In$Outbound` instead. */
  export type Outbound = SearchKnowledge1In$Outbound;
}

export function searchKnowledge1InToJSON(
  searchKnowledge1In: SearchKnowledge1In,
): string {
  return JSON.stringify(
    SearchKnowledge1In$outboundSchema.parse(searchKnowledge1In),
  );
}

export function searchKnowledge1InFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1In, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1In$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1In' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Lte$inboundSchema: z.ZodType<
  SearchKnowledge1Lte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});

/** @internal */
export type SearchKnowledge1Lte$Outbound = {
  lte: number;
};

/** @internal */
export const SearchKnowledge1Lte$outboundSchema: z.ZodType<
  SearchKnowledge1Lte$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Lte
> = z.object({
  lte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Lte$ {
  /** @deprecated use `SearchKnowledge1Lte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Lte$inboundSchema;
  /** @deprecated use `SearchKnowledge1Lte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Lte$outboundSchema;
  /** @deprecated use `SearchKnowledge1Lte$Outbound` instead. */
  export type Outbound = SearchKnowledge1Lte$Outbound;
}

export function searchKnowledge1LteToJSON(
  searchKnowledge1Lte: SearchKnowledge1Lte,
): string {
  return JSON.stringify(
    SearchKnowledge1Lte$outboundSchema.parse(searchKnowledge1Lte),
  );
}

export function searchKnowledge1LteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Lte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Lte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Lte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Lt$inboundSchema: z.ZodType<
  SearchKnowledge1Lt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});

/** @internal */
export type SearchKnowledge1Lt$Outbound = {
  lt: number;
};

/** @internal */
export const SearchKnowledge1Lt$outboundSchema: z.ZodType<
  SearchKnowledge1Lt$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Lt
> = z.object({
  lt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Lt$ {
  /** @deprecated use `SearchKnowledge1Lt$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Lt$inboundSchema;
  /** @deprecated use `SearchKnowledge1Lt$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Lt$outboundSchema;
  /** @deprecated use `SearchKnowledge1Lt$Outbound` instead. */
  export type Outbound = SearchKnowledge1Lt$Outbound;
}

export function searchKnowledge1LtToJSON(
  searchKnowledge1Lt: SearchKnowledge1Lt,
): string {
  return JSON.stringify(
    SearchKnowledge1Lt$outboundSchema.parse(searchKnowledge1Lt),
  );
}

export function searchKnowledge1LtFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Lt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Lt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Lt' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Gte$inboundSchema: z.ZodType<
  SearchKnowledge1Gte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});

/** @internal */
export type SearchKnowledge1Gte$Outbound = {
  gte: number;
};

/** @internal */
export const SearchKnowledge1Gte$outboundSchema: z.ZodType<
  SearchKnowledge1Gte$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Gte
> = z.object({
  gte: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Gte$ {
  /** @deprecated use `SearchKnowledge1Gte$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Gte$inboundSchema;
  /** @deprecated use `SearchKnowledge1Gte$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Gte$outboundSchema;
  /** @deprecated use `SearchKnowledge1Gte$Outbound` instead. */
  export type Outbound = SearchKnowledge1Gte$Outbound;
}

export function searchKnowledge1GteToJSON(
  searchKnowledge1Gte: SearchKnowledge1Gte,
): string {
  return JSON.stringify(
    SearchKnowledge1Gte$outboundSchema.parse(searchKnowledge1Gte),
  );
}

export function searchKnowledge1GteFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Gte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Gte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Gte' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge13$inboundSchema: z.ZodType<
  SearchKnowledge13,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});

/** @internal */
export type SearchKnowledge13$Outbound = {
  gt: number;
};

/** @internal */
export const SearchKnowledge13$outboundSchema: z.ZodType<
  SearchKnowledge13$Outbound,
  z.ZodTypeDef,
  SearchKnowledge13
> = z.object({
  gt: z.number(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge13$ {
  /** @deprecated use `SearchKnowledge13$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge13$inboundSchema;
  /** @deprecated use `SearchKnowledge13$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge13$outboundSchema;
  /** @deprecated use `SearchKnowledge13$Outbound` instead. */
  export type Outbound = SearchKnowledge13$Outbound;
}

export function searchKnowledge13ToJSON(
  searchKnowledge13: SearchKnowledge13,
): string {
  return JSON.stringify(
    SearchKnowledge13$outboundSchema.parse(searchKnowledge13),
  );
}

export function searchKnowledge13FromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge13, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge13$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge13' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1KnowledgeNe$inboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledge1KnowledgeNe$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeNe$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeNe$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1KnowledgeNe$ {
  /** @deprecated use `SearchKnowledge1KnowledgeNe$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1KnowledgeNe$inboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeNe$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1KnowledgeNe$outboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeNe$Outbound` instead. */
  export type Outbound = SearchKnowledge1KnowledgeNe$Outbound;
}

export function searchKnowledge1KnowledgeNeToJSON(
  searchKnowledge1KnowledgeNe: SearchKnowledge1KnowledgeNe,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeNe$outboundSchema.parse(
      searchKnowledge1KnowledgeNe,
    ),
  );
}

export function searchKnowledge1KnowledgeNeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1KnowledgeNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1KnowledgeNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1KnowledgeNe' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Ne$inboundSchema: z.ZodType<
  SearchKnowledge1Ne,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledge1Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const SearchKnowledge1Ne$outboundSchema: z.ZodType<
  SearchKnowledge1Ne$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Ne
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Ne$ {
  /** @deprecated use `SearchKnowledge1Ne$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Ne$inboundSchema;
  /** @deprecated use `SearchKnowledge1Ne$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Ne$outboundSchema;
  /** @deprecated use `SearchKnowledge1Ne$Outbound` instead. */
  export type Outbound = SearchKnowledge1Ne$Outbound;
}

export function searchKnowledge1NeToJSON(
  searchKnowledge1Ne: SearchKnowledge1Ne,
): string {
  return JSON.stringify(
    SearchKnowledge1Ne$outboundSchema.parse(searchKnowledge1Ne),
  );
}

export function searchKnowledge1NeFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Ne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Ne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Ne' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1KnowledgeEq$inboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type SearchKnowledge1KnowledgeEq$Outbound = string | number | boolean;

/** @internal */
export const SearchKnowledge1KnowledgeEq$outboundSchema: z.ZodType<
  SearchKnowledge1KnowledgeEq$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1KnowledgeEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1KnowledgeEq$ {
  /** @deprecated use `SearchKnowledge1KnowledgeEq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1KnowledgeEq$inboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeEq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1KnowledgeEq$outboundSchema;
  /** @deprecated use `SearchKnowledge1KnowledgeEq$Outbound` instead. */
  export type Outbound = SearchKnowledge1KnowledgeEq$Outbound;
}

export function searchKnowledge1KnowledgeEqToJSON(
  searchKnowledge1KnowledgeEq: SearchKnowledge1KnowledgeEq,
): string {
  return JSON.stringify(
    SearchKnowledge1KnowledgeEq$outboundSchema.parse(
      searchKnowledge1KnowledgeEq,
    ),
  );
}

export function searchKnowledge1KnowledgeEqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1KnowledgeEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1KnowledgeEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1KnowledgeEq' from JSON`,
  );
}

/** @internal */
export const SearchKnowledge1Eq$inboundSchema: z.ZodType<
  SearchKnowledge1Eq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/** @internal */
export type SearchKnowledge1Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const SearchKnowledge1Eq$outboundSchema: z.ZodType<
  SearchKnowledge1Eq$Outbound,
  z.ZodTypeDef,
  SearchKnowledge1Eq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledge1Eq$ {
  /** @deprecated use `SearchKnowledge1Eq$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledge1Eq$inboundSchema;
  /** @deprecated use `SearchKnowledge1Eq$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledge1Eq$outboundSchema;
  /** @deprecated use `SearchKnowledge1Eq$Outbound` instead. */
  export type Outbound = SearchKnowledge1Eq$Outbound;
}

export function searchKnowledge1EqToJSON(
  searchKnowledge1Eq: SearchKnowledge1Eq,
): string {
  return JSON.stringify(
    SearchKnowledge1Eq$outboundSchema.parse(searchKnowledge1Eq),
  );
}

export function searchKnowledge1EqFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledge1Eq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledge1Eq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledge1Eq' from JSON`,
  );
}

/** @internal */
export const FilterBy1$inboundSchema: z.ZodType<
  FilterBy1,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SearchKnowledge1Eq$inboundSchema),
  z.lazy(() => SearchKnowledge1Ne$inboundSchema),
  z.lazy(() => SearchKnowledge13$inboundSchema),
  z.lazy(() => SearchKnowledge1Gte$inboundSchema),
  z.lazy(() => SearchKnowledge1Lt$inboundSchema),
  z.lazy(() => SearchKnowledge1Lte$inboundSchema),
  z.lazy(() => SearchKnowledge1In$inboundSchema),
  z.lazy(() => SearchKnowledge1Nin$inboundSchema),
  z.lazy(() => SearchKnowledge1Exists$inboundSchema),
]);

/** @internal */
export type FilterBy1$Outbound =
  | SearchKnowledge1Eq$Outbound
  | SearchKnowledge1Ne$Outbound
  | SearchKnowledge13$Outbound
  | SearchKnowledge1Gte$Outbound
  | SearchKnowledge1Lt$Outbound
  | SearchKnowledge1Lte$Outbound
  | SearchKnowledge1In$Outbound
  | SearchKnowledge1Nin$Outbound
  | SearchKnowledge1Exists$Outbound;

/** @internal */
export const FilterBy1$outboundSchema: z.ZodType<
  FilterBy1$Outbound,
  z.ZodTypeDef,
  FilterBy1
> = z.union([
  z.lazy(() => SearchKnowledge1Eq$outboundSchema),
  z.lazy(() => SearchKnowledge1Ne$outboundSchema),
  z.lazy(() => SearchKnowledge13$outboundSchema),
  z.lazy(() => SearchKnowledge1Gte$outboundSchema),
  z.lazy(() => SearchKnowledge1Lt$outboundSchema),
  z.lazy(() => SearchKnowledge1Lte$outboundSchema),
  z.lazy(() => SearchKnowledge1In$outboundSchema),
  z.lazy(() => SearchKnowledge1Nin$outboundSchema),
  z.lazy(() => SearchKnowledge1Exists$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterBy1$ {
  /** @deprecated use `FilterBy1$inboundSchema` instead. */
  export const inboundSchema = FilterBy1$inboundSchema;
  /** @deprecated use `FilterBy1$outboundSchema` instead. */
  export const outboundSchema = FilterBy1$outboundSchema;
  /** @deprecated use `FilterBy1$Outbound` instead. */
  export type Outbound = FilterBy1$Outbound;
}

export function filterBy1ToJSON(filterBy1: FilterBy1): string {
  return JSON.stringify(FilterBy1$outboundSchema.parse(filterBy1));
}

export function filterBy1FromJSON(
  jsonString: string,
): SafeParseResult<FilterBy1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterBy1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterBy1' from JSON`,
  );
}

/** @internal */
export const FilterBy$inboundSchema: z.ZodType<
  FilterBy,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FilterByAnd$inboundSchema),
  z.lazy(() => FilterByOr$inboundSchema),
  z.record(z.union([
    z.lazy(() => SearchKnowledge1Eq$inboundSchema),
    z.lazy(() => SearchKnowledge1Ne$inboundSchema),
    z.lazy(() => SearchKnowledge13$inboundSchema),
    z.lazy(() => SearchKnowledge1Gte$inboundSchema),
    z.lazy(() => SearchKnowledge1Lt$inboundSchema),
    z.lazy(() => SearchKnowledge1Lte$inboundSchema),
    z.lazy(() => SearchKnowledge1In$inboundSchema),
    z.lazy(() => SearchKnowledge1Nin$inboundSchema),
    z.lazy(() => SearchKnowledge1Exists$inboundSchema),
  ])),
]);

/** @internal */
export type FilterBy$Outbound = FilterByAnd$Outbound | FilterByOr$Outbound | {
  [k: string]:
    | SearchKnowledge1Eq$Outbound
    | SearchKnowledge1Ne$Outbound
    | SearchKnowledge13$Outbound
    | SearchKnowledge1Gte$Outbound
    | SearchKnowledge1Lt$Outbound
    | SearchKnowledge1Lte$Outbound
    | SearchKnowledge1In$Outbound
    | SearchKnowledge1Nin$Outbound
    | SearchKnowledge1Exists$Outbound;
};

/** @internal */
export const FilterBy$outboundSchema: z.ZodType<
  FilterBy$Outbound,
  z.ZodTypeDef,
  FilterBy
> = z.union([
  z.lazy(() => FilterByAnd$outboundSchema),
  z.lazy(() => FilterByOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => SearchKnowledge1Eq$outboundSchema),
    z.lazy(() => SearchKnowledge1Ne$outboundSchema),
    z.lazy(() => SearchKnowledge13$outboundSchema),
    z.lazy(() => SearchKnowledge1Gte$outboundSchema),
    z.lazy(() => SearchKnowledge1Lt$outboundSchema),
    z.lazy(() => SearchKnowledge1Lte$outboundSchema),
    z.lazy(() => SearchKnowledge1In$outboundSchema),
    z.lazy(() => SearchKnowledge1Nin$outboundSchema),
    z.lazy(() => SearchKnowledge1Exists$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FilterBy$ {
  /** @deprecated use `FilterBy$inboundSchema` instead. */
  export const inboundSchema = FilterBy$inboundSchema;
  /** @deprecated use `FilterBy$outboundSchema` instead. */
  export const outboundSchema = FilterBy$outboundSchema;
  /** @deprecated use `FilterBy$Outbound` instead. */
  export type Outbound = FilterBy$Outbound;
}

export function filterByToJSON(filterBy: FilterBy): string {
  return JSON.stringify(FilterBy$outboundSchema.parse(filterBy));
}

export function filterByFromJSON(
  jsonString: string,
): SafeParseResult<FilterBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilterBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilterBy' from JSON`,
  );
}

/** @internal */
export const SearchOptions$inboundSchema: z.ZodType<
  SearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_vectors: z.boolean().optional(),
  include_metadata: z.boolean().optional(),
  include_scores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_vectors": "includeVectors",
    "include_metadata": "includeMetadata",
    "include_scores": "includeScores",
  });
});

/** @internal */
export type SearchOptions$Outbound = {
  include_vectors?: boolean | undefined;
  include_metadata?: boolean | undefined;
  include_scores?: boolean | undefined;
};

/** @internal */
export const SearchOptions$outboundSchema: z.ZodType<
  SearchOptions$Outbound,
  z.ZodTypeDef,
  SearchOptions
> = z.object({
  includeVectors: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeScores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeVectors: "include_vectors",
    includeMetadata: "include_metadata",
    includeScores: "include_scores",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchOptions$ {
  /** @deprecated use `SearchOptions$inboundSchema` instead. */
  export const inboundSchema = SearchOptions$inboundSchema;
  /** @deprecated use `SearchOptions$outboundSchema` instead. */
  export const outboundSchema = SearchOptions$outboundSchema;
  /** @deprecated use `SearchOptions$Outbound` instead. */
  export type Outbound = SearchOptions$Outbound;
}

export function searchOptionsToJSON(searchOptions: SearchOptions): string {
  return JSON.stringify(SearchOptions$outboundSchema.parse(searchOptions));
}

export function searchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<SearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchOptions' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeRequestBody$inboundSchema: z.ZodType<
  SearchKnowledgeRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  query: z.string(),
  top_k: z.number().int().optional(),
  threshold: z.number().optional(),
  search_type: SearchType$inboundSchema.default("hybrid_search"),
  filter_by: z.union([
    z.lazy(() => FilterByAnd$inboundSchema),
    z.lazy(() => FilterByOr$inboundSchema),
    z.record(z.union([
      z.lazy(() => SearchKnowledge1Eq$inboundSchema),
      z.lazy(() => SearchKnowledge1Ne$inboundSchema),
      z.lazy(() => SearchKnowledge13$inboundSchema),
      z.lazy(() => SearchKnowledge1Gte$inboundSchema),
      z.lazy(() => SearchKnowledge1Lt$inboundSchema),
      z.lazy(() => SearchKnowledge1Lte$inboundSchema),
      z.lazy(() => SearchKnowledge1In$inboundSchema),
      z.lazy(() => SearchKnowledge1Nin$inboundSchema),
      z.lazy(() => SearchKnowledge1Exists$inboundSchema),
    ])),
  ]).optional(),
  search_options: z.lazy(() => SearchOptions$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "search_type": "searchType",
    "filter_by": "filterBy",
    "search_options": "searchOptions",
  });
});

/** @internal */
export type SearchKnowledgeRequestBody$Outbound = {
  query: string;
  top_k?: number | undefined;
  threshold?: number | undefined;
  search_type: string;
  filter_by?: FilterByAnd$Outbound | FilterByOr$Outbound | {
    [k: string]:
      | SearchKnowledge1Eq$Outbound
      | SearchKnowledge1Ne$Outbound
      | SearchKnowledge13$Outbound
      | SearchKnowledge1Gte$Outbound
      | SearchKnowledge1Lt$Outbound
      | SearchKnowledge1Lte$Outbound
      | SearchKnowledge1In$Outbound
      | SearchKnowledge1Nin$Outbound
      | SearchKnowledge1Exists$Outbound;
  } | undefined;
  search_options?: SearchOptions$Outbound | undefined;
};

/** @internal */
export const SearchKnowledgeRequestBody$outboundSchema: z.ZodType<
  SearchKnowledgeRequestBody$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeRequestBody
> = z.object({
  query: z.string(),
  topK: z.number().int().optional(),
  threshold: z.number().optional(),
  searchType: SearchType$outboundSchema.default("hybrid_search"),
  filterBy: z.union([
    z.lazy(() => FilterByAnd$outboundSchema),
    z.lazy(() => FilterByOr$outboundSchema),
    z.record(z.union([
      z.lazy(() => SearchKnowledge1Eq$outboundSchema),
      z.lazy(() => SearchKnowledge1Ne$outboundSchema),
      z.lazy(() => SearchKnowledge13$outboundSchema),
      z.lazy(() => SearchKnowledge1Gte$outboundSchema),
      z.lazy(() => SearchKnowledge1Lt$outboundSchema),
      z.lazy(() => SearchKnowledge1Lte$outboundSchema),
      z.lazy(() => SearchKnowledge1In$outboundSchema),
      z.lazy(() => SearchKnowledge1Nin$outboundSchema),
      z.lazy(() => SearchKnowledge1Exists$outboundSchema),
    ])),
  ]).optional(),
  searchOptions: z.lazy(() => SearchOptions$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    searchType: "search_type",
    filterBy: "filter_by",
    searchOptions: "search_options",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeRequestBody$ {
  /** @deprecated use `SearchKnowledgeRequestBody$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeRequestBody$inboundSchema;
  /** @deprecated use `SearchKnowledgeRequestBody$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeRequestBody$outboundSchema;
  /** @deprecated use `SearchKnowledgeRequestBody$Outbound` instead. */
  export type Outbound = SearchKnowledgeRequestBody$Outbound;
}

export function searchKnowledgeRequestBodyToJSON(
  searchKnowledgeRequestBody: SearchKnowledgeRequestBody,
): string {
  return JSON.stringify(
    SearchKnowledgeRequestBody$outboundSchema.parse(searchKnowledgeRequestBody),
  );
}

export function searchKnowledgeRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeRequestBody' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeRequest$inboundSchema: z.ZodType<
  SearchKnowledgeRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
  RequestBody: z.lazy(() => SearchKnowledgeRequestBody$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type SearchKnowledgeRequest$Outbound = {
  knowledge_id: string;
  RequestBody?: SearchKnowledgeRequestBody$Outbound | undefined;
};

/** @internal */
export const SearchKnowledgeRequest$outboundSchema: z.ZodType<
  SearchKnowledgeRequest$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeRequest
> = z.object({
  knowledgeId: z.string(),
  requestBody: z.lazy(() => SearchKnowledgeRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeRequest$ {
  /** @deprecated use `SearchKnowledgeRequest$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeRequest$inboundSchema;
  /** @deprecated use `SearchKnowledgeRequest$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeRequest$outboundSchema;
  /** @deprecated use `SearchKnowledgeRequest$Outbound` instead. */
  export type Outbound = SearchKnowledgeRequest$Outbound;
}

export function searchKnowledgeRequestToJSON(
  searchKnowledgeRequest: SearchKnowledgeRequest,
): string {
  return JSON.stringify(
    SearchKnowledgeRequest$outboundSchema.parse(searchKnowledgeRequest),
  );
}

export function searchKnowledgeRequestFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeRequest' from JSON`,
  );
}

/** @internal */
export const Scores$inboundSchema: z.ZodType<Scores, z.ZodTypeDef, unknown> = z
  .object({
    rerank_score: z.number().optional(),
    search_score: z.number().optional(),
  }).transform((v) => {
    return remap$(v, {
      "rerank_score": "rerankScore",
      "search_score": "searchScore",
    });
  });

/** @internal */
export type Scores$Outbound = {
  rerank_score?: number | undefined;
  search_score?: number | undefined;
};

/** @internal */
export const Scores$outboundSchema: z.ZodType<
  Scores$Outbound,
  z.ZodTypeDef,
  Scores
> = z.object({
  rerankScore: z.number().optional(),
  searchScore: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    rerankScore: "rerank_score",
    searchScore: "search_score",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Scores$ {
  /** @deprecated use `Scores$inboundSchema` instead. */
  export const inboundSchema = Scores$inboundSchema;
  /** @deprecated use `Scores$outboundSchema` instead. */
  export const outboundSchema = Scores$outboundSchema;
  /** @deprecated use `Scores$Outbound` instead. */
  export type Outbound = Scores$Outbound;
}

export function scoresToJSON(scores: Scores): string {
  return JSON.stringify(Scores$outboundSchema.parse(scores));
}

export function scoresFromJSON(
  jsonString: string,
): SafeParseResult<Scores, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Scores$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Scores' from JSON`,
  );
}

/** @internal */
export const Matches$inboundSchema: z.ZodType<Matches, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    text: z.string(),
    vector: z.array(z.number()).optional(),
    metadata: z.record(z.any()).optional(),
    scores: z.lazy(() => Scores$inboundSchema).optional(),
  });

/** @internal */
export type Matches$Outbound = {
  id: string;
  text: string;
  vector?: Array<number> | undefined;
  metadata?: { [k: string]: any } | undefined;
  scores?: Scores$Outbound | undefined;
};

/** @internal */
export const Matches$outboundSchema: z.ZodType<
  Matches$Outbound,
  z.ZodTypeDef,
  Matches
> = z.object({
  id: z.string(),
  text: z.string(),
  vector: z.array(z.number()).optional(),
  metadata: z.record(z.any()).optional(),
  scores: z.lazy(() => Scores$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Matches$ {
  /** @deprecated use `Matches$inboundSchema` instead. */
  export const inboundSchema = Matches$inboundSchema;
  /** @deprecated use `Matches$outboundSchema` instead. */
  export const outboundSchema = Matches$outboundSchema;
  /** @deprecated use `Matches$Outbound` instead. */
  export type Outbound = Matches$Outbound;
}

export function matchesToJSON(matches: Matches): string {
  return JSON.stringify(Matches$outboundSchema.parse(matches));
}

export function matchesFromJSON(
  jsonString: string,
): SafeParseResult<Matches, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Matches$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Matches' from JSON`,
  );
}

/** @internal */
export const SearchKnowledgeResponseBody$inboundSchema: z.ZodType<
  SearchKnowledgeResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  matches: z.array(z.lazy(() => Matches$inboundSchema)),
});

/** @internal */
export type SearchKnowledgeResponseBody$Outbound = {
  matches: Array<Matches$Outbound>;
};

/** @internal */
export const SearchKnowledgeResponseBody$outboundSchema: z.ZodType<
  SearchKnowledgeResponseBody$Outbound,
  z.ZodTypeDef,
  SearchKnowledgeResponseBody
> = z.object({
  matches: z.array(z.lazy(() => Matches$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchKnowledgeResponseBody$ {
  /** @deprecated use `SearchKnowledgeResponseBody$inboundSchema` instead. */
  export const inboundSchema = SearchKnowledgeResponseBody$inboundSchema;
  /** @deprecated use `SearchKnowledgeResponseBody$outboundSchema` instead. */
  export const outboundSchema = SearchKnowledgeResponseBody$outboundSchema;
  /** @deprecated use `SearchKnowledgeResponseBody$Outbound` instead. */
  export type Outbound = SearchKnowledgeResponseBody$Outbound;
}

export function searchKnowledgeResponseBodyToJSON(
  searchKnowledgeResponseBody: SearchKnowledgeResponseBody,
): string {
  return JSON.stringify(
    SearchKnowledgeResponseBody$outboundSchema.parse(
      searchKnowledgeResponseBody,
    ),
  );
}

export function searchKnowledgeResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<SearchKnowledgeResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchKnowledgeResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchKnowledgeResponseBody' from JSON`,
  );
}
