/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
 */
export const CreateImageVariationResponseFormat = {
  Url: "url",
  B64Json: "b64_json",
} as const;
/**
 * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
 */
export type CreateImageVariationResponseFormat = ClosedEnum<
  typeof CreateImageVariationResponseFormat
>;

/**
 * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
 */
export const Size = {
  TwoHundredAndFiftySixx256: "256x256",
  FiveHundredAndTwelvex512: "512x512",
  OneThousandAndTwentyFourx1024: "1024x1024",
} as const;
/**
 * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
 */
export type Size = ClosedEnum<typeof Size>;

/**
 * Retry configuration for the request
 */
export type CreateImageVariationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateImageVariationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export const CreateImageVariationVersion = {
  Latest: "latest",
} as const;
/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export type CreateImageVariationVersion = ClosedEnum<
  typeof CreateImageVariationVersion
>;

/**
 * Prompt configuration for the request
 */
export type CreateImageVariationPrompt = {
  /**
   * Unique identifier of the prompt to use
   */
  id: string;
  /**
   * Version of the prompt to use (currently only "latest" supported)
   */
  version: CreateImageVariationVersion;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateImageVariationContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

export const CreateImageVariationType = {
  ExactMatch: "exact_match",
} as const;
export type CreateImageVariationType = ClosedEnum<
  typeof CreateImageVariationType
>;

/**
 * Cache configuration for the request.
 */
export type CreateImageVariationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateImageVariationType;
};

export const CreateImageVariationLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateImageVariationLoadBalancerType = ClosedEnum<
  typeof CreateImageVariationLoadBalancerType
>;

export type CreateImageVariationLoadBalancer1 = {
  type: CreateImageVariationLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateImageVariationLoadBalancer =
  CreateImageVariationLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateImageVariationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateImageVariationOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateImageVariationRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateImageVariationFallbacks> | undefined;
  /**
   * Prompt configuration for the request
   */
  prompt?: CreateImageVariationPrompt | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateImageVariationContact | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateImageVariationCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateImageVariationLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateImageVariationTimeout | undefined;
};

/**
 * input
 */
export type CreateImageVariationRequestBody = {
  /**
   * The image to edit. Must be a supported image file. It should be a png, webp, or jpg file less than 50MB.
   */
  image?: any | undefined;
  /**
   * The model to use for image generation.
   */
  model: string;
  /**
   * The number of images to generate. Must be between 1 and 10.
   */
  n?: number | null | undefined;
  /**
   * The format in which the generated images are returned. Must be one of `url` or `b64_json`. URLs are only valid for 60 minutes after the image has been generated.
   */
  responseFormat?: CreateImageVariationResponseFormat | undefined;
  /**
   * The size of the generated images. Must be one of `256x256`, `512x512`, or `1024x1024`.
   */
  size?: Size | undefined;
  /**
   * A unique identifier representing your end-user, which can help to monitor and detect abuse.
   */
  user?: string | undefined;
  orq?: CreateImageVariationOrq | undefined;
};

export type CreateImageVariationData = {
  /**
   * The base64-encoded JSON of the generated image, if response_format is b64_json
   */
  b64Json?: string | undefined;
  /**
   * The URL of the generated image, if response_format is url (default)
   */
  url?: string | undefined;
};

/**
 * The input tokens detailed information for the image generation.
 */
export type CreateImageVariationInputTokensDetails = {
  /**
   * The number of text tokens in the input prompt.
   */
  textTokens: number;
  /**
   * The number of image tokens in the input prompt.
   */
  imageTokens: number;
};

/**
 * The token usage information for the image generation.
 */
export type CreateImageVariationUsage = {
  /**
   * The total number of tokens (images and text) used for the image generation.
   */
  totalTokens: number;
  /**
   * The number of tokens (images and text) in the input prompt.
   */
  inputTokens: number;
  /**
   * The number of output tokens generated by the model.
   */
  outputTokens: number;
  /**
   * The input tokens detailed information for the image generation.
   */
  inputTokensDetails: CreateImageVariationInputTokensDetails;
};

/**
 * Represents an image variation response from the API.
 */
export type CreateImageVariationResponseBody = {
  /**
   * The Unix timestamp (in seconds) of when the image was created.
   */
  created: number;
  /**
   * The output format of the image generation
   */
  outputFormat?: string | undefined;
  /**
   * The size of the image generated
   */
  size?: string | undefined;
  /**
   * The quality of the image generated
   */
  quality?: string | undefined;
  /**
   * The list of generated images.
   */
  data: Array<CreateImageVariationData>;
  /**
   * The token usage information for the image generation.
   */
  usage?: CreateImageVariationUsage | undefined;
};

/** @internal */
export const CreateImageVariationResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageVariationResponseFormat
> = z.nativeEnum(CreateImageVariationResponseFormat);

/** @internal */
export const Size$outboundSchema: z.ZodNativeEnum<typeof Size> = z.nativeEnum(
  Size,
);

/** @internal */
export type CreateImageVariationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateImageVariationRetry$outboundSchema: z.ZodType<
  CreateImageVariationRetry$Outbound,
  z.ZodTypeDef,
  CreateImageVariationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createImageVariationRetryToJSON(
  createImageVariationRetry: CreateImageVariationRetry,
): string {
  return JSON.stringify(
    CreateImageVariationRetry$outboundSchema.parse(createImageVariationRetry),
  );
}

/** @internal */
export type CreateImageVariationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateImageVariationFallbacks$outboundSchema: z.ZodType<
  CreateImageVariationFallbacks$Outbound,
  z.ZodTypeDef,
  CreateImageVariationFallbacks
> = z.object({
  model: z.string(),
});

export function createImageVariationFallbacksToJSON(
  createImageVariationFallbacks: CreateImageVariationFallbacks,
): string {
  return JSON.stringify(
    CreateImageVariationFallbacks$outboundSchema.parse(
      createImageVariationFallbacks,
    ),
  );
}

/** @internal */
export const CreateImageVariationVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageVariationVersion
> = z.nativeEnum(CreateImageVariationVersion);

/** @internal */
export type CreateImageVariationPrompt$Outbound = {
  id: string;
  version: string;
};

/** @internal */
export const CreateImageVariationPrompt$outboundSchema: z.ZodType<
  CreateImageVariationPrompt$Outbound,
  z.ZodTypeDef,
  CreateImageVariationPrompt
> = z.object({
  id: z.string(),
  version: CreateImageVariationVersion$outboundSchema,
});

export function createImageVariationPromptToJSON(
  createImageVariationPrompt: CreateImageVariationPrompt,
): string {
  return JSON.stringify(
    CreateImageVariationPrompt$outboundSchema.parse(createImageVariationPrompt),
  );
}

/** @internal */
export type CreateImageVariationContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateImageVariationContact$outboundSchema: z.ZodType<
  CreateImageVariationContact$Outbound,
  z.ZodTypeDef,
  CreateImageVariationContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createImageVariationContactToJSON(
  createImageVariationContact: CreateImageVariationContact,
): string {
  return JSON.stringify(
    CreateImageVariationContact$outboundSchema.parse(
      createImageVariationContact,
    ),
  );
}

/** @internal */
export const CreateImageVariationType$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageVariationType
> = z.nativeEnum(CreateImageVariationType);

/** @internal */
export type CreateImageVariationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateImageVariationCache$outboundSchema: z.ZodType<
  CreateImageVariationCache$Outbound,
  z.ZodTypeDef,
  CreateImageVariationCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateImageVariationType$outboundSchema,
});

export function createImageVariationCacheToJSON(
  createImageVariationCache: CreateImageVariationCache,
): string {
  return JSON.stringify(
    CreateImageVariationCache$outboundSchema.parse(createImageVariationCache),
  );
}

/** @internal */
export const CreateImageVariationLoadBalancerType$outboundSchema:
  z.ZodNativeEnum<typeof CreateImageVariationLoadBalancerType> = z.nativeEnum(
    CreateImageVariationLoadBalancerType,
  );

/** @internal */
export type CreateImageVariationLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const CreateImageVariationLoadBalancer1$outboundSchema: z.ZodType<
  CreateImageVariationLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateImageVariationLoadBalancer1
> = z.object({
  type: CreateImageVariationLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createImageVariationLoadBalancer1ToJSON(
  createImageVariationLoadBalancer1: CreateImageVariationLoadBalancer1,
): string {
  return JSON.stringify(
    CreateImageVariationLoadBalancer1$outboundSchema.parse(
      createImageVariationLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateImageVariationLoadBalancer$Outbound =
  CreateImageVariationLoadBalancer1$Outbound;

/** @internal */
export const CreateImageVariationLoadBalancer$outboundSchema: z.ZodType<
  CreateImageVariationLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateImageVariationLoadBalancer
> = z.lazy(() => CreateImageVariationLoadBalancer1$outboundSchema);

export function createImageVariationLoadBalancerToJSON(
  createImageVariationLoadBalancer: CreateImageVariationLoadBalancer,
): string {
  return JSON.stringify(
    CreateImageVariationLoadBalancer$outboundSchema.parse(
      createImageVariationLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateImageVariationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateImageVariationTimeout$outboundSchema: z.ZodType<
  CreateImageVariationTimeout$Outbound,
  z.ZodTypeDef,
  CreateImageVariationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createImageVariationTimeoutToJSON(
  createImageVariationTimeout: CreateImageVariationTimeout,
): string {
  return JSON.stringify(
    CreateImageVariationTimeout$outboundSchema.parse(
      createImageVariationTimeout,
    ),
  );
}

/** @internal */
export type CreateImageVariationOrq$Outbound = {
  name?: string | undefined;
  retry?: CreateImageVariationRetry$Outbound | undefined;
  fallbacks?: Array<CreateImageVariationFallbacks$Outbound> | undefined;
  prompt?: CreateImageVariationPrompt$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateImageVariationContact$Outbound | undefined;
  cache?: CreateImageVariationCache$Outbound | undefined;
  load_balancer?: Array<CreateImageVariationLoadBalancer1$Outbound> | undefined;
  timeout?: CreateImageVariationTimeout$Outbound | undefined;
};

/** @internal */
export const CreateImageVariationOrq$outboundSchema: z.ZodType<
  CreateImageVariationOrq$Outbound,
  z.ZodTypeDef,
  CreateImageVariationOrq
> = z.object({
  name: z.string().optional(),
  retry: z.lazy(() => CreateImageVariationRetry$outboundSchema).optional(),
  fallbacks: z.array(z.lazy(() => CreateImageVariationFallbacks$outboundSchema))
    .optional(),
  prompt: z.lazy(() => CreateImageVariationPrompt$outboundSchema).optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateImageVariationContact$outboundSchema).optional(),
  cache: z.lazy(() => CreateImageVariationCache$outboundSchema).optional(),
  loadBalancer: z.array(
    z.lazy(() => CreateImageVariationLoadBalancer1$outboundSchema),
  ).optional(),
  timeout: z.lazy(() => CreateImageVariationTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createImageVariationOrqToJSON(
  createImageVariationOrq: CreateImageVariationOrq,
): string {
  return JSON.stringify(
    CreateImageVariationOrq$outboundSchema.parse(createImageVariationOrq),
  );
}

/** @internal */
export type CreateImageVariationRequestBody$Outbound = {
  image?: any | undefined;
  model: string;
  n: number | null;
  response_format: string;
  size: string;
  user?: string | undefined;
  orq?: CreateImageVariationOrq$Outbound | undefined;
};

/** @internal */
export const CreateImageVariationRequestBody$outboundSchema: z.ZodType<
  CreateImageVariationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateImageVariationRequestBody
> = z.object({
  image: z.any().optional(),
  model: z.string(),
  n: z.nullable(z.number().int().default(1)),
  responseFormat: CreateImageVariationResponseFormat$outboundSchema.default(
    "url",
  ),
  size: Size$outboundSchema.default("1024x1024"),
  user: z.string().optional(),
  orq: z.lazy(() => CreateImageVariationOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    responseFormat: "response_format",
  });
});

export function createImageVariationRequestBodyToJSON(
  createImageVariationRequestBody: CreateImageVariationRequestBody,
): string {
  return JSON.stringify(
    CreateImageVariationRequestBody$outboundSchema.parse(
      createImageVariationRequestBody,
    ),
  );
}

/** @internal */
export const CreateImageVariationData$inboundSchema: z.ZodType<
  CreateImageVariationData,
  z.ZodTypeDef,
  unknown
> = z.object({
  b64_json: z.string().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "b64_json": "b64Json",
  });
});

export function createImageVariationDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageVariationData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageVariationData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageVariationData' from JSON`,
  );
}

/** @internal */
export const CreateImageVariationInputTokensDetails$inboundSchema: z.ZodType<
  CreateImageVariationInputTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  text_tokens: z.number(),
  image_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "text_tokens": "textTokens",
    "image_tokens": "imageTokens",
  });
});

export function createImageVariationInputTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageVariationInputTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateImageVariationInputTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageVariationInputTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateImageVariationUsage$inboundSchema: z.ZodType<
  CreateImageVariationUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_tokens: z.number(),
  input_tokens: z.number(),
  output_tokens: z.number(),
  input_tokens_details: z.lazy(() =>
    CreateImageVariationInputTokensDetails$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "total_tokens": "totalTokens",
    "input_tokens": "inputTokens",
    "output_tokens": "outputTokens",
    "input_tokens_details": "inputTokensDetails",
  });
});

export function createImageVariationUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageVariationUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageVariationUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageVariationUsage' from JSON`,
  );
}

/** @internal */
export const CreateImageVariationResponseBody$inboundSchema: z.ZodType<
  CreateImageVariationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  created: z.number(),
  output_format: z.string().optional(),
  size: z.string().optional(),
  quality: z.string().optional(),
  data: z.array(z.lazy(() => CreateImageVariationData$inboundSchema)),
  usage: z.lazy(() => CreateImageVariationUsage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "output_format": "outputFormat",
  });
});

export function createImageVariationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageVariationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageVariationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageVariationResponseBody' from JSON`,
  );
}
