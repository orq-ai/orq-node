/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const UseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type UseCases = ClosedEnum<typeof UseCases>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const CreatePromptLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type CreatePromptLanguage = ClosedEnum<typeof CreatePromptLanguage>;

export type CreatePromptMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<UseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: CreatePromptLanguage | null | undefined;
};

/**
 * The role of the prompt message
 */
export const CreatePromptRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type CreatePromptRole = ClosedEnum<typeof CreatePromptRole>;

export type TwoFile = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Two3 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: TwoFile;
};

export type TwoImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type CreatePrompt22 = {
  type: "image_url";
  imageUrl: TwoImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type Two1 = {
  type: "text";
  text: string;
};

export type CreatePromptContent2 = Two1 | CreatePrompt22 | Two3;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type CreatePromptContent = string | Array<Two1 | CreatePrompt22 | Two3>;

export const CreatePromptType = {
  Function: "function",
} as const;
export type CreatePromptType = ClosedEnum<typeof CreatePromptType>;

export type CreatePromptFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type CreatePromptToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: CreatePromptType;
  function: CreatePromptFunction;
};

export type CreatePromptMessages = {
  /**
   * The role of the prompt message
   */
  role: CreatePromptRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content: string | Array<Two1 | CreatePrompt22 | Two3> | null;
  toolCalls?: Array<CreatePromptToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * Only supported on `image` models.
 */
export const CreatePromptFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type CreatePromptFormat = ClosedEnum<typeof CreatePromptFormat>;

export const Six = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type Six = ClosedEnum<typeof Six>;

export const Five = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type Five = ClosedEnum<typeof Five>;

export const ResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type ResponseFormat4 = ClosedEnum<typeof ResponseFormat4>;

export const CreatePromptResponseFormatPromptsRequestType = {
  Text: "text",
} as const;
export type CreatePromptResponseFormatPromptsRequestType = ClosedEnum<
  typeof CreatePromptResponseFormatPromptsRequestType
>;

export type ResponseFormat3 = {
  type: CreatePromptResponseFormatPromptsRequestType;
};

export const CreatePromptResponseFormatPromptsType = {
  JsonObject: "json_object",
} as const;
export type CreatePromptResponseFormatPromptsType = ClosedEnum<
  typeof CreatePromptResponseFormatPromptsType
>;

export type ResponseFormat2 = {
  type: CreatePromptResponseFormatPromptsType;
};

export const CreatePromptResponseFormatType = {
  JsonSchema: "json_schema",
} as const;
export type CreatePromptResponseFormatType = ClosedEnum<
  typeof CreatePromptResponseFormatType
>;

export type CreatePromptResponseFormatJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type ResponseFormat1 = {
  type: CreatePromptResponseFormatType;
  displayName?: string | undefined;
  jsonSchema: CreatePromptResponseFormatJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type CreatePromptResponseFormat =
  | ResponseFormat1
  | ResponseFormat2
  | ResponseFormat3
  | ResponseFormat4
  | Five
  | Six;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const PhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type PhotoRealVersion = ClosedEnum<typeof PhotoRealVersion>;

/**
 * The format to return the embeddings
 */
export const EncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type EncodingFormat = ClosedEnum<typeof EncodingFormat>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const ReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type ReasoningEffort = ClosedEnum<typeof ReasoningEffort>;

/**
 * Controls the verbosity of the model output.
 */
export const Verbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type Verbosity = ClosedEnum<typeof Verbosity>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const CreatePromptThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type CreatePromptThinkingLevel = ClosedEnum<
  typeof CreatePromptThinkingLevel
>;

/**
 * Optional model parameters like temperature and maxTokens.
 */
export type ModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: CreatePromptFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | ResponseFormat1
    | ResponseFormat2
    | ResponseFormat3
    | ResponseFormat4
    | Five
    | Six
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: PhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: EncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: ReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: Verbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: CreatePromptThinkingLevel | undefined;
};

/**
 * [DEPRECATED]. Please use the `prompt` property instead. The current `prompt_config` will keep working but it will be deprecated in future versions. Configuration for the prompt including model and messages.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type PromptConfiguration = {
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `google/gemini-2.5-pro`. The full list of models can be found at https://docs.orq.ai/docs/ai-gateway-supported-models. Only chat models are supported.
   */
  model?: string | undefined;
  /**
   * Array of messages that make up the conversation.
   */
  messages: Array<CreatePromptMessages>;
  /**
   * Optional model parameters like temperature and maxTokens.
   */
  modelParameters?: ModelParameters | undefined;
};

export type CreatePromptContentPromptsRequestRequestBody2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type CreatePromptMessagesPromptsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreatePromptMessagesPromptsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreatePromptMessagesPromptsType = ClosedEnum<
  typeof CreatePromptMessagesPromptsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreatePromptMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreatePromptMessagesTtl = ClosedEnum<
  typeof CreatePromptMessagesTtl
>;

export type CreatePromptMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreatePromptMessagesPromptsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreatePromptMessagesTtl | undefined;
};

export type CreatePromptMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
  cacheControl?: CreatePromptMessagesCacheControl | undefined;
};

export type CreatePromptContentPromptsRequest2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type CreatePromptMessagesPromptsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type CreatePromptMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const CreatePromptMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type CreatePromptMessagesType = ClosedEnum<
  typeof CreatePromptMessagesType
>;

export type CreatePromptMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreatePromptMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: CreatePromptMessagesType;
  function: CreatePromptMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type CreatePromptMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: CreatePromptMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<CreatePromptMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreatePrompt2PromptsRequestRequestBodyPromptType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreatePrompt2PromptsRequestRequestBodyPromptType = ClosedEnum<
  typeof CreatePrompt2PromptsRequestRequestBodyPromptType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreatePrompt2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreatePrompt2Ttl = ClosedEnum<typeof CreatePrompt2Ttl>;

export type CreatePrompt2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreatePrompt2PromptsRequestRequestBodyPromptType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreatePrompt2Ttl | undefined;
};

export type CreatePrompt24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: CreatePrompt2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type CreatePromptContentPrompts2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | CreatePrompt24;

/**
 * The contents of the user message.
 */
export type CreatePromptMessagesPromptsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | CreatePrompt24
  >;

export type CreatePromptMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | CreatePrompt24
    >;
};

/**
 * The contents of the system message.
 */
export type CreatePromptMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type CreatePromptMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type CreatePromptPromptsMessages =
  | CreatePromptMessagesSystemMessage
  | CreatePromptMessagesUserMessage
  | CreatePromptMessagesAssistantMessage
  | CreatePromptMessagesToolMessage;

export type CreatePromptResponseFormatPromptsRequestJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreatePromptResponseFormatPromptsJSONSchema = {
  type: "json_schema";
  jsonSchema: CreatePromptResponseFormatPromptsRequestJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreatePromptResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreatePromptResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreatePromptPromptsResponseFormat =
  | CreatePromptResponseFormatText
  | CreatePromptResponseFormatJSONObject
  | CreatePromptResponseFormatPromptsJSONSchema;

/**
 * Prompt configuration with model and messages. Either this field or `prompt_config` must be provided.
 */
export type PromptInput = {
  /**
   * Array of messages that make up the conversation. Each message has a role (system, user, assistant, or tool) and content.
   */
  messages: Array<
    | CreatePromptMessagesSystemMessage
    | CreatePromptMessagesUserMessage
    | CreatePromptMessagesAssistantMessage
    | CreatePromptMessagesToolMessage
  >;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-3-5-sonnet-20241022`. The full list of models can be found at https://docs.orq.ai/docs/ai-gateway-supported-models. Only chat models are supported.
   */
  model?: string | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreatePromptResponseFormatText
    | CreatePromptResponseFormatJSONObject
    | CreatePromptResponseFormatPromptsJSONSchema
    | undefined;
};

export type CreatePromptRequestBody = {
  /**
   * The prompt’s name, meant to be displayable in the UI.
   */
  displayName: string;
  /**
   * The prompt’s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  metadata?: CreatePromptMetadata | undefined;
  /**
   * [DEPRECATED]. Please use the `prompt` property instead. The current `prompt_config` will keep working but it will be deprecated in future versions. Configuration for the prompt including model and messages.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  promptConfig?: PromptConfiguration | undefined;
  /**
   * Prompt configuration with model and messages. Either this field or `prompt_config` must be provided.
   */
  prompt?: PromptInput | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
};

export const CreatePromptPromptsType = {
  Prompt: "prompt",
} as const;
export type CreatePromptPromptsType = ClosedEnum<
  typeof CreatePromptPromptsType
>;

/**
 * The modality of the model
 */
export const CreatePromptModelType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The modality of the model
 */
export type CreatePromptModelType = ClosedEnum<typeof CreatePromptModelType>;

/**
 * Only supported on `image` models.
 */
export const CreatePromptPromptsFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type CreatePromptPromptsFormat = ClosedEnum<
  typeof CreatePromptPromptsFormat
>;

export const CreatePromptResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type CreatePromptResponseFormat6 = ClosedEnum<
  typeof CreatePromptResponseFormat6
>;

export const CreatePromptResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type CreatePromptResponseFormat5 = ClosedEnum<
  typeof CreatePromptResponseFormat5
>;

export const CreatePromptResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type CreatePromptResponseFormat4 = ClosedEnum<
  typeof CreatePromptResponseFormat4
>;

export const CreatePromptResponseFormatPromptsResponse200ApplicationJSONType = {
  Text: "text",
} as const;
export type CreatePromptResponseFormatPromptsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof CreatePromptResponseFormatPromptsResponse200ApplicationJSONType
  >;

export type CreatePromptResponseFormat3 = {
  type: CreatePromptResponseFormatPromptsResponse200ApplicationJSONType;
};

export const CreatePromptResponseFormatPromptsResponse200Type = {
  JsonObject: "json_object",
} as const;
export type CreatePromptResponseFormatPromptsResponse200Type = ClosedEnum<
  typeof CreatePromptResponseFormatPromptsResponse200Type
>;

export type CreatePromptResponseFormat2 = {
  type: CreatePromptResponseFormatPromptsResponse200Type;
};

export const CreatePromptResponseFormatPromptsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type CreatePromptResponseFormatPromptsResponseType = ClosedEnum<
  typeof CreatePromptResponseFormatPromptsResponseType
>;

export type CreatePromptResponseFormatPromptsResponseJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type CreatePromptResponseFormat1 = {
  type: CreatePromptResponseFormatPromptsResponseType;
  displayName?: string | undefined;
  jsonSchema: CreatePromptResponseFormatPromptsResponseJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type CreatePromptPromptsResponseResponseFormat =
  | CreatePromptResponseFormat1
  | CreatePromptResponseFormat2
  | CreatePromptResponseFormat3
  | CreatePromptResponseFormat4
  | CreatePromptResponseFormat5
  | CreatePromptResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const CreatePromptPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type CreatePromptPhotoRealVersion = ClosedEnum<
  typeof CreatePromptPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const CreatePromptEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type CreatePromptEncodingFormat = ClosedEnum<
  typeof CreatePromptEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const CreatePromptReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type CreatePromptReasoningEffort = ClosedEnum<
  typeof CreatePromptReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const CreatePromptVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type CreatePromptVerbosity = ClosedEnum<typeof CreatePromptVerbosity>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const CreatePromptPromptsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type CreatePromptPromptsThinkingLevel = ClosedEnum<
  typeof CreatePromptPromptsThinkingLevel
>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type CreatePromptModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: CreatePromptPromptsFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | CreatePromptResponseFormat1
    | CreatePromptResponseFormat2
    | CreatePromptResponseFormat3
    | CreatePromptResponseFormat4
    | CreatePromptResponseFormat5
    | CreatePromptResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: CreatePromptPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: CreatePromptEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: CreatePromptReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: CreatePromptVerbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: CreatePromptPromptsThinkingLevel | undefined;
};

export const CreatePromptProvider = {
  Openai: "openai",
  Groq: "groq",
  Cohere: "cohere",
  Azure: "azure",
  Aws: "aws",
  Google: "google",
  GoogleAi: "google-ai",
  Huggingface: "huggingface",
  Togetherai: "togetherai",
  Perplexity: "perplexity",
  Anthropic: "anthropic",
  Leonardoai: "leonardoai",
  Fal: "fal",
  Nvidia: "nvidia",
  Jina: "jina",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Cerebras: "cerebras",
  Openailike: "openailike",
  Bytedance: "bytedance",
  Mistral: "mistral",
  Deepseek: "deepseek",
  Contextualai: "contextualai",
  Moonshotai: "moonshotai",
} as const;
export type CreatePromptProvider = ClosedEnum<typeof CreatePromptProvider>;

/**
 * The role of the prompt message
 */
export const CreatePromptPromptsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type CreatePromptPromptsRole = ClosedEnum<
  typeof CreatePromptPromptsRole
>;

export type CreatePrompt2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type CreatePrompt23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: CreatePrompt2File;
};

export type CreatePrompt2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type CreatePrompt2Prompts2 = {
  type: "image_url";
  imageUrl: CreatePrompt2ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type CreatePrompt21 = {
  type: "text";
  text: string;
};

export type CreatePromptContentPromptsResponse2 =
  | CreatePrompt21
  | CreatePrompt2Prompts2
  | CreatePrompt23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type CreatePromptPromptsContent =
  | string
  | Array<CreatePrompt21 | CreatePrompt2Prompts2 | CreatePrompt23>;

export const CreatePromptPromptsResponseType = {
  Function: "function",
} as const;
export type CreatePromptPromptsResponseType = ClosedEnum<
  typeof CreatePromptPromptsResponseType
>;

export type CreatePromptPromptsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type CreatePromptPromptsToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: CreatePromptPromptsResponseType;
  function: CreatePromptPromptsFunction;
};

export type CreatePromptPromptsResponseMessages = {
  /**
   * The role of the prompt message
   */
  role: CreatePromptPromptsRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<CreatePrompt21 | CreatePrompt2Prompts2 | CreatePrompt23>
    | null;
  toolCalls?: Array<CreatePromptPromptsToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * A list of messages compatible with the openAI schema
 */
export type CreatePromptPromptConfig = {
  stream?: boolean | undefined;
  model?: string | undefined;
  /**
   * The id of the resource
   */
  modelDbId?: string | null | undefined;
  /**
   * The modality of the model
   */
  modelType?: CreatePromptModelType | null | undefined;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  modelParameters?: CreatePromptModelParameters | undefined;
  provider?: CreatePromptProvider | undefined;
  /**
   * The ID of the integration to use
   */
  integrationId?: string | null | undefined;
  version?: string | undefined;
  messages: Array<CreatePromptPromptsResponseMessages>;
};

export const CreatePromptUseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type CreatePromptUseCases = ClosedEnum<typeof CreatePromptUseCases>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const CreatePromptPromptsLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type CreatePromptPromptsLanguage = ClosedEnum<
  typeof CreatePromptPromptsLanguage
>;

export type CreatePromptPromptsMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<CreatePromptUseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: CreatePromptPromptsLanguage | null | undefined;
};

/**
 * A prompt entity with configuration, metadata, and versioning.
 */
export type CreatePromptPrompt = {
  id: string;
  type: CreatePromptPromptsType;
  owner: string;
  domainId: string;
  created: string;
  updated: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The prompt’s name, meant to be displayable in the UI.
   */
  displayName: string;
  /**
   * The prompt’s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  /**
   * A list of messages compatible with the openAI schema
   */
  promptConfig: CreatePromptPromptConfig;
  metadata?: CreatePromptPromptsMetadata | undefined;
};

/** @internal */
export const UseCases$inboundSchema: z.ZodNativeEnum<typeof UseCases> = z
  .nativeEnum(UseCases);
/** @internal */
export const UseCases$outboundSchema: z.ZodNativeEnum<typeof UseCases> =
  UseCases$inboundSchema;

/** @internal */
export const CreatePromptLanguage$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptLanguage
> = z.nativeEnum(CreatePromptLanguage);
/** @internal */
export const CreatePromptLanguage$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptLanguage
> = CreatePromptLanguage$inboundSchema;

/** @internal */
export const CreatePromptMetadata$inboundSchema: z.ZodType<
  CreatePromptMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  use_cases: z.array(UseCases$inboundSchema).optional(),
  language: z.nullable(CreatePromptLanguage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "use_cases": "useCases",
  });
});
/** @internal */
export type CreatePromptMetadata$Outbound = {
  use_cases?: Array<string> | undefined;
  language?: string | null | undefined;
};

/** @internal */
export const CreatePromptMetadata$outboundSchema: z.ZodType<
  CreatePromptMetadata$Outbound,
  z.ZodTypeDef,
  CreatePromptMetadata
> = z.object({
  useCases: z.array(UseCases$outboundSchema).optional(),
  language: z.nullable(CreatePromptLanguage$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    useCases: "use_cases",
  });
});

export function createPromptMetadataToJSON(
  createPromptMetadata: CreatePromptMetadata,
): string {
  return JSON.stringify(
    CreatePromptMetadata$outboundSchema.parse(createPromptMetadata),
  );
}
export function createPromptMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMetadata' from JSON`,
  );
}

/** @internal */
export const CreatePromptRole$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptRole
> = z.nativeEnum(CreatePromptRole);
/** @internal */
export const CreatePromptRole$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptRole
> = CreatePromptRole$inboundSchema;

/** @internal */
export const TwoFile$inboundSchema: z.ZodType<TwoFile, z.ZodTypeDef, unknown> =
  z.object({
    file_data: z.string().optional(),
    uri: z.string().optional(),
    mimeType: z.string().optional(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });
/** @internal */
export type TwoFile$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const TwoFile$outboundSchema: z.ZodType<
  TwoFile$Outbound,
  z.ZodTypeDef,
  TwoFile
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function twoFileToJSON(twoFile: TwoFile): string {
  return JSON.stringify(TwoFile$outboundSchema.parse(twoFile));
}
export function twoFileFromJSON(
  jsonString: string,
): SafeParseResult<TwoFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoFile' from JSON`,
  );
}

/** @internal */
export const Two3$inboundSchema: z.ZodType<Two3, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("file"),
    file: z.lazy(() => TwoFile$inboundSchema),
  });
/** @internal */
export type Two3$Outbound = {
  type: "file";
  file: TwoFile$Outbound;
};

/** @internal */
export const Two3$outboundSchema: z.ZodType<Two3$Outbound, z.ZodTypeDef, Two3> =
  z.object({
    type: z.literal("file"),
    file: z.lazy(() => TwoFile$outboundSchema),
  });

export function two3ToJSON(two3: Two3): string {
  return JSON.stringify(Two3$outboundSchema.parse(two3));
}
export function two3FromJSON(
  jsonString: string,
): SafeParseResult<Two3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two3' from JSON`,
  );
}

/** @internal */
export const TwoImageUrl$inboundSchema: z.ZodType<
  TwoImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});
/** @internal */
export type TwoImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const TwoImageUrl$outboundSchema: z.ZodType<
  TwoImageUrl$Outbound,
  z.ZodTypeDef,
  TwoImageUrl
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

export function twoImageUrlToJSON(twoImageUrl: TwoImageUrl): string {
  return JSON.stringify(TwoImageUrl$outboundSchema.parse(twoImageUrl));
}
export function twoImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<TwoImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoImageUrl' from JSON`,
  );
}

/** @internal */
export const CreatePrompt22$inboundSchema: z.ZodType<
  CreatePrompt22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => TwoImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});
/** @internal */
export type CreatePrompt22$Outbound = {
  type: "image_url";
  image_url: TwoImageUrl$Outbound;
};

/** @internal */
export const CreatePrompt22$outboundSchema: z.ZodType<
  CreatePrompt22$Outbound,
  z.ZodTypeDef,
  CreatePrompt22
> = z.object({
  type: z.literal("image_url"),
  imageUrl: z.lazy(() => TwoImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function createPrompt22ToJSON(createPrompt22: CreatePrompt22): string {
  return JSON.stringify(CreatePrompt22$outboundSchema.parse(createPrompt22));
}
export function createPrompt22FromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt22' from JSON`,
  );
}

/** @internal */
export const Two1$inboundSchema: z.ZodType<Two1, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("text"),
    text: z.string(),
  });
/** @internal */
export type Two1$Outbound = {
  type: "text";
  text: string;
};

/** @internal */
export const Two1$outboundSchema: z.ZodType<Two1$Outbound, z.ZodTypeDef, Two1> =
  z.object({
    type: z.literal("text"),
    text: z.string(),
  });

export function two1ToJSON(two1: Two1): string {
  return JSON.stringify(Two1$outboundSchema.parse(two1));
}
export function two1FromJSON(
  jsonString: string,
): SafeParseResult<Two1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two1' from JSON`,
  );
}

/** @internal */
export const CreatePromptContent2$inboundSchema: z.ZodType<
  CreatePromptContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Two1$inboundSchema),
  z.lazy(() => CreatePrompt22$inboundSchema),
  z.lazy(() => Two3$inboundSchema),
]);
/** @internal */
export type CreatePromptContent2$Outbound =
  | Two1$Outbound
  | CreatePrompt22$Outbound
  | Two3$Outbound;

/** @internal */
export const CreatePromptContent2$outboundSchema: z.ZodType<
  CreatePromptContent2$Outbound,
  z.ZodTypeDef,
  CreatePromptContent2
> = z.union([
  z.lazy(() => Two1$outboundSchema),
  z.lazy(() => CreatePrompt22$outboundSchema),
  z.lazy(() => Two3$outboundSchema),
]);

export function createPromptContent2ToJSON(
  createPromptContent2: CreatePromptContent2,
): string {
  return JSON.stringify(
    CreatePromptContent2$outboundSchema.parse(createPromptContent2),
  );
}
export function createPromptContent2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptContent2' from JSON`,
  );
}

/** @internal */
export const CreatePromptContent$inboundSchema: z.ZodType<
  CreatePromptContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$inboundSchema),
    z.lazy(() => CreatePrompt22$inboundSchema),
    z.lazy(() => Two3$inboundSchema),
  ])),
]);
/** @internal */
export type CreatePromptContent$Outbound =
  | string
  | Array<Two1$Outbound | CreatePrompt22$Outbound | Two3$Outbound>;

/** @internal */
export const CreatePromptContent$outboundSchema: z.ZodType<
  CreatePromptContent$Outbound,
  z.ZodTypeDef,
  CreatePromptContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$outboundSchema),
    z.lazy(() => CreatePrompt22$outboundSchema),
    z.lazy(() => Two3$outboundSchema),
  ])),
]);

export function createPromptContentToJSON(
  createPromptContent: CreatePromptContent,
): string {
  return JSON.stringify(
    CreatePromptContent$outboundSchema.parse(createPromptContent),
  );
}
export function createPromptContentFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptType
> = z.nativeEnum(CreatePromptType);
/** @internal */
export const CreatePromptType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptType
> = CreatePromptType$inboundSchema;

/** @internal */
export const CreatePromptFunction$inboundSchema: z.ZodType<
  CreatePromptFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});
/** @internal */
export type CreatePromptFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const CreatePromptFunction$outboundSchema: z.ZodType<
  CreatePromptFunction$Outbound,
  z.ZodTypeDef,
  CreatePromptFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function createPromptFunctionToJSON(
  createPromptFunction: CreatePromptFunction,
): string {
  return JSON.stringify(
    CreatePromptFunction$outboundSchema.parse(createPromptFunction),
  );
}
export function createPromptFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptFunction' from JSON`,
  );
}

/** @internal */
export const CreatePromptToolCalls$inboundSchema: z.ZodType<
  CreatePromptToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: CreatePromptType$inboundSchema,
  function: z.lazy(() => CreatePromptFunction$inboundSchema),
});
/** @internal */
export type CreatePromptToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: CreatePromptFunction$Outbound;
};

/** @internal */
export const CreatePromptToolCalls$outboundSchema: z.ZodType<
  CreatePromptToolCalls$Outbound,
  z.ZodTypeDef,
  CreatePromptToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: CreatePromptType$outboundSchema,
  function: z.lazy(() => CreatePromptFunction$outboundSchema),
});

export function createPromptToolCallsToJSON(
  createPromptToolCalls: CreatePromptToolCalls,
): string {
  return JSON.stringify(
    CreatePromptToolCalls$outboundSchema.parse(createPromptToolCalls),
  );
}
export function createPromptToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptToolCalls' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessages$inboundSchema: z.ZodType<
  CreatePromptMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: CreatePromptRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => Two1$inboundSchema),
        z.lazy(() => CreatePrompt22$inboundSchema),
        z.lazy(() => Two3$inboundSchema),
      ])),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => CreatePromptToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type CreatePromptMessages$Outbound = {
  role: string;
  content:
    | string
    | Array<Two1$Outbound | CreatePrompt22$Outbound | Two3$Outbound>
    | null;
  tool_calls?: Array<CreatePromptToolCalls$Outbound> | undefined;
  tool_call_id?: string | null | undefined;
};

/** @internal */
export const CreatePromptMessages$outboundSchema: z.ZodType<
  CreatePromptMessages$Outbound,
  z.ZodTypeDef,
  CreatePromptMessages
> = z.object({
  role: CreatePromptRole$outboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => Two1$outboundSchema),
        z.lazy(() => CreatePrompt22$outboundSchema),
        z.lazy(() => Two3$outboundSchema),
      ])),
    ]),
  ),
  toolCalls: z.array(z.lazy(() => CreatePromptToolCalls$outboundSchema))
    .optional(),
  toolCallId: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    toolCallId: "tool_call_id",
  });
});

export function createPromptMessagesToJSON(
  createPromptMessages: CreatePromptMessages,
): string {
  return JSON.stringify(
    CreatePromptMessages$outboundSchema.parse(createPromptMessages),
  );
}
export function createPromptMessagesFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessages' from JSON`,
  );
}

/** @internal */
export const CreatePromptFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptFormat
> = z.nativeEnum(CreatePromptFormat);
/** @internal */
export const CreatePromptFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptFormat
> = CreatePromptFormat$inboundSchema;

/** @internal */
export const Six$inboundSchema: z.ZodNativeEnum<typeof Six> = z.nativeEnum(Six);
/** @internal */
export const Six$outboundSchema: z.ZodNativeEnum<typeof Six> =
  Six$inboundSchema;

/** @internal */
export const Five$inboundSchema: z.ZodNativeEnum<typeof Five> = z.nativeEnum(
  Five,
);
/** @internal */
export const Five$outboundSchema: z.ZodNativeEnum<typeof Five> =
  Five$inboundSchema;

/** @internal */
export const ResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof ResponseFormat4
> = z.nativeEnum(ResponseFormat4);
/** @internal */
export const ResponseFormat4$outboundSchema: z.ZodNativeEnum<
  typeof ResponseFormat4
> = ResponseFormat4$inboundSchema;

/** @internal */
export const CreatePromptResponseFormatPromptsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsRequestType> = z
    .nativeEnum(CreatePromptResponseFormatPromptsRequestType);
/** @internal */
export const CreatePromptResponseFormatPromptsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsRequestType> =
    CreatePromptResponseFormatPromptsRequestType$inboundSchema;

/** @internal */
export const ResponseFormat3$inboundSchema: z.ZodType<
  ResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptResponseFormatPromptsRequestType$inboundSchema,
});
/** @internal */
export type ResponseFormat3$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormat3$outboundSchema: z.ZodType<
  ResponseFormat3$Outbound,
  z.ZodTypeDef,
  ResponseFormat3
> = z.object({
  type: CreatePromptResponseFormatPromptsRequestType$outboundSchema,
});

export function responseFormat3ToJSON(
  responseFormat3: ResponseFormat3,
): string {
  return JSON.stringify(ResponseFormat3$outboundSchema.parse(responseFormat3));
}
export function responseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat3' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatPromptsType$inboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsType> = z.nativeEnum(
    CreatePromptResponseFormatPromptsType,
  );
/** @internal */
export const CreatePromptResponseFormatPromptsType$outboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsType> =
    CreatePromptResponseFormatPromptsType$inboundSchema;

/** @internal */
export const ResponseFormat2$inboundSchema: z.ZodType<
  ResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptResponseFormatPromptsType$inboundSchema,
});
/** @internal */
export type ResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const ResponseFormat2$outboundSchema: z.ZodType<
  ResponseFormat2$Outbound,
  z.ZodTypeDef,
  ResponseFormat2
> = z.object({
  type: CreatePromptResponseFormatPromptsType$outboundSchema,
});

export function responseFormat2ToJSON(
  responseFormat2: ResponseFormat2,
): string {
  return JSON.stringify(ResponseFormat2$outboundSchema.parse(responseFormat2));
}
export function responseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat2' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormatType
> = z.nativeEnum(CreatePromptResponseFormatType);
/** @internal */
export const CreatePromptResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormatType
> = CreatePromptResponseFormatType$inboundSchema;

/** @internal */
export const CreatePromptResponseFormatJsonSchema$inboundSchema: z.ZodType<
  CreatePromptResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  schema: z.record(z.any()),
});
/** @internal */
export type CreatePromptResponseFormatJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

/** @internal */
export const CreatePromptResponseFormatJsonSchema$outboundSchema: z.ZodType<
  CreatePromptResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormatJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  schema: z.record(z.any()),
});

export function createPromptResponseFormatJsonSchemaToJSON(
  createPromptResponseFormatJsonSchema: CreatePromptResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatJsonSchema$outboundSchema.parse(
      createPromptResponseFormatJsonSchema,
    ),
  );
}
export function createPromptResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ResponseFormat1$inboundSchema: z.ZodType<
  ResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptResponseFormatType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() => CreatePromptResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type ResponseFormat1$Outbound = {
  type: string;
  display_name?: string | undefined;
  json_schema: CreatePromptResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const ResponseFormat1$outboundSchema: z.ZodType<
  ResponseFormat1$Outbound,
  z.ZodTypeDef,
  ResponseFormat1
> = z.object({
  type: CreatePromptResponseFormatType$outboundSchema,
  displayName: z.string().optional(),
  jsonSchema: z.lazy(() => CreatePromptResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function responseFormat1ToJSON(
  responseFormat1: ResponseFormat1,
): string {
  return JSON.stringify(ResponseFormat1$outboundSchema.parse(responseFormat1));
}
export function responseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseFormat1' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormat$inboundSchema: z.ZodType<
  CreatePromptResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ResponseFormat1$inboundSchema),
  z.lazy(() => ResponseFormat2$inboundSchema),
  z.lazy(() => ResponseFormat3$inboundSchema),
  ResponseFormat4$inboundSchema,
  Five$inboundSchema,
  Six$inboundSchema,
]);
/** @internal */
export type CreatePromptResponseFormat$Outbound =
  | ResponseFormat1$Outbound
  | ResponseFormat2$Outbound
  | ResponseFormat3$Outbound
  | string
  | string
  | string;

/** @internal */
export const CreatePromptResponseFormat$outboundSchema: z.ZodType<
  CreatePromptResponseFormat$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormat
> = z.union([
  z.lazy(() => ResponseFormat1$outboundSchema),
  z.lazy(() => ResponseFormat2$outboundSchema),
  z.lazy(() => ResponseFormat3$outboundSchema),
  ResponseFormat4$outboundSchema,
  Five$outboundSchema,
  Six$outboundSchema,
]);

export function createPromptResponseFormatToJSON(
  createPromptResponseFormat: CreatePromptResponseFormat,
): string {
  return JSON.stringify(
    CreatePromptResponseFormat$outboundSchema.parse(createPromptResponseFormat),
  );
}
export function createPromptResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormat' from JSON`,
  );
}

/** @internal */
export const PhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof PhotoRealVersion
> = z.nativeEnum(PhotoRealVersion);
/** @internal */
export const PhotoRealVersion$outboundSchema: z.ZodNativeEnum<
  typeof PhotoRealVersion
> = PhotoRealVersion$inboundSchema;

/** @internal */
export const EncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof EncodingFormat
> = z.nativeEnum(EncodingFormat);
/** @internal */
export const EncodingFormat$outboundSchema: z.ZodNativeEnum<
  typeof EncodingFormat
> = EncodingFormat$inboundSchema;

/** @internal */
export const ReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof ReasoningEffort
> = z.nativeEnum(ReasoningEffort);
/** @internal */
export const ReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof ReasoningEffort
> = ReasoningEffort$inboundSchema;

/** @internal */
export const Verbosity$inboundSchema: z.ZodNativeEnum<typeof Verbosity> = z
  .nativeEnum(Verbosity);
/** @internal */
export const Verbosity$outboundSchema: z.ZodNativeEnum<typeof Verbosity> =
  Verbosity$inboundSchema;

/** @internal */
export const CreatePromptThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptThinkingLevel
> = z.nativeEnum(CreatePromptThinkingLevel);
/** @internal */
export const CreatePromptThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptThinkingLevel
> = CreatePromptThinkingLevel$inboundSchema;

/** @internal */
export const ModelParameters$inboundSchema: z.ZodType<
  ModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: CreatePromptFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => ResponseFormat1$inboundSchema),
      z.lazy(() => ResponseFormat2$inboundSchema),
      z.lazy(() => ResponseFormat3$inboundSchema),
      ResponseFormat4$inboundSchema,
      Five$inboundSchema,
      Six$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: PhotoRealVersion$inboundSchema.optional(),
  encoding_format: EncodingFormat$inboundSchema.optional(),
  reasoningEffort: ReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: Verbosity$inboundSchema.optional(),
  thinkingLevel: CreatePromptThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});
/** @internal */
export type ModelParameters$Outbound = {
  temperature?: number | undefined;
  maxTokens?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  frequencyPenalty?: number | undefined;
  presencePenalty?: number | undefined;
  numImages?: number | undefined;
  seed?: number | undefined;
  format?: string | undefined;
  dimensions?: string | undefined;
  quality?: string | undefined;
  style?: string | undefined;
  responseFormat?:
    | ResponseFormat1$Outbound
    | ResponseFormat2$Outbound
    | ResponseFormat3$Outbound
    | string
    | string
    | string
    | null
    | undefined;
  photoRealVersion?: string | undefined;
  encoding_format?: string | undefined;
  reasoningEffort?: string | undefined;
  budgetTokens?: number | undefined;
  verbosity?: string | undefined;
  thinkingLevel?: string | undefined;
};

/** @internal */
export const ModelParameters$outboundSchema: z.ZodType<
  ModelParameters$Outbound,
  z.ZodTypeDef,
  ModelParameters
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: CreatePromptFormat$outboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => ResponseFormat1$outboundSchema),
      z.lazy(() => ResponseFormat2$outboundSchema),
      z.lazy(() => ResponseFormat3$outboundSchema),
      ResponseFormat4$outboundSchema,
      Five$outboundSchema,
      Six$outboundSchema,
    ]),
  ).optional(),
  photoRealVersion: PhotoRealVersion$outboundSchema.optional(),
  encodingFormat: EncodingFormat$outboundSchema.optional(),
  reasoningEffort: ReasoningEffort$outboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: Verbosity$outboundSchema.optional(),
  thinkingLevel: CreatePromptThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

export function modelParametersToJSON(
  modelParameters: ModelParameters,
): string {
  return JSON.stringify(ModelParameters$outboundSchema.parse(modelParameters));
}
export function modelParametersFromJSON(
  jsonString: string,
): SafeParseResult<ModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelParameters' from JSON`,
  );
}

/** @internal */
export const PromptConfiguration$inboundSchema: z.ZodType<
  PromptConfiguration,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string().optional(),
  messages: z.array(z.lazy(() => CreatePromptMessages$inboundSchema)),
  model_parameters: z.lazy(() => ModelParameters$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "model_parameters": "modelParameters",
  });
});
/** @internal */
export type PromptConfiguration$Outbound = {
  model?: string | undefined;
  messages: Array<CreatePromptMessages$Outbound>;
  model_parameters?: ModelParameters$Outbound | undefined;
};

/** @internal */
export const PromptConfiguration$outboundSchema: z.ZodType<
  PromptConfiguration$Outbound,
  z.ZodTypeDef,
  PromptConfiguration
> = z.object({
  model: z.string().optional(),
  messages: z.array(z.lazy(() => CreatePromptMessages$outboundSchema)),
  modelParameters: z.lazy(() => ModelParameters$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    modelParameters: "model_parameters",
  });
});

export function promptConfigurationToJSON(
  promptConfiguration: PromptConfiguration,
): string {
  return JSON.stringify(
    PromptConfiguration$outboundSchema.parse(promptConfiguration),
  );
}
export function promptConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<PromptConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptConfiguration' from JSON`,
  );
}

/** @internal */
export const CreatePromptContentPromptsRequestRequestBody2$inboundSchema:
  z.ZodType<
    CreatePromptContentPromptsRequestRequestBody2,
    z.ZodTypeDef,
    unknown
  > = components.TextContentPartSchema$inboundSchema;
/** @internal */
export type CreatePromptContentPromptsRequestRequestBody2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const CreatePromptContentPromptsRequestRequestBody2$outboundSchema:
  z.ZodType<
    CreatePromptContentPromptsRequestRequestBody2$Outbound,
    z.ZodTypeDef,
    CreatePromptContentPromptsRequestRequestBody2
  > = components.TextContentPartSchema$outboundSchema;

export function createPromptContentPromptsRequestRequestBody2ToJSON(
  createPromptContentPromptsRequestRequestBody2:
    CreatePromptContentPromptsRequestRequestBody2,
): string {
  return JSON.stringify(
    CreatePromptContentPromptsRequestRequestBody2$outboundSchema.parse(
      createPromptContentPromptsRequestRequestBody2,
    ),
  );
}
export function createPromptContentPromptsRequestRequestBody2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptContentPromptsRequestRequestBody2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptContentPromptsRequestRequestBody2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptContentPromptsRequestRequestBody2' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesPromptsRequestRequestBodyContent$inboundSchema:
  z.ZodType<
    CreatePromptMessagesPromptsRequestRequestBodyContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);
/** @internal */
export type CreatePromptMessagesPromptsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreatePromptMessagesPromptsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    CreatePromptMessagesPromptsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    CreatePromptMessagesPromptsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function createPromptMessagesPromptsRequestRequestBodyContentToJSON(
  createPromptMessagesPromptsRequestRequestBodyContent:
    CreatePromptMessagesPromptsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    CreatePromptMessagesPromptsRequestRequestBodyContent$outboundSchema.parse(
      createPromptMessagesPromptsRequestRequestBodyContent,
    ),
  );
}
export function createPromptMessagesPromptsRequestRequestBodyContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptMessagesPromptsRequestRequestBodyContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptMessagesPromptsRequestRequestBodyContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptMessagesPromptsRequestRequestBodyContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesPromptsType
> = z.nativeEnum(CreatePromptMessagesPromptsType);
/** @internal */
export const CreatePromptMessagesPromptsType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesPromptsType
> = CreatePromptMessagesPromptsType$inboundSchema;

/** @internal */
export const CreatePromptMessagesTtl$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesTtl
> = z.nativeEnum(CreatePromptMessagesTtl);
/** @internal */
export const CreatePromptMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesTtl
> = CreatePromptMessagesTtl$inboundSchema;

/** @internal */
export const CreatePromptMessagesCacheControl$inboundSchema: z.ZodType<
  CreatePromptMessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptMessagesPromptsType$inboundSchema,
  ttl: CreatePromptMessagesTtl$inboundSchema.default("5m"),
});
/** @internal */
export type CreatePromptMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreatePromptMessagesCacheControl$outboundSchema: z.ZodType<
  CreatePromptMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesCacheControl
> = z.object({
  type: CreatePromptMessagesPromptsType$outboundSchema,
  ttl: CreatePromptMessagesTtl$outboundSchema.default("5m"),
});

export function createPromptMessagesCacheControlToJSON(
  createPromptMessagesCacheControl: CreatePromptMessagesCacheControl,
): string {
  return JSON.stringify(
    CreatePromptMessagesCacheControl$outboundSchema.parse(
      createPromptMessagesCacheControl,
    ),
  );
}
export function createPromptMessagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesToolMessage$inboundSchema: z.ZodType<
  CreatePromptMessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.string(),
  cache_control: z.lazy(() => CreatePromptMessagesCacheControl$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type CreatePromptMessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string;
  cache_control?: CreatePromptMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const CreatePromptMessagesToolMessage$outboundSchema: z.ZodType<
  CreatePromptMessagesToolMessage$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.string(),
  cacheControl: z.lazy(() => CreatePromptMessagesCacheControl$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function createPromptMessagesToolMessageToJSON(
  createPromptMessagesToolMessage: CreatePromptMessagesToolMessage,
): string {
  return JSON.stringify(
    CreatePromptMessagesToolMessage$outboundSchema.parse(
      createPromptMessagesToolMessage,
    ),
  );
}
export function createPromptMessagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const CreatePromptContentPromptsRequest2$inboundSchema: z.ZodType<
  CreatePromptContentPromptsRequest2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$inboundSchema,
  components.ReasoningPartSchema$inboundSchema,
  components.RedactedReasoningPartSchema$inboundSchema,
]);
/** @internal */
export type CreatePromptContentPromptsRequest2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const CreatePromptContentPromptsRequest2$outboundSchema: z.ZodType<
  CreatePromptContentPromptsRequest2$Outbound,
  z.ZodTypeDef,
  CreatePromptContentPromptsRequest2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$outboundSchema,
  components.ReasoningPartSchema$outboundSchema,
  components.RedactedReasoningPartSchema$outboundSchema,
]);

export function createPromptContentPromptsRequest2ToJSON(
  createPromptContentPromptsRequest2: CreatePromptContentPromptsRequest2,
): string {
  return JSON.stringify(
    CreatePromptContentPromptsRequest2$outboundSchema.parse(
      createPromptContentPromptsRequest2,
    ),
  );
}
export function createPromptContentPromptsRequest2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptContentPromptsRequest2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptContentPromptsRequest2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptContentPromptsRequest2' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesPromptsRequestContent$inboundSchema: z.ZodType<
  CreatePromptMessagesPromptsRequestContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$inboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.RefusalPartSchema$inboundSchema,
      components.ReasoningPartSchema$inboundSchema,
      components.RedactedReasoningPartSchema$inboundSchema,
    ]),
  ),
]);
/** @internal */
export type CreatePromptMessagesPromptsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const CreatePromptMessagesPromptsRequestContent$outboundSchema:
  z.ZodType<
    CreatePromptMessagesPromptsRequestContent$Outbound,
    z.ZodTypeDef,
    CreatePromptMessagesPromptsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function createPromptMessagesPromptsRequestContentToJSON(
  createPromptMessagesPromptsRequestContent:
    CreatePromptMessagesPromptsRequestContent,
): string {
  return JSON.stringify(
    CreatePromptMessagesPromptsRequestContent$outboundSchema.parse(
      createPromptMessagesPromptsRequestContent,
    ),
  );
}
export function createPromptMessagesPromptsRequestContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptMessagesPromptsRequestContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptMessagesPromptsRequestContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptMessagesPromptsRequestContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesAudio$inboundSchema: z.ZodType<
  CreatePromptMessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});
/** @internal */
export type CreatePromptMessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const CreatePromptMessagesAudio$outboundSchema: z.ZodType<
  CreatePromptMessagesAudio$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesAudio
> = z.object({
  id: z.string(),
});

export function createPromptMessagesAudioToJSON(
  createPromptMessagesAudio: CreatePromptMessagesAudio,
): string {
  return JSON.stringify(
    CreatePromptMessagesAudio$outboundSchema.parse(createPromptMessagesAudio),
  );
}
export function createPromptMessagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesAudio' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesType
> = z.nativeEnum(CreatePromptMessagesType);
/** @internal */
export const CreatePromptMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptMessagesType
> = CreatePromptMessagesType$inboundSchema;

/** @internal */
export const CreatePromptMessagesFunction$inboundSchema: z.ZodType<
  CreatePromptMessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type CreatePromptMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const CreatePromptMessagesFunction$outboundSchema: z.ZodType<
  CreatePromptMessagesFunction$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function createPromptMessagesFunctionToJSON(
  createPromptMessagesFunction: CreatePromptMessagesFunction,
): string {
  return JSON.stringify(
    CreatePromptMessagesFunction$outboundSchema.parse(
      createPromptMessagesFunction,
    ),
  );
}
export function createPromptMessagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesFunction' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesToolCalls$inboundSchema: z.ZodType<
  CreatePromptMessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreatePromptMessagesType$inboundSchema,
  function: z.lazy(() => CreatePromptMessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type CreatePromptMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: CreatePromptMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const CreatePromptMessagesToolCalls$outboundSchema: z.ZodType<
  CreatePromptMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesToolCalls
> = z.object({
  id: z.string(),
  type: CreatePromptMessagesType$outboundSchema,
  function: z.lazy(() => CreatePromptMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function createPromptMessagesToolCallsToJSON(
  createPromptMessagesToolCalls: CreatePromptMessagesToolCalls,
): string {
  return JSON.stringify(
    CreatePromptMessagesToolCalls$outboundSchema.parse(
      createPromptMessagesToolCalls,
    ),
  );
}
export function createPromptMessagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesAssistantMessage$inboundSchema: z.ZodType<
  CreatePromptMessagesAssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$inboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$inboundSchema,
          components.ReasoningPartSchema$inboundSchema,
          components.RedactedReasoningPartSchema$inboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => CreatePromptMessagesAudio$inboundSchema))
    .optional(),
  tool_calls: z.array(z.lazy(() => CreatePromptMessagesToolCalls$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});
/** @internal */
export type CreatePromptMessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: CreatePromptMessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<CreatePromptMessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const CreatePromptMessagesAssistantMessage$outboundSchema: z.ZodType<
  CreatePromptMessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => CreatePromptMessagesAudio$outboundSchema))
    .optional(),
  toolCalls: z.array(z.lazy(() => CreatePromptMessagesToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function createPromptMessagesAssistantMessageToJSON(
  createPromptMessagesAssistantMessage: CreatePromptMessagesAssistantMessage,
): string {
  return JSON.stringify(
    CreatePromptMessagesAssistantMessage$outboundSchema.parse(
      createPromptMessagesAssistantMessage,
    ),
  );
}
export function createPromptMessagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesAssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptMessagesAssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const CreatePrompt2PromptsRequestRequestBodyPromptType$inboundSchema:
  z.ZodNativeEnum<typeof CreatePrompt2PromptsRequestRequestBodyPromptType> = z
    .nativeEnum(CreatePrompt2PromptsRequestRequestBodyPromptType);
/** @internal */
export const CreatePrompt2PromptsRequestRequestBodyPromptType$outboundSchema:
  z.ZodNativeEnum<typeof CreatePrompt2PromptsRequestRequestBodyPromptType> =
    CreatePrompt2PromptsRequestRequestBodyPromptType$inboundSchema;

/** @internal */
export const CreatePrompt2Ttl$inboundSchema: z.ZodNativeEnum<
  typeof CreatePrompt2Ttl
> = z.nativeEnum(CreatePrompt2Ttl);
/** @internal */
export const CreatePrompt2Ttl$outboundSchema: z.ZodNativeEnum<
  typeof CreatePrompt2Ttl
> = CreatePrompt2Ttl$inboundSchema;

/** @internal */
export const CreatePrompt2CacheControl$inboundSchema: z.ZodType<
  CreatePrompt2CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePrompt2PromptsRequestRequestBodyPromptType$inboundSchema,
  ttl: CreatePrompt2Ttl$inboundSchema.default("5m"),
});
/** @internal */
export type CreatePrompt2CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreatePrompt2CacheControl$outboundSchema: z.ZodType<
  CreatePrompt2CacheControl$Outbound,
  z.ZodTypeDef,
  CreatePrompt2CacheControl
> = z.object({
  type: CreatePrompt2PromptsRequestRequestBodyPromptType$outboundSchema,
  ttl: CreatePrompt2Ttl$outboundSchema.default("5m"),
});

export function createPrompt2CacheControlToJSON(
  createPrompt2CacheControl: CreatePrompt2CacheControl,
): string {
  return JSON.stringify(
    CreatePrompt2CacheControl$outboundSchema.parse(createPrompt2CacheControl),
  );
}
export function createPrompt2CacheControlFromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt2CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt2CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt2CacheControl' from JSON`,
  );
}

/** @internal */
export const CreatePrompt24$inboundSchema: z.ZodType<
  CreatePrompt24,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  cache_control: z.lazy(() => CreatePrompt2CacheControl$inboundSchema)
    .optional(),
  file: components.FileContentPartSchema$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type CreatePrompt24$Outbound = {
  type: "file";
  cache_control?: CreatePrompt2CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const CreatePrompt24$outboundSchema: z.ZodType<
  CreatePrompt24$Outbound,
  z.ZodTypeDef,
  CreatePrompt24
> = z.object({
  type: z.literal("file"),
  cacheControl: z.lazy(() => CreatePrompt2CacheControl$outboundSchema)
    .optional(),
  file: components.FileContentPartSchema$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    cacheControl: "cache_control",
  });
});

export function createPrompt24ToJSON(createPrompt24: CreatePrompt24): string {
  return JSON.stringify(CreatePrompt24$outboundSchema.parse(createPrompt24));
}
export function createPrompt24FromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt24, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt24$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt24' from JSON`,
  );
}

/** @internal */
export const CreatePromptContentPrompts2$inboundSchema: z.ZodType<
  CreatePromptContentPrompts2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => CreatePrompt24$inboundSchema),
]);
/** @internal */
export type CreatePromptContentPrompts2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | CreatePrompt24$Outbound;

/** @internal */
export const CreatePromptContentPrompts2$outboundSchema: z.ZodType<
  CreatePromptContentPrompts2$Outbound,
  z.ZodTypeDef,
  CreatePromptContentPrompts2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => CreatePrompt24$outboundSchema),
]);

export function createPromptContentPrompts2ToJSON(
  createPromptContentPrompts2: CreatePromptContentPrompts2,
): string {
  return JSON.stringify(
    CreatePromptContentPrompts2$outboundSchema.parse(
      createPromptContentPrompts2,
    ),
  );
}
export function createPromptContentPrompts2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptContentPrompts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptContentPrompts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptContentPrompts2' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesPromptsContent$inboundSchema: z.ZodType<
  CreatePromptMessagesPromptsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$inboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.ImageContentPartSchema$inboundSchema,
      components.AudioContentPartSchema$inboundSchema,
      z.lazy(() => CreatePrompt24$inboundSchema),
    ]),
  ),
]);
/** @internal */
export type CreatePromptMessagesPromptsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | CreatePrompt24$Outbound
  >;

/** @internal */
export const CreatePromptMessagesPromptsContent$outboundSchema: z.ZodType<
  CreatePromptMessagesPromptsContent$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesPromptsContent
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$outboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.ImageContentPartSchema$outboundSchema,
      components.AudioContentPartSchema$outboundSchema,
      z.lazy(() => CreatePrompt24$outboundSchema),
    ]),
  ),
]);

export function createPromptMessagesPromptsContentToJSON(
  createPromptMessagesPromptsContent: CreatePromptMessagesPromptsContent,
): string {
  return JSON.stringify(
    CreatePromptMessagesPromptsContent$outboundSchema.parse(
      createPromptMessagesPromptsContent,
    ),
  );
}
export function createPromptMessagesPromptsContentFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesPromptsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptMessagesPromptsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesPromptsContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesUserMessage$inboundSchema: z.ZodType<
  CreatePromptMessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => CreatePrompt24$inboundSchema),
      ]),
    ),
  ]),
});
/** @internal */
export type CreatePromptMessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | CreatePrompt24$Outbound
    >;
};

/** @internal */
export const CreatePromptMessagesUserMessage$outboundSchema: z.ZodType<
  CreatePromptMessagesUserMessage$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => CreatePrompt24$outboundSchema),
      ]),
    ),
  ]),
});

export function createPromptMessagesUserMessageToJSON(
  createPromptMessagesUserMessage: CreatePromptMessagesUserMessage,
): string {
  return JSON.stringify(
    CreatePromptMessagesUserMessage$outboundSchema.parse(
      createPromptMessagesUserMessage,
    ),
  );
}
export function createPromptMessagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesContent$inboundSchema: z.ZodType<
  CreatePromptMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type CreatePromptMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreatePromptMessagesContent$outboundSchema: z.ZodType<
  CreatePromptMessagesContent$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function createPromptMessagesContentToJSON(
  createPromptMessagesContent: CreatePromptMessagesContent,
): string {
  return JSON.stringify(
    CreatePromptMessagesContent$outboundSchema.parse(
      createPromptMessagesContent,
    ),
  );
}
export function createPromptMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptMessagesSystemMessage$inboundSchema: z.ZodType<
  CreatePromptMessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type CreatePromptMessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const CreatePromptMessagesSystemMessage$outboundSchema: z.ZodType<
  CreatePromptMessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  CreatePromptMessagesSystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function createPromptMessagesSystemMessageToJSON(
  createPromptMessagesSystemMessage: CreatePromptMessagesSystemMessage,
): string {
  return JSON.stringify(
    CreatePromptMessagesSystemMessage$outboundSchema.parse(
      createPromptMessagesSystemMessage,
    ),
  );
}
export function createPromptMessagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptMessagesSystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptMessagesSystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptMessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsMessages$inboundSchema: z.ZodType<
  CreatePromptPromptsMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePromptMessagesSystemMessage$inboundSchema),
  z.lazy(() => CreatePromptMessagesUserMessage$inboundSchema),
  z.lazy(() => CreatePromptMessagesAssistantMessage$inboundSchema),
  z.lazy(() => CreatePromptMessagesToolMessage$inboundSchema),
]);
/** @internal */
export type CreatePromptPromptsMessages$Outbound =
  | CreatePromptMessagesSystemMessage$Outbound
  | CreatePromptMessagesUserMessage$Outbound
  | CreatePromptMessagesAssistantMessage$Outbound
  | CreatePromptMessagesToolMessage$Outbound;

/** @internal */
export const CreatePromptPromptsMessages$outboundSchema: z.ZodType<
  CreatePromptPromptsMessages$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsMessages
> = z.union([
  z.lazy(() => CreatePromptMessagesSystemMessage$outboundSchema),
  z.lazy(() => CreatePromptMessagesUserMessage$outboundSchema),
  z.lazy(() => CreatePromptMessagesAssistantMessage$outboundSchema),
  z.lazy(() => CreatePromptMessagesToolMessage$outboundSchema),
]);

export function createPromptPromptsMessagesToJSON(
  createPromptPromptsMessages: CreatePromptPromptsMessages,
): string {
  return JSON.stringify(
    CreatePromptPromptsMessages$outboundSchema.parse(
      createPromptPromptsMessages,
    ),
  );
}
export function createPromptPromptsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsMessages' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatPromptsRequestJsonSchema$inboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsRequestJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type CreatePromptResponseFormatPromptsRequestJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const CreatePromptResponseFormatPromptsRequestJsonSchema$outboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsRequestJsonSchema$Outbound,
    z.ZodTypeDef,
    CreatePromptResponseFormatPromptsRequestJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createPromptResponseFormatPromptsRequestJsonSchemaToJSON(
  createPromptResponseFormatPromptsRequestJsonSchema:
    CreatePromptResponseFormatPromptsRequestJsonSchema,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatPromptsRequestJsonSchema$outboundSchema.parse(
      createPromptResponseFormatPromptsRequestJsonSchema,
    ),
  );
}
export function createPromptResponseFormatPromptsRequestJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptResponseFormatPromptsRequestJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptResponseFormatPromptsRequestJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptResponseFormatPromptsRequestJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatPromptsJSONSchema$inboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreatePromptResponseFormatPromptsRequestJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreatePromptResponseFormatPromptsJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: CreatePromptResponseFormatPromptsRequestJsonSchema$Outbound;
};

/** @internal */
export const CreatePromptResponseFormatPromptsJSONSchema$outboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsJSONSchema$Outbound,
    z.ZodTypeDef,
    CreatePromptResponseFormatPromptsJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreatePromptResponseFormatPromptsRequestJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createPromptResponseFormatPromptsJSONSchemaToJSON(
  createPromptResponseFormatPromptsJSONSchema:
    CreatePromptResponseFormatPromptsJSONSchema,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatPromptsJSONSchema$outboundSchema.parse(
      createPromptResponseFormatPromptsJSONSchema,
    ),
  );
}
export function createPromptResponseFormatPromptsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptResponseFormatPromptsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptResponseFormatPromptsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptResponseFormatPromptsJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatJSONObject$inboundSchema: z.ZodType<
  CreatePromptResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type CreatePromptResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CreatePromptResponseFormatJSONObject$outboundSchema: z.ZodType<
  CreatePromptResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function createPromptResponseFormatJSONObjectToJSON(
  createPromptResponseFormatJSONObject: CreatePromptResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatJSONObject$outboundSchema.parse(
      createPromptResponseFormatJSONObject,
    ),
  );
}
export function createPromptResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatText$inboundSchema: z.ZodType<
  CreatePromptResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type CreatePromptResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const CreatePromptResponseFormatText$outboundSchema: z.ZodType<
  CreatePromptResponseFormatText$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function createPromptResponseFormatTextToJSON(
  createPromptResponseFormatText: CreatePromptResponseFormatText,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatText$outboundSchema.parse(
      createPromptResponseFormatText,
    ),
  );
}
export function createPromptResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormatText' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsResponseFormat$inboundSchema: z.ZodType<
  CreatePromptPromptsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePromptResponseFormatText$inboundSchema),
  z.lazy(() => CreatePromptResponseFormatJSONObject$inboundSchema),
  z.lazy(() => CreatePromptResponseFormatPromptsJSONSchema$inboundSchema),
]);
/** @internal */
export type CreatePromptPromptsResponseFormat$Outbound =
  | CreatePromptResponseFormatText$Outbound
  | CreatePromptResponseFormatJSONObject$Outbound
  | CreatePromptResponseFormatPromptsJSONSchema$Outbound;

/** @internal */
export const CreatePromptPromptsResponseFormat$outboundSchema: z.ZodType<
  CreatePromptPromptsResponseFormat$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsResponseFormat
> = z.union([
  z.lazy(() => CreatePromptResponseFormatText$outboundSchema),
  z.lazy(() => CreatePromptResponseFormatJSONObject$outboundSchema),
  z.lazy(() => CreatePromptResponseFormatPromptsJSONSchema$outboundSchema),
]);

export function createPromptPromptsResponseFormatToJSON(
  createPromptPromptsResponseFormat: CreatePromptPromptsResponseFormat,
): string {
  return JSON.stringify(
    CreatePromptPromptsResponseFormat$outboundSchema.parse(
      createPromptPromptsResponseFormat,
    ),
  );
}
export function createPromptPromptsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsResponseFormat' from JSON`,
  );
}

/** @internal */
export const PromptInput$inboundSchema: z.ZodType<
  PromptInput,
  z.ZodTypeDef,
  unknown
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => CreatePromptMessagesSystemMessage$inboundSchema),
      z.lazy(() => CreatePromptMessagesUserMessage$inboundSchema),
      z.lazy(() => CreatePromptMessagesAssistantMessage$inboundSchema),
      z.lazy(() => CreatePromptMessagesToolMessage$inboundSchema),
    ]),
  ),
  model: z.string().optional(),
  temperature: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  response_format: z.union([
    z.lazy(() => CreatePromptResponseFormatText$inboundSchema),
    z.lazy(() => CreatePromptResponseFormatJSONObject$inboundSchema),
    z.lazy(() => CreatePromptResponseFormatPromptsJSONSchema$inboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "max_tokens": "maxTokens",
    "response_format": "responseFormat",
  });
});
/** @internal */
export type PromptInput$Outbound = {
  messages: Array<
    | CreatePromptMessagesSystemMessage$Outbound
    | CreatePromptMessagesUserMessage$Outbound
    | CreatePromptMessagesAssistantMessage$Outbound
    | CreatePromptMessagesToolMessage$Outbound
  >;
  model?: string | undefined;
  temperature?: number | null | undefined;
  max_tokens?: number | null | undefined;
  response_format?:
    | CreatePromptResponseFormatText$Outbound
    | CreatePromptResponseFormatJSONObject$Outbound
    | CreatePromptResponseFormatPromptsJSONSchema$Outbound
    | undefined;
};

/** @internal */
export const PromptInput$outboundSchema: z.ZodType<
  PromptInput$Outbound,
  z.ZodTypeDef,
  PromptInput
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => CreatePromptMessagesSystemMessage$outboundSchema),
      z.lazy(() => CreatePromptMessagesUserMessage$outboundSchema),
      z.lazy(() => CreatePromptMessagesAssistantMessage$outboundSchema),
      z.lazy(() => CreatePromptMessagesToolMessage$outboundSchema),
    ]),
  ),
  model: z.string().optional(),
  temperature: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreatePromptResponseFormatText$outboundSchema),
    z.lazy(() => CreatePromptResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CreatePromptResponseFormatPromptsJSONSchema$outboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    maxTokens: "max_tokens",
    responseFormat: "response_format",
  });
});

export function promptInputToJSON(promptInput: PromptInput): string {
  return JSON.stringify(PromptInput$outboundSchema.parse(promptInput));
}
export function promptInputFromJSON(
  jsonString: string,
): SafeParseResult<PromptInput, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptInput$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptInput' from JSON`,
  );
}

/** @internal */
export const CreatePromptRequestBody$inboundSchema: z.ZodType<
  CreatePromptRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_name: z.string(),
  description: z.nullable(z.string()).optional(),
  metadata: z.lazy(() => CreatePromptMetadata$inboundSchema).optional(),
  prompt_config: z.lazy(() => PromptConfiguration$inboundSchema).optional(),
  prompt: z.lazy(() => PromptInput$inboundSchema).optional(),
  path: z.string(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "prompt_config": "promptConfig",
  });
});
/** @internal */
export type CreatePromptRequestBody$Outbound = {
  display_name: string;
  description?: string | null | undefined;
  metadata?: CreatePromptMetadata$Outbound | undefined;
  prompt_config?: PromptConfiguration$Outbound | undefined;
  prompt?: PromptInput$Outbound | undefined;
  path: string;
};

/** @internal */
export const CreatePromptRequestBody$outboundSchema: z.ZodType<
  CreatePromptRequestBody$Outbound,
  z.ZodTypeDef,
  CreatePromptRequestBody
> = z.object({
  displayName: z.string(),
  description: z.nullable(z.string()).optional(),
  metadata: z.lazy(() => CreatePromptMetadata$outboundSchema).optional(),
  promptConfig: z.lazy(() => PromptConfiguration$outboundSchema).optional(),
  prompt: z.lazy(() => PromptInput$outboundSchema).optional(),
  path: z.string(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    promptConfig: "prompt_config",
  });
});

export function createPromptRequestBodyToJSON(
  createPromptRequestBody: CreatePromptRequestBody,
): string {
  return JSON.stringify(
    CreatePromptRequestBody$outboundSchema.parse(createPromptRequestBody),
  );
}
export function createPromptRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptRequestBody' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsType
> = z.nativeEnum(CreatePromptPromptsType);
/** @internal */
export const CreatePromptPromptsType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsType
> = CreatePromptPromptsType$inboundSchema;

/** @internal */
export const CreatePromptModelType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptModelType
> = z.nativeEnum(CreatePromptModelType);
/** @internal */
export const CreatePromptModelType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptModelType
> = CreatePromptModelType$inboundSchema;

/** @internal */
export const CreatePromptPromptsFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsFormat
> = z.nativeEnum(CreatePromptPromptsFormat);
/** @internal */
export const CreatePromptPromptsFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsFormat
> = CreatePromptPromptsFormat$inboundSchema;

/** @internal */
export const CreatePromptResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat6
> = z.nativeEnum(CreatePromptResponseFormat6);
/** @internal */
export const CreatePromptResponseFormat6$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat6
> = CreatePromptResponseFormat6$inboundSchema;

/** @internal */
export const CreatePromptResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat5
> = z.nativeEnum(CreatePromptResponseFormat5);
/** @internal */
export const CreatePromptResponseFormat5$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat5
> = CreatePromptResponseFormat5$inboundSchema;

/** @internal */
export const CreatePromptResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat4
> = z.nativeEnum(CreatePromptResponseFormat4);
/** @internal */
export const CreatePromptResponseFormat4$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptResponseFormat4
> = CreatePromptResponseFormat4$inboundSchema;

/** @internal */
export const CreatePromptResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreatePromptResponseFormatPromptsResponse200ApplicationJSONType
  > = z.nativeEnum(
    CreatePromptResponseFormatPromptsResponse200ApplicationJSONType,
  );
/** @internal */
export const CreatePromptResponseFormatPromptsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreatePromptResponseFormatPromptsResponse200ApplicationJSONType
  > =
    CreatePromptResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const CreatePromptResponseFormat3$inboundSchema: z.ZodType<
  CreatePromptResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreatePromptResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema,
});
/** @internal */
export type CreatePromptResponseFormat3$Outbound = {
  type: string;
};

/** @internal */
export const CreatePromptResponseFormat3$outboundSchema: z.ZodType<
  CreatePromptResponseFormat3$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormat3
> = z.object({
  type:
    CreatePromptResponseFormatPromptsResponse200ApplicationJSONType$outboundSchema,
});

export function createPromptResponseFormat3ToJSON(
  createPromptResponseFormat3: CreatePromptResponseFormat3,
): string {
  return JSON.stringify(
    CreatePromptResponseFormat3$outboundSchema.parse(
      createPromptResponseFormat3,
    ),
  );
}
export function createPromptResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormat3' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatPromptsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsResponse200Type> = z
    .nativeEnum(CreatePromptResponseFormatPromptsResponse200Type);
/** @internal */
export const CreatePromptResponseFormatPromptsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsResponse200Type> =
    CreatePromptResponseFormatPromptsResponse200Type$inboundSchema;

/** @internal */
export const CreatePromptResponseFormat2$inboundSchema: z.ZodType<
  CreatePromptResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptResponseFormatPromptsResponse200Type$inboundSchema,
});
/** @internal */
export type CreatePromptResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const CreatePromptResponseFormat2$outboundSchema: z.ZodType<
  CreatePromptResponseFormat2$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormat2
> = z.object({
  type: CreatePromptResponseFormatPromptsResponse200Type$outboundSchema,
});

export function createPromptResponseFormat2ToJSON(
  createPromptResponseFormat2: CreatePromptResponseFormat2,
): string {
  return JSON.stringify(
    CreatePromptResponseFormat2$outboundSchema.parse(
      createPromptResponseFormat2,
    ),
  );
}
export function createPromptResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormat2' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormatPromptsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsResponseType> = z
    .nativeEnum(CreatePromptResponseFormatPromptsResponseType);
/** @internal */
export const CreatePromptResponseFormatPromptsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreatePromptResponseFormatPromptsResponseType> =
    CreatePromptResponseFormatPromptsResponseType$inboundSchema;

/** @internal */
export const CreatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });
/** @internal */
export type CreatePromptResponseFormatPromptsResponseJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

/** @internal */
export const CreatePromptResponseFormatPromptsResponseJsonSchema$outboundSchema:
  z.ZodType<
    CreatePromptResponseFormatPromptsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    CreatePromptResponseFormatPromptsResponseJsonSchema
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function createPromptResponseFormatPromptsResponseJsonSchemaToJSON(
  createPromptResponseFormatPromptsResponseJsonSchema:
    CreatePromptResponseFormatPromptsResponseJsonSchema,
): string {
  return JSON.stringify(
    CreatePromptResponseFormatPromptsResponseJsonSchema$outboundSchema.parse(
      createPromptResponseFormatPromptsResponseJsonSchema,
    ),
  );
}
export function createPromptResponseFormatPromptsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptResponseFormatPromptsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptResponseFormatPromptsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreatePromptResponseFormat1$inboundSchema: z.ZodType<
  CreatePromptResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreatePromptResponseFormatPromptsResponseType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    CreatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type CreatePromptResponseFormat1$Outbound = {
  type: string;
  display_name?: string | undefined;
  json_schema: CreatePromptResponseFormatPromptsResponseJsonSchema$Outbound;
};

/** @internal */
export const CreatePromptResponseFormat1$outboundSchema: z.ZodType<
  CreatePromptResponseFormat1$Outbound,
  z.ZodTypeDef,
  CreatePromptResponseFormat1
> = z.object({
  type: CreatePromptResponseFormatPromptsResponseType$outboundSchema,
  displayName: z.string().optional(),
  jsonSchema: z.lazy(() =>
    CreatePromptResponseFormatPromptsResponseJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function createPromptResponseFormat1ToJSON(
  createPromptResponseFormat1: CreatePromptResponseFormat1,
): string {
  return JSON.stringify(
    CreatePromptResponseFormat1$outboundSchema.parse(
      createPromptResponseFormat1,
    ),
  );
}
export function createPromptResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptResponseFormat1' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsResponseResponseFormat$inboundSchema: z.ZodType<
  CreatePromptPromptsResponseResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePromptResponseFormat1$inboundSchema),
  z.lazy(() => CreatePromptResponseFormat2$inboundSchema),
  z.lazy(() => CreatePromptResponseFormat3$inboundSchema),
  CreatePromptResponseFormat4$inboundSchema,
  CreatePromptResponseFormat5$inboundSchema,
  CreatePromptResponseFormat6$inboundSchema,
]);
/** @internal */
export type CreatePromptPromptsResponseResponseFormat$Outbound =
  | CreatePromptResponseFormat1$Outbound
  | CreatePromptResponseFormat2$Outbound
  | CreatePromptResponseFormat3$Outbound
  | string
  | string
  | string;

/** @internal */
export const CreatePromptPromptsResponseResponseFormat$outboundSchema:
  z.ZodType<
    CreatePromptPromptsResponseResponseFormat$Outbound,
    z.ZodTypeDef,
    CreatePromptPromptsResponseResponseFormat
  > = z.union([
    z.lazy(() => CreatePromptResponseFormat1$outboundSchema),
    z.lazy(() => CreatePromptResponseFormat2$outboundSchema),
    z.lazy(() => CreatePromptResponseFormat3$outboundSchema),
    CreatePromptResponseFormat4$outboundSchema,
    CreatePromptResponseFormat5$outboundSchema,
    CreatePromptResponseFormat6$outboundSchema,
  ]);

export function createPromptPromptsResponseResponseFormatToJSON(
  createPromptPromptsResponseResponseFormat:
    CreatePromptPromptsResponseResponseFormat,
): string {
  return JSON.stringify(
    CreatePromptPromptsResponseResponseFormat$outboundSchema.parse(
      createPromptPromptsResponseResponseFormat,
    ),
  );
}
export function createPromptPromptsResponseResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  CreatePromptPromptsResponseResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptPromptsResponseResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreatePromptPromptsResponseResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreatePromptPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPhotoRealVersion
> = z.nativeEnum(CreatePromptPhotoRealVersion);
/** @internal */
export const CreatePromptPhotoRealVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPhotoRealVersion
> = CreatePromptPhotoRealVersion$inboundSchema;

/** @internal */
export const CreatePromptEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptEncodingFormat
> = z.nativeEnum(CreatePromptEncodingFormat);
/** @internal */
export const CreatePromptEncodingFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptEncodingFormat
> = CreatePromptEncodingFormat$inboundSchema;

/** @internal */
export const CreatePromptReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptReasoningEffort
> = z.nativeEnum(CreatePromptReasoningEffort);
/** @internal */
export const CreatePromptReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptReasoningEffort
> = CreatePromptReasoningEffort$inboundSchema;

/** @internal */
export const CreatePromptVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptVerbosity
> = z.nativeEnum(CreatePromptVerbosity);
/** @internal */
export const CreatePromptVerbosity$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptVerbosity
> = CreatePromptVerbosity$inboundSchema;

/** @internal */
export const CreatePromptPromptsThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsThinkingLevel
> = z.nativeEnum(CreatePromptPromptsThinkingLevel);
/** @internal */
export const CreatePromptPromptsThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsThinkingLevel
> = CreatePromptPromptsThinkingLevel$inboundSchema;

/** @internal */
export const CreatePromptModelParameters$inboundSchema: z.ZodType<
  CreatePromptModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: CreatePromptPromptsFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => CreatePromptResponseFormat1$inboundSchema),
      z.lazy(() => CreatePromptResponseFormat2$inboundSchema),
      z.lazy(() => CreatePromptResponseFormat3$inboundSchema),
      CreatePromptResponseFormat4$inboundSchema,
      CreatePromptResponseFormat5$inboundSchema,
      CreatePromptResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: CreatePromptPhotoRealVersion$inboundSchema.optional(),
  encoding_format: CreatePromptEncodingFormat$inboundSchema.optional(),
  reasoningEffort: CreatePromptReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: CreatePromptVerbosity$inboundSchema.optional(),
  thinkingLevel: CreatePromptPromptsThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});
/** @internal */
export type CreatePromptModelParameters$Outbound = {
  temperature?: number | undefined;
  maxTokens?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  frequencyPenalty?: number | undefined;
  presencePenalty?: number | undefined;
  numImages?: number | undefined;
  seed?: number | undefined;
  format?: string | undefined;
  dimensions?: string | undefined;
  quality?: string | undefined;
  style?: string | undefined;
  responseFormat?:
    | CreatePromptResponseFormat1$Outbound
    | CreatePromptResponseFormat2$Outbound
    | CreatePromptResponseFormat3$Outbound
    | string
    | string
    | string
    | null
    | undefined;
  photoRealVersion?: string | undefined;
  encoding_format?: string | undefined;
  reasoningEffort?: string | undefined;
  budgetTokens?: number | undefined;
  verbosity?: string | undefined;
  thinkingLevel?: string | undefined;
};

/** @internal */
export const CreatePromptModelParameters$outboundSchema: z.ZodType<
  CreatePromptModelParameters$Outbound,
  z.ZodTypeDef,
  CreatePromptModelParameters
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: CreatePromptPromptsFormat$outboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => CreatePromptResponseFormat1$outboundSchema),
      z.lazy(() => CreatePromptResponseFormat2$outboundSchema),
      z.lazy(() => CreatePromptResponseFormat3$outboundSchema),
      CreatePromptResponseFormat4$outboundSchema,
      CreatePromptResponseFormat5$outboundSchema,
      CreatePromptResponseFormat6$outboundSchema,
    ]),
  ).optional(),
  photoRealVersion: CreatePromptPhotoRealVersion$outboundSchema.optional(),
  encodingFormat: CreatePromptEncodingFormat$outboundSchema.optional(),
  reasoningEffort: CreatePromptReasoningEffort$outboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: CreatePromptVerbosity$outboundSchema.optional(),
  thinkingLevel: CreatePromptPromptsThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

export function createPromptModelParametersToJSON(
  createPromptModelParameters: CreatePromptModelParameters,
): string {
  return JSON.stringify(
    CreatePromptModelParameters$outboundSchema.parse(
      createPromptModelParameters,
    ),
  );
}
export function createPromptModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptModelParameters' from JSON`,
  );
}

/** @internal */
export const CreatePromptProvider$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptProvider
> = z.nativeEnum(CreatePromptProvider);
/** @internal */
export const CreatePromptProvider$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptProvider
> = CreatePromptProvider$inboundSchema;

/** @internal */
export const CreatePromptPromptsRole$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsRole
> = z.nativeEnum(CreatePromptPromptsRole);
/** @internal */
export const CreatePromptPromptsRole$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsRole
> = CreatePromptPromptsRole$inboundSchema;

/** @internal */
export const CreatePrompt2File$inboundSchema: z.ZodType<
  CreatePrompt2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});
/** @internal */
export type CreatePrompt2File$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const CreatePrompt2File$outboundSchema: z.ZodType<
  CreatePrompt2File$Outbound,
  z.ZodTypeDef,
  CreatePrompt2File
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function createPrompt2FileToJSON(
  createPrompt2File: CreatePrompt2File,
): string {
  return JSON.stringify(
    CreatePrompt2File$outboundSchema.parse(createPrompt2File),
  );
}
export function createPrompt2FileFromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt2File' from JSON`,
  );
}

/** @internal */
export const CreatePrompt23$inboundSchema: z.ZodType<
  CreatePrompt23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => CreatePrompt2File$inboundSchema),
});
/** @internal */
export type CreatePrompt23$Outbound = {
  type: "file";
  file: CreatePrompt2File$Outbound;
};

/** @internal */
export const CreatePrompt23$outboundSchema: z.ZodType<
  CreatePrompt23$Outbound,
  z.ZodTypeDef,
  CreatePrompt23
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => CreatePrompt2File$outboundSchema),
});

export function createPrompt23ToJSON(createPrompt23: CreatePrompt23): string {
  return JSON.stringify(CreatePrompt23$outboundSchema.parse(createPrompt23));
}
export function createPrompt23FromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt23' from JSON`,
  );
}

/** @internal */
export const CreatePrompt2ImageUrl$inboundSchema: z.ZodType<
  CreatePrompt2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});
/** @internal */
export type CreatePrompt2ImageUrl$Outbound = {
  id?: string | undefined;
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const CreatePrompt2ImageUrl$outboundSchema: z.ZodType<
  CreatePrompt2ImageUrl$Outbound,
  z.ZodTypeDef,
  CreatePrompt2ImageUrl
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function createPrompt2ImageUrlToJSON(
  createPrompt2ImageUrl: CreatePrompt2ImageUrl,
): string {
  return JSON.stringify(
    CreatePrompt2ImageUrl$outboundSchema.parse(createPrompt2ImageUrl),
  );
}
export function createPrompt2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt2ImageUrl' from JSON`,
  );
}

/** @internal */
export const CreatePrompt2Prompts2$inboundSchema: z.ZodType<
  CreatePrompt2Prompts2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => CreatePrompt2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});
/** @internal */
export type CreatePrompt2Prompts2$Outbound = {
  type: "image_url";
  image_url: CreatePrompt2ImageUrl$Outbound;
};

/** @internal */
export const CreatePrompt2Prompts2$outboundSchema: z.ZodType<
  CreatePrompt2Prompts2$Outbound,
  z.ZodTypeDef,
  CreatePrompt2Prompts2
> = z.object({
  type: z.literal("image_url"),
  imageUrl: z.lazy(() => CreatePrompt2ImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function createPrompt2Prompts2ToJSON(
  createPrompt2Prompts2: CreatePrompt2Prompts2,
): string {
  return JSON.stringify(
    CreatePrompt2Prompts2$outboundSchema.parse(createPrompt2Prompts2),
  );
}
export function createPrompt2Prompts2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt2Prompts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt2Prompts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt2Prompts2' from JSON`,
  );
}

/** @internal */
export const CreatePrompt21$inboundSchema: z.ZodType<
  CreatePrompt21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});
/** @internal */
export type CreatePrompt21$Outbound = {
  type: "text";
  text: string;
};

/** @internal */
export const CreatePrompt21$outboundSchema: z.ZodType<
  CreatePrompt21$Outbound,
  z.ZodTypeDef,
  CreatePrompt21
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function createPrompt21ToJSON(createPrompt21: CreatePrompt21): string {
  return JSON.stringify(CreatePrompt21$outboundSchema.parse(createPrompt21));
}
export function createPrompt21FromJSON(
  jsonString: string,
): SafeParseResult<CreatePrompt21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePrompt21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePrompt21' from JSON`,
  );
}

/** @internal */
export const CreatePromptContentPromptsResponse2$inboundSchema: z.ZodType<
  CreatePromptContentPromptsResponse2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreatePrompt21$inboundSchema),
  z.lazy(() => CreatePrompt2Prompts2$inboundSchema),
  z.lazy(() => CreatePrompt23$inboundSchema),
]);
/** @internal */
export type CreatePromptContentPromptsResponse2$Outbound =
  | CreatePrompt21$Outbound
  | CreatePrompt2Prompts2$Outbound
  | CreatePrompt23$Outbound;

/** @internal */
export const CreatePromptContentPromptsResponse2$outboundSchema: z.ZodType<
  CreatePromptContentPromptsResponse2$Outbound,
  z.ZodTypeDef,
  CreatePromptContentPromptsResponse2
> = z.union([
  z.lazy(() => CreatePrompt21$outboundSchema),
  z.lazy(() => CreatePrompt2Prompts2$outboundSchema),
  z.lazy(() => CreatePrompt23$outboundSchema),
]);

export function createPromptContentPromptsResponse2ToJSON(
  createPromptContentPromptsResponse2: CreatePromptContentPromptsResponse2,
): string {
  return JSON.stringify(
    CreatePromptContentPromptsResponse2$outboundSchema.parse(
      createPromptContentPromptsResponse2,
    ),
  );
}
export function createPromptContentPromptsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptContentPromptsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptContentPromptsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptContentPromptsResponse2' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsContent$inboundSchema: z.ZodType<
  CreatePromptPromptsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => CreatePrompt21$inboundSchema),
    z.lazy(() => CreatePrompt2Prompts2$inboundSchema),
    z.lazy(() => CreatePrompt23$inboundSchema),
  ])),
]);
/** @internal */
export type CreatePromptPromptsContent$Outbound =
  | string
  | Array<
    | CreatePrompt21$Outbound
    | CreatePrompt2Prompts2$Outbound
    | CreatePrompt23$Outbound
  >;

/** @internal */
export const CreatePromptPromptsContent$outboundSchema: z.ZodType<
  CreatePromptPromptsContent$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => CreatePrompt21$outboundSchema),
    z.lazy(() => CreatePrompt2Prompts2$outboundSchema),
    z.lazy(() => CreatePrompt23$outboundSchema),
  ])),
]);

export function createPromptPromptsContentToJSON(
  createPromptPromptsContent: CreatePromptPromptsContent,
): string {
  return JSON.stringify(
    CreatePromptPromptsContent$outboundSchema.parse(createPromptPromptsContent),
  );
}
export function createPromptPromptsContentFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsContent' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsResponseType
> = z.nativeEnum(CreatePromptPromptsResponseType);
/** @internal */
export const CreatePromptPromptsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsResponseType
> = CreatePromptPromptsResponseType$inboundSchema;

/** @internal */
export const CreatePromptPromptsFunction$inboundSchema: z.ZodType<
  CreatePromptPromptsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});
/** @internal */
export type CreatePromptPromptsFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const CreatePromptPromptsFunction$outboundSchema: z.ZodType<
  CreatePromptPromptsFunction$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function createPromptPromptsFunctionToJSON(
  createPromptPromptsFunction: CreatePromptPromptsFunction,
): string {
  return JSON.stringify(
    CreatePromptPromptsFunction$outboundSchema.parse(
      createPromptPromptsFunction,
    ),
  );
}
export function createPromptPromptsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsFunction' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsToolCalls$inboundSchema: z.ZodType<
  CreatePromptPromptsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: CreatePromptPromptsResponseType$inboundSchema,
  function: z.lazy(() => CreatePromptPromptsFunction$inboundSchema),
});
/** @internal */
export type CreatePromptPromptsToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: CreatePromptPromptsFunction$Outbound;
};

/** @internal */
export const CreatePromptPromptsToolCalls$outboundSchema: z.ZodType<
  CreatePromptPromptsToolCalls$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: CreatePromptPromptsResponseType$outboundSchema,
  function: z.lazy(() => CreatePromptPromptsFunction$outboundSchema),
});

export function createPromptPromptsToolCallsToJSON(
  createPromptPromptsToolCalls: CreatePromptPromptsToolCalls,
): string {
  return JSON.stringify(
    CreatePromptPromptsToolCalls$outboundSchema.parse(
      createPromptPromptsToolCalls,
    ),
  );
}
export function createPromptPromptsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsToolCalls' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptsResponseMessages$inboundSchema: z.ZodType<
  CreatePromptPromptsResponseMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: CreatePromptPromptsRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => CreatePrompt21$inboundSchema),
        z.lazy(() => CreatePrompt2Prompts2$inboundSchema),
        z.lazy(() => CreatePrompt23$inboundSchema),
      ])),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => CreatePromptPromptsToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type CreatePromptPromptsResponseMessages$Outbound = {
  role: string;
  content:
    | string
    | Array<
      | CreatePrompt21$Outbound
      | CreatePrompt2Prompts2$Outbound
      | CreatePrompt23$Outbound
    >
    | null;
  tool_calls?: Array<CreatePromptPromptsToolCalls$Outbound> | undefined;
  tool_call_id?: string | null | undefined;
};

/** @internal */
export const CreatePromptPromptsResponseMessages$outboundSchema: z.ZodType<
  CreatePromptPromptsResponseMessages$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsResponseMessages
> = z.object({
  role: CreatePromptPromptsRole$outboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => CreatePrompt21$outboundSchema),
        z.lazy(() => CreatePrompt2Prompts2$outboundSchema),
        z.lazy(() => CreatePrompt23$outboundSchema),
      ])),
    ]),
  ),
  toolCalls: z.array(z.lazy(() => CreatePromptPromptsToolCalls$outboundSchema))
    .optional(),
  toolCallId: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    toolCallId: "tool_call_id",
  });
});

export function createPromptPromptsResponseMessagesToJSON(
  createPromptPromptsResponseMessages: CreatePromptPromptsResponseMessages,
): string {
  return JSON.stringify(
    CreatePromptPromptsResponseMessages$outboundSchema.parse(
      createPromptPromptsResponseMessages,
    ),
  );
}
export function createPromptPromptsResponseMessagesFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsResponseMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreatePromptPromptsResponseMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsResponseMessages' from JSON`,
  );
}

/** @internal */
export const CreatePromptPromptConfig$inboundSchema: z.ZodType<
  CreatePromptPromptConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  stream: z.boolean().optional(),
  model: z.string().optional(),
  model_db_id: z.nullable(z.string()).optional(),
  model_type: z.nullable(CreatePromptModelType$inboundSchema).optional(),
  model_parameters: z.lazy(() => CreatePromptModelParameters$inboundSchema)
    .optional(),
  provider: CreatePromptProvider$inboundSchema.optional(),
  integration_id: z.nullable(z.string()).optional(),
  version: z.string().optional(),
  messages: z.array(
    z.lazy(() => CreatePromptPromptsResponseMessages$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "model_db_id": "modelDbId",
    "model_type": "modelType",
    "model_parameters": "modelParameters",
    "integration_id": "integrationId",
  });
});
/** @internal */
export type CreatePromptPromptConfig$Outbound = {
  stream?: boolean | undefined;
  model?: string | undefined;
  model_db_id?: string | null | undefined;
  model_type?: string | null | undefined;
  model_parameters?: CreatePromptModelParameters$Outbound | undefined;
  provider?: string | undefined;
  integration_id?: string | null | undefined;
  version?: string | undefined;
  messages: Array<CreatePromptPromptsResponseMessages$Outbound>;
};

/** @internal */
export const CreatePromptPromptConfig$outboundSchema: z.ZodType<
  CreatePromptPromptConfig$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptConfig
> = z.object({
  stream: z.boolean().optional(),
  model: z.string().optional(),
  modelDbId: z.nullable(z.string()).optional(),
  modelType: z.nullable(CreatePromptModelType$outboundSchema).optional(),
  modelParameters: z.lazy(() => CreatePromptModelParameters$outboundSchema)
    .optional(),
  provider: CreatePromptProvider$outboundSchema.optional(),
  integrationId: z.nullable(z.string()).optional(),
  version: z.string().optional(),
  messages: z.array(
    z.lazy(() => CreatePromptPromptsResponseMessages$outboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    modelDbId: "model_db_id",
    modelType: "model_type",
    modelParameters: "model_parameters",
    integrationId: "integration_id",
  });
});

export function createPromptPromptConfigToJSON(
  createPromptPromptConfig: CreatePromptPromptConfig,
): string {
  return JSON.stringify(
    CreatePromptPromptConfig$outboundSchema.parse(createPromptPromptConfig),
  );
}
export function createPromptPromptConfigFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptConfig' from JSON`,
  );
}

/** @internal */
export const CreatePromptUseCases$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptUseCases
> = z.nativeEnum(CreatePromptUseCases);
/** @internal */
export const CreatePromptUseCases$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptUseCases
> = CreatePromptUseCases$inboundSchema;

/** @internal */
export const CreatePromptPromptsLanguage$inboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsLanguage
> = z.nativeEnum(CreatePromptPromptsLanguage);
/** @internal */
export const CreatePromptPromptsLanguage$outboundSchema: z.ZodNativeEnum<
  typeof CreatePromptPromptsLanguage
> = CreatePromptPromptsLanguage$inboundSchema;

/** @internal */
export const CreatePromptPromptsMetadata$inboundSchema: z.ZodType<
  CreatePromptPromptsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  use_cases: z.array(CreatePromptUseCases$inboundSchema).optional(),
  language: z.nullable(CreatePromptPromptsLanguage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "use_cases": "useCases",
  });
});
/** @internal */
export type CreatePromptPromptsMetadata$Outbound = {
  use_cases?: Array<string> | undefined;
  language?: string | null | undefined;
};

/** @internal */
export const CreatePromptPromptsMetadata$outboundSchema: z.ZodType<
  CreatePromptPromptsMetadata$Outbound,
  z.ZodTypeDef,
  CreatePromptPromptsMetadata
> = z.object({
  useCases: z.array(CreatePromptUseCases$outboundSchema).optional(),
  language: z.nullable(CreatePromptPromptsLanguage$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    useCases: "use_cases",
  });
});

export function createPromptPromptsMetadataToJSON(
  createPromptPromptsMetadata: CreatePromptPromptsMetadata,
): string {
  return JSON.stringify(
    CreatePromptPromptsMetadata$outboundSchema.parse(
      createPromptPromptsMetadata,
    ),
  );
}
export function createPromptPromptsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPromptsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPromptsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPromptsMetadata' from JSON`,
  );
}

/** @internal */
export const CreatePromptPrompt$inboundSchema: z.ZodType<
  CreatePromptPrompt,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  type: CreatePromptPromptsType$inboundSchema,
  owner: z.string(),
  domain_id: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  display_name: z.string(),
  description: z.nullable(z.string()).optional(),
  prompt_config: z.lazy(() => CreatePromptPromptConfig$inboundSchema),
  metadata: z.lazy(() => CreatePromptPromptsMetadata$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "display_name": "displayName",
    "prompt_config": "promptConfig",
  });
});
/** @internal */
export type CreatePromptPrompt$Outbound = {
  _id: string;
  type: string;
  owner: string;
  domain_id: string;
  created: string;
  updated: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  display_name: string;
  description?: string | null | undefined;
  prompt_config: CreatePromptPromptConfig$Outbound;
  metadata?: CreatePromptPromptsMetadata$Outbound | undefined;
};

/** @internal */
export const CreatePromptPrompt$outboundSchema: z.ZodType<
  CreatePromptPrompt$Outbound,
  z.ZodTypeDef,
  CreatePromptPrompt
> = z.object({
  id: z.string(),
  type: CreatePromptPromptsType$outboundSchema,
  owner: z.string(),
  domainId: z.string(),
  created: z.string(),
  updated: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  displayName: z.string(),
  description: z.nullable(z.string()).optional(),
  promptConfig: z.lazy(() => CreatePromptPromptConfig$outboundSchema),
  metadata: z.lazy(() => CreatePromptPromptsMetadata$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    displayName: "display_name",
    promptConfig: "prompt_config",
  });
});

export function createPromptPromptToJSON(
  createPromptPrompt: CreatePromptPrompt,
): string {
  return JSON.stringify(
    CreatePromptPrompt$outboundSchema.parse(createPromptPrompt),
  );
}
export function createPromptPromptFromJSON(
  jsonString: string,
): SafeParseResult<CreatePromptPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreatePromptPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreatePromptPrompt' from JSON`,
  );
}
