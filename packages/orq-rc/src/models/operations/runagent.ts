/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RunAgentModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RunAgentModelConfigurationVoice = ClosedEnum<
  typeof RunAgentModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RunAgentModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RunAgentModelConfigurationFormat = ClosedEnum<
  typeof RunAgentModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RunAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RunAgentModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RunAgentModelConfigurationFormat;
};

export type RunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RunAgentResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: RunAgentResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RunAgentResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RunAgentResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type RunAgentModelConfigurationResponseFormat =
  | RunAgentResponseFormatText
  | RunAgentResponseFormatJSONObject
  | RunAgentResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const RunAgentModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type RunAgentModelConfigurationReasoningEffort = ClosedEnum<
  typeof RunAgentModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RunAgentModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RunAgentModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type RunAgentModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RunAgentToolChoiceType = ClosedEnum<typeof RunAgentToolChoiceType>;

export type RunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type RunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RunAgentToolChoiceType | undefined;
  function: RunAgentToolChoiceFunction;
};

export const RunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RunAgentToolChoice1 = ClosedEnum<typeof RunAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RunAgentModelConfigurationToolChoice =
  | RunAgentToolChoice2
  | RunAgentToolChoice1;

export const RunAgentModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RunAgentModelConfigurationModalities = ClosedEnum<
  typeof RunAgentModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const RunAgentId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type RunAgentId1 = ClosedEnum<typeof RunAgentId1>;

export type RunAgentModelConfigurationId = RunAgentId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const RunAgentModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type RunAgentModelConfigurationExecuteOn = ClosedEnum<
  typeof RunAgentModelConfigurationExecuteOn
>;

export type RunAgentModelConfigurationGuardrails = {
  id: RunAgentId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: RunAgentModelConfigurationExecuteOn;
};

export type RunAgentModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type RunAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const RunAgentModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type RunAgentModelConfigurationType = ClosedEnum<
  typeof RunAgentModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type RunAgentModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: RunAgentModelConfigurationType;
};

export const RunAgentLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type RunAgentLoadBalancerType = ClosedEnum<
  typeof RunAgentLoadBalancerType
>;

export type RunAgentLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type RunAgentLoadBalancer1 = {
  type: RunAgentLoadBalancerType;
  models: Array<RunAgentLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type RunAgentModelConfigurationLoadBalancer = RunAgentLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type RunAgentModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type RunAgentModelConfigurationParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: RunAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RunAgentResponseFormatText
    | RunAgentResponseFormatJSONObject
    | RunAgentResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: RunAgentModelConfigurationReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: RunAgentModelConfigurationStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: RunAgentToolChoice2 | RunAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<RunAgentModelConfigurationModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<RunAgentModelConfigurationGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<RunAgentModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: RunAgentModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: RunAgentModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: RunAgentLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: RunAgentModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type RunAgentModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type RunAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: RunAgentModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: RunAgentModelConfigurationAgentsRetry | undefined;
};

/**
 * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
 */
export type RunAgentModelConfiguration = RunAgentModelConfiguration2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RunAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RunAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RunAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RunAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RunAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RunAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RunAgentFallbackModelConfigurationFormat;
};

export type RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RunAgentResponseFormatAgentsRequestJSONSchema = {
  type: "json_schema";
  jsonSchema: RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RunAgentResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RunAgentResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type RunAgentFallbackModelConfigurationResponseFormat =
  | RunAgentResponseFormatAgentsText
  | RunAgentResponseFormatAgentsJSONObject
  | RunAgentResponseFormatAgentsRequestJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const RunAgentFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type RunAgentFallbackModelConfigurationReasoningEffort = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RunAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RunAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type RunAgentFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RunAgentToolChoiceAgentsType = ClosedEnum<
  typeof RunAgentToolChoiceAgentsType
>;

export type RunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type RunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RunAgentToolChoiceAgentsType | undefined;
  function: RunAgentToolChoiceAgentsFunction;
};

export const RunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RunAgentToolChoiceAgents1 = ClosedEnum<
  typeof RunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RunAgentFallbackModelConfigurationToolChoice =
  | RunAgentToolChoiceAgents2
  | RunAgentToolChoiceAgents1;

export const RunAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RunAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const RunAgentIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type RunAgentIdAgents1 = ClosedEnum<typeof RunAgentIdAgents1>;

export type RunAgentFallbackModelConfigurationId = RunAgentIdAgents1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const RunAgentFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type RunAgentFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationExecuteOn
>;

export type RunAgentFallbackModelConfigurationGuardrails = {
  id: RunAgentIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: RunAgentFallbackModelConfigurationExecuteOn;
};

export type RunAgentFallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type RunAgentFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const RunAgentFallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type RunAgentFallbackModelConfigurationType = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type RunAgentFallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: RunAgentFallbackModelConfigurationType;
};

export const RunAgentLoadBalancerAgentsType = {
  WeightBased: "weight_based",
} as const;
export type RunAgentLoadBalancerAgentsType = ClosedEnum<
  typeof RunAgentLoadBalancerAgentsType
>;

export type RunAgentLoadBalancerAgentsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type RunAgentLoadBalancerAgents1 = {
  type: RunAgentLoadBalancerAgentsType;
  models: Array<RunAgentLoadBalancerAgentsModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type RunAgentFallbackModelConfigurationLoadBalancer =
  RunAgentLoadBalancerAgents1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type RunAgentFallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type RunAgentFallbackModelConfigurationParameters = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: RunAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RunAgentResponseFormatAgentsText
    | RunAgentResponseFormatAgentsJSONObject
    | RunAgentResponseFormatAgentsRequestJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | RunAgentFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | RunAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | RunAgentToolChoiceAgents2
    | RunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<RunAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<RunAgentFallbackModelConfigurationGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<RunAgentFallbackModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: RunAgentFallbackModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: RunAgentFallbackModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: RunAgentLoadBalancerAgents1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: RunAgentFallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type RunAgentFallbackModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type RunAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: RunAgentFallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: RunAgentFallbackModelConfigurationAgentsRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type RunAgentFallbackModelConfiguration =
  | RunAgentFallbackModelConfiguration2
  | string;

/**
 * Message containing tool execution results
 */
export const RunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type RunAgentRoleToolMessage = ClosedEnum<
  typeof RunAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const RunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type RunAgentRoleUserMessage = ClosedEnum<
  typeof RunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type RunAgentRole = RunAgentRoleUserMessage | RunAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type RunAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart
  | components.ErrorPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type RunAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: RunAgentRoleUserMessage | RunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | components.TextPart
    | components.FilePart
    | components.ToolResultPart
    | components.ErrorPart
  >;
};

/**
 * Information about the identity making the request. If the identity does not exist, it will be created automatically.
 */
export type RunAgentIdentity = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type RunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type RunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type RunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type RunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type RunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type AgentToolInputRunHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  {
    Object: "object",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  >;

export type AgentToolInputRunSchema = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type Tools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: AgentToolInputRunSchema;
};

/**
 * The connection type used by the MCP server
 */
export const ConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ConnectionType = ClosedEnum<typeof ConnectionType>;

export type Mcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: AgentToolInputRunHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<Tools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ConnectionType;
};

/**
 * MCP tool with inline definition for on-the-fly creation in run endpoint
 */
export type MCPToolRun = {
  type: "mcp";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  mcp: Mcp;
  requiresApproval?: boolean | undefined;
};

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type Schema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type AgentToolInputRunJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: Schema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * JSON Schema tool with inline definition for on-the-fly creation in run endpoint
 */
export type JSONSchemaToolRun = {
  type: "json_schema";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  jsonSchema: AgentToolInputRunJsonSchema;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RunAgentAgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type AgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RunAgentAgentToolInputRunParameters | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type FunctionToolRun = {
  type: "function";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: AgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type AgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const Language = {
  Python: "python",
} as const;
export type Language = ClosedEnum<typeof Language>;

export type CodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: AgentToolInputRunParameters | undefined;
  language: Language;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type CodeToolRun = {
  type: "code";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: CodeTool;
  requiresApproval?: boolean | undefined;
};

/**
 * The HTTP method to use.
 */
export const Method = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type Method = ClosedEnum<typeof Method>;

export type Headers2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type Headers = Headers2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type Blueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: Method;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: Headers2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type DefaultValue = string | number | boolean;

export type Arguments = {
  /**
   * The type of the argument.
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type Http = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: Blueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: Arguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type HTTPToolRun = {
  type: "http";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: Http;
  requiresApproval?: boolean | undefined;
};

/**
 * Returns the current date and time
 */
export type AgentToolInputRunCurrentDateTool = {
  type: "current_date";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries knowledge bases for information
 */
export type AgentToolInputRunQueryKnowledgeBaseTool = {
  type: "query_knowledge_base";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available knowledge bases
 */
export type AgentToolInputRunRetrieveKnowledgeBasesTool = {
  type: "retrieve_knowledge_bases";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Deletes documents from memory stores
 */
export type AgentToolInputRunDeleteMemoryDocumentTool = {
  type: "delete_memory_document";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available memory stores
 */
export type AgentToolInputRunRetrieveMemoryStoresTool = {
  type: "retrieve_memory_stores";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Writes information to agent memory stores
 */
export type AgentToolInputRunWriteMemoryStoreTool = {
  type: "write_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries agent memory stores for context
 */
export type AgentToolInputRunQueryMemoryStoreTool = {
  type: "query_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Retrieves available agents in the system
 */
export type AgentToolInputRunRetrieveAgentsTool = {
  type: "retrieve_agents";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Delegates tasks to specialized sub-agents
 */
export type AgentToolInputRunCallSubAgentTool = {
  type: "call_sub_agent";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Scrapes and extracts content from web pages
 */
export type AgentToolInputRunWebScraperTool = {
  type: "web_scraper";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Performs Google searches to retrieve web content
 */
export type AgentToolInputRunGoogleSearchTool = {
  type: "google_search";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function, JSON Schema, MCP) support full inline definitions for on-the-fly creation.
 */
export type AgentToolInputRun =
  | AgentToolInputRunGoogleSearchTool
  | AgentToolInputRunWebScraperTool
  | AgentToolInputRunCallSubAgentTool
  | AgentToolInputRunRetrieveAgentsTool
  | AgentToolInputRunQueryMemoryStoreTool
  | AgentToolInputRunWriteMemoryStoreTool
  | AgentToolInputRunRetrieveMemoryStoresTool
  | AgentToolInputRunDeleteMemoryDocumentTool
  | AgentToolInputRunRetrieveKnowledgeBasesTool
  | AgentToolInputRunQueryKnowledgeBaseTool
  | AgentToolInputRunCurrentDateTool
  | HTTPToolRun
  | CodeToolRun
  | FunctionToolRun
  | JSONSchemaToolRun
  | MCPToolRun;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const RunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type RunAgentToolApprovalRequired = ClosedEnum<
  typeof RunAgentToolApprovalRequired
>;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RunAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RunAgentExecuteOn = ClosedEnum<typeof RunAgentExecuteOn>;

export type RunAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RunAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RunAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RunAgentAgentsExecuteOn = ClosedEnum<
  typeof RunAgentAgentsExecuteOn
>;

export type RunAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RunAgentAgentsExecuteOn;
};

export type RunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | AgentToolInputRunGoogleSearchTool
      | AgentToolInputRunWebScraperTool
      | AgentToolInputRunCallSubAgentTool
      | AgentToolInputRunRetrieveAgentsTool
      | AgentToolInputRunQueryMemoryStoreTool
      | AgentToolInputRunWriteMemoryStoreTool
      | AgentToolInputRunRetrieveMemoryStoresTool
      | AgentToolInputRunDeleteMemoryDocumentTool
      | AgentToolInputRunRetrieveKnowledgeBasesTool
      | AgentToolInputRunQueryKnowledgeBaseTool
      | AgentToolInputRunCurrentDateTool
      | HTTPToolRun
      | CodeToolRun
      | FunctionToolRun
      | JSONSchemaToolRun
      | MCPToolRun
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: RunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<RunAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<RunAgentGuardrails> | undefined;
};

export type RunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
   */
  model: RunAgentModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<RunAgentFallbackModelConfiguration2 | string>
    | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: RunAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: RunAgentIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: RunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: RunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: RunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<RunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<RunAgentTeamOfAgents> | undefined;
  settings: RunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * A2A entity type identifier
 */
export const RunAgentKind = {
  Task: "task",
} as const;
/**
 * A2A entity type identifier
 */
export type RunAgentKind = ClosedEnum<typeof RunAgentKind>;

/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export const RunAgentTaskState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  AuthRequired: "auth-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
} as const;
/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export type RunAgentTaskState = ClosedEnum<typeof RunAgentTaskState>;

export const RunAgentAgentsKind = {
  Message: "message",
} as const;
export type RunAgentAgentsKind = ClosedEnum<typeof RunAgentAgentsKind>;

/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export const RunAgentExtendedMessageRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export type RunAgentExtendedMessageRole = ClosedEnum<
  typeof RunAgentExtendedMessageRole
>;

export type RunAgentParts =
  | components.TextPart
  | components.ErrorPart
  | components.DataPart
  | components.FilePart
  | components.ToolCallPart
  | components.ToolResultPart;

/**
 * Optional A2A message providing additional context about the current status
 */
export type RunAgentTaskStatusMessage = {
  kind: RunAgentAgentsKind;
  messageId: string;
  /**
   * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
   */
  role: RunAgentExtendedMessageRole;
  parts: Array<
    | components.TextPart
    | components.ErrorPart
    | components.DataPart
    | components.FilePart
    | components.ToolCallPart
    | components.ToolResultPart
  >;
};

/**
 * Current task status information
 */
export type RunAgentTaskStatus = {
  /**
   * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
   */
  state: RunAgentTaskState;
  /**
   * ISO 8601 timestamp of when the status was updated
   */
  timestamp?: string | undefined;
  /**
   * Optional A2A message providing additional context about the current status
   */
  message?: RunAgentTaskStatusMessage | undefined;
};

/**
 * Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution.
 */
export type RunAgentA2ATaskResponse = {
  /**
   * The unique ID of the created agent execution task
   */
  id: string;
  /**
   * The correlation ID for this execution (used for tracking)
   */
  contextId: string;
  /**
   * A2A entity type identifier
   */
  kind: RunAgentKind;
  /**
   * Current task status information
   */
  status: RunAgentTaskStatus;
  /**
   * Task metadata containing workspace_id and trace_id for feedback and tracking
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationVoice
> = z.nativeEnum(RunAgentModelConfigurationVoice);

/** @internal */
export const RunAgentModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationFormat
> = z.nativeEnum(RunAgentModelConfigurationFormat);

/** @internal */
export type RunAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RunAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  RunAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationAudio
> = z.object({
  voice: RunAgentModelConfigurationVoice$outboundSchema,
  format: RunAgentModelConfigurationFormat$outboundSchema,
});

export function runAgentModelConfigurationAudioToJSON(
  runAgentModelConfigurationAudio: RunAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationAudio$outboundSchema.parse(
      runAgentModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const RunAgentResponseFormatAgentsJsonSchema$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJsonSchema$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});

export function runAgentResponseFormatAgentsJsonSchemaToJSON(
  runAgentResponseFormatAgentsJsonSchema:
    RunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      runAgentResponseFormatAgentsJsonSchema,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: RunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const RunAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  RunAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    RunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function runAgentResponseFormatJSONSchemaToJSON(
  runAgentResponseFormatJSONSchema: RunAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatJSONSchema$outboundSchema.parse(
      runAgentResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const RunAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  RunAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function runAgentResponseFormatJSONObjectToJSON(
  runAgentResponseFormatJSONObject: RunAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    RunAgentResponseFormatJSONObject$outboundSchema.parse(
      runAgentResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const RunAgentResponseFormatText$outboundSchema: z.ZodType<
  RunAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function runAgentResponseFormatTextToJSON(
  runAgentResponseFormatText: RunAgentResponseFormatText,
): string {
  return JSON.stringify(
    RunAgentResponseFormatText$outboundSchema.parse(runAgentResponseFormatText),
  );
}

/** @internal */
export type RunAgentModelConfigurationResponseFormat$Outbound =
  | RunAgentResponseFormatText$Outbound
  | RunAgentResponseFormatJSONObject$Outbound
  | RunAgentResponseFormatJSONSchema$Outbound;

/** @internal */
export const RunAgentModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  RunAgentModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => RunAgentResponseFormatText$outboundSchema),
  z.lazy(() => RunAgentResponseFormatJSONObject$outboundSchema),
  z.lazy(() => RunAgentResponseFormatJSONSchema$outboundSchema),
]);

export function runAgentModelConfigurationResponseFormatToJSON(
  runAgentModelConfigurationResponseFormat:
    RunAgentModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationResponseFormat$outboundSchema.parse(
      runAgentModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const RunAgentModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationReasoningEffort> = z
    .nativeEnum(RunAgentModelConfigurationReasoningEffort);

/** @internal */
export type RunAgentModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const RunAgentModelConfigurationStop$outboundSchema: z.ZodType<
  RunAgentModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function runAgentModelConfigurationStopToJSON(
  runAgentModelConfigurationStop: RunAgentModelConfigurationStop,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationStop$outboundSchema.parse(
      runAgentModelConfigurationStop,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const RunAgentModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  RunAgentModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function runAgentModelConfigurationStreamOptionsToJSON(
  runAgentModelConfigurationStreamOptions:
    RunAgentModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationStreamOptions$outboundSchema.parse(
      runAgentModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const RunAgentModelConfigurationThinking$outboundSchema: z.ZodType<
  RunAgentModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function runAgentModelConfigurationThinkingToJSON(
  runAgentModelConfigurationThinking: RunAgentModelConfigurationThinking,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationThinking$outboundSchema.parse(
      runAgentModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const RunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceType
> = z.nativeEnum(RunAgentToolChoiceType);

/** @internal */
export type RunAgentToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const RunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  RunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function runAgentToolChoiceFunctionToJSON(
  runAgentToolChoiceFunction: RunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    RunAgentToolChoiceFunction$outboundSchema.parse(runAgentToolChoiceFunction),
  );
}

/** @internal */
export type RunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: RunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const RunAgentToolChoice2$outboundSchema: z.ZodType<
  RunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoice2
> = z.object({
  type: RunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceFunction$outboundSchema),
});

export function runAgentToolChoice2ToJSON(
  runAgentToolChoice2: RunAgentToolChoice2,
): string {
  return JSON.stringify(
    RunAgentToolChoice2$outboundSchema.parse(runAgentToolChoice2),
  );
}

/** @internal */
export const RunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoice1
> = z.nativeEnum(RunAgentToolChoice1);

/** @internal */
export type RunAgentModelConfigurationToolChoice$Outbound =
  | RunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const RunAgentModelConfigurationToolChoice$outboundSchema: z.ZodType<
  RunAgentModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationToolChoice
> = z.union([
  z.lazy(() => RunAgentToolChoice2$outboundSchema),
  RunAgentToolChoice1$outboundSchema,
]);

export function runAgentModelConfigurationToolChoiceToJSON(
  runAgentModelConfigurationToolChoice: RunAgentModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationToolChoice$outboundSchema.parse(
      runAgentModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const RunAgentModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationModalities> = z.nativeEnum(
    RunAgentModelConfigurationModalities,
  );

/** @internal */
export const RunAgentId1$outboundSchema: z.ZodNativeEnum<typeof RunAgentId1> = z
  .nativeEnum(RunAgentId1);

/** @internal */
export type RunAgentModelConfigurationId$Outbound = string | string;

/** @internal */
export const RunAgentModelConfigurationId$outboundSchema: z.ZodType<
  RunAgentModelConfigurationId$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationId
> = z.union([RunAgentId1$outboundSchema, z.string()]);

export function runAgentModelConfigurationIdToJSON(
  runAgentModelConfigurationId: RunAgentModelConfigurationId,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationId$outboundSchema.parse(
      runAgentModelConfigurationId,
    ),
  );
}

/** @internal */
export const RunAgentModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationExecuteOn> = z.nativeEnum(
    RunAgentModelConfigurationExecuteOn,
  );

/** @internal */
export type RunAgentModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const RunAgentModelConfigurationGuardrails$outboundSchema: z.ZodType<
  RunAgentModelConfigurationGuardrails$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationGuardrails
> = z.object({
  id: z.union([RunAgentId1$outboundSchema, z.string()]),
  executeOn: RunAgentModelConfigurationExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function runAgentModelConfigurationGuardrailsToJSON(
  runAgentModelConfigurationGuardrails: RunAgentModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationGuardrails$outboundSchema.parse(
      runAgentModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const RunAgentModelConfigurationFallbacks$outboundSchema: z.ZodType<
  RunAgentModelConfigurationFallbacks$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationFallbacks
> = z.object({
  model: z.string(),
});

export function runAgentModelConfigurationFallbacksToJSON(
  runAgentModelConfigurationFallbacks: RunAgentModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationFallbacks$outboundSchema.parse(
      runAgentModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RunAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  RunAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function runAgentModelConfigurationRetryToJSON(
  runAgentModelConfigurationRetry: RunAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationRetry$outboundSchema.parse(
      runAgentModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const RunAgentModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationType
> = z.nativeEnum(RunAgentModelConfigurationType);

/** @internal */
export type RunAgentModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const RunAgentModelConfigurationCache$outboundSchema: z.ZodType<
  RunAgentModelConfigurationCache$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationCache
> = z.object({
  ttl: z.number().default(1800),
  type: RunAgentModelConfigurationType$outboundSchema,
});

export function runAgentModelConfigurationCacheToJSON(
  runAgentModelConfigurationCache: RunAgentModelConfigurationCache,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationCache$outboundSchema.parse(
      runAgentModelConfigurationCache,
    ),
  );
}

/** @internal */
export const RunAgentLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentLoadBalancerType
> = z.nativeEnum(RunAgentLoadBalancerType);

/** @internal */
export type RunAgentLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const RunAgentLoadBalancerModels$outboundSchema: z.ZodType<
  RunAgentLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  RunAgentLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function runAgentLoadBalancerModelsToJSON(
  runAgentLoadBalancerModels: RunAgentLoadBalancerModels,
): string {
  return JSON.stringify(
    RunAgentLoadBalancerModels$outboundSchema.parse(runAgentLoadBalancerModels),
  );
}

/** @internal */
export type RunAgentLoadBalancer1$Outbound = {
  type: string;
  models: Array<RunAgentLoadBalancerModels$Outbound>;
};

/** @internal */
export const RunAgentLoadBalancer1$outboundSchema: z.ZodType<
  RunAgentLoadBalancer1$Outbound,
  z.ZodTypeDef,
  RunAgentLoadBalancer1
> = z.object({
  type: RunAgentLoadBalancerType$outboundSchema,
  models: z.array(z.lazy(() => RunAgentLoadBalancerModels$outboundSchema)),
});

export function runAgentLoadBalancer1ToJSON(
  runAgentLoadBalancer1: RunAgentLoadBalancer1,
): string {
  return JSON.stringify(
    RunAgentLoadBalancer1$outboundSchema.parse(runAgentLoadBalancer1),
  );
}

/** @internal */
export type RunAgentModelConfigurationLoadBalancer$Outbound =
  RunAgentLoadBalancer1$Outbound;

/** @internal */
export const RunAgentModelConfigurationLoadBalancer$outboundSchema: z.ZodType<
  RunAgentModelConfigurationLoadBalancer$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationLoadBalancer
> = z.lazy(() => RunAgentLoadBalancer1$outboundSchema);

export function runAgentModelConfigurationLoadBalancerToJSON(
  runAgentModelConfigurationLoadBalancer:
    RunAgentModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationLoadBalancer$outboundSchema.parse(
      runAgentModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const RunAgentModelConfigurationTimeout$outboundSchema: z.ZodType<
  RunAgentModelConfigurationTimeout$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function runAgentModelConfigurationTimeoutToJSON(
  runAgentModelConfigurationTimeout: RunAgentModelConfigurationTimeout,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationTimeout$outboundSchema.parse(
      runAgentModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationParameters$Outbound = {
  name?: string | undefined;
  audio?: RunAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | RunAgentResponseFormatText$Outbound
    | RunAgentResponseFormatJSONObject$Outbound
    | RunAgentResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | RunAgentModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: RunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<RunAgentModelConfigurationGuardrails$Outbound> | undefined;
  fallbacks?: Array<RunAgentModelConfigurationFallbacks$Outbound> | undefined;
  retry?: RunAgentModelConfigurationRetry$Outbound | undefined;
  cache?: RunAgentModelConfigurationCache$Outbound | undefined;
  load_balancer?: RunAgentLoadBalancer1$Outbound | undefined;
  timeout?: RunAgentModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const RunAgentModelConfigurationParameters$outboundSchema: z.ZodType<
  RunAgentModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationParameters
> = z.object({
  name: z.string().optional(),
  audio: z.nullable(
    z.lazy(() => RunAgentModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => RunAgentResponseFormatText$outboundSchema),
    z.lazy(() => RunAgentResponseFormatJSONObject$outboundSchema),
    z.lazy(() => RunAgentResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: RunAgentModelConfigurationReasoningEffort$outboundSchema
    .optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => RunAgentModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => RunAgentToolChoice2$outboundSchema),
    RunAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(RunAgentModelConfigurationModalities$outboundSchema),
  ).optional(),
  guardrails: z.array(
    z.lazy(() => RunAgentModelConfigurationGuardrails$outboundSchema),
  ).optional(),
  fallbacks: z.array(
    z.lazy(() => RunAgentModelConfigurationFallbacks$outboundSchema),
  ).optional(),
  retry: z.lazy(() => RunAgentModelConfigurationRetry$outboundSchema)
    .optional(),
  cache: z.lazy(() => RunAgentModelConfigurationCache$outboundSchema)
    .optional(),
  loadBalancer: z.lazy(() => RunAgentLoadBalancer1$outboundSchema).optional(),
  timeout: z.lazy(() => RunAgentModelConfigurationTimeout$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function runAgentModelConfigurationParametersToJSON(
  runAgentModelConfigurationParameters: RunAgentModelConfigurationParameters,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationParameters$outboundSchema.parse(
      runAgentModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type RunAgentModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RunAgentModelConfigurationAgentsRetry$outboundSchema: z.ZodType<
  RunAgentModelConfigurationAgentsRetry$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationAgentsRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function runAgentModelConfigurationAgentsRetryToJSON(
  runAgentModelConfigurationAgentsRetry: RunAgentModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationAgentsRetry$outboundSchema.parse(
      runAgentModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type RunAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: RunAgentModelConfigurationParameters$Outbound | undefined;
  retry?: RunAgentModelConfigurationAgentsRetry$Outbound | undefined;
};

/** @internal */
export const RunAgentModelConfiguration2$outboundSchema: z.ZodType<
  RunAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => RunAgentModelConfigurationParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => RunAgentModelConfigurationAgentsRetry$outboundSchema)
    .optional(),
});

export function runAgentModelConfiguration2ToJSON(
  runAgentModelConfiguration2: RunAgentModelConfiguration2,
): string {
  return JSON.stringify(
    RunAgentModelConfiguration2$outboundSchema.parse(
      runAgentModelConfiguration2,
    ),
  );
}

/** @internal */
export type RunAgentModelConfiguration$Outbound =
  | RunAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const RunAgentModelConfiguration$outboundSchema: z.ZodType<
  RunAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfiguration
> = z.union([
  z.lazy(() => RunAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function runAgentModelConfigurationToJSON(
  runAgentModelConfiguration: RunAgentModelConfiguration,
): string {
  return JSON.stringify(
    RunAgentModelConfiguration$outboundSchema.parse(runAgentModelConfiguration),
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(RunAgentFallbackModelConfigurationVoice);

/** @internal */
export const RunAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(RunAgentFallbackModelConfigurationFormat);

/** @internal */
export type RunAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RunAgentFallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationAudio
> = z.object({
  voice: RunAgentFallbackModelConfigurationVoice$outboundSchema,
  format: RunAgentFallbackModelConfigurationFormat$outboundSchema,
});

export function runAgentFallbackModelConfigurationAudioToJSON(
  runAgentFallbackModelConfigurationAudio:
    RunAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      runAgentFallbackModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function runAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  runAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(runAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}

/** @internal */
export type RunAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    RunAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function runAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  runAgentResponseFormatAgentsRequestJSONSchema:
    RunAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      runAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const RunAgentResponseFormatAgentsJSONObject$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJSONObject$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function runAgentResponseFormatAgentsJSONObjectToJSON(
  runAgentResponseFormatAgentsJSONObject:
    RunAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      runAgentResponseFormatAgentsJSONObject,
    ),
  );
}

/** @internal */
export type RunAgentResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const RunAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsText
> = z.object({
  type: z.literal("text"),
});

export function runAgentResponseFormatAgentsTextToJSON(
  runAgentResponseFormatAgentsText: RunAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsText$outboundSchema.parse(
      runAgentResponseFormatAgentsText,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationResponseFormat$Outbound =
  | RunAgentResponseFormatAgentsText$Outbound
  | RunAgentResponseFormatAgentsJSONObject$Outbound
  | RunAgentResponseFormatAgentsRequestJSONSchema$Outbound;

/** @internal */
export const RunAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => RunAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsJSONObject$outboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema),
  ]);

export function runAgentFallbackModelConfigurationResponseFormatToJSON(
  runAgentFallbackModelConfigurationResponseFormat:
    RunAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      runAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationReasoningEffort> = z
    .nativeEnum(RunAgentFallbackModelConfigurationReasoningEffort);

/** @internal */
export type RunAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const RunAgentFallbackModelConfigurationStop$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function runAgentFallbackModelConfigurationStopToJSON(
  runAgentFallbackModelConfigurationStop:
    RunAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationStop$outboundSchema.parse(
      runAgentFallbackModelConfigurationStop,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function runAgentFallbackModelConfigurationStreamOptionsToJSON(
  runAgentFallbackModelConfigurationStreamOptions:
    RunAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      runAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const RunAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function runAgentFallbackModelConfigurationThinkingToJSON(
  runAgentFallbackModelConfigurationThinking:
    RunAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      runAgentFallbackModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const RunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgentsType
> = z.nativeEnum(RunAgentToolChoiceAgentsType);

/** @internal */
export type RunAgentToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const RunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  RunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string(),
});

export function runAgentToolChoiceAgentsFunctionToJSON(
  runAgentToolChoiceAgentsFunction: RunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    RunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      runAgentToolChoiceAgentsFunction,
    ),
  );
}

/** @internal */
export type RunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: RunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const RunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  RunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceAgents2
> = z.object({
  type: RunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function runAgentToolChoiceAgents2ToJSON(
  runAgentToolChoiceAgents2: RunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    RunAgentToolChoiceAgents2$outboundSchema.parse(runAgentToolChoiceAgents2),
  );
}

/** @internal */
export const RunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgents1
> = z.nativeEnum(RunAgentToolChoiceAgents1);

/** @internal */
export type RunAgentFallbackModelConfigurationToolChoice$Outbound =
  | RunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const RunAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => RunAgentToolChoiceAgents2$outboundSchema),
    RunAgentToolChoiceAgents1$outboundSchema,
  ]);

export function runAgentFallbackModelConfigurationToolChoiceToJSON(
  runAgentFallbackModelConfigurationToolChoice:
    RunAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      runAgentFallbackModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(RunAgentFallbackModelConfigurationModalities);

/** @internal */
export const RunAgentIdAgents1$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentIdAgents1
> = z.nativeEnum(RunAgentIdAgents1);

/** @internal */
export type RunAgentFallbackModelConfigurationId$Outbound = string | string;

/** @internal */
export const RunAgentFallbackModelConfigurationId$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationId$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationId
> = z.union([RunAgentIdAgents1$outboundSchema, z.string()]);

export function runAgentFallbackModelConfigurationIdToJSON(
  runAgentFallbackModelConfigurationId: RunAgentFallbackModelConfigurationId,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationId$outboundSchema.parse(
      runAgentFallbackModelConfigurationId,
    ),
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationExecuteOn> = z
    .nativeEnum(RunAgentFallbackModelConfigurationExecuteOn);

/** @internal */
export type RunAgentFallbackModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const RunAgentFallbackModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationGuardrails
  > = z.object({
    id: z.union([RunAgentIdAgents1$outboundSchema, z.string()]),
    executeOn: RunAgentFallbackModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function runAgentFallbackModelConfigurationGuardrailsToJSON(
  runAgentFallbackModelConfigurationGuardrails:
    RunAgentFallbackModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationGuardrails$outboundSchema.parse(
      runAgentFallbackModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const RunAgentFallbackModelConfigurationFallbacks$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationFallbacks$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationFallbacks
  > = z.object({
    model: z.string(),
  });

export function runAgentFallbackModelConfigurationFallbacksToJSON(
  runAgentFallbackModelConfigurationFallbacks:
    RunAgentFallbackModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationFallbacks$outboundSchema.parse(
      runAgentFallbackModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationRetry$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function runAgentFallbackModelConfigurationRetryToJSON(
  runAgentFallbackModelConfigurationRetry:
    RunAgentFallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationRetry$outboundSchema.parse(
      runAgentFallbackModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationType> = z.nativeEnum(
    RunAgentFallbackModelConfigurationType,
  );

/** @internal */
export type RunAgentFallbackModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const RunAgentFallbackModelConfigurationCache$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationCache$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationCache
> = z.object({
  ttl: z.number().default(1800),
  type: RunAgentFallbackModelConfigurationType$outboundSchema,
});

export function runAgentFallbackModelConfigurationCacheToJSON(
  runAgentFallbackModelConfigurationCache:
    RunAgentFallbackModelConfigurationCache,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationCache$outboundSchema.parse(
      runAgentFallbackModelConfigurationCache,
    ),
  );
}

/** @internal */
export const RunAgentLoadBalancerAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentLoadBalancerAgentsType
> = z.nativeEnum(RunAgentLoadBalancerAgentsType);

/** @internal */
export type RunAgentLoadBalancerAgentsModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const RunAgentLoadBalancerAgentsModels$outboundSchema: z.ZodType<
  RunAgentLoadBalancerAgentsModels$Outbound,
  z.ZodTypeDef,
  RunAgentLoadBalancerAgentsModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function runAgentLoadBalancerAgentsModelsToJSON(
  runAgentLoadBalancerAgentsModels: RunAgentLoadBalancerAgentsModels,
): string {
  return JSON.stringify(
    RunAgentLoadBalancerAgentsModels$outboundSchema.parse(
      runAgentLoadBalancerAgentsModels,
    ),
  );
}

/** @internal */
export type RunAgentLoadBalancerAgents1$Outbound = {
  type: string;
  models: Array<RunAgentLoadBalancerAgentsModels$Outbound>;
};

/** @internal */
export const RunAgentLoadBalancerAgents1$outboundSchema: z.ZodType<
  RunAgentLoadBalancerAgents1$Outbound,
  z.ZodTypeDef,
  RunAgentLoadBalancerAgents1
> = z.object({
  type: RunAgentLoadBalancerAgentsType$outboundSchema,
  models: z.array(
    z.lazy(() => RunAgentLoadBalancerAgentsModels$outboundSchema),
  ),
});

export function runAgentLoadBalancerAgents1ToJSON(
  runAgentLoadBalancerAgents1: RunAgentLoadBalancerAgents1,
): string {
  return JSON.stringify(
    RunAgentLoadBalancerAgents1$outboundSchema.parse(
      runAgentLoadBalancerAgents1,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationLoadBalancer$Outbound =
  RunAgentLoadBalancerAgents1$Outbound;

/** @internal */
export const RunAgentFallbackModelConfigurationLoadBalancer$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationLoadBalancer$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationLoadBalancer
  > = z.lazy(() => RunAgentLoadBalancerAgents1$outboundSchema);

export function runAgentFallbackModelConfigurationLoadBalancerToJSON(
  runAgentFallbackModelConfigurationLoadBalancer:
    RunAgentFallbackModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationLoadBalancer$outboundSchema.parse(
      runAgentFallbackModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const RunAgentFallbackModelConfigurationTimeout$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationTimeout$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationTimeout
  > = z.object({
    callTimeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      callTimeout: "call_timeout",
    });
  });

export function runAgentFallbackModelConfigurationTimeoutToJSON(
  runAgentFallbackModelConfigurationTimeout:
    RunAgentFallbackModelConfigurationTimeout,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationTimeout$outboundSchema.parse(
      runAgentFallbackModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationParameters$Outbound = {
  name?: string | undefined;
  audio?: RunAgentFallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | RunAgentResponseFormatAgentsText$Outbound
    | RunAgentResponseFormatAgentsJSONObject$Outbound
    | RunAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | RunAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: RunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<RunAgentFallbackModelConfigurationGuardrails$Outbound>
    | undefined;
  fallbacks?:
    | Array<RunAgentFallbackModelConfigurationFallbacks$Outbound>
    | undefined;
  retry?: RunAgentFallbackModelConfigurationRetry$Outbound | undefined;
  cache?: RunAgentFallbackModelConfigurationCache$Outbound | undefined;
  load_balancer?: RunAgentLoadBalancerAgents1$Outbound | undefined;
  timeout?: RunAgentFallbackModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationParameters
  > = z.object({
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => RunAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => RunAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => RunAgentResponseFormatAgentsJSONObject$outboundSchema),
      z.lazy(() =>
        RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort:
      RunAgentFallbackModelConfigurationReasoningEffort$outboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        RunAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => RunAgentToolChoiceAgents2$outboundSchema),
      RunAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(RunAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() => RunAgentFallbackModelConfigurationGuardrails$outboundSchema),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() => RunAgentFallbackModelConfigurationFallbacks$outboundSchema),
    ).optional(),
    retry: z.lazy(() => RunAgentFallbackModelConfigurationRetry$outboundSchema)
      .optional(),
    cache: z.lazy(() => RunAgentFallbackModelConfigurationCache$outboundSchema)
      .optional(),
    loadBalancer: z.lazy(() => RunAgentLoadBalancerAgents1$outboundSchema)
      .optional(),
    timeout: z.lazy(() =>
      RunAgentFallbackModelConfigurationTimeout$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
      loadBalancer: "load_balancer",
    });
  });

export function runAgentFallbackModelConfigurationParametersToJSON(
  runAgentFallbackModelConfigurationParameters:
    RunAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      runAgentFallbackModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationAgentsRetry$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationAgentsRetry$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationAgentsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function runAgentFallbackModelConfigurationAgentsRetryToJSON(
  runAgentFallbackModelConfigurationAgentsRetry:
    RunAgentFallbackModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationAgentsRetry$outboundSchema.parse(
      runAgentFallbackModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | RunAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
  retry?: RunAgentFallbackModelConfigurationAgentsRetry$Outbound | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    RunAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
  retry: z.lazy(() =>
    RunAgentFallbackModelConfigurationAgentsRetry$outboundSchema
  ).optional(),
});

export function runAgentFallbackModelConfiguration2ToJSON(
  runAgentFallbackModelConfiguration2: RunAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfiguration2$outboundSchema.parse(
      runAgentFallbackModelConfiguration2,
    ),
  );
}

/** @internal */
export type RunAgentFallbackModelConfiguration$Outbound =
  | RunAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const RunAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => RunAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function runAgentFallbackModelConfigurationToJSON(
  runAgentFallbackModelConfiguration: RunAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfiguration$outboundSchema.parse(
      runAgentFallbackModelConfiguration,
    ),
  );
}

/** @internal */
export const RunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleToolMessage
> = z.nativeEnum(RunAgentRoleToolMessage);

/** @internal */
export const RunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleUserMessage
> = z.nativeEnum(RunAgentRoleUserMessage);

/** @internal */
export type RunAgentRole$Outbound = string | string;

/** @internal */
export const RunAgentRole$outboundSchema: z.ZodType<
  RunAgentRole$Outbound,
  z.ZodTypeDef,
  RunAgentRole
> = z.union([
  RunAgentRoleUserMessage$outboundSchema,
  RunAgentRoleToolMessage$outboundSchema,
]);

export function runAgentRoleToJSON(runAgentRole: RunAgentRole): string {
  return JSON.stringify(RunAgentRole$outboundSchema.parse(runAgentRole));
}

/** @internal */
export type RunAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound
  | components.ErrorPart$Outbound;

/** @internal */
export const RunAgentPublicMessagePart$outboundSchema: z.ZodType<
  RunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  RunAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
  components.ErrorPart$outboundSchema,
]);

export function runAgentPublicMessagePartToJSON(
  runAgentPublicMessagePart: RunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    RunAgentPublicMessagePart$outboundSchema.parse(runAgentPublicMessagePart),
  );
}

/** @internal */
export type RunAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
    | components.ErrorPart$Outbound
  >;
};

/** @internal */
export const RunAgentA2AMessage$outboundSchema: z.ZodType<
  RunAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  RunAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RunAgentRoleUserMessage$outboundSchema,
    RunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
      components.ErrorPart$outboundSchema,
    ]),
  ),
});

export function runAgentA2AMessageToJSON(
  runAgentA2AMessage: RunAgentA2AMessage,
): string {
  return JSON.stringify(
    RunAgentA2AMessage$outboundSchema.parse(runAgentA2AMessage),
  );
}

/** @internal */
export type RunAgentIdentity$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentIdentity$outboundSchema: z.ZodType<
  RunAgentIdentity$Outbound,
  z.ZodTypeDef,
  RunAgentIdentity
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function runAgentIdentityToJSON(
  runAgentIdentity: RunAgentIdentity,
): string {
  return JSON.stringify(
    RunAgentIdentity$outboundSchema.parse(runAgentIdentity),
  );
}

/** @internal */
export type RunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentContact$outboundSchema: z.ZodType<
  RunAgentContact$Outbound,
  z.ZodTypeDef,
  RunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function runAgentContactToJSON(
  runAgentContact: RunAgentContact,
): string {
  return JSON.stringify(RunAgentContact$outboundSchema.parse(runAgentContact));
}

/** @internal */
export type RunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentThread$outboundSchema: z.ZodType<
  RunAgentThread$Outbound,
  z.ZodTypeDef,
  RunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function runAgentThreadToJSON(runAgentThread: RunAgentThread): string {
  return JSON.stringify(RunAgentThread$outboundSchema.parse(runAgentThread));
}

/** @internal */
export type RunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const RunAgentMemory$outboundSchema: z.ZodType<
  RunAgentMemory$Outbound,
  z.ZodTypeDef,
  RunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function runAgentMemoryToJSON(runAgentMemory: RunAgentMemory): string {
  return JSON.stringify(RunAgentMemory$outboundSchema.parse(runAgentMemory));
}

/** @internal */
export type RunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const RunAgentKnowledgeBases$outboundSchema: z.ZodType<
  RunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  RunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function runAgentKnowledgeBasesToJSON(
  runAgentKnowledgeBases: RunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    RunAgentKnowledgeBases$outboundSchema.parse(runAgentKnowledgeBases),
  );
}

/** @internal */
export type RunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const RunAgentTeamOfAgents$outboundSchema: z.ZodType<
  RunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  RunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function runAgentTeamOfAgentsToJSON(
  runAgentTeamOfAgents: RunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    RunAgentTeamOfAgents$outboundSchema.parse(runAgentTeamOfAgents),
  );
}

/** @internal */
export type AgentToolInputRunHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const AgentToolInputRunHeaders$outboundSchema: z.ZodType<
  AgentToolInputRunHeaders$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function agentToolInputRunHeadersToJSON(
  agentToolInputRunHeaders: AgentToolInputRunHeaders,
): string {
  return JSON.stringify(
    AgentToolInputRunHeaders$outboundSchema.parse(agentToolInputRunHeaders),
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType,
  );

/** @internal */
export type AgentToolInputRunSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const AgentToolInputRunSchema$outboundSchema: z.ZodType<
  AgentToolInputRunSchema$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunSchema
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function agentToolInputRunSchemaToJSON(
  agentToolInputRunSchema: AgentToolInputRunSchema,
): string {
  return JSON.stringify(
    AgentToolInputRunSchema$outboundSchema.parse(agentToolInputRunSchema),
  );
}

/** @internal */
export type Tools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: AgentToolInputRunSchema$Outbound;
};

/** @internal */
export const Tools$outboundSchema: z.ZodType<
  Tools$Outbound,
  z.ZodTypeDef,
  Tools
> = z.object({
  id: z.string().default("01KG4YQBAHVNTP6MZY77YBZ7AH"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => AgentToolInputRunSchema$outboundSchema),
});

export function toolsToJSON(tools: Tools): string {
  return JSON.stringify(Tools$outboundSchema.parse(tools));
}

/** @internal */
export const ConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = z.nativeEnum(ConnectionType);

/** @internal */
export type Mcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: AgentToolInputRunHeaders$Outbound } | undefined;
  tools: Array<Tools$Outbound>;
  connection_type: string;
};

/** @internal */
export const Mcp$outboundSchema: z.ZodType<Mcp$Outbound, z.ZodTypeDef, Mcp> = z
  .object({
    serverUrl: z.string(),
    headers: z.record(z.lazy(() => AgentToolInputRunHeaders$outboundSchema))
      .optional(),
    tools: z.array(z.lazy(() => Tools$outboundSchema)),
    connectionType: ConnectionType$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      serverUrl: "server_url",
      connectionType: "connection_type",
    });
  });

export function mcpToJSON(mcp: Mcp): string {
  return JSON.stringify(Mcp$outboundSchema.parse(mcp));
}

/** @internal */
export type MCPToolRun$Outbound = {
  type: "mcp";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  mcp: Mcp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const MCPToolRun$outboundSchema: z.ZodType<
  MCPToolRun$Outbound,
  z.ZodTypeDef,
  MCPToolRun
> = z.object({
  type: z.literal("mcp"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => Mcp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function mcpToolRunToJSON(mcpToolRun: MCPToolRun): string {
  return JSON.stringify(MCPToolRun$outboundSchema.parse(mcpToolRun));
}

/** @internal */
export type Schema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const Schema$outboundSchema: z.ZodType<
  Schema$Outbound,
  z.ZodTypeDef,
  Schema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(Schema$outboundSchema.parse(schema));
}

/** @internal */
export type AgentToolInputRunJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: Schema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunJsonSchema$outboundSchema: z.ZodType<
  AgentToolInputRunJsonSchema$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => Schema$outboundSchema),
  strict: z.boolean().optional(),
});

export function agentToolInputRunJsonSchemaToJSON(
  agentToolInputRunJsonSchema: AgentToolInputRunJsonSchema,
): string {
  return JSON.stringify(
    AgentToolInputRunJsonSchema$outboundSchema.parse(
      agentToolInputRunJsonSchema,
    ),
  );
}

/** @internal */
export type JSONSchemaToolRun$Outbound = {
  type: "json_schema";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  json_schema: AgentToolInputRunJsonSchema$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const JSONSchemaToolRun$outboundSchema: z.ZodType<
  JSONSchemaToolRun$Outbound,
  z.ZodTypeDef,
  JSONSchemaToolRun
> = z.object({
  type: z.literal("json_schema"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  jsonSchema: z.lazy(() => AgentToolInputRunJsonSchema$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    jsonSchema: "json_schema",
    requiresApproval: "requires_approval",
  });
});

export function jsonSchemaToolRunToJSON(
  jsonSchemaToolRun: JSONSchemaToolRun,
): string {
  return JSON.stringify(
    JSONSchemaToolRun$outboundSchema.parse(jsonSchemaToolRun),
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType,
  );

/** @internal */
export type RunAgentAgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RunAgentAgentToolInputRunParameters$outboundSchema: z.ZodType<
  RunAgentAgentToolInputRunParameters$Outbound,
  z.ZodTypeDef,
  RunAgentAgentToolInputRunParameters
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function runAgentAgentToolInputRunParametersToJSON(
  runAgentAgentToolInputRunParameters: RunAgentAgentToolInputRunParameters,
): string {
  return JSON.stringify(
    RunAgentAgentToolInputRunParameters$outboundSchema.parse(
      runAgentAgentToolInputRunParameters,
    ),
  );
}

/** @internal */
export type AgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: RunAgentAgentToolInputRunParameters$Outbound | undefined;
};

/** @internal */
export const AgentToolInputRunFunction$outboundSchema: z.ZodType<
  AgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RunAgentAgentToolInputRunParameters$outboundSchema)
    .optional(),
});

export function agentToolInputRunFunctionToJSON(
  agentToolInputRunFunction: AgentToolInputRunFunction,
): string {
  return JSON.stringify(
    AgentToolInputRunFunction$outboundSchema.parse(agentToolInputRunFunction),
  );
}

/** @internal */
export type FunctionToolRun$Outbound = {
  type: "function";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: AgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const FunctionToolRun$outboundSchema: z.ZodType<
  FunctionToolRun$Outbound,
  z.ZodTypeDef,
  FunctionToolRun
> = z.object({
  type: z.literal("function"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => AgentToolInputRunFunction$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function functionToolRunToJSON(
  functionToolRun: FunctionToolRun,
): string {
  return JSON.stringify(FunctionToolRun$outboundSchema.parse(functionToolRun));
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType,
  );

/** @internal */
export type AgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const AgentToolInputRunParameters$outboundSchema: z.ZodType<
  AgentToolInputRunParameters$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunParameters
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function agentToolInputRunParametersToJSON(
  agentToolInputRunParameters: AgentToolInputRunParameters,
): string {
  return JSON.stringify(
    AgentToolInputRunParameters$outboundSchema.parse(
      agentToolInputRunParameters,
    ),
  );
}

/** @internal */
export const Language$outboundSchema: z.ZodNativeEnum<typeof Language> = z
  .nativeEnum(Language);

/** @internal */
export type CodeTool$Outbound = {
  parameters?: AgentToolInputRunParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const CodeTool$outboundSchema: z.ZodType<
  CodeTool$Outbound,
  z.ZodTypeDef,
  CodeTool
> = z.object({
  parameters: z.lazy(() => AgentToolInputRunParameters$outboundSchema)
    .optional(),
  language: Language$outboundSchema,
  code: z.string(),
});

export function codeToolToJSON(codeTool: CodeTool): string {
  return JSON.stringify(CodeTool$outboundSchema.parse(codeTool));
}

/** @internal */
export type CodeToolRun$Outbound = {
  type: "code";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: CodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const CodeToolRun$outboundSchema: z.ZodType<
  CodeToolRun$Outbound,
  z.ZodTypeDef,
  CodeToolRun
> = z.object({
  type: z.literal("code"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => CodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function codeToolRunToJSON(codeToolRun: CodeToolRun): string {
  return JSON.stringify(CodeToolRun$outboundSchema.parse(codeToolRun));
}

/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);

/** @internal */
export type Headers2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const Headers2$outboundSchema: z.ZodType<
  Headers2$Outbound,
  z.ZodTypeDef,
  Headers2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function headers2ToJSON(headers2: Headers2): string {
  return JSON.stringify(Headers2$outboundSchema.parse(headers2));
}

/** @internal */
export type Headers$Outbound = Headers2$Outbound | string;

/** @internal */
export const Headers$outboundSchema: z.ZodType<
  Headers$Outbound,
  z.ZodTypeDef,
  Headers
> = z.union([z.lazy(() => Headers2$outboundSchema), z.string()]);

export function headersToJSON(headers: Headers): string {
  return JSON.stringify(Headers$outboundSchema.parse(headers));
}

/** @internal */
export type Blueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: Headers2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const Blueprint$outboundSchema: z.ZodType<
  Blueprint$Outbound,
  z.ZodTypeDef,
  Blueprint
> = z.object({
  url: z.string(),
  method: Method$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => Headers2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function blueprintToJSON(blueprint: Blueprint): string {
  return JSON.stringify(Blueprint$outboundSchema.parse(blueprint));
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );

/** @internal */
export type DefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}

/** @internal */
export type Arguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const Arguments$outboundSchema: z.ZodType<
  Arguments$Outbound,
  z.ZodTypeDef,
  Arguments
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function argumentsToJSON(value: Arguments): string {
  return JSON.stringify(Arguments$outboundSchema.parse(value));
}

/** @internal */
export type Http$Outbound = {
  blueprint: Blueprint$Outbound;
  arguments?: { [k: string]: Arguments$Outbound } | undefined;
};

/** @internal */
export const Http$outboundSchema: z.ZodType<Http$Outbound, z.ZodTypeDef, Http> =
  z.object({
    blueprint: z.lazy(() => Blueprint$outboundSchema),
    arguments: z.record(z.lazy(() => Arguments$outboundSchema)).optional(),
  });

export function httpToJSON(http: Http): string {
  return JSON.stringify(Http$outboundSchema.parse(http));
}

/** @internal */
export type HTTPToolRun$Outbound = {
  type: "http";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: Http$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const HTTPToolRun$outboundSchema: z.ZodType<
  HTTPToolRun$Outbound,
  z.ZodTypeDef,
  HTTPToolRun
> = z.object({
  type: z.literal("http"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => Http$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function httpToolRunToJSON(httpToolRun: HTTPToolRun): string {
  return JSON.stringify(HTTPToolRun$outboundSchema.parse(httpToolRun));
}

/** @internal */
export type AgentToolInputRunCurrentDateTool$Outbound = {
  type: "current_date";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunCurrentDateTool$outboundSchema: z.ZodType<
  AgentToolInputRunCurrentDateTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCurrentDateTool
> = z.object({
  type: z.literal("current_date"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCurrentDateToolToJSON(
  agentToolInputRunCurrentDateTool: AgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCurrentDateTool$outboundSchema.parse(
      agentToolInputRunCurrentDateTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: "query_knowledge_base";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  AgentToolInputRunQueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunQueryKnowledgeBaseTool
> = z.object({
  type: z.literal("query_knowledge_base"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunQueryKnowledgeBaseToolToJSON(
  agentToolInputRunQueryKnowledgeBaseTool:
    AgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      agentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound = {
  type: "retrieve_knowledge_bases";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  agentToolInputRunRetrieveKnowledgeBasesTool:
    AgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema.parse(
      agentToolInputRunRetrieveKnowledgeBasesTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: "delete_memory_document";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type: z.literal("delete_memory_document"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunDeleteMemoryDocumentToolToJSON(
  agentToolInputRunDeleteMemoryDocumentTool:
    AgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema.parse(
      agentToolInputRunDeleteMemoryDocumentTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: "retrieve_memory_stores";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type: z.literal("retrieve_memory_stores"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunRetrieveMemoryStoresToolToJSON(
  agentToolInputRunRetrieveMemoryStoresTool:
    AgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema.parse(
      agentToolInputRunRetrieveMemoryStoresTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: "write_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunWriteMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputRunWriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunWriteMemoryStoreTool
> = z.object({
  type: z.literal("write_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunWriteMemoryStoreToolToJSON(
  agentToolInputRunWriteMemoryStoreTool: AgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      agentToolInputRunWriteMemoryStoreTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: "query_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunQueryMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputRunQueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunQueryMemoryStoreTool
> = z.object({
  type: z.literal("query_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunQueryMemoryStoreToolToJSON(
  agentToolInputRunQueryMemoryStoreTool: AgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      agentToolInputRunQueryMemoryStoreTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: "retrieve_agents";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveAgentsTool$outboundSchema: z.ZodType<
  AgentToolInputRunRetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunRetrieveAgentsTool
> = z.object({
  type: z.literal("retrieve_agents"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunRetrieveAgentsToolToJSON(
  agentToolInputRunRetrieveAgentsTool: AgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      agentToolInputRunRetrieveAgentsTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunCallSubAgentTool$Outbound = {
  type: "call_sub_agent";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunCallSubAgentTool$outboundSchema: z.ZodType<
  AgentToolInputRunCallSubAgentTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCallSubAgentTool
> = z.object({
  type: z.literal("call_sub_agent"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCallSubAgentToolToJSON(
  agentToolInputRunCallSubAgentTool: AgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      agentToolInputRunCallSubAgentTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunWebScraperTool$Outbound = {
  type: "web_scraper";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunWebScraperTool$outboundSchema: z.ZodType<
  AgentToolInputRunWebScraperTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunWebScraperTool
> = z.object({
  type: z.literal("web_scraper"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunWebScraperToolToJSON(
  agentToolInputRunWebScraperTool: AgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    AgentToolInputRunWebScraperTool$outboundSchema.parse(
      agentToolInputRunWebScraperTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRunGoogleSearchTool$Outbound = {
  type: "google_search";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunGoogleSearchTool$outboundSchema: z.ZodType<
  AgentToolInputRunGoogleSearchTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunGoogleSearchTool
> = z.object({
  type: z.literal("google_search"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunGoogleSearchToolToJSON(
  agentToolInputRunGoogleSearchTool: AgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    AgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      agentToolInputRunGoogleSearchTool,
    ),
  );
}

/** @internal */
export type AgentToolInputRun$Outbound =
  | AgentToolInputRunGoogleSearchTool$Outbound
  | AgentToolInputRunWebScraperTool$Outbound
  | AgentToolInputRunCallSubAgentTool$Outbound
  | AgentToolInputRunRetrieveAgentsTool$Outbound
  | AgentToolInputRunQueryMemoryStoreTool$Outbound
  | AgentToolInputRunWriteMemoryStoreTool$Outbound
  | AgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | AgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | AgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | AgentToolInputRunCurrentDateTool$Outbound
  | HTTPToolRun$Outbound
  | CodeToolRun$Outbound
  | FunctionToolRun$Outbound
  | JSONSchemaToolRun$Outbound
  | MCPToolRun$Outbound;

/** @internal */
export const AgentToolInputRun$outboundSchema: z.ZodType<
  AgentToolInputRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRun
> = z.union([
  z.lazy(() => AgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => AgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => AgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveAgentsTool$outboundSchema),
  z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => AgentToolInputRunCurrentDateTool$outboundSchema),
  z.lazy(() => HTTPToolRun$outboundSchema),
  z.lazy(() => CodeToolRun$outboundSchema),
  z.lazy(() => FunctionToolRun$outboundSchema),
  z.lazy(() => JSONSchemaToolRun$outboundSchema),
  z.lazy(() => MCPToolRun$outboundSchema),
]);

export function agentToolInputRunToJSON(
  agentToolInputRun: AgentToolInputRun,
): string {
  return JSON.stringify(
    AgentToolInputRun$outboundSchema.parse(agentToolInputRun),
  );
}

/** @internal */
export const RunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolApprovalRequired
> = z.nativeEnum(RunAgentToolApprovalRequired);

/** @internal */
export const RunAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentExecuteOn
> = z.nativeEnum(RunAgentExecuteOn);

/** @internal */
export type RunAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RunAgentEvaluators$outboundSchema: z.ZodType<
  RunAgentEvaluators$Outbound,
  z.ZodTypeDef,
  RunAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RunAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function runAgentEvaluatorsToJSON(
  runAgentEvaluators: RunAgentEvaluators,
): string {
  return JSON.stringify(
    RunAgentEvaluators$outboundSchema.parse(runAgentEvaluators),
  );
}

/** @internal */
export const RunAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsExecuteOn
> = z.nativeEnum(RunAgentAgentsExecuteOn);

/** @internal */
export type RunAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RunAgentGuardrails$outboundSchema: z.ZodType<
  RunAgentGuardrails$Outbound,
  z.ZodTypeDef,
  RunAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RunAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function runAgentGuardrailsToJSON(
  runAgentGuardrails: RunAgentGuardrails,
): string {
  return JSON.stringify(
    RunAgentGuardrails$outboundSchema.parse(runAgentGuardrails),
  );
}

/** @internal */
export type RunAgentSettings$Outbound = {
  tools?:
    | Array<
      | AgentToolInputRunGoogleSearchTool$Outbound
      | AgentToolInputRunWebScraperTool$Outbound
      | AgentToolInputRunCallSubAgentTool$Outbound
      | AgentToolInputRunRetrieveAgentsTool$Outbound
      | AgentToolInputRunQueryMemoryStoreTool$Outbound
      | AgentToolInputRunWriteMemoryStoreTool$Outbound
      | AgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | AgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | AgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | AgentToolInputRunCurrentDateTool$Outbound
      | HTTPToolRun$Outbound
      | CodeToolRun$Outbound
      | FunctionToolRun$Outbound
      | JSONSchemaToolRun$Outbound
      | MCPToolRun$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
  evaluators?: Array<RunAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<RunAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const RunAgentSettings$outboundSchema: z.ZodType<
  RunAgentSettings$Outbound,
  z.ZodTypeDef,
  RunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputRunGoogleSearchTool$outboundSchema),
      z.lazy(() => AgentToolInputRunWebScraperTool$outboundSchema),
      z.lazy(() => AgentToolInputRunCallSubAgentTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveAgentsTool$outboundSchema),
      z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => AgentToolInputRunCurrentDateTool$outboundSchema),
      z.lazy(() => HTTPToolRun$outboundSchema),
      z.lazy(() => CodeToolRun$outboundSchema),
      z.lazy(() => FunctionToolRun$outboundSchema),
      z.lazy(() => JSONSchemaToolRun$outboundSchema),
      z.lazy(() => MCPToolRun$outboundSchema),
    ]),
  ).optional(),
  toolApprovalRequired: RunAgentToolApprovalRequired$outboundSchema.default(
    "none",
  ),
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  evaluators: z.array(z.lazy(() => RunAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => RunAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

export function runAgentSettingsToJSON(
  runAgentSettings: RunAgentSettings,
): string {
  return JSON.stringify(
    RunAgentSettings$outboundSchema.parse(runAgentSettings),
  );
}

/** @internal */
export type RunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: RunAgentModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<RunAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: RunAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  identity?: RunAgentIdentity$Outbound | undefined;
  contact?: RunAgentContact$Outbound | undefined;
  thread?: RunAgentThread$Outbound | undefined;
  memory?: RunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<RunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<RunAgentTeamOfAgents$Outbound> | undefined;
  settings: RunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentRequestBody$outboundSchema: z.ZodType<
  RunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  RunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => RunAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => RunAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => RunAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => RunAgentIdentity$outboundSchema).optional(),
  contact: z.lazy(() => RunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => RunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => RunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => RunAgentKnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => RunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => RunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function runAgentRequestBodyToJSON(
  runAgentRequestBody: RunAgentRequestBody,
): string {
  return JSON.stringify(
    RunAgentRequestBody$outboundSchema.parse(runAgentRequestBody),
  );
}

/** @internal */
export const RunAgentKind$inboundSchema: z.ZodNativeEnum<typeof RunAgentKind> =
  z.nativeEnum(RunAgentKind);

/** @internal */
export const RunAgentTaskState$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentTaskState
> = z.nativeEnum(RunAgentTaskState);

/** @internal */
export const RunAgentAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsKind
> = z.nativeEnum(RunAgentAgentsKind);

/** @internal */
export const RunAgentExtendedMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentExtendedMessageRole
> = z.nativeEnum(RunAgentExtendedMessageRole);

/** @internal */
export const RunAgentParts$inboundSchema: z.ZodType<
  RunAgentParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.ErrorPart$inboundSchema,
  components.DataPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolCallPart$inboundSchema,
  components.ToolResultPart$inboundSchema,
]);

export function runAgentPartsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts' from JSON`,
  );
}

/** @internal */
export const RunAgentTaskStatusMessage$inboundSchema: z.ZodType<
  RunAgentTaskStatusMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentAgentsKind$inboundSchema,
  messageId: z.string(),
  role: RunAgentExtendedMessageRole$inboundSchema,
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.ErrorPart$inboundSchema,
      components.DataPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolCallPart$inboundSchema,
      components.ToolResultPart$inboundSchema,
    ]),
  ),
});

export function runAgentTaskStatusMessageFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentTaskStatusMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentTaskStatusMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentTaskStatusMessage' from JSON`,
  );
}

/** @internal */
export const RunAgentTaskStatus$inboundSchema: z.ZodType<
  RunAgentTaskStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: RunAgentTaskState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => RunAgentTaskStatusMessage$inboundSchema).optional(),
});

export function runAgentTaskStatusFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentTaskStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentTaskStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentTaskStatus' from JSON`,
  );
}

/** @internal */
export const RunAgentA2ATaskResponse$inboundSchema: z.ZodType<
  RunAgentA2ATaskResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: RunAgentKind$inboundSchema,
  status: z.lazy(() => RunAgentTaskStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});

export function runAgentA2ATaskResponseFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentA2ATaskResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentA2ATaskResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentA2ATaskResponse' from JSON`,
  );
}
