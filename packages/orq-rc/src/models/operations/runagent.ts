/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const Role2 = {
  Tool: "tool",
} as const;
export type Role2 = ClosedEnum<typeof Role2>;

export const Role1 = {
  User: "user",
} as const;
export type Role1 = ClosedEnum<typeof Role1>;

/**
 * Message role (user or tool for continuing executions)
 */
export type RunAgentRole = Role1 | Role2;

export const RunAgentPartsAgentsRequestKind = {
  ToolResult: "tool_result",
} as const;
export type RunAgentPartsAgentsRequestKind = ClosedEnum<
  typeof RunAgentPartsAgentsRequestKind
>;

export type Five = {
  kind: RunAgentPartsAgentsRequestKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsAgentsKind = {
  ToolCall: "tool_call",
} as const;
export type RunAgentPartsAgentsKind = ClosedEnum<
  typeof RunAgentPartsAgentsKind
>;

export type Parts4 = {
  kind: RunAgentPartsAgentsKind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsKind = {
  File: "file",
} as const;
export type RunAgentPartsKind = ClosedEnum<typeof RunAgentPartsKind>;

export type File2 = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type File1 = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type PartsFile = File1 | File2;

export type Parts3 = {
  kind: RunAgentPartsKind;
  file: File1 | File2;
  metadata?: { [k: string]: any } | undefined;
};

export const PartsKind = {
  Data: "data",
} as const;
export type PartsKind = ClosedEnum<typeof PartsKind>;

export type Parts2 = {
  kind: PartsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const Kind = {
  Text: "text",
} as const;
export type Kind = ClosedEnum<typeof Kind>;

export type Parts1 = {
  kind: Kind;
  text: string;
};

export type Parts = Parts4 | Parts1 | Parts2 | Parts3 | Five;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type Message = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: Role1 | Role2;
  /**
   * A2A message parts
   */
  parts: Array<Parts4 | Parts1 | Parts2 | Parts3 | Five>;
  /**
   * Optional message metadata
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type Contact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type RunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type Memory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export const RunAgentConfigurationType = {
  Query: "query",
} as const;
export type RunAgentConfigurationType = ClosedEnum<
  typeof RunAgentConfigurationType
>;

export type Configuration2 = {
  type: RunAgentConfigurationType;
  query: string;
};

export const ConfigurationType = {
  LastUserMessage: "last_user_message",
} as const;
export type ConfigurationType = ClosedEnum<typeof ConfigurationType>;

export type Configuration1 = {
  type: ConfigurationType;
};

/**
 * Defines the configuration settings which can either be for a user message or a text entry.
 */
export type Configuration = Configuration2 | Configuration1;

export type KnowledgeBases = {
  /**
   * Defines the configuration settings which can either be for a user message or a text entry.
   */
  configuration: Configuration2 | Configuration1;
};

export type TeamOfAgents = {
  id: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type Status = ClosedEnum<typeof Status>;

export const ToolsType = {
  Http: "http",
} as const;
export type ToolsType = ClosedEnum<typeof ToolsType>;

/**
 * The HTTP method to use.
 */
export const Method = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type Method = ClosedEnum<typeof Method>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type Blueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: Method;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const RunAgentToolsType = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type RunAgentToolsType = ClosedEnum<typeof RunAgentToolsType>;

/**
 * The default value of the argument.
 */
export type DefaultValue = string | number | boolean;

export type Arguments = {
  /**
   * The type of the argument.
   */
  type: RunAgentToolsType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type Http = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: Blueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: Arguments } | undefined;
};

/**
 * Makes HTTP requests to external APIs
 */
export type TwentyFour = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: Status | undefined;
  versionHash?: string | undefined;
  type: ToolsType;
  http: Http;
  requiresApproval?: boolean | undefined;
};

/**
 * Available tools for agent execution. Each tool provides specific capabilities to interact with external systems, retrieve information, or perform specialized tasks.
 */
export type Tools =
  | (components.HttpTool & { type: "http" })
  | (components.CodeExecutionTool & { type: "code" })
  | (components.FunctionTool & { type: "function" })
  | (components.GoogleSearchTool & { type: "google_search" })
  | (components.WebScraperTool & { type: "web_scraper" })
  | (components.CallSubAgentTool & { type: "call_sub_agent" })
  | (components.RetrieveAgentsTool & { type: "retrieve_agents" })
  | (components.QueryMemoryStoreTool & { type: "query_memory_store" })
  | (components.WriteMemoryStoreTool & { type: "write_memory_store" })
  | (components.RetrieveMemoryStoresTool & { type: "retrieve_memory_stores" })
  | (components.RetrieveKnowledgeBasesTool & {
    type: "retrieve_knowledge_bases";
  })
  | (components.QueryKnowledgeBaseTool & { type: "query_knowledge_base" })
  | (components.CurrentDateTool & { type: "current_date" });

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const ToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type ToolApprovalRequired = ClosedEnum<typeof ToolApprovalRequired>;

export type Settings = {
  tools: Array<
    | (components.HttpTool & { type: "http" })
    | (components.CodeExecutionTool & { type: "code" })
    | (components.FunctionTool & { type: "function" })
    | (components.GoogleSearchTool & { type: "google_search" })
    | (components.WebScraperTool & { type: "web_scraper" })
    | (components.CallSubAgentTool & { type: "call_sub_agent" })
    | (components.RetrieveAgentsTool & { type: "retrieve_agents" })
    | (components.QueryMemoryStoreTool & { type: "query_memory_store" })
    | (components.WriteMemoryStoreTool & { type: "write_memory_store" })
    | (components.RetrieveMemoryStoresTool & { type: "retrieve_memory_stores" })
    | (components.RetrieveKnowledgeBasesTool & {
      type: "retrieve_knowledge_bases";
    })
    | (components.QueryKnowledgeBaseTool & { type: "query_knowledge_base" })
    | (components.CurrentDateTool & { type: "current_date" })
  >;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: ToolApprovalRequired | undefined;
  /**
   * Maximum iterations before the agent must provide its best answer.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for task execution.
   */
  maxExecutionTime?: number | undefined;
};

export type RunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The language model that powers the agent. The model must support tool calling capabilities.
   */
  model: string;
  /**
   * Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities.
   */
  fallbackModels?: Array<string> | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: Message;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: Contact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: RunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: Memory | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  memoryStores?: Array<string> | undefined;
  knowledgeBases?: Array<KnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<TeamOfAgents> | undefined;
  settings: Settings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * A2A entity type
 */
export const RunAgentKind = {
  Task: "task",
} as const;
/**
 * A2A entity type
 */
export type RunAgentKind = ClosedEnum<typeof RunAgentKind>;

/**
 * Current task state
 */
export const RunAgentState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
  AuthRequired: "auth-required",
  Unknown: "unknown",
} as const;
/**
 * Current task state
 */
export type RunAgentState = ClosedEnum<typeof RunAgentState>;

export const RunAgentAgentsKind = {
  Message: "message",
} as const;
export type RunAgentAgentsKind = ClosedEnum<typeof RunAgentAgentsKind>;

/**
 * Extended A2A message role
 */
export const RunAgentAgentsRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type RunAgentAgentsRole = ClosedEnum<typeof RunAgentAgentsRole>;

/**
 * Optional status message
 */
export type RunAgentMessage = {
  kind: RunAgentAgentsKind;
  messageId: string;
  /**
   * Extended A2A message role
   */
  role: RunAgentAgentsRole;
  parts: Array<any>;
};

/**
 * Task status information
 */
export type RunAgentStatus = {
  /**
   * Current task state
   */
  state: RunAgentState;
  /**
   * ISO timestamp of status update
   */
  timestamp?: string | undefined;
  /**
   * Optional status message
   */
  message?: RunAgentMessage | undefined;
};

/**
 * A2A Task response format
 */
export type RunAgentResponseBody = {
  /**
   * The ID of the created agent execution task
   */
  id: string;
  /**
   * The context ID (workspace ID)
   */
  contextId: string;
  /**
   * A2A entity type
   */
  kind: RunAgentKind;
  /**
   * Task status information
   */
  status: RunAgentStatus;
  /**
   * Task metadata
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Role2$inboundSchema: z.ZodNativeEnum<typeof Role2> = z.nativeEnum(
  Role2,
);

/** @internal */
export const Role2$outboundSchema: z.ZodNativeEnum<typeof Role2> =
  Role2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Role2$ {
  /** @deprecated use `Role2$inboundSchema` instead. */
  export const inboundSchema = Role2$inboundSchema;
  /** @deprecated use `Role2$outboundSchema` instead. */
  export const outboundSchema = Role2$outboundSchema;
}

/** @internal */
export const Role1$inboundSchema: z.ZodNativeEnum<typeof Role1> = z.nativeEnum(
  Role1,
);

/** @internal */
export const Role1$outboundSchema: z.ZodNativeEnum<typeof Role1> =
  Role1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Role1$ {
  /** @deprecated use `Role1$inboundSchema` instead. */
  export const inboundSchema = Role1$inboundSchema;
  /** @deprecated use `Role1$outboundSchema` instead. */
  export const outboundSchema = Role1$outboundSchema;
}

/** @internal */
export const RunAgentRole$inboundSchema: z.ZodType<
  RunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([Role1$inboundSchema, Role2$inboundSchema]);

/** @internal */
export type RunAgentRole$Outbound = string | string;

/** @internal */
export const RunAgentRole$outboundSchema: z.ZodType<
  RunAgentRole$Outbound,
  z.ZodTypeDef,
  RunAgentRole
> = z.union([Role1$outboundSchema, Role2$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentRole$ {
  /** @deprecated use `RunAgentRole$inboundSchema` instead. */
  export const inboundSchema = RunAgentRole$inboundSchema;
  /** @deprecated use `RunAgentRole$outboundSchema` instead. */
  export const outboundSchema = RunAgentRole$outboundSchema;
  /** @deprecated use `RunAgentRole$Outbound` instead. */
  export type Outbound = RunAgentRole$Outbound;
}

export function runAgentRoleToJSON(runAgentRole: RunAgentRole): string {
  return JSON.stringify(RunAgentRole$outboundSchema.parse(runAgentRole));
}

export function runAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentRole' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsAgentsRequestKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsRequestKind
> = z.nativeEnum(RunAgentPartsAgentsRequestKind);

/** @internal */
export const RunAgentPartsAgentsRequestKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsRequestKind
> = RunAgentPartsAgentsRequestKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentPartsAgentsRequestKind$ {
  /** @deprecated use `RunAgentPartsAgentsRequestKind$inboundSchema` instead. */
  export const inboundSchema = RunAgentPartsAgentsRequestKind$inboundSchema;
  /** @deprecated use `RunAgentPartsAgentsRequestKind$outboundSchema` instead. */
  export const outboundSchema = RunAgentPartsAgentsRequestKind$outboundSchema;
}

/** @internal */
export const Five$inboundSchema: z.ZodType<Five, z.ZodTypeDef, unknown> = z
  .object({
    kind: RunAgentPartsAgentsRequestKind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });

/** @internal */
export type Five$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Five$outboundSchema: z.ZodType<Five$Outbound, z.ZodTypeDef, Five> =
  z.object({
    kind: RunAgentPartsAgentsRequestKind$outboundSchema,
    toolCallId: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCallId: "tool_call_id",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Five$ {
  /** @deprecated use `Five$inboundSchema` instead. */
  export const inboundSchema = Five$inboundSchema;
  /** @deprecated use `Five$outboundSchema` instead. */
  export const outboundSchema = Five$outboundSchema;
  /** @deprecated use `Five$Outbound` instead. */
  export type Outbound = Five$Outbound;
}

export function fiveToJSON(five: Five): string {
  return JSON.stringify(Five$outboundSchema.parse(five));
}

export function fiveFromJSON(
  jsonString: string,
): SafeParseResult<Five, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Five$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Five' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsKind
> = z.nativeEnum(RunAgentPartsAgentsKind);

/** @internal */
export const RunAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsKind
> = RunAgentPartsAgentsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentPartsAgentsKind$ {
  /** @deprecated use `RunAgentPartsAgentsKind$inboundSchema` instead. */
  export const inboundSchema = RunAgentPartsAgentsKind$inboundSchema;
  /** @deprecated use `RunAgentPartsAgentsKind$outboundSchema` instead. */
  export const outboundSchema = RunAgentPartsAgentsKind$outboundSchema;
}

/** @internal */
export const Parts4$inboundSchema: z.ZodType<Parts4, z.ZodTypeDef, unknown> = z
  .object({
    kind: RunAgentPartsAgentsKind$inboundSchema,
    tool_name: z.string(),
    tool_call_id: z.string(),
    arguments: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_name": "toolName",
      "tool_call_id": "toolCallId",
    });
  });

/** @internal */
export type Parts4$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Parts4$outboundSchema: z.ZodType<
  Parts4$Outbound,
  z.ZodTypeDef,
  Parts4
> = z.object({
  kind: RunAgentPartsAgentsKind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts4$ {
  /** @deprecated use `Parts4$inboundSchema` instead. */
  export const inboundSchema = Parts4$inboundSchema;
  /** @deprecated use `Parts4$outboundSchema` instead. */
  export const outboundSchema = Parts4$outboundSchema;
  /** @deprecated use `Parts4$Outbound` instead. */
  export type Outbound = Parts4$Outbound;
}

export function parts4ToJSON(parts4: Parts4): string {
  return JSON.stringify(Parts4$outboundSchema.parse(parts4));
}

export function parts4FromJSON(
  jsonString: string,
): SafeParseResult<Parts4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts4' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsKind
> = z.nativeEnum(RunAgentPartsKind);

/** @internal */
export const RunAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsKind
> = RunAgentPartsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentPartsKind$ {
  /** @deprecated use `RunAgentPartsKind$inboundSchema` instead. */
  export const inboundSchema = RunAgentPartsKind$inboundSchema;
  /** @deprecated use `RunAgentPartsKind$outboundSchema` instead. */
  export const outboundSchema = RunAgentPartsKind$outboundSchema;
}

/** @internal */
export const File2$inboundSchema: z.ZodType<File2, z.ZodTypeDef, unknown> = z
  .object({
    uri: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

/** @internal */
export type File2$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const File2$outboundSchema: z.ZodType<
  File2$Outbound,
  z.ZodTypeDef,
  File2
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace File2$ {
  /** @deprecated use `File2$inboundSchema` instead. */
  export const inboundSchema = File2$inboundSchema;
  /** @deprecated use `File2$outboundSchema` instead. */
  export const outboundSchema = File2$outboundSchema;
  /** @deprecated use `File2$Outbound` instead. */
  export type Outbound = File2$Outbound;
}

export function file2ToJSON(file2: File2): string {
  return JSON.stringify(File2$outboundSchema.parse(file2));
}

export function file2FromJSON(
  jsonString: string,
): SafeParseResult<File2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => File2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'File2' from JSON`,
  );
}

/** @internal */
export const File1$inboundSchema: z.ZodType<File1, z.ZodTypeDef, unknown> = z
  .object({
    bytes: z.string(),
    mimeType: z.string().optional(),
    name: z.string().optional(),
  });

/** @internal */
export type File1$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const File1$outboundSchema: z.ZodType<
  File1$Outbound,
  z.ZodTypeDef,
  File1
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace File1$ {
  /** @deprecated use `File1$inboundSchema` instead. */
  export const inboundSchema = File1$inboundSchema;
  /** @deprecated use `File1$outboundSchema` instead. */
  export const outboundSchema = File1$outboundSchema;
  /** @deprecated use `File1$Outbound` instead. */
  export type Outbound = File1$Outbound;
}

export function file1ToJSON(file1: File1): string {
  return JSON.stringify(File1$outboundSchema.parse(file1));
}

export function file1FromJSON(
  jsonString: string,
): SafeParseResult<File1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => File1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'File1' from JSON`,
  );
}

/** @internal */
export const PartsFile$inboundSchema: z.ZodType<
  PartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => File1$inboundSchema),
  z.lazy(() => File2$inboundSchema),
]);

/** @internal */
export type PartsFile$Outbound = File1$Outbound | File2$Outbound;

/** @internal */
export const PartsFile$outboundSchema: z.ZodType<
  PartsFile$Outbound,
  z.ZodTypeDef,
  PartsFile
> = z.union([
  z.lazy(() => File1$outboundSchema),
  z.lazy(() => File2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PartsFile$ {
  /** @deprecated use `PartsFile$inboundSchema` instead. */
  export const inboundSchema = PartsFile$inboundSchema;
  /** @deprecated use `PartsFile$outboundSchema` instead. */
  export const outboundSchema = PartsFile$outboundSchema;
  /** @deprecated use `PartsFile$Outbound` instead. */
  export type Outbound = PartsFile$Outbound;
}

export function partsFileToJSON(partsFile: PartsFile): string {
  return JSON.stringify(PartsFile$outboundSchema.parse(partsFile));
}

export function partsFileFromJSON(
  jsonString: string,
): SafeParseResult<PartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PartsFile' from JSON`,
  );
}

/** @internal */
export const Parts3$inboundSchema: z.ZodType<Parts3, z.ZodTypeDef, unknown> = z
  .object({
    kind: RunAgentPartsKind$inboundSchema,
    file: z.union([
      z.lazy(() => File1$inboundSchema),
      z.lazy(() => File2$inboundSchema),
    ]),
    metadata: z.record(z.any()).optional(),
  });

/** @internal */
export type Parts3$Outbound = {
  kind: string;
  file: File1$Outbound | File2$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Parts3$outboundSchema: z.ZodType<
  Parts3$Outbound,
  z.ZodTypeDef,
  Parts3
> = z.object({
  kind: RunAgentPartsKind$outboundSchema,
  file: z.union([
    z.lazy(() => File1$outboundSchema),
    z.lazy(() => File2$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts3$ {
  /** @deprecated use `Parts3$inboundSchema` instead. */
  export const inboundSchema = Parts3$inboundSchema;
  /** @deprecated use `Parts3$outboundSchema` instead. */
  export const outboundSchema = Parts3$outboundSchema;
  /** @deprecated use `Parts3$Outbound` instead. */
  export type Outbound = Parts3$Outbound;
}

export function parts3ToJSON(parts3: Parts3): string {
  return JSON.stringify(Parts3$outboundSchema.parse(parts3));
}

export function parts3FromJSON(
  jsonString: string,
): SafeParseResult<Parts3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts3' from JSON`,
  );
}

/** @internal */
export const PartsKind$inboundSchema: z.ZodNativeEnum<typeof PartsKind> = z
  .nativeEnum(PartsKind);

/** @internal */
export const PartsKind$outboundSchema: z.ZodNativeEnum<typeof PartsKind> =
  PartsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PartsKind$ {
  /** @deprecated use `PartsKind$inboundSchema` instead. */
  export const inboundSchema = PartsKind$inboundSchema;
  /** @deprecated use `PartsKind$outboundSchema` instead. */
  export const outboundSchema = PartsKind$outboundSchema;
}

/** @internal */
export const Parts2$inboundSchema: z.ZodType<Parts2, z.ZodTypeDef, unknown> = z
  .object({
    kind: PartsKind$inboundSchema,
    data: z.record(z.any()),
    metadata: z.record(z.any()).optional(),
  });

/** @internal */
export type Parts2$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Parts2$outboundSchema: z.ZodType<
  Parts2$Outbound,
  z.ZodTypeDef,
  Parts2
> = z.object({
  kind: PartsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts2$ {
  /** @deprecated use `Parts2$inboundSchema` instead. */
  export const inboundSchema = Parts2$inboundSchema;
  /** @deprecated use `Parts2$outboundSchema` instead. */
  export const outboundSchema = Parts2$outboundSchema;
  /** @deprecated use `Parts2$Outbound` instead. */
  export type Outbound = Parts2$Outbound;
}

export function parts2ToJSON(parts2: Parts2): string {
  return JSON.stringify(Parts2$outboundSchema.parse(parts2));
}

export function parts2FromJSON(
  jsonString: string,
): SafeParseResult<Parts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts2' from JSON`,
  );
}

/** @internal */
export const Kind$inboundSchema: z.ZodNativeEnum<typeof Kind> = z.nativeEnum(
  Kind,
);

/** @internal */
export const Kind$outboundSchema: z.ZodNativeEnum<typeof Kind> =
  Kind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Kind$ {
  /** @deprecated use `Kind$inboundSchema` instead. */
  export const inboundSchema = Kind$inboundSchema;
  /** @deprecated use `Kind$outboundSchema` instead. */
  export const outboundSchema = Kind$outboundSchema;
}

/** @internal */
export const Parts1$inboundSchema: z.ZodType<Parts1, z.ZodTypeDef, unknown> = z
  .object({
    kind: Kind$inboundSchema,
    text: z.string(),
  });

/** @internal */
export type Parts1$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const Parts1$outboundSchema: z.ZodType<
  Parts1$Outbound,
  z.ZodTypeDef,
  Parts1
> = z.object({
  kind: Kind$outboundSchema,
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts1$ {
  /** @deprecated use `Parts1$inboundSchema` instead. */
  export const inboundSchema = Parts1$inboundSchema;
  /** @deprecated use `Parts1$outboundSchema` instead. */
  export const outboundSchema = Parts1$outboundSchema;
  /** @deprecated use `Parts1$Outbound` instead. */
  export type Outbound = Parts1$Outbound;
}

export function parts1ToJSON(parts1: Parts1): string {
  return JSON.stringify(Parts1$outboundSchema.parse(parts1));
}

export function parts1FromJSON(
  jsonString: string,
): SafeParseResult<Parts1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts1' from JSON`,
  );
}

/** @internal */
export const Parts$inboundSchema: z.ZodType<Parts, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Parts4$inboundSchema),
    z.lazy(() => Parts1$inboundSchema),
    z.lazy(() => Parts2$inboundSchema),
    z.lazy(() => Parts3$inboundSchema),
    z.lazy(() => Five$inboundSchema),
  ]);

/** @internal */
export type Parts$Outbound =
  | Parts4$Outbound
  | Parts1$Outbound
  | Parts2$Outbound
  | Parts3$Outbound
  | Five$Outbound;

/** @internal */
export const Parts$outboundSchema: z.ZodType<
  Parts$Outbound,
  z.ZodTypeDef,
  Parts
> = z.union([
  z.lazy(() => Parts4$outboundSchema),
  z.lazy(() => Parts1$outboundSchema),
  z.lazy(() => Parts2$outboundSchema),
  z.lazy(() => Parts3$outboundSchema),
  z.lazy(() => Five$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts$ {
  /** @deprecated use `Parts$inboundSchema` instead. */
  export const inboundSchema = Parts$inboundSchema;
  /** @deprecated use `Parts$outboundSchema` instead. */
  export const outboundSchema = Parts$outboundSchema;
  /** @deprecated use `Parts$Outbound` instead. */
  export type Outbound = Parts$Outbound;
}

export function partsToJSON(parts: Parts): string {
  return JSON.stringify(Parts$outboundSchema.parse(parts));
}

export function partsFromJSON(
  jsonString: string,
): SafeParseResult<Parts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts' from JSON`,
  );
}

/** @internal */
export const Message$inboundSchema: z.ZodType<Message, z.ZodTypeDef, unknown> =
  z.object({
    messageId: z.string().optional(),
    role: z.union([Role1$inboundSchema, Role2$inboundSchema]),
    parts: z.array(
      z.union([
        z.lazy(() => Parts4$inboundSchema),
        z.lazy(() => Parts1$inboundSchema),
        z.lazy(() => Parts2$inboundSchema),
        z.lazy(() => Parts3$inboundSchema),
        z.lazy(() => Five$inboundSchema),
      ]),
    ),
    metadata: z.record(z.any()).optional(),
  });

/** @internal */
export type Message$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | Parts4$Outbound
    | Parts1$Outbound
    | Parts2$Outbound
    | Parts3$Outbound
    | Five$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Message$outboundSchema: z.ZodType<
  Message$Outbound,
  z.ZodTypeDef,
  Message
> = z.object({
  messageId: z.string().optional(),
  role: z.union([Role1$outboundSchema, Role2$outboundSchema]),
  parts: z.array(
    z.union([
      z.lazy(() => Parts4$outboundSchema),
      z.lazy(() => Parts1$outboundSchema),
      z.lazy(() => Parts2$outboundSchema),
      z.lazy(() => Parts3$outboundSchema),
      z.lazy(() => Five$outboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Message$ {
  /** @deprecated use `Message$inboundSchema` instead. */
  export const inboundSchema = Message$inboundSchema;
  /** @deprecated use `Message$outboundSchema` instead. */
  export const outboundSchema = Message$outboundSchema;
  /** @deprecated use `Message$Outbound` instead. */
  export type Outbound = Message$Outbound;
}

export function messageToJSON(message: Message): string {
  return JSON.stringify(Message$outboundSchema.parse(message));
}

export function messageFromJSON(
  jsonString: string,
): SafeParseResult<Message, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Message$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Message' from JSON`,
  );
}

/** @internal */
export const Contact$inboundSchema: z.ZodType<Contact, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    display_name: z.string().optional(),
    email: z.string().optional(),
    metadata: z.array(z.record(z.any())).optional(),
    logo_url: z.string().optional(),
    tags: z.array(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
      "logo_url": "logoUrl",
    });
  });

/** @internal */
export type Contact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Contact$outboundSchema: z.ZodType<
  Contact$Outbound,
  z.ZodTypeDef,
  Contact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Contact$ {
  /** @deprecated use `Contact$inboundSchema` instead. */
  export const inboundSchema = Contact$inboundSchema;
  /** @deprecated use `Contact$outboundSchema` instead. */
  export const outboundSchema = Contact$outboundSchema;
  /** @deprecated use `Contact$Outbound` instead. */
  export type Outbound = Contact$Outbound;
}

export function contactToJSON(contact: Contact): string {
  return JSON.stringify(Contact$outboundSchema.parse(contact));
}

export function contactFromJSON(
  jsonString: string,
): SafeParseResult<Contact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contact' from JSON`,
  );
}

/** @internal */
export const RunAgentThread$inboundSchema: z.ZodType<
  RunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

/** @internal */
export type RunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentThread$outboundSchema: z.ZodType<
  RunAgentThread$Outbound,
  z.ZodTypeDef,
  RunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentThread$ {
  /** @deprecated use `RunAgentThread$inboundSchema` instead. */
  export const inboundSchema = RunAgentThread$inboundSchema;
  /** @deprecated use `RunAgentThread$outboundSchema` instead. */
  export const outboundSchema = RunAgentThread$outboundSchema;
  /** @deprecated use `RunAgentThread$Outbound` instead. */
  export type Outbound = RunAgentThread$Outbound;
}

export function runAgentThreadToJSON(runAgentThread: RunAgentThread): string {
  return JSON.stringify(RunAgentThread$outboundSchema.parse(runAgentThread));
}

export function runAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentThread' from JSON`,
  );
}

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    entity_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entity_id": "entityId",
    });
  });

/** @internal */
export type Memory$Outbound = {
  entity_id: string;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Memory$ {
  /** @deprecated use `Memory$inboundSchema` instead. */
  export const inboundSchema = Memory$inboundSchema;
  /** @deprecated use `Memory$outboundSchema` instead. */
  export const outboundSchema = Memory$outboundSchema;
  /** @deprecated use `Memory$Outbound` instead. */
  export type Outbound = Memory$Outbound;
}

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}

export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const RunAgentConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentConfigurationType
> = z.nativeEnum(RunAgentConfigurationType);

/** @internal */
export const RunAgentConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentConfigurationType
> = RunAgentConfigurationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentConfigurationType$ {
  /** @deprecated use `RunAgentConfigurationType$inboundSchema` instead. */
  export const inboundSchema = RunAgentConfigurationType$inboundSchema;
  /** @deprecated use `RunAgentConfigurationType$outboundSchema` instead. */
  export const outboundSchema = RunAgentConfigurationType$outboundSchema;
}

/** @internal */
export const Configuration2$inboundSchema: z.ZodType<
  Configuration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentConfigurationType$inboundSchema,
  query: z.string(),
});

/** @internal */
export type Configuration2$Outbound = {
  type: string;
  query: string;
};

/** @internal */
export const Configuration2$outboundSchema: z.ZodType<
  Configuration2$Outbound,
  z.ZodTypeDef,
  Configuration2
> = z.object({
  type: RunAgentConfigurationType$outboundSchema,
  query: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Configuration2$ {
  /** @deprecated use `Configuration2$inboundSchema` instead. */
  export const inboundSchema = Configuration2$inboundSchema;
  /** @deprecated use `Configuration2$outboundSchema` instead. */
  export const outboundSchema = Configuration2$outboundSchema;
  /** @deprecated use `Configuration2$Outbound` instead. */
  export type Outbound = Configuration2$Outbound;
}

export function configuration2ToJSON(configuration2: Configuration2): string {
  return JSON.stringify(Configuration2$outboundSchema.parse(configuration2));
}

export function configuration2FromJSON(
  jsonString: string,
): SafeParseResult<Configuration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration2' from JSON`,
  );
}

/** @internal */
export const ConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof ConfigurationType
> = z.nativeEnum(ConfigurationType);

/** @internal */
export const ConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof ConfigurationType
> = ConfigurationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ConfigurationType$ {
  /** @deprecated use `ConfigurationType$inboundSchema` instead. */
  export const inboundSchema = ConfigurationType$inboundSchema;
  /** @deprecated use `ConfigurationType$outboundSchema` instead. */
  export const outboundSchema = ConfigurationType$outboundSchema;
}

/** @internal */
export const Configuration1$inboundSchema: z.ZodType<
  Configuration1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ConfigurationType$inboundSchema,
});

/** @internal */
export type Configuration1$Outbound = {
  type: string;
};

/** @internal */
export const Configuration1$outboundSchema: z.ZodType<
  Configuration1$Outbound,
  z.ZodTypeDef,
  Configuration1
> = z.object({
  type: ConfigurationType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Configuration1$ {
  /** @deprecated use `Configuration1$inboundSchema` instead. */
  export const inboundSchema = Configuration1$inboundSchema;
  /** @deprecated use `Configuration1$outboundSchema` instead. */
  export const outboundSchema = Configuration1$outboundSchema;
  /** @deprecated use `Configuration1$Outbound` instead. */
  export type Outbound = Configuration1$Outbound;
}

export function configuration1ToJSON(configuration1: Configuration1): string {
  return JSON.stringify(Configuration1$outboundSchema.parse(configuration1));
}

export function configuration1FromJSON(
  jsonString: string,
): SafeParseResult<Configuration1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration1' from JSON`,
  );
}

/** @internal */
export const Configuration$inboundSchema: z.ZodType<
  Configuration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Configuration2$inboundSchema),
  z.lazy(() => Configuration1$inboundSchema),
]);

/** @internal */
export type Configuration$Outbound =
  | Configuration2$Outbound
  | Configuration1$Outbound;

/** @internal */
export const Configuration$outboundSchema: z.ZodType<
  Configuration$Outbound,
  z.ZodTypeDef,
  Configuration
> = z.union([
  z.lazy(() => Configuration2$outboundSchema),
  z.lazy(() => Configuration1$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Configuration$ {
  /** @deprecated use `Configuration$inboundSchema` instead. */
  export const inboundSchema = Configuration$inboundSchema;
  /** @deprecated use `Configuration$outboundSchema` instead. */
  export const outboundSchema = Configuration$outboundSchema;
  /** @deprecated use `Configuration$Outbound` instead. */
  export type Outbound = Configuration$Outbound;
}

export function configurationToJSON(configuration: Configuration): string {
  return JSON.stringify(Configuration$outboundSchema.parse(configuration));
}

export function configurationFromJSON(
  jsonString: string,
): SafeParseResult<Configuration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Configuration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Configuration' from JSON`,
  );
}

/** @internal */
export const KnowledgeBases$inboundSchema: z.ZodType<
  KnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: z.union([
    z.lazy(() => Configuration2$inboundSchema),
    z.lazy(() => Configuration1$inboundSchema),
  ]),
});

/** @internal */
export type KnowledgeBases$Outbound = {
  configuration: Configuration2$Outbound | Configuration1$Outbound;
};

/** @internal */
export const KnowledgeBases$outboundSchema: z.ZodType<
  KnowledgeBases$Outbound,
  z.ZodTypeDef,
  KnowledgeBases
> = z.object({
  configuration: z.union([
    z.lazy(() => Configuration2$outboundSchema),
    z.lazy(() => Configuration1$outboundSchema),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeBases$ {
  /** @deprecated use `KnowledgeBases$inboundSchema` instead. */
  export const inboundSchema = KnowledgeBases$inboundSchema;
  /** @deprecated use `KnowledgeBases$outboundSchema` instead. */
  export const outboundSchema = KnowledgeBases$outboundSchema;
  /** @deprecated use `KnowledgeBases$Outbound` instead. */
  export type Outbound = KnowledgeBases$Outbound;
}

export function knowledgeBasesToJSON(knowledgeBases: KnowledgeBases): string {
  return JSON.stringify(KnowledgeBases$outboundSchema.parse(knowledgeBases));
}

export function knowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeBases' from JSON`,
  );
}

/** @internal */
export const TeamOfAgents$inboundSchema: z.ZodType<
  TeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  role: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});

/** @internal */
export type TeamOfAgents$Outbound = {
  _id: string;
  role?: string | undefined;
};

/** @internal */
export const TeamOfAgents$outboundSchema: z.ZodType<
  TeamOfAgents$Outbound,
  z.ZodTypeDef,
  TeamOfAgents
> = z.object({
  id: z.string(),
  role: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TeamOfAgents$ {
  /** @deprecated use `TeamOfAgents$inboundSchema` instead. */
  export const inboundSchema = TeamOfAgents$inboundSchema;
  /** @deprecated use `TeamOfAgents$outboundSchema` instead. */
  export const outboundSchema = TeamOfAgents$outboundSchema;
  /** @deprecated use `TeamOfAgents$Outbound` instead. */
  export type Outbound = TeamOfAgents$Outbound;
}

export function teamOfAgentsToJSON(teamOfAgents: TeamOfAgents): string {
  return JSON.stringify(TeamOfAgents$outboundSchema.parse(teamOfAgents));
}

export function teamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<TeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TeamOfAgents' from JSON`,
  );
}

/** @internal */
export const Status$inboundSchema: z.ZodNativeEnum<typeof Status> = z
  .nativeEnum(Status);

/** @internal */
export const Status$outboundSchema: z.ZodNativeEnum<typeof Status> =
  Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Status$ {
  /** @deprecated use `Status$inboundSchema` instead. */
  export const inboundSchema = Status$inboundSchema;
  /** @deprecated use `Status$outboundSchema` instead. */
  export const outboundSchema = Status$outboundSchema;
}

/** @internal */
export const ToolsType$inboundSchema: z.ZodNativeEnum<typeof ToolsType> = z
  .nativeEnum(ToolsType);

/** @internal */
export const ToolsType$outboundSchema: z.ZodNativeEnum<typeof ToolsType> =
  ToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsType$ {
  /** @deprecated use `ToolsType$inboundSchema` instead. */
  export const inboundSchema = ToolsType$inboundSchema;
  /** @deprecated use `ToolsType$outboundSchema` instead. */
  export const outboundSchema = ToolsType$outboundSchema;
}

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);

/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Method$ {
  /** @deprecated use `Method$inboundSchema` instead. */
  export const inboundSchema = Method$inboundSchema;
  /** @deprecated use `Method$outboundSchema` instead. */
  export const outboundSchema = Method$outboundSchema;
}

/** @internal */
export const Blueprint$inboundSchema: z.ZodType<
  Blueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: Method$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type Blueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const Blueprint$outboundSchema: z.ZodType<
  Blueprint$Outbound,
  z.ZodTypeDef,
  Blueprint
> = z.object({
  url: z.string(),
  method: Method$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Blueprint$ {
  /** @deprecated use `Blueprint$inboundSchema` instead. */
  export const inboundSchema = Blueprint$inboundSchema;
  /** @deprecated use `Blueprint$outboundSchema` instead. */
  export const outboundSchema = Blueprint$outboundSchema;
  /** @deprecated use `Blueprint$Outbound` instead. */
  export type Outbound = Blueprint$Outbound;
}

export function blueprintToJSON(blueprint: Blueprint): string {
  return JSON.stringify(Blueprint$outboundSchema.parse(blueprint));
}

export function blueprintFromJSON(
  jsonString: string,
): SafeParseResult<Blueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Blueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Blueprint' from JSON`,
  );
}

/** @internal */
export const RunAgentToolsType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolsType
> = z.nativeEnum(RunAgentToolsType);

/** @internal */
export const RunAgentToolsType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolsType
> = RunAgentToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentToolsType$ {
  /** @deprecated use `RunAgentToolsType$inboundSchema` instead. */
  export const inboundSchema = RunAgentToolsType$inboundSchema;
  /** @deprecated use `RunAgentToolsType$outboundSchema` instead. */
  export const outboundSchema = RunAgentToolsType$outboundSchema;
}

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DefaultValue$ {
  /** @deprecated use `DefaultValue$inboundSchema` instead. */
  export const inboundSchema = DefaultValue$inboundSchema;
  /** @deprecated use `DefaultValue$outboundSchema` instead. */
  export const outboundSchema = DefaultValue$outboundSchema;
  /** @deprecated use `DefaultValue$Outbound` instead. */
  export type Outbound = DefaultValue$Outbound;
}

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}

export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const Arguments$inboundSchema: z.ZodType<
  Arguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentToolsType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type Arguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const Arguments$outboundSchema: z.ZodType<
  Arguments$Outbound,
  z.ZodTypeDef,
  Arguments
> = z.object({
  type: RunAgentToolsType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Arguments$ {
  /** @deprecated use `Arguments$inboundSchema` instead. */
  export const inboundSchema = Arguments$inboundSchema;
  /** @deprecated use `Arguments$outboundSchema` instead. */
  export const outboundSchema = Arguments$outboundSchema;
  /** @deprecated use `Arguments$Outbound` instead. */
  export type Outbound = Arguments$Outbound;
}

export function argumentsToJSON(value: Arguments): string {
  return JSON.stringify(Arguments$outboundSchema.parse(value));
}

export function argumentsFromJSON(
  jsonString: string,
): SafeParseResult<Arguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Arguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Arguments' from JSON`,
  );
}

/** @internal */
export const Http$inboundSchema: z.ZodType<Http, z.ZodTypeDef, unknown> = z
  .object({
    blueprint: z.lazy(() => Blueprint$inboundSchema),
    arguments: z.record(z.lazy(() => Arguments$inboundSchema)).optional(),
  });

/** @internal */
export type Http$Outbound = {
  blueprint: Blueprint$Outbound;
  arguments?: { [k: string]: Arguments$Outbound } | undefined;
};

/** @internal */
export const Http$outboundSchema: z.ZodType<Http$Outbound, z.ZodTypeDef, Http> =
  z.object({
    blueprint: z.lazy(() => Blueprint$outboundSchema),
    arguments: z.record(z.lazy(() => Arguments$outboundSchema)).optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Http$ {
  /** @deprecated use `Http$inboundSchema` instead. */
  export const inboundSchema = Http$inboundSchema;
  /** @deprecated use `Http$outboundSchema` instead. */
  export const outboundSchema = Http$outboundSchema;
  /** @deprecated use `Http$Outbound` instead. */
  export type Outbound = Http$Outbound;
}

export function httpToJSON(http: Http): string {
  return JSON.stringify(Http$outboundSchema.parse(http));
}

export function httpFromJSON(
  jsonString: string,
): SafeParseResult<Http, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Http$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Http' from JSON`,
  );
}

/** @internal */
export const TwentyFour$inboundSchema: z.ZodType<
  TwentyFour,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K5ZT3CQZFBXVN2YQ8CKRJ1MW"),
  path: z.string(),
  key: z.string(),
  display_name: z.string(),
  description: z.string(),
  status: Status$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: ToolsType$inboundSchema,
  http: z.lazy(() => Http$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "version_hash": "versionHash",
    "requires_approval": "requiresApproval",
  });
});

/** @internal */
export type TwentyFour$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: Http$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const TwentyFour$outboundSchema: z.ZodType<
  TwentyFour$Outbound,
  z.ZodTypeDef,
  TwentyFour
> = z.object({
  id: z.string().default("01K5ZT3CQZFBXVN2YQ8CKRJ1MW"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: Status$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: ToolsType$outboundSchema,
  http: z.lazy(() => Http$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    versionHash: "version_hash",
    requiresApproval: "requires_approval",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwentyFour$ {
  /** @deprecated use `TwentyFour$inboundSchema` instead. */
  export const inboundSchema = TwentyFour$inboundSchema;
  /** @deprecated use `TwentyFour$outboundSchema` instead. */
  export const outboundSchema = TwentyFour$outboundSchema;
  /** @deprecated use `TwentyFour$Outbound` instead. */
  export type Outbound = TwentyFour$Outbound;
}

export function twentyFourToJSON(twentyFour: TwentyFour): string {
  return JSON.stringify(TwentyFour$outboundSchema.parse(twentyFour));
}

export function twentyFourFromJSON(
  jsonString: string,
): SafeParseResult<TwentyFour, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwentyFour$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwentyFour' from JSON`,
  );
}

/** @internal */
export const Tools$inboundSchema: z.ZodType<Tools, z.ZodTypeDef, unknown> = z
  .union([
    components.HttpTool$inboundSchema.and(
      z.object({ type: z.literal("http") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.CodeExecutionTool$inboundSchema.and(
      z.object({ type: z.literal("code") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.FunctionTool$inboundSchema.and(
      z.object({ type: z.literal("function") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.GoogleSearchTool$inboundSchema.and(
      z.object({ type: z.literal("google_search") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.WebScraperTool$inboundSchema.and(
      z.object({ type: z.literal("web_scraper") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.CallSubAgentTool$inboundSchema.and(
      z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.RetrieveAgentsTool$inboundSchema.and(
      z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.QueryMemoryStoreTool$inboundSchema.and(
      z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.WriteMemoryStoreTool$inboundSchema.and(
      z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.RetrieveMemoryStoresTool$inboundSchema.and(
      z.object({ type: z.literal("retrieve_memory_stores") }).transform((
        v,
      ) => ({ type: v.type })),
    ),
    components.RetrieveKnowledgeBasesTool$inboundSchema.and(
      z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
        v,
      ) => ({ type: v.type })),
    ),
    components.QueryKnowledgeBaseTool$inboundSchema.and(
      z.object({ type: z.literal("query_knowledge_base") }).transform((v) => ({
        type: v.type,
      })),
    ),
    components.CurrentDateTool$inboundSchema.and(
      z.object({ type: z.literal("current_date") }).transform((v) => ({
        type: v.type,
      })),
    ),
  ]);

/** @internal */
export type Tools$Outbound =
  | (components.HttpTool$Outbound & { type: "http" })
  | (components.CodeExecutionTool$Outbound & { type: "code" })
  | (components.FunctionTool$Outbound & { type: "function" })
  | (components.GoogleSearchTool$Outbound & { type: "google_search" })
  | (components.WebScraperTool$Outbound & { type: "web_scraper" })
  | (components.CallSubAgentTool$Outbound & { type: "call_sub_agent" })
  | (components.RetrieveAgentsTool$Outbound & { type: "retrieve_agents" })
  | (components.QueryMemoryStoreTool$Outbound & { type: "query_memory_store" })
  | (components.WriteMemoryStoreTool$Outbound & { type: "write_memory_store" })
  | (components.RetrieveMemoryStoresTool$Outbound & {
    type: "retrieve_memory_stores";
  })
  | (components.RetrieveKnowledgeBasesTool$Outbound & {
    type: "retrieve_knowledge_bases";
  })
  | (components.QueryKnowledgeBaseTool$Outbound & {
    type: "query_knowledge_base";
  })
  | (components.CurrentDateTool$Outbound & { type: "current_date" });

/** @internal */
export const Tools$outboundSchema: z.ZodType<
  Tools$Outbound,
  z.ZodTypeDef,
  Tools
> = z.union([
  components.HttpTool$outboundSchema.and(
    z.object({ type: z.literal("http") }).transform((v) => ({ type: v.type })),
  ),
  components.CodeExecutionTool$outboundSchema.and(
    z.object({ type: z.literal("code") }).transform((v) => ({ type: v.type })),
  ),
  components.FunctionTool$outboundSchema.and(
    z.object({ type: z.literal("function") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.GoogleSearchTool$outboundSchema.and(
    z.object({ type: z.literal("google_search") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WebScraperTool$outboundSchema.and(
    z.object({ type: z.literal("web_scraper") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CallSubAgentTool$outboundSchema.and(
    z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveAgentsTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.QueryMemoryStoreTool$outboundSchema.and(
    z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WriteMemoryStoreTool$outboundSchema.and(
    z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveMemoryStoresTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_memory_stores") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveKnowledgeBasesTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
      v,
    ) => ({ type: v.type })),
  ),
  components.QueryKnowledgeBaseTool$outboundSchema.and(
    z.object({ type: z.literal("query_knowledge_base") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CurrentDateTool$outboundSchema.and(
    z.object({ type: z.literal("current_date") }).transform((v) => ({
      type: v.type,
    })),
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tools$ {
  /** @deprecated use `Tools$inboundSchema` instead. */
  export const inboundSchema = Tools$inboundSchema;
  /** @deprecated use `Tools$outboundSchema` instead. */
  export const outboundSchema = Tools$outboundSchema;
  /** @deprecated use `Tools$Outbound` instead. */
  export type Outbound = Tools$Outbound;
}

export function toolsToJSON(tools: Tools): string {
  return JSON.stringify(Tools$outboundSchema.parse(tools));
}

export function toolsFromJSON(
  jsonString: string,
): SafeParseResult<Tools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tools' from JSON`,
  );
}

/** @internal */
export const ToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = z.nativeEnum(ToolApprovalRequired);

/** @internal */
export const ToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof ToolApprovalRequired
> = ToolApprovalRequired$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolApprovalRequired$ {
  /** @deprecated use `ToolApprovalRequired$inboundSchema` instead. */
  export const inboundSchema = ToolApprovalRequired$inboundSchema;
  /** @deprecated use `ToolApprovalRequired$outboundSchema` instead. */
  export const outboundSchema = ToolApprovalRequired$outboundSchema;
}

/** @internal */
export const Settings$inboundSchema: z.ZodType<
  Settings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      components.HttpTool$inboundSchema.and(
        z.object({ type: z.literal("http") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CodeExecutionTool$inboundSchema.and(
        z.object({ type: z.literal("code") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.FunctionTool$inboundSchema.and(
        z.object({ type: z.literal("function") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.GoogleSearchTool$inboundSchema.and(
        z.object({ type: z.literal("google_search") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WebScraperTool$inboundSchema.and(
        z.object({ type: z.literal("web_scraper") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CallSubAgentTool$inboundSchema.and(
        z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveAgentsTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.QueryMemoryStoreTool$inboundSchema.and(
        z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WriteMemoryStoreTool$inboundSchema.and(
        z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveMemoryStoresTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_memory_stores") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.RetrieveKnowledgeBasesTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.QueryKnowledgeBaseTool$inboundSchema.and(
        z.object({ type: z.literal("query_knowledge_base") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.CurrentDateTool$inboundSchema.and(
        z.object({ type: z.literal("current_date") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ),
  tool_approval_required: ToolApprovalRequired$inboundSchema.default("none"),
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(120),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});

/** @internal */
export type Settings$Outbound = {
  tools: Array<
    | (components.HttpTool$Outbound & { type: "http" })
    | (components.CodeExecutionTool$Outbound & { type: "code" })
    | (components.FunctionTool$Outbound & { type: "function" })
    | (components.GoogleSearchTool$Outbound & { type: "google_search" })
    | (components.WebScraperTool$Outbound & { type: "web_scraper" })
    | (components.CallSubAgentTool$Outbound & { type: "call_sub_agent" })
    | (components.RetrieveAgentsTool$Outbound & { type: "retrieve_agents" })
    | (components.QueryMemoryStoreTool$Outbound & {
      type: "query_memory_store";
    })
    | (components.WriteMemoryStoreTool$Outbound & {
      type: "write_memory_store";
    })
    | (components.RetrieveMemoryStoresTool$Outbound & {
      type: "retrieve_memory_stores";
    })
    | (components.RetrieveKnowledgeBasesTool$Outbound & {
      type: "retrieve_knowledge_bases";
    })
    | (components.QueryKnowledgeBaseTool$Outbound & {
      type: "query_knowledge_base";
    })
    | (components.CurrentDateTool$Outbound & { type: "current_date" })
  >;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
};

/** @internal */
export const Settings$outboundSchema: z.ZodType<
  Settings$Outbound,
  z.ZodTypeDef,
  Settings
> = z.object({
  tools: z.array(
    z.union([
      components.HttpTool$outboundSchema.and(
        z.object({ type: z.literal("http") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CodeExecutionTool$outboundSchema.and(
        z.object({ type: z.literal("code") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.FunctionTool$outboundSchema.and(
        z.object({ type: z.literal("function") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.GoogleSearchTool$outboundSchema.and(
        z.object({ type: z.literal("google_search") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WebScraperTool$outboundSchema.and(
        z.object({ type: z.literal("web_scraper") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CallSubAgentTool$outboundSchema.and(
        z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveAgentsTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.QueryMemoryStoreTool$outboundSchema.and(
        z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WriteMemoryStoreTool$outboundSchema.and(
        z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveMemoryStoresTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_memory_stores") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.RetrieveKnowledgeBasesTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.QueryKnowledgeBaseTool$outboundSchema.and(
        z.object({ type: z.literal("query_knowledge_base") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.CurrentDateTool$outboundSchema.and(
        z.object({ type: z.literal("current_date") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ),
  toolApprovalRequired: ToolApprovalRequired$outboundSchema.default("none"),
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(120),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Settings$ {
  /** @deprecated use `Settings$inboundSchema` instead. */
  export const inboundSchema = Settings$inboundSchema;
  /** @deprecated use `Settings$outboundSchema` instead. */
  export const outboundSchema = Settings$outboundSchema;
  /** @deprecated use `Settings$Outbound` instead. */
  export type Outbound = Settings$Outbound;
}

export function settingsToJSON(settings: Settings): string {
  return JSON.stringify(Settings$outboundSchema.parse(settings));
}

export function settingsFromJSON(
  jsonString: string,
): SafeParseResult<Settings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Settings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Settings' from JSON`,
  );
}

/** @internal */
export const RunAgentRequestBody$inboundSchema: z.ZodType<
  RunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.string(),
  fallback_models: z.array(z.string()).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => Message$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$inboundSchema).optional(),
  thread: z.lazy(() => RunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(z.lazy(() => KnowledgeBases$inboundSchema))
    .optional(),
  team_of_agents: z.array(z.lazy(() => TeamOfAgents$inboundSchema)).optional(),
  settings: z.lazy(() => Settings$inboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});

/** @internal */
export type RunAgentRequestBody$Outbound = {
  key: string;
  taskId?: string | undefined;
  model: string;
  fallback_models?: Array<string> | undefined;
  role: string;
  instructions: string;
  message: Message$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: Contact$Outbound | undefined;
  thread?: RunAgentThread$Outbound | undefined;
  memory?: Memory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<KnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<TeamOfAgents$Outbound> | undefined;
  settings: Settings$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentRequestBody$outboundSchema: z.ZodType<
  RunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  RunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.string(),
  fallbackModels: z.array(z.string()).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => Message$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$outboundSchema).optional(),
  thread: z.lazy(() => RunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => KnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => TeamOfAgents$outboundSchema)).optional(),
  settings: z.lazy(() => Settings$outboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentRequestBody$ {
  /** @deprecated use `RunAgentRequestBody$inboundSchema` instead. */
  export const inboundSchema = RunAgentRequestBody$inboundSchema;
  /** @deprecated use `RunAgentRequestBody$outboundSchema` instead. */
  export const outboundSchema = RunAgentRequestBody$outboundSchema;
  /** @deprecated use `RunAgentRequestBody$Outbound` instead. */
  export type Outbound = RunAgentRequestBody$Outbound;
}

export function runAgentRequestBodyToJSON(
  runAgentRequestBody: RunAgentRequestBody,
): string {
  return JSON.stringify(
    RunAgentRequestBody$outboundSchema.parse(runAgentRequestBody),
  );
}

export function runAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const RunAgentKind$inboundSchema: z.ZodNativeEnum<typeof RunAgentKind> =
  z.nativeEnum(RunAgentKind);

/** @internal */
export const RunAgentKind$outboundSchema: z.ZodNativeEnum<typeof RunAgentKind> =
  RunAgentKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentKind$ {
  /** @deprecated use `RunAgentKind$inboundSchema` instead. */
  export const inboundSchema = RunAgentKind$inboundSchema;
  /** @deprecated use `RunAgentKind$outboundSchema` instead. */
  export const outboundSchema = RunAgentKind$outboundSchema;
}

/** @internal */
export const RunAgentState$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentState
> = z.nativeEnum(RunAgentState);

/** @internal */
export const RunAgentState$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentState
> = RunAgentState$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentState$ {
  /** @deprecated use `RunAgentState$inboundSchema` instead. */
  export const inboundSchema = RunAgentState$inboundSchema;
  /** @deprecated use `RunAgentState$outboundSchema` instead. */
  export const outboundSchema = RunAgentState$outboundSchema;
}

/** @internal */
export const RunAgentAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsKind
> = z.nativeEnum(RunAgentAgentsKind);

/** @internal */
export const RunAgentAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsKind
> = RunAgentAgentsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentAgentsKind$ {
  /** @deprecated use `RunAgentAgentsKind$inboundSchema` instead. */
  export const inboundSchema = RunAgentAgentsKind$inboundSchema;
  /** @deprecated use `RunAgentAgentsKind$outboundSchema` instead. */
  export const outboundSchema = RunAgentAgentsKind$outboundSchema;
}

/** @internal */
export const RunAgentAgentsRole$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsRole
> = z.nativeEnum(RunAgentAgentsRole);

/** @internal */
export const RunAgentAgentsRole$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsRole
> = RunAgentAgentsRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentAgentsRole$ {
  /** @deprecated use `RunAgentAgentsRole$inboundSchema` instead. */
  export const inboundSchema = RunAgentAgentsRole$inboundSchema;
  /** @deprecated use `RunAgentAgentsRole$outboundSchema` instead. */
  export const outboundSchema = RunAgentAgentsRole$outboundSchema;
}

/** @internal */
export const RunAgentMessage$inboundSchema: z.ZodType<
  RunAgentMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentAgentsKind$inboundSchema,
  messageId: z.string(),
  role: RunAgentAgentsRole$inboundSchema,
  parts: z.array(z.any()),
});

/** @internal */
export type RunAgentMessage$Outbound = {
  kind: string;
  messageId: string;
  role: string;
  parts: Array<any>;
};

/** @internal */
export const RunAgentMessage$outboundSchema: z.ZodType<
  RunAgentMessage$Outbound,
  z.ZodTypeDef,
  RunAgentMessage
> = z.object({
  kind: RunAgentAgentsKind$outboundSchema,
  messageId: z.string(),
  role: RunAgentAgentsRole$outboundSchema,
  parts: z.array(z.any()),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentMessage$ {
  /** @deprecated use `RunAgentMessage$inboundSchema` instead. */
  export const inboundSchema = RunAgentMessage$inboundSchema;
  /** @deprecated use `RunAgentMessage$outboundSchema` instead. */
  export const outboundSchema = RunAgentMessage$outboundSchema;
  /** @deprecated use `RunAgentMessage$Outbound` instead. */
  export type Outbound = RunAgentMessage$Outbound;
}

export function runAgentMessageToJSON(
  runAgentMessage: RunAgentMessage,
): string {
  return JSON.stringify(RunAgentMessage$outboundSchema.parse(runAgentMessage));
}

export function runAgentMessageFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentMessage' from JSON`,
  );
}

/** @internal */
export const RunAgentStatus$inboundSchema: z.ZodType<
  RunAgentStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: RunAgentState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => RunAgentMessage$inboundSchema).optional(),
});

/** @internal */
export type RunAgentStatus$Outbound = {
  state: string;
  timestamp?: string | undefined;
  message?: RunAgentMessage$Outbound | undefined;
};

/** @internal */
export const RunAgentStatus$outboundSchema: z.ZodType<
  RunAgentStatus$Outbound,
  z.ZodTypeDef,
  RunAgentStatus
> = z.object({
  state: RunAgentState$outboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => RunAgentMessage$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentStatus$ {
  /** @deprecated use `RunAgentStatus$inboundSchema` instead. */
  export const inboundSchema = RunAgentStatus$inboundSchema;
  /** @deprecated use `RunAgentStatus$outboundSchema` instead. */
  export const outboundSchema = RunAgentStatus$outboundSchema;
  /** @deprecated use `RunAgentStatus$Outbound` instead. */
  export type Outbound = RunAgentStatus$Outbound;
}

export function runAgentStatusToJSON(runAgentStatus: RunAgentStatus): string {
  return JSON.stringify(RunAgentStatus$outboundSchema.parse(runAgentStatus));
}

export function runAgentStatusFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentStatus' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseBody$inboundSchema: z.ZodType<
  RunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: RunAgentKind$inboundSchema,
  status: z.lazy(() => RunAgentStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});

/** @internal */
export type RunAgentResponseBody$Outbound = {
  id: string;
  contextId: string;
  kind: string;
  status: RunAgentStatus$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentResponseBody$outboundSchema: z.ZodType<
  RunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  RunAgentResponseBody
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: RunAgentKind$outboundSchema,
  status: z.lazy(() => RunAgentStatus$outboundSchema),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RunAgentResponseBody$ {
  /** @deprecated use `RunAgentResponseBody$inboundSchema` instead. */
  export const inboundSchema = RunAgentResponseBody$inboundSchema;
  /** @deprecated use `RunAgentResponseBody$outboundSchema` instead. */
  export const outboundSchema = RunAgentResponseBody$outboundSchema;
  /** @deprecated use `RunAgentResponseBody$Outbound` instead. */
  export type Outbound = RunAgentResponseBody$Outbound;
}

export function runAgentResponseBodyToJSON(
  runAgentResponseBody: RunAgentResponseBody,
): string {
  return JSON.stringify(
    RunAgentResponseBody$outboundSchema.parse(runAgentResponseBody),
  );
}

export function runAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseBody' from JSON`,
  );
}
