/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RunAgentModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RunAgentModelConfigurationVoice = ClosedEnum<
  typeof RunAgentModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RunAgentModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RunAgentModelConfigurationFormat = ClosedEnum<
  typeof RunAgentModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RunAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RunAgentModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RunAgentModelConfigurationFormat;
};

export const RunAgentResponseFormatAgentsRequestType = {
  JsonSchema: "json_schema",
} as const;
export type RunAgentResponseFormatAgentsRequestType = ClosedEnum<
  typeof RunAgentResponseFormatAgentsRequestType
>;

export type RunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | null | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RunAgentResponseFormatJSONSchema = {
  type: RunAgentResponseFormatAgentsRequestType;
  jsonSchema: RunAgentResponseFormatAgentsJsonSchema;
};

export const RunAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type RunAgentResponseFormatAgentsType = ClosedEnum<
  typeof RunAgentResponseFormatAgentsType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RunAgentResponseFormatJSONObject = {
  type: RunAgentResponseFormatAgentsType;
};

export const RunAgentResponseFormatType = {
  Text: "text",
} as const;
export type RunAgentResponseFormatType = ClosedEnum<
  typeof RunAgentResponseFormatType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RunAgentResponseFormatText = {
  type: RunAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type RunAgentModelConfigurationResponseFormat =
  | RunAgentResponseFormatJSONSchema
  | RunAgentResponseFormatText
  | RunAgentResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RunAgentModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RunAgentModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const RunAgentModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type RunAgentModelConfigurationType = ClosedEnum<
  typeof RunAgentModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const RunAgentModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type RunAgentModelConfigurationThinkingLevel = ClosedEnum<
  typeof RunAgentModelConfigurationThinkingLevel
>;

export type RunAgentModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: RunAgentModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: RunAgentModelConfigurationThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RunAgentToolChoiceType = ClosedEnum<typeof RunAgentToolChoiceType>;

export type RunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type RunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RunAgentToolChoiceType | undefined;
  function: RunAgentToolChoiceFunction;
};

export const RunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RunAgentToolChoice1 = ClosedEnum<typeof RunAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RunAgentModelConfigurationToolChoice =
  | RunAgentToolChoice2
  | RunAgentToolChoice1;

export const RunAgentModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RunAgentModelConfigurationModalities = ClosedEnum<
  typeof RunAgentModelConfigurationModalities
>;

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type RunAgentModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: RunAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RunAgentResponseFormatJSONSchema
    | RunAgentResponseFormatText
    | RunAgentResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: RunAgentModelConfigurationStreamOptions | null | undefined;
  thinking?: RunAgentModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: RunAgentToolChoice2 | RunAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<RunAgentModelConfigurationModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type RunAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type RunAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: RunAgentModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: RunAgentModelConfigurationRetry | undefined;
};

/**
 * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
 */
export type RunAgentModelConfiguration = RunAgentModelConfiguration2 | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const RunAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type RunAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const RunAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type RunAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type RunAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: RunAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: RunAgentFallbackModelConfigurationFormat;
};

export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType =
  {
    JsonSchema: "json_schema",
  } as const;
export type RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType =
  ClosedEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  >;

export type RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | null | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type RunAgentResponseFormatAgentsRequestJSONSchema = {
  type:
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType;
  jsonSchema: RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  {
    JsonObject: "json_object",
  } as const;
export type RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType =
  ClosedEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  >;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type RunAgentResponseFormatAgentsJSONObject = {
  type: RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType;
};

export const RunAgentResponseFormatAgentsRequestRequestBodyType = {
  Text: "text",
} as const;
export type RunAgentResponseFormatAgentsRequestRequestBodyType = ClosedEnum<
  typeof RunAgentResponseFormatAgentsRequestRequestBodyType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type RunAgentResponseFormatAgentsText = {
  type: RunAgentResponseFormatAgentsRequestRequestBodyType;
};

/**
 * An object specifying the format that the model must output
 */
export type RunAgentFallbackModelConfigurationResponseFormat =
  | RunAgentResponseFormatAgentsRequestJSONSchema
  | RunAgentResponseFormatAgentsText
  | RunAgentResponseFormatAgentsJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type RunAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type RunAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const RunAgentFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type RunAgentFallbackModelConfigurationType = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const RunAgentFallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type RunAgentFallbackModelConfigurationThinkingLevel = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationThinkingLevel
>;

export type RunAgentFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: RunAgentFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: RunAgentFallbackModelConfigurationThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const RunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type RunAgentToolChoiceAgentsType = ClosedEnum<
  typeof RunAgentToolChoiceAgentsType
>;

export type RunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type RunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: RunAgentToolChoiceAgentsType | undefined;
  function: RunAgentToolChoiceAgentsFunction;
};

export const RunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type RunAgentToolChoiceAgents1 = ClosedEnum<
  typeof RunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type RunAgentFallbackModelConfigurationToolChoice =
  | RunAgentToolChoiceAgents2
  | RunAgentToolChoiceAgents1;

export const RunAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type RunAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof RunAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type RunAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: RunAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | RunAgentResponseFormatAgentsRequestJSONSchema
    | RunAgentResponseFormatAgentsText
    | RunAgentResponseFormatAgentsJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | RunAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: RunAgentFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | RunAgentToolChoiceAgents2
    | RunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<RunAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type RunAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: RunAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type RunAgentFallbackModelConfiguration =
  | RunAgentFallbackModelConfiguration2
  | string;

/**
 * Tool message
 */
export const RunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Tool message
 */
export type RunAgentRoleToolMessage = ClosedEnum<
  typeof RunAgentRoleToolMessage
>;

/**
 * User message
 */
export const RunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * User message
 */
export type RunAgentRoleUserMessage = ClosedEnum<
  typeof RunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type RunAgentRole = RunAgentRoleUserMessage | RunAgentRoleToolMessage;

export const RunAgentPublicMessagePartAgentsRequestKind = {
  ToolResult: "tool_result",
} as const;
export type RunAgentPublicMessagePartAgentsRequestKind = ClosedEnum<
  typeof RunAgentPublicMessagePartAgentsRequestKind
>;

/**
 * Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request.
 */
export type PublicMessagePartToolResultPart = {
  kind: RunAgentPublicMessagePartAgentsRequestKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPublicMessagePartAgentsKind = {
  File: "file",
} as const;
export type RunAgentPublicMessagePartAgentsKind = ClosedEnum<
  typeof RunAgentPublicMessagePartAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type FileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type FileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type RunAgentPublicMessagePartFile =
  | FileBinaryFormat
  | FileFileInURIFormat;

/**
 * File attachment part. Use this to send files (images, documents, etc.) to the agent for processing.
 */
export type PublicMessagePartFilePart = {
  kind: RunAgentPublicMessagePartAgentsKind;
  file: FileBinaryFormat | FileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPublicMessagePartKind = {
  Text: "text",
} as const;
export type RunAgentPublicMessagePartKind = ClosedEnum<
  typeof RunAgentPublicMessagePartKind
>;

/**
 * Text content part. Use this to send text messages to the agent.
 */
export type PublicMessagePartTextPart = {
  kind: RunAgentPublicMessagePartKind;
  text: string;
};

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type RunAgentPublicMessagePart =
  | PublicMessagePartTextPart
  | PublicMessagePartFilePart
  | PublicMessagePartToolResultPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type RunAgentMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: RunAgentRoleUserMessage | RunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | PublicMessagePartTextPart
    | PublicMessagePartFilePart
    | PublicMessagePartToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type RunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type RunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type RunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type RunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type RunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type =
  {
    Mcp: "mcp",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  >;

export type AgentToolInputRunHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType =
  {
    Object: "object",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  >;

export type Schema = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type Tools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: Schema;
};

/**
 * The connection type used by the MCP server
 */
export const ConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type ConnectionType = ClosedEnum<typeof ConnectionType>;

export type Mcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: AgentToolInputRunHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<Tools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: ConnectionType;
};

/**
 * MCP tool with inline definition for on-the-fly creation in run endpoint
 */
export type MCPToolRun = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  mcp: Mcp;
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * The type must be "object"
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RunAgentAgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type AgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RunAgentAgentToolInputRunParameters | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type FunctionToolRun = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: AgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * The type must be "object"
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type AgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const Language = {
  Python: "python",
} as const;
export type Language = ClosedEnum<typeof Language>;

export type CodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: AgentToolInputRunParameters | undefined;
  language: Language;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type CodeToolRun = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: CodeTool;
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * The HTTP method to use.
 */
export const Method = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type Method = ClosedEnum<typeof Method>;

export type Headers2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type Headers = Headers2 | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type Blueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: Method;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: Headers2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type DefaultValue = string | number | boolean;

export type Arguments = {
  /**
   * The type of the argument.
   */
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type Http = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: Blueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: Arguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type HTTPToolRun = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: Http;
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type AgentToolInputRunCurrentDateTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type AgentToolInputRunQueryKnowledgeBaseTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type AgentToolInputRunRetrieveKnowledgeBasesTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type AgentToolInputRunDeleteMemoryDocumentTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Lists available memory stores
 */
export type AgentToolInputRunRetrieveMemoryStoresTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType = {
  WriteMemoryStore: "write_memory_store",
} as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  >;

/**
 * Writes information to agent memory stores
 */
export type AgentToolInputRunWriteMemoryStoreTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestRequestBodyType = {
  QueryMemoryStore: "query_memory_store",
} as const;
export type RunAgentAgentToolInputRunAgentsRequestRequestBodyType = ClosedEnum<
  typeof RunAgentAgentToolInputRunAgentsRequestRequestBodyType
>;

/**
 * Queries agent memory stores for context
 */
export type AgentToolInputRunQueryMemoryStoreTool = {
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsRequestType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type RunAgentAgentToolInputRunAgentsRequestType = ClosedEnum<
  typeof RunAgentAgentToolInputRunAgentsRequestType
>;

/**
 * Retrieves available agents in the system
 */
export type AgentToolInputRunRetrieveAgentsTool = {
  type: RunAgentAgentToolInputRunAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunAgentsType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type RunAgentAgentToolInputRunAgentsType = ClosedEnum<
  typeof RunAgentAgentToolInputRunAgentsType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type AgentToolInputRunCallSubAgentTool = {
  type: RunAgentAgentToolInputRunAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const RunAgentAgentToolInputRunType = {
  WebScraper: "web_scraper",
} as const;
export type RunAgentAgentToolInputRunType = ClosedEnum<
  typeof RunAgentAgentToolInputRunType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type AgentToolInputRunWebScraperTool = {
  type: RunAgentAgentToolInputRunType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const AgentToolInputRunType = {
  GoogleSearch: "google_search",
} as const;
export type AgentToolInputRunType = ClosedEnum<typeof AgentToolInputRunType>;

/**
 * Performs Google searches to retrieve web content
 */
export type AgentToolInputRunGoogleSearchTool = {
  type: AgentToolInputRunType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function, MCP) support full inline definitions for on-the-fly creation.
 */
export type AgentToolInputRun =
  | HTTPToolRun
  | CodeToolRun
  | MCPToolRun
  | FunctionToolRun
  | AgentToolInputRunGoogleSearchTool
  | AgentToolInputRunWebScraperTool
  | AgentToolInputRunCallSubAgentTool
  | AgentToolInputRunRetrieveAgentsTool
  | AgentToolInputRunQueryMemoryStoreTool
  | AgentToolInputRunWriteMemoryStoreTool
  | AgentToolInputRunRetrieveMemoryStoresTool
  | AgentToolInputRunDeleteMemoryDocumentTool
  | AgentToolInputRunRetrieveKnowledgeBasesTool
  | AgentToolInputRunQueryKnowledgeBaseTool
  | AgentToolInputRunCurrentDateTool;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const RunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type RunAgentToolApprovalRequired = ClosedEnum<
  typeof RunAgentToolApprovalRequired
>;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RunAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RunAgentExecuteOn = ClosedEnum<typeof RunAgentExecuteOn>;

export type RunAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RunAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const RunAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type RunAgentAgentsExecuteOn = ClosedEnum<
  typeof RunAgentAgentsExecuteOn
>;

export type RunAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: RunAgentAgentsExecuteOn;
};

export type RunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | HTTPToolRun
      | CodeToolRun
      | MCPToolRun
      | FunctionToolRun
      | AgentToolInputRunGoogleSearchTool
      | AgentToolInputRunWebScraperTool
      | AgentToolInputRunCallSubAgentTool
      | AgentToolInputRunRetrieveAgentsTool
      | AgentToolInputRunQueryMemoryStoreTool
      | AgentToolInputRunWriteMemoryStoreTool
      | AgentToolInputRunRetrieveMemoryStoresTool
      | AgentToolInputRunDeleteMemoryDocumentTool
      | AgentToolInputRunRetrieveKnowledgeBasesTool
      | AgentToolInputRunQueryKnowledgeBaseTool
      | AgentToolInputRunCurrentDateTool
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: RunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<RunAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<RunAgentGuardrails> | undefined;
};

export type RunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
   */
  model: RunAgentModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<RunAgentFallbackModelConfiguration2 | string>
    | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: RunAgentMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: RunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: RunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: RunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<RunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<RunAgentTeamOfAgents> | undefined;
  settings: RunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * A2A entity type
 */
export const RunAgentKind = {
  Task: "task",
} as const;
/**
 * A2A entity type
 */
export type RunAgentKind = ClosedEnum<typeof RunAgentKind>;

/**
 * Current task state
 */
export const RunAgentState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
  AuthRequired: "auth-required",
  Unknown: "unknown",
} as const;
/**
 * Current task state
 */
export type RunAgentState = ClosedEnum<typeof RunAgentState>;

export const RunAgentAgentsKind = {
  Message: "message",
} as const;
export type RunAgentAgentsKind = ClosedEnum<typeof RunAgentAgentsKind>;

/**
 * Extended A2A message role
 */
export const RunAgentAgentsRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Extended A2A message role
 */
export type RunAgentAgentsRole = ClosedEnum<typeof RunAgentAgentsRole>;

export const RunAgentPartsAgentsResponse200ApplicationJSONKind = {
  ToolResult: "tool_result",
} as const;
export type RunAgentPartsAgentsResponse200ApplicationJSONKind = ClosedEnum<
  typeof RunAgentPartsAgentsResponse200ApplicationJSONKind
>;

export type RunAgentParts5 = {
  kind: RunAgentPartsAgentsResponse200ApplicationJSONKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsAgentsResponse200Kind = {
  ToolCall: "tool_call",
} as const;
export type RunAgentPartsAgentsResponse200Kind = ClosedEnum<
  typeof RunAgentPartsAgentsResponse200Kind
>;

export type RunAgentParts4 = {
  kind: RunAgentPartsAgentsResponse200Kind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsAgentsResponseKind = {
  File: "file",
} as const;
export type RunAgentPartsAgentsResponseKind = ClosedEnum<
  typeof RunAgentPartsAgentsResponseKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type RunAgentFileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type RunAgentFileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type RunAgentPartsFile =
  | RunAgentFileBinaryFormat
  | RunAgentFileFileInURIFormat;

export type RunAgentParts3 = {
  kind: RunAgentPartsAgentsResponseKind;
  file: RunAgentFileBinaryFormat | RunAgentFileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsAgentsKind = {
  Data: "data",
} as const;
export type RunAgentPartsAgentsKind = ClosedEnum<
  typeof RunAgentPartsAgentsKind
>;

export type RunAgentParts2 = {
  kind: RunAgentPartsAgentsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const RunAgentPartsKind = {
  Text: "text",
} as const;
export type RunAgentPartsKind = ClosedEnum<typeof RunAgentPartsKind>;

export type RunAgentParts1 = {
  kind: RunAgentPartsKind;
  text: string;
};

export type RunAgentParts =
  | RunAgentParts4
  | RunAgentParts1
  | RunAgentParts2
  | RunAgentParts3
  | RunAgentParts5;

/**
 * Optional status message
 */
export type RunAgentAgentsMessage = {
  kind: RunAgentAgentsKind;
  messageId: string;
  /**
   * Extended A2A message role
   */
  role: RunAgentAgentsRole;
  parts: Array<
    | RunAgentParts4
    | RunAgentParts1
    | RunAgentParts2
    | RunAgentParts3
    | RunAgentParts5
  >;
};

/**
 * Task status information
 */
export type RunAgentStatus = {
  /**
   * Current task state
   */
  state: RunAgentState;
  /**
   * ISO timestamp of status update
   */
  timestamp?: string | undefined;
  /**
   * Optional status message
   */
  message?: RunAgentAgentsMessage | undefined;
};

/**
 * A2A Task response format
 */
export type RunAgentResponseBody = {
  /**
   * The ID of the created agent execution task
   */
  id: string;
  /**
   * The correlation ID for this execution
   */
  contextId: string;
  /**
   * A2A entity type
   */
  kind: RunAgentKind;
  /**
   * Task status information
   */
  status: RunAgentStatus;
  /**
   * Task metadata containing workspace_id and trace_id for feedback
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentModelConfigurationVoice$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationVoice
> = z.nativeEnum(RunAgentModelConfigurationVoice);
/** @internal */
export const RunAgentModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationVoice
> = RunAgentModelConfigurationVoice$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationFormat$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationFormat
> = z.nativeEnum(RunAgentModelConfigurationFormat);
/** @internal */
export const RunAgentModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationFormat
> = RunAgentModelConfigurationFormat$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationAudio$inboundSchema: z.ZodType<
  RunAgentModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: RunAgentModelConfigurationVoice$inboundSchema,
  format: RunAgentModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type RunAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RunAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  RunAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationAudio
> = z.object({
  voice: RunAgentModelConfigurationVoice$outboundSchema,
  format: RunAgentModelConfigurationFormat$outboundSchema,
});

export function runAgentModelConfigurationAudioToJSON(
  runAgentModelConfigurationAudio: RunAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationAudio$outboundSchema.parse(
      runAgentModelConfigurationAudio,
    ),
  );
}
export function runAgentModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentResponseFormatAgentsRequestType> = z
    .nativeEnum(RunAgentResponseFormatAgentsRequestType);
/** @internal */
export const RunAgentResponseFormatAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentResponseFormatAgentsRequestType> =
    RunAgentResponseFormatAgentsRequestType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.nullable(z.boolean()).optional(),
});
/** @internal */
export type RunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | null | undefined;
};

/** @internal */
export const RunAgentResponseFormatAgentsJsonSchema$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJsonSchema$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.nullable(z.boolean()).optional(),
});

export function runAgentResponseFormatAgentsJsonSchemaToJSON(
  runAgentResponseFormatAgentsJsonSchema:
    RunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      runAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function runAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatAgentsJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatJSONSchema$inboundSchema: z.ZodType<
  RunAgentResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentResponseFormatAgentsRequestType$inboundSchema,
  json_schema: z.lazy(() =>
    RunAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type RunAgentResponseFormatJSONSchema$Outbound = {
  type: string;
  json_schema: RunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const RunAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  RunAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatJSONSchema
> = z.object({
  type: RunAgentResponseFormatAgentsRequestType$outboundSchema,
  jsonSchema: z.lazy(() =>
    RunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function runAgentResponseFormatJSONSchemaToJSON(
  runAgentResponseFormatJSONSchema: RunAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatJSONSchema$outboundSchema.parse(
      runAgentResponseFormatJSONSchema,
    ),
  );
}
export function runAgentResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentResponseFormatAgentsType
> = z.nativeEnum(RunAgentResponseFormatAgentsType);
/** @internal */
export const RunAgentResponseFormatAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentResponseFormatAgentsType
> = RunAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  RunAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type RunAgentResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const RunAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  RunAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatJSONObject
> = z.object({
  type: RunAgentResponseFormatAgentsType$outboundSchema,
});

export function runAgentResponseFormatJSONObjectToJSON(
  runAgentResponseFormatJSONObject: RunAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    RunAgentResponseFormatJSONObject$outboundSchema.parse(
      runAgentResponseFormatJSONObject,
    ),
  );
}
export function runAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentResponseFormatType
> = z.nativeEnum(RunAgentResponseFormatType);
/** @internal */
export const RunAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentResponseFormatType
> = RunAgentResponseFormatType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatText$inboundSchema: z.ZodType<
  RunAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type RunAgentResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const RunAgentResponseFormatText$outboundSchema: z.ZodType<
  RunAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatText
> = z.object({
  type: RunAgentResponseFormatType$outboundSchema,
});

export function runAgentResponseFormatTextToJSON(
  runAgentResponseFormatText: RunAgentResponseFormatText,
): string {
  return JSON.stringify(
    RunAgentResponseFormatText$outboundSchema.parse(runAgentResponseFormatText),
  );
}
export function runAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationResponseFormat$inboundSchema: z.ZodType<
  RunAgentModelConfigurationResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentResponseFormatJSONSchema$inboundSchema),
  z.lazy(() => RunAgentResponseFormatText$inboundSchema),
  z.lazy(() => RunAgentResponseFormatJSONObject$inboundSchema),
]);
/** @internal */
export type RunAgentModelConfigurationResponseFormat$Outbound =
  | RunAgentResponseFormatJSONSchema$Outbound
  | RunAgentResponseFormatText$Outbound
  | RunAgentResponseFormatJSONObject$Outbound;

/** @internal */
export const RunAgentModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  RunAgentModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => RunAgentResponseFormatJSONSchema$outboundSchema),
  z.lazy(() => RunAgentResponseFormatText$outboundSchema),
  z.lazy(() => RunAgentResponseFormatJSONObject$outboundSchema),
]);

export function runAgentModelConfigurationResponseFormatToJSON(
  runAgentModelConfigurationResponseFormat:
    RunAgentModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationResponseFormat$outboundSchema.parse(
      runAgentModelConfigurationResponseFormat,
    ),
  );
}
export function runAgentModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationStop$inboundSchema: z.ZodType<
  RunAgentModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type RunAgentModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const RunAgentModelConfigurationStop$outboundSchema: z.ZodType<
  RunAgentModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function runAgentModelConfigurationStopToJSON(
  runAgentModelConfigurationStop: RunAgentModelConfigurationStop,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationStop$outboundSchema.parse(
      runAgentModelConfigurationStop,
    ),
  );
}
export function runAgentModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationStreamOptions$inboundSchema: z.ZodType<
  RunAgentModelConfigurationStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type RunAgentModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const RunAgentModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  RunAgentModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function runAgentModelConfigurationStreamOptionsToJSON(
  runAgentModelConfigurationStreamOptions:
    RunAgentModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationStreamOptions$outboundSchema.parse(
      runAgentModelConfigurationStreamOptions,
    ),
  );
}
export function runAgentModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationType
> = z.nativeEnum(RunAgentModelConfigurationType);
/** @internal */
export const RunAgentModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentModelConfigurationType
> = RunAgentModelConfigurationType$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationThinkingLevel> = z
    .nativeEnum(RunAgentModelConfigurationThinkingLevel);
/** @internal */
export const RunAgentModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationThinkingLevel> =
    RunAgentModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationThinking$inboundSchema: z.ZodType<
  RunAgentModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentModelConfigurationType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: RunAgentModelConfigurationThinkingLevel$inboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type RunAgentModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const RunAgentModelConfigurationThinking$outboundSchema: z.ZodType<
  RunAgentModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationThinking
> = z.object({
  type: RunAgentModelConfigurationType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: RunAgentModelConfigurationThinkingLevel$outboundSchema
    .optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function runAgentModelConfigurationThinkingToJSON(
  runAgentModelConfigurationThinking: RunAgentModelConfigurationThinking,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationThinking$outboundSchema.parse(
      runAgentModelConfigurationThinking,
    ),
  );
}
export function runAgentModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentModelConfigurationThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceType
> = z.nativeEnum(RunAgentToolChoiceType);
/** @internal */
export const RunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceType
> = RunAgentToolChoiceType$inboundSchema;

/** @internal */
export const RunAgentToolChoiceFunction$inboundSchema: z.ZodType<
  RunAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type RunAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const RunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  RunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function runAgentToolChoiceFunctionToJSON(
  runAgentToolChoiceFunction: RunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    RunAgentToolChoiceFunction$outboundSchema.parse(runAgentToolChoiceFunction),
  );
}
export function runAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoice2$inboundSchema: z.ZodType<
  RunAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type RunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: RunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const RunAgentToolChoice2$outboundSchema: z.ZodType<
  RunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoice2
> = z.object({
  type: RunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceFunction$outboundSchema),
});

export function runAgentToolChoice2ToJSON(
  runAgentToolChoice2: RunAgentToolChoice2,
): string {
  return JSON.stringify(
    RunAgentToolChoice2$outboundSchema.parse(runAgentToolChoice2),
  );
}
export function runAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoice1
> = z.nativeEnum(RunAgentToolChoice1);
/** @internal */
export const RunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoice1
> = RunAgentToolChoice1$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationToolChoice$inboundSchema: z.ZodType<
  RunAgentModelConfigurationToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentToolChoice2$inboundSchema),
  RunAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type RunAgentModelConfigurationToolChoice$Outbound =
  | RunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const RunAgentModelConfigurationToolChoice$outboundSchema: z.ZodType<
  RunAgentModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationToolChoice
> = z.union([
  z.lazy(() => RunAgentToolChoice2$outboundSchema),
  RunAgentToolChoice1$outboundSchema,
]);

export function runAgentModelConfigurationToolChoiceToJSON(
  runAgentModelConfigurationToolChoice: RunAgentModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationToolChoice$outboundSchema.parse(
      runAgentModelConfigurationToolChoice,
    ),
  );
}
export function runAgentModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentModelConfigurationToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationModalities> = z.nativeEnum(
    RunAgentModelConfigurationModalities,
  );
/** @internal */
export const RunAgentModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentModelConfigurationModalities> =
    RunAgentModelConfigurationModalities$inboundSchema;

/** @internal */
export const RunAgentModelConfigurationParameters$inboundSchema: z.ZodType<
  RunAgentModelConfigurationParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => RunAgentModelConfigurationAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => RunAgentResponseFormatJSONSchema$inboundSchema),
    z.lazy(() => RunAgentResponseFormatText$inboundSchema),
    z.lazy(() => RunAgentResponseFormatJSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => RunAgentModelConfigurationStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => RunAgentModelConfigurationThinking$inboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => RunAgentToolChoice2$inboundSchema),
    RunAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(RunAgentModelConfigurationModalities$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type RunAgentModelConfigurationParameters$Outbound = {
  audio?: RunAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | RunAgentResponseFormatJSONSchema$Outbound
    | RunAgentResponseFormatText$Outbound
    | RunAgentResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | RunAgentModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: RunAgentModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: RunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const RunAgentModelConfigurationParameters$outboundSchema: z.ZodType<
  RunAgentModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => RunAgentModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => RunAgentResponseFormatJSONSchema$outboundSchema),
    z.lazy(() => RunAgentResponseFormatText$outboundSchema),
    z.lazy(() => RunAgentResponseFormatJSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => RunAgentModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => RunAgentModelConfigurationThinking$outboundSchema)
    .optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => RunAgentToolChoice2$outboundSchema),
    RunAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(
    z.array(RunAgentModelConfigurationModalities$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function runAgentModelConfigurationParametersToJSON(
  runAgentModelConfigurationParameters: RunAgentModelConfigurationParameters,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationParameters$outboundSchema.parse(
      runAgentModelConfigurationParameters,
    ),
  );
}
export function runAgentModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentModelConfigurationParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfigurationRetry$inboundSchema: z.ZodType<
  RunAgentModelConfigurationRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type RunAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const RunAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  RunAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function runAgentModelConfigurationRetryToJSON(
  runAgentModelConfigurationRetry: RunAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    RunAgentModelConfigurationRetry$outboundSchema.parse(
      runAgentModelConfigurationRetry,
    ),
  );
}
export function runAgentModelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfigurationRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentModelConfigurationRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfiguration2$inboundSchema: z.ZodType<
  RunAgentModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => RunAgentModelConfigurationParameters$inboundSchema)
    .optional(),
  retry: z.lazy(() => RunAgentModelConfigurationRetry$inboundSchema).optional(),
});
/** @internal */
export type RunAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: RunAgentModelConfigurationParameters$Outbound | undefined;
  retry?: RunAgentModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const RunAgentModelConfiguration2$outboundSchema: z.ZodType<
  RunAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => RunAgentModelConfigurationParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => RunAgentModelConfigurationRetry$outboundSchema)
    .optional(),
});

export function runAgentModelConfiguration2ToJSON(
  runAgentModelConfiguration2: RunAgentModelConfiguration2,
): string {
  return JSON.stringify(
    RunAgentModelConfiguration2$outboundSchema.parse(
      runAgentModelConfiguration2,
    ),
  );
}
export function runAgentModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const RunAgentModelConfiguration$inboundSchema: z.ZodType<
  RunAgentModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type RunAgentModelConfiguration$Outbound =
  | RunAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const RunAgentModelConfiguration$outboundSchema: z.ZodType<
  RunAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  RunAgentModelConfiguration
> = z.union([
  z.lazy(() => RunAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function runAgentModelConfigurationToJSON(
  runAgentModelConfiguration: RunAgentModelConfiguration,
): string {
  return JSON.stringify(
    RunAgentModelConfiguration$outboundSchema.parse(runAgentModelConfiguration),
  );
}
export function runAgentModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentModelConfiguration' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(RunAgentFallbackModelConfigurationVoice);
/** @internal */
export const RunAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationVoice> =
    RunAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(RunAgentFallbackModelConfigurationFormat);
/** @internal */
export const RunAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationFormat> =
    RunAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationAudio$inboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: RunAgentFallbackModelConfigurationVoice$inboundSchema,
  format: RunAgentFallbackModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type RunAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const RunAgentFallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationAudio
> = z.object({
  voice: RunAgentFallbackModelConfigurationVoice$outboundSchema,
  format: RunAgentFallbackModelConfigurationFormat$outboundSchema,
});

export function runAgentFallbackModelConfigurationAudioToJSON(
  runAgentFallbackModelConfigurationAudio:
    RunAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      runAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function runAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  > = z.nativeEnum(
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType,
  );
/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType
  > =
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.nullable(z.boolean()).optional(),
  });
/** @internal */
export type RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict?: boolean | null | undefined;
  };

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.nullable(z.boolean()).optional(),
  });

export function runAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  runAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(runAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}
export function runAgentResponseFormatAgentsRequestRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$inboundSchema,
    json_schema: z.lazy(() =>
      RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type RunAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: string;
  json_schema:
    RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    RunAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    RunAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type:
      RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsFallbackModelConfigurationType$outboundSchema,
    jsonSchema: z.lazy(() =>
      RunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function runAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  runAgentResponseFormatAgentsRequestJSONSchema:
    RunAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      runAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}
export function runAgentResponseFormatAgentsRequestJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentResponseFormatAgentsRequestJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentResponseFormatAgentsRequestJSONSchema' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > = z.nativeEnum(
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType,
  );
/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType
  > =
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatAgentsJSONObject$inboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$inboundSchema,
});
/** @internal */
export type RunAgentResponseFormatAgentsJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const RunAgentResponseFormatAgentsJSONObject$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsJSONObject$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsJSONObject
> = z.object({
  type:
    RunAgentResponseFormatAgentsRequestRequestBodyFallbackModelsType$outboundSchema,
});

export function runAgentResponseFormatAgentsJSONObjectToJSON(
  runAgentResponseFormatAgentsJSONObject:
    RunAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      runAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function runAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatAgentsJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentResponseFormatAgentsJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentResponseFormatAgentsRequestRequestBodyType> = z
    .nativeEnum(RunAgentResponseFormatAgentsRequestRequestBodyType);
/** @internal */
export const RunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentResponseFormatAgentsRequestRequestBodyType> =
    RunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const RunAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentResponseFormatAgentsRequestRequestBodyType$inboundSchema,
});
/** @internal */
export type RunAgentResponseFormatAgentsText$Outbound = {
  type: string;
};

/** @internal */
export const RunAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  RunAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  RunAgentResponseFormatAgentsText
> = z.object({
  type: RunAgentResponseFormatAgentsRequestRequestBodyType$outboundSchema,
});

export function runAgentResponseFormatAgentsTextToJSON(
  runAgentResponseFormatAgentsText: RunAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    RunAgentResponseFormatAgentsText$outboundSchema.parse(
      runAgentResponseFormatAgentsText,
    ),
  );
}
export function runAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => RunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsJSONObject$inboundSchema),
  ]);
/** @internal */
export type RunAgentFallbackModelConfigurationResponseFormat$Outbound =
  | RunAgentResponseFormatAgentsRequestJSONSchema$Outbound
  | RunAgentResponseFormatAgentsText$Outbound
  | RunAgentResponseFormatAgentsJSONObject$Outbound;

/** @internal */
export const RunAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => RunAgentResponseFormatAgentsJSONObject$outboundSchema),
  ]);

export function runAgentFallbackModelConfigurationResponseFormatToJSON(
  runAgentFallbackModelConfigurationResponseFormat:
    RunAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      runAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function runAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationStop$inboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type RunAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const RunAgentFallbackModelConfigurationStop$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function runAgentFallbackModelConfigurationStopToJSON(
  runAgentFallbackModelConfigurationStop:
    RunAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationStop$outboundSchema.parse(
      runAgentFallbackModelConfigurationStop,
    ),
  );
}
export function runAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentFallbackModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type RunAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function runAgentFallbackModelConfigurationStreamOptionsToJSON(
  runAgentFallbackModelConfigurationStreamOptions:
    RunAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      runAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function runAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationType> = z.nativeEnum(
    RunAgentFallbackModelConfigurationType,
  );
/** @internal */
export const RunAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationType> =
    RunAgentFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationThinkingLevel> = z
    .nativeEnum(RunAgentFallbackModelConfigurationThinkingLevel);
/** @internal */
export const RunAgentFallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationThinkingLevel> =
    RunAgentFallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<RunAgentFallbackModelConfigurationThinking, z.ZodTypeDef, unknown> =
    z.object({
      type: RunAgentFallbackModelConfigurationType$inboundSchema,
      budget_tokens: z.number(),
      thinking_level:
        RunAgentFallbackModelConfigurationThinkingLevel$inboundSchema
          .optional(),
    }).transform((v) => {
      return remap$(v, {
        "budget_tokens": "budgetTokens",
        "thinking_level": "thinkingLevel",
      });
    });
/** @internal */
export type RunAgentFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationThinking
  > = z.object({
    type: RunAgentFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
    thinkingLevel:
      RunAgentFallbackModelConfigurationThinkingLevel$outboundSchema.optional(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
      thinkingLevel: "thinking_level",
    });
  });

export function runAgentFallbackModelConfigurationThinkingToJSON(
  runAgentFallbackModelConfigurationThinking:
    RunAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      runAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function runAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgentsType
> = z.nativeEnum(RunAgentToolChoiceAgentsType);
/** @internal */
export const RunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgentsType
> = RunAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const RunAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  RunAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type RunAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const RunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  RunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function runAgentToolChoiceAgentsFunctionToJSON(
  runAgentToolChoiceAgentsFunction: RunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    RunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      runAgentToolChoiceAgentsFunction,
    ),
  );
}
export function runAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  RunAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type RunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: RunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const RunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  RunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  RunAgentToolChoiceAgents2
> = z.object({
  type: RunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => RunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function runAgentToolChoiceAgents2ToJSON(
  runAgentToolChoiceAgents2: RunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    RunAgentToolChoiceAgents2$outboundSchema.parse(runAgentToolChoiceAgents2),
  );
}
export function runAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const RunAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgents1
> = z.nativeEnum(RunAgentToolChoiceAgents1);
/** @internal */
export const RunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolChoiceAgents1
> = RunAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => RunAgentToolChoiceAgents2$inboundSchema),
    RunAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type RunAgentFallbackModelConfigurationToolChoice$Outbound =
  | RunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const RunAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => RunAgentToolChoiceAgents2$outboundSchema),
    RunAgentToolChoiceAgents1$outboundSchema,
  ]);

export function runAgentFallbackModelConfigurationToolChoiceToJSON(
  runAgentFallbackModelConfigurationToolChoice:
    RunAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      runAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function runAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(RunAgentFallbackModelConfigurationModalities);
/** @internal */
export const RunAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentFallbackModelConfigurationModalities> =
    RunAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const RunAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => RunAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => RunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema),
      z.lazy(() => RunAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => RunAgentResponseFormatAgentsJSONObject$inboundSchema),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        RunAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      RunAgentFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => RunAgentToolChoiceAgents2$inboundSchema),
      RunAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(RunAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type RunAgentFallbackModelConfigurationParameters$Outbound = {
  audio?: RunAgentFallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | RunAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | RunAgentResponseFormatAgentsText$Outbound
    | RunAgentResponseFormatAgentsJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | RunAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: RunAgentFallbackModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: RunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    RunAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    RunAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => RunAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        RunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
      z.lazy(() => RunAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => RunAgentResponseFormatAgentsJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        RunAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      RunAgentFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => RunAgentToolChoiceAgents2$outboundSchema),
      RunAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(RunAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function runAgentFallbackModelConfigurationParametersToJSON(
  runAgentFallbackModelConfigurationParameters:
    RunAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      runAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function runAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  RunAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RunAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    RunAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type RunAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | RunAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const RunAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    RunAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
});

export function runAgentFallbackModelConfiguration2ToJSON(
  runAgentFallbackModelConfiguration2: RunAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfiguration2$outboundSchema.parse(
      runAgentFallbackModelConfiguration2,
    ),
  );
}
export function runAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentFallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const RunAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type RunAgentFallbackModelConfiguration$Outbound =
  | RunAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const RunAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  RunAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  RunAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => RunAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function runAgentFallbackModelConfigurationToJSON(
  runAgentFallbackModelConfiguration: RunAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    RunAgentFallbackModelConfiguration$outboundSchema.parse(
      runAgentFallbackModelConfiguration,
    ),
  );
}
export function runAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentFallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentFallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const RunAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleToolMessage
> = z.nativeEnum(RunAgentRoleToolMessage);
/** @internal */
export const RunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleToolMessage
> = RunAgentRoleToolMessage$inboundSchema;

/** @internal */
export const RunAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleUserMessage
> = z.nativeEnum(RunAgentRoleUserMessage);
/** @internal */
export const RunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentRoleUserMessage
> = RunAgentRoleUserMessage$inboundSchema;

/** @internal */
export const RunAgentRole$inboundSchema: z.ZodType<
  RunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  RunAgentRoleUserMessage$inboundSchema,
  RunAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type RunAgentRole$Outbound = string | string;

/** @internal */
export const RunAgentRole$outboundSchema: z.ZodType<
  RunAgentRole$Outbound,
  z.ZodTypeDef,
  RunAgentRole
> = z.union([
  RunAgentRoleUserMessage$outboundSchema,
  RunAgentRoleToolMessage$outboundSchema,
]);

export function runAgentRoleToJSON(runAgentRole: RunAgentRole): string {
  return JSON.stringify(RunAgentRole$outboundSchema.parse(runAgentRole));
}
export function runAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentRole' from JSON`,
  );
}

/** @internal */
export const RunAgentPublicMessagePartAgentsRequestKind$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentPublicMessagePartAgentsRequestKind> = z
    .nativeEnum(RunAgentPublicMessagePartAgentsRequestKind);
/** @internal */
export const RunAgentPublicMessagePartAgentsRequestKind$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentPublicMessagePartAgentsRequestKind> =
    RunAgentPublicMessagePartAgentsRequestKind$inboundSchema;

/** @internal */
export const PublicMessagePartToolResultPart$inboundSchema: z.ZodType<
  PublicMessagePartToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPublicMessagePartAgentsRequestKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type PublicMessagePartToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PublicMessagePartToolResultPart$outboundSchema: z.ZodType<
  PublicMessagePartToolResultPart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartToolResultPart
> = z.object({
  kind: RunAgentPublicMessagePartAgentsRequestKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function publicMessagePartToolResultPartToJSON(
  publicMessagePartToolResultPart: PublicMessagePartToolResultPart,
): string {
  return JSON.stringify(
    PublicMessagePartToolResultPart$outboundSchema.parse(
      publicMessagePartToolResultPart,
    ),
  );
}
export function publicMessagePartToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartToolResultPart' from JSON`,
  );
}

/** @internal */
export const RunAgentPublicMessagePartAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPublicMessagePartAgentsKind
> = z.nativeEnum(RunAgentPublicMessagePartAgentsKind);
/** @internal */
export const RunAgentPublicMessagePartAgentsKind$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentPublicMessagePartAgentsKind> =
    RunAgentPublicMessagePartAgentsKind$inboundSchema;

/** @internal */
export const FileFileInURIFormat$inboundSchema: z.ZodType<
  FileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileFileInURIFormat$outboundSchema: z.ZodType<
  FileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  FileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileFileInURIFormatToJSON(
  fileFileInURIFormat: FileFileInURIFormat,
): string {
  return JSON.stringify(
    FileFileInURIFormat$outboundSchema.parse(fileFileInURIFormat),
  );
}
export function fileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const FileBinaryFormat$inboundSchema: z.ZodType<
  FileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileBinaryFormat$outboundSchema: z.ZodType<
  FileBinaryFormat$Outbound,
  z.ZodTypeDef,
  FileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileBinaryFormatToJSON(
  fileBinaryFormat: FileBinaryFormat,
): string {
  return JSON.stringify(
    FileBinaryFormat$outboundSchema.parse(fileBinaryFormat),
  );
}
export function fileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const RunAgentPublicMessagePartFile$inboundSchema: z.ZodType<
  RunAgentPublicMessagePartFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FileBinaryFormat$inboundSchema),
  z.lazy(() => FileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type RunAgentPublicMessagePartFile$Outbound =
  | FileBinaryFormat$Outbound
  | FileFileInURIFormat$Outbound;

/** @internal */
export const RunAgentPublicMessagePartFile$outboundSchema: z.ZodType<
  RunAgentPublicMessagePartFile$Outbound,
  z.ZodTypeDef,
  RunAgentPublicMessagePartFile
> = z.union([
  z.lazy(() => FileBinaryFormat$outboundSchema),
  z.lazy(() => FileFileInURIFormat$outboundSchema),
]);

export function runAgentPublicMessagePartFileToJSON(
  runAgentPublicMessagePartFile: RunAgentPublicMessagePartFile,
): string {
  return JSON.stringify(
    RunAgentPublicMessagePartFile$outboundSchema.parse(
      runAgentPublicMessagePartFile,
    ),
  );
}
export function runAgentPublicMessagePartFileFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentPublicMessagePartFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentPublicMessagePartFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentPublicMessagePartFile' from JSON`,
  );
}

/** @internal */
export const PublicMessagePartFilePart$inboundSchema: z.ZodType<
  PublicMessagePartFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPublicMessagePartAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => FileBinaryFormat$inboundSchema),
    z.lazy(() => FileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type PublicMessagePartFilePart$Outbound = {
  kind: string;
  file: FileBinaryFormat$Outbound | FileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const PublicMessagePartFilePart$outboundSchema: z.ZodType<
  PublicMessagePartFilePart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartFilePart
> = z.object({
  kind: RunAgentPublicMessagePartAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => FileBinaryFormat$outboundSchema),
    z.lazy(() => FileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function publicMessagePartFilePartToJSON(
  publicMessagePartFilePart: PublicMessagePartFilePart,
): string {
  return JSON.stringify(
    PublicMessagePartFilePart$outboundSchema.parse(publicMessagePartFilePart),
  );
}
export function publicMessagePartFilePartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartFilePart' from JSON`,
  );
}

/** @internal */
export const RunAgentPublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPublicMessagePartKind
> = z.nativeEnum(RunAgentPublicMessagePartKind);
/** @internal */
export const RunAgentPublicMessagePartKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPublicMessagePartKind
> = RunAgentPublicMessagePartKind$inboundSchema;

/** @internal */
export const PublicMessagePartTextPart$inboundSchema: z.ZodType<
  PublicMessagePartTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPublicMessagePartKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type PublicMessagePartTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const PublicMessagePartTextPart$outboundSchema: z.ZodType<
  PublicMessagePartTextPart$Outbound,
  z.ZodTypeDef,
  PublicMessagePartTextPart
> = z.object({
  kind: RunAgentPublicMessagePartKind$outboundSchema,
  text: z.string(),
});

export function publicMessagePartTextPartToJSON(
  publicMessagePartTextPart: PublicMessagePartTextPart,
): string {
  return JSON.stringify(
    PublicMessagePartTextPart$outboundSchema.parse(publicMessagePartTextPart),
  );
}
export function publicMessagePartTextPartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartTextPart' from JSON`,
  );
}

/** @internal */
export const RunAgentPublicMessagePart$inboundSchema: z.ZodType<
  RunAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => PublicMessagePartTextPart$inboundSchema),
  z.lazy(() => PublicMessagePartFilePart$inboundSchema),
  z.lazy(() => PublicMessagePartToolResultPart$inboundSchema),
]);
/** @internal */
export type RunAgentPublicMessagePart$Outbound =
  | PublicMessagePartTextPart$Outbound
  | PublicMessagePartFilePart$Outbound
  | PublicMessagePartToolResultPart$Outbound;

/** @internal */
export const RunAgentPublicMessagePart$outboundSchema: z.ZodType<
  RunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  RunAgentPublicMessagePart
> = z.union([
  z.lazy(() => PublicMessagePartTextPart$outboundSchema),
  z.lazy(() => PublicMessagePartFilePart$outboundSchema),
  z.lazy(() => PublicMessagePartToolResultPart$outboundSchema),
]);

export function runAgentPublicMessagePartToJSON(
  runAgentPublicMessagePart: RunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    RunAgentPublicMessagePart$outboundSchema.parse(runAgentPublicMessagePart),
  );
}
export function runAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const RunAgentMessage$inboundSchema: z.ZodType<
  RunAgentMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RunAgentRoleUserMessage$inboundSchema,
    RunAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => PublicMessagePartTextPart$inboundSchema),
      z.lazy(() => PublicMessagePartFilePart$inboundSchema),
      z.lazy(() => PublicMessagePartToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type RunAgentMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | PublicMessagePartTextPart$Outbound
    | PublicMessagePartFilePart$Outbound
    | PublicMessagePartToolResultPart$Outbound
  >;
};

/** @internal */
export const RunAgentMessage$outboundSchema: z.ZodType<
  RunAgentMessage$Outbound,
  z.ZodTypeDef,
  RunAgentMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RunAgentRoleUserMessage$outboundSchema,
    RunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => PublicMessagePartTextPart$outboundSchema),
      z.lazy(() => PublicMessagePartFilePart$outboundSchema),
      z.lazy(() => PublicMessagePartToolResultPart$outboundSchema),
    ]),
  ),
});

export function runAgentMessageToJSON(
  runAgentMessage: RunAgentMessage,
): string {
  return JSON.stringify(RunAgentMessage$outboundSchema.parse(runAgentMessage));
}
export function runAgentMessageFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentMessage' from JSON`,
  );
}

/** @internal */
export const RunAgentContact$inboundSchema: z.ZodType<
  RunAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type RunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentContact$outboundSchema: z.ZodType<
  RunAgentContact$Outbound,
  z.ZodTypeDef,
  RunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function runAgentContactToJSON(
  runAgentContact: RunAgentContact,
): string {
  return JSON.stringify(RunAgentContact$outboundSchema.parse(runAgentContact));
}
export function runAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentContact' from JSON`,
  );
}

/** @internal */
export const RunAgentThread$inboundSchema: z.ZodType<
  RunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type RunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const RunAgentThread$outboundSchema: z.ZodType<
  RunAgentThread$Outbound,
  z.ZodTypeDef,
  RunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function runAgentThreadToJSON(runAgentThread: RunAgentThread): string {
  return JSON.stringify(RunAgentThread$outboundSchema.parse(runAgentThread));
}
export function runAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentThread' from JSON`,
  );
}

/** @internal */
export const RunAgentMemory$inboundSchema: z.ZodType<
  RunAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type RunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const RunAgentMemory$outboundSchema: z.ZodType<
  RunAgentMemory$Outbound,
  z.ZodTypeDef,
  RunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function runAgentMemoryToJSON(runAgentMemory: RunAgentMemory): string {
  return JSON.stringify(RunAgentMemory$outboundSchema.parse(runAgentMemory));
}
export function runAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentMemory' from JSON`,
  );
}

/** @internal */
export const RunAgentKnowledgeBases$inboundSchema: z.ZodType<
  RunAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type RunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const RunAgentKnowledgeBases$outboundSchema: z.ZodType<
  RunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  RunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function runAgentKnowledgeBasesToJSON(
  runAgentKnowledgeBases: RunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    RunAgentKnowledgeBases$outboundSchema.parse(runAgentKnowledgeBases),
  );
}
export function runAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const RunAgentTeamOfAgents$inboundSchema: z.ZodType<
  RunAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type RunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const RunAgentTeamOfAgents$outboundSchema: z.ZodType<
  RunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  RunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function runAgentTeamOfAgentsToJSON(
  runAgentTeamOfAgents: RunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    RunAgentTeamOfAgents$outboundSchema.parse(runAgentTeamOfAgents),
  );
}
export function runAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema;

/** @internal */
export const AgentToolInputRunHeaders$inboundSchema: z.ZodType<
  AgentToolInputRunHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type AgentToolInputRunHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const AgentToolInputRunHeaders$outboundSchema: z.ZodType<
  AgentToolInputRunHeaders$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function agentToolInputRunHeadersToJSON(
  agentToolInputRunHeaders: AgentToolInputRunHeaders,
): string {
  return JSON.stringify(
    AgentToolInputRunHeaders$outboundSchema.parse(agentToolInputRunHeaders),
  );
}
export function agentToolInputRunHeadersFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHeaders' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema;

/** @internal */
export const Schema$inboundSchema: z.ZodType<Schema, z.ZodTypeDef, unknown> = z
  .object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$inboundSchema,
    properties: z.record(z.any()).optional(),
    required: z.array(z.string()).optional(),
  });
/** @internal */
export type Schema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const Schema$outboundSchema: z.ZodType<
  Schema$Outbound,
  z.ZodTypeDef,
  Schema
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15McpType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function schemaToJSON(schema: Schema): string {
  return JSON.stringify(Schema$outboundSchema.parse(schema));
}
export function schemaFromJSON(
  jsonString: string,
): SafeParseResult<Schema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Schema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Schema' from JSON`,
  );
}

/** @internal */
export const Tools$inboundSchema: z.ZodType<Tools, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string().default("01KAD4TR9Q17HN5ZNE6N20V4SW"),
    name: z.string(),
    description: z.string().optional(),
    schema: z.lazy(() => Schema$inboundSchema),
  });
/** @internal */
export type Tools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: Schema$Outbound;
};

/** @internal */
export const Tools$outboundSchema: z.ZodType<
  Tools$Outbound,
  z.ZodTypeDef,
  Tools
> = z.object({
  id: z.string().default("01KAD4TR9Q17HN5ZNE6N20V4SW"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => Schema$outboundSchema),
});

export function toolsToJSON(tools: Tools): string {
  return JSON.stringify(Tools$outboundSchema.parse(tools));
}
export function toolsFromJSON(
  jsonString: string,
): SafeParseResult<Tools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tools' from JSON`,
  );
}

/** @internal */
export const ConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = z.nativeEnum(ConnectionType);
/** @internal */
export const ConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof ConnectionType
> = ConnectionType$inboundSchema;

/** @internal */
export const Mcp$inboundSchema: z.ZodType<Mcp, z.ZodTypeDef, unknown> = z
  .object({
    server_url: z.string(),
    headers: z.record(z.lazy(() => AgentToolInputRunHeaders$inboundSchema))
      .optional(),
    tools: z.array(z.lazy(() => Tools$inboundSchema)),
    connection_type: ConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_url": "serverUrl",
      "connection_type": "connectionType",
    });
  });
/** @internal */
export type Mcp$Outbound = {
  server_url: string;
  headers?: { [k: string]: AgentToolInputRunHeaders$Outbound } | undefined;
  tools: Array<Tools$Outbound>;
  connection_type: string;
};

/** @internal */
export const Mcp$outboundSchema: z.ZodType<Mcp$Outbound, z.ZodTypeDef, Mcp> = z
  .object({
    serverUrl: z.string(),
    headers: z.record(z.lazy(() => AgentToolInputRunHeaders$outboundSchema))
      .optional(),
    tools: z.array(z.lazy(() => Tools$outboundSchema)),
    connectionType: ConnectionType$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      serverUrl: "server_url",
      connectionType: "connection_type",
    });
  });

export function mcpToJSON(mcp: Mcp): string {
  return JSON.stringify(Mcp$outboundSchema.parse(mcp));
}
export function mcpFromJSON(
  jsonString: string,
): SafeParseResult<Mcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Mcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Mcp' from JSON`,
  );
}

/** @internal */
export const MCPToolRun$inboundSchema: z.ZodType<
  MCPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => Mcp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type MCPToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  mcp: Mcp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const MCPToolRun$outboundSchema: z.ZodType<
  MCPToolRun$Outbound,
  z.ZodTypeDef,
  MCPToolRun
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools15Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => Mcp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function mcpToolRunToJSON(mcpToolRun: MCPToolRun): string {
  return JSON.stringify(MCPToolRun$outboundSchema.parse(mcpToolRun));
}
export function mcpToolRunFromJSON(
  jsonString: string,
): SafeParseResult<MCPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MCPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MCPToolRun' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema;

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema;

/** @internal */
export const RunAgentAgentToolInputRunParameters$inboundSchema: z.ZodType<
  RunAgentAgentToolInputRunParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type RunAgentAgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const RunAgentAgentToolInputRunParameters$outboundSchema: z.ZodType<
  RunAgentAgentToolInputRunParameters$Outbound,
  z.ZodTypeDef,
  RunAgentAgentToolInputRunParameters
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function runAgentAgentToolInputRunParametersToJSON(
  runAgentAgentToolInputRunParameters: RunAgentAgentToolInputRunParameters,
): string {
  return JSON.stringify(
    RunAgentAgentToolInputRunParameters$outboundSchema.parse(
      runAgentAgentToolInputRunParameters,
    ),
  );
}
export function runAgentAgentToolInputRunParametersFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentAgentToolInputRunParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RunAgentAgentToolInputRunParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentAgentToolInputRunParameters' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunFunction$inboundSchema: z.ZodType<
  AgentToolInputRunFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RunAgentAgentToolInputRunParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type AgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: RunAgentAgentToolInputRunParameters$Outbound | undefined;
};

/** @internal */
export const AgentToolInputRunFunction$outboundSchema: z.ZodType<
  AgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RunAgentAgentToolInputRunParameters$outboundSchema)
    .optional(),
});

export function agentToolInputRunFunctionToJSON(
  agentToolInputRunFunction: AgentToolInputRunFunction,
): string {
  return JSON.stringify(
    AgentToolInputRunFunction$outboundSchema.parse(agentToolInputRunFunction),
  );
}
export function agentToolInputRunFunctionFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunFunction' from JSON`,
  );
}

/** @internal */
export const FunctionToolRun$inboundSchema: z.ZodType<
  FunctionToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => AgentToolInputRunFunction$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type FunctionToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: AgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const FunctionToolRun$outboundSchema: z.ZodType<
  FunctionToolRun$Outbound,
  z.ZodTypeDef,
  FunctionToolRun
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => AgentToolInputRunFunction$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function functionToolRunToJSON(
  functionToolRun: FunctionToolRun,
): string {
  return JSON.stringify(FunctionToolRun$outboundSchema.parse(functionToolRun));
}
export function functionToolRunFromJSON(
  jsonString: string,
): SafeParseResult<FunctionToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionToolRun' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema;

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema;

/** @internal */
export const AgentToolInputRunParameters$inboundSchema: z.ZodType<
  AgentToolInputRunParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type AgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const AgentToolInputRunParameters$outboundSchema: z.ZodType<
  AgentToolInputRunParameters$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunParameters
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function agentToolInputRunParametersToJSON(
  agentToolInputRunParameters: AgentToolInputRunParameters,
): string {
  return JSON.stringify(
    AgentToolInputRunParameters$outboundSchema.parse(
      agentToolInputRunParameters,
    ),
  );
}
export function agentToolInputRunParametersFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunParameters' from JSON`,
  );
}

/** @internal */
export const Language$inboundSchema: z.ZodNativeEnum<typeof Language> = z
  .nativeEnum(Language);
/** @internal */
export const Language$outboundSchema: z.ZodNativeEnum<typeof Language> =
  Language$inboundSchema;

/** @internal */
export const CodeTool$inboundSchema: z.ZodType<
  CodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() => AgentToolInputRunParameters$inboundSchema)
    .optional(),
  language: Language$inboundSchema,
  code: z.string(),
});
/** @internal */
export type CodeTool$Outbound = {
  parameters?: AgentToolInputRunParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const CodeTool$outboundSchema: z.ZodType<
  CodeTool$Outbound,
  z.ZodTypeDef,
  CodeTool
> = z.object({
  parameters: z.lazy(() => AgentToolInputRunParameters$outboundSchema)
    .optional(),
  language: Language$outboundSchema,
  code: z.string(),
});

export function codeToolToJSON(codeTool: CodeTool): string {
  return JSON.stringify(CodeTool$outboundSchema.parse(codeTool));
}
export function codeToolFromJSON(
  jsonString: string,
): SafeParseResult<CodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CodeTool' from JSON`,
  );
}

/** @internal */
export const CodeToolRun$inboundSchema: z.ZodType<
  CodeToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  code_tool: z.lazy(() => CodeTool$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "code_tool": "codeTool",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type CodeToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: CodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const CodeToolRun$outboundSchema: z.ZodType<
  CodeToolRun$Outbound,
  z.ZodTypeDef,
  CodeToolRun
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => CodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function codeToolRunToJSON(codeToolRun: CodeToolRun): string {
  return JSON.stringify(CodeToolRun$outboundSchema.parse(codeToolRun));
}
export function codeToolRunFromJSON(
  jsonString: string,
): SafeParseResult<CodeToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CodeToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CodeToolRun' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema;

/** @internal */
export const Method$inboundSchema: z.ZodNativeEnum<typeof Method> = z
  .nativeEnum(Method);
/** @internal */
export const Method$outboundSchema: z.ZodNativeEnum<typeof Method> =
  Method$inboundSchema;

/** @internal */
export const Headers2$inboundSchema: z.ZodType<
  Headers2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type Headers2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const Headers2$outboundSchema: z.ZodType<
  Headers2$Outbound,
  z.ZodTypeDef,
  Headers2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function headers2ToJSON(headers2: Headers2): string {
  return JSON.stringify(Headers2$outboundSchema.parse(headers2));
}
export function headers2FromJSON(
  jsonString: string,
): SafeParseResult<Headers2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Headers2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Headers2' from JSON`,
  );
}

/** @internal */
export const Headers$inboundSchema: z.ZodType<Headers, z.ZodTypeDef, unknown> =
  z.union([z.lazy(() => Headers2$inboundSchema), z.string()]);
/** @internal */
export type Headers$Outbound = Headers2$Outbound | string;

/** @internal */
export const Headers$outboundSchema: z.ZodType<
  Headers$Outbound,
  z.ZodTypeDef,
  Headers
> = z.union([z.lazy(() => Headers2$outboundSchema), z.string()]);

export function headersToJSON(headers: Headers): string {
  return JSON.stringify(Headers$outboundSchema.parse(headers));
}
export function headersFromJSON(
  jsonString: string,
): SafeParseResult<Headers, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Headers$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Headers' from JSON`,
  );
}

/** @internal */
export const Blueprint$inboundSchema: z.ZodType<
  Blueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: Method$inboundSchema,
  headers: z.record(z.union([z.lazy(() => Headers2$inboundSchema), z.string()]))
    .optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type Blueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: Headers2$Outbound | string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const Blueprint$outboundSchema: z.ZodType<
  Blueprint$Outbound,
  z.ZodTypeDef,
  Blueprint
> = z.object({
  url: z.string(),
  method: Method$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => Headers2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function blueprintToJSON(blueprint: Blueprint): string {
  return JSON.stringify(Blueprint$outboundSchema.parse(blueprint));
}
export function blueprintFromJSON(
  jsonString: string,
): SafeParseResult<Blueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Blueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Blueprint' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema;

/** @internal */
export const DefaultValue$inboundSchema: z.ZodType<
  DefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DefaultValue$outboundSchema: z.ZodType<
  DefaultValue$Outbound,
  z.ZodTypeDef,
  DefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function defaultValueToJSON(defaultValue: DefaultValue): string {
  return JSON.stringify(DefaultValue$outboundSchema.parse(defaultValue));
}
export function defaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DefaultValue' from JSON`,
  );
}

/** @internal */
export const Arguments$inboundSchema: z.ZodType<
  Arguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type Arguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const Arguments$outboundSchema: z.ZodType<
  Arguments$Outbound,
  z.ZodTypeDef,
  Arguments
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function argumentsToJSON(value: Arguments): string {
  return JSON.stringify(Arguments$outboundSchema.parse(value));
}
export function argumentsFromJSON(
  jsonString: string,
): SafeParseResult<Arguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Arguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Arguments' from JSON`,
  );
}

/** @internal */
export const Http$inboundSchema: z.ZodType<Http, z.ZodTypeDef, unknown> = z
  .object({
    blueprint: z.lazy(() => Blueprint$inboundSchema),
    arguments: z.record(z.lazy(() => Arguments$inboundSchema)).optional(),
  });
/** @internal */
export type Http$Outbound = {
  blueprint: Blueprint$Outbound;
  arguments?: { [k: string]: Arguments$Outbound } | undefined;
};

/** @internal */
export const Http$outboundSchema: z.ZodType<Http$Outbound, z.ZodTypeDef, Http> =
  z.object({
    blueprint: z.lazy(() => Blueprint$outboundSchema),
    arguments: z.record(z.lazy(() => Arguments$outboundSchema)).optional(),
  });

export function httpToJSON(http: Http): string {
  return JSON.stringify(Http$outboundSchema.parse(http));
}
export function httpFromJSON(
  jsonString: string,
): SafeParseResult<Http, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Http$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Http' from JSON`,
  );
}

/** @internal */
export const HTTPToolRun$inboundSchema: z.ZodType<
  HTTPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$inboundSchema,
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => Http$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type HTTPToolRun$Outbound = {
  type: string;
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: Http$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const HTTPToolRun$outboundSchema: z.ZodType<
  HTTPToolRun$Outbound,
  z.ZodTypeDef,
  HTTPToolRun
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12Type$outboundSchema,
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => Http$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function httpToolRunToJSON(httpToolRun: HTTPToolRun): string {
  return JSON.stringify(HTTPToolRun$outboundSchema.parse(httpToolRun));
}
export function httpToolRunFromJSON(
  jsonString: string,
): SafeParseResult<HTTPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => HTTPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'HTTPToolRun' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema;

/** @internal */
export const AgentToolInputRunCurrentDateTool$inboundSchema: z.ZodType<
  AgentToolInputRunCurrentDateTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunCurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunCurrentDateTool$outboundSchema: z.ZodType<
  AgentToolInputRunCurrentDateTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCurrentDateTool
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCurrentDateToolToJSON(
  agentToolInputRunCurrentDateTool: AgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCurrentDateTool$outboundSchema.parse(
      agentToolInputRunCurrentDateTool,
    ),
  );
}
export function agentToolInputRunCurrentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCurrentDateTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCurrentDateTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCurrentDateTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema;

/** @internal */
export const AgentToolInputRunQueryKnowledgeBaseTool$inboundSchema: z.ZodType<
  AgentToolInputRunQueryKnowledgeBaseTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  AgentToolInputRunQueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunQueryKnowledgeBaseTool
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunQueryKnowledgeBaseToolToJSON(
  agentToolInputRunQueryKnowledgeBaseTool:
    AgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      agentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}
export function agentToolInputRunQueryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputRunQueryKnowledgeBaseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunQueryKnowledgeBaseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputRunQueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema;

/** @internal */
export const AgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema:
  z.ZodType<
    AgentToolInputRunRetrieveKnowledgeBasesTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$inboundSchema,
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  agentToolInputRunRetrieveKnowledgeBasesTool:
    AgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema.parse(
      agentToolInputRunRetrieveKnowledgeBasesTool,
    ),
  );
}
export function agentToolInputRunRetrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputRunRetrieveKnowledgeBasesTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputRunRetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema;

/** @internal */
export const AgentToolInputRunDeleteMemoryDocumentTool$inboundSchema: z.ZodType<
  AgentToolInputRunDeleteMemoryDocumentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunDeleteMemoryDocumentToolToJSON(
  agentToolInputRunDeleteMemoryDocumentTool:
    AgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema.parse(
      agentToolInputRunDeleteMemoryDocumentTool,
    ),
  );
}
export function agentToolInputRunDeleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputRunDeleteMemoryDocumentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunDeleteMemoryDocumentTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputRunDeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema;

/** @internal */
export const AgentToolInputRunRetrieveMemoryStoresTool$inboundSchema: z.ZodType<
  AgentToolInputRunRetrieveMemoryStoresTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    AgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type:
      RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsToolsType$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputRunRetrieveMemoryStoresToolToJSON(
  agentToolInputRunRetrieveMemoryStoresTool:
    AgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema.parse(
      agentToolInputRunRetrieveMemoryStoresTool,
    ),
  );
}
export function agentToolInputRunRetrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputRunRetrieveMemoryStoresTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunRetrieveMemoryStoresTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputRunRetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType,
  );
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType
  > =
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema;

/** @internal */
export const AgentToolInputRunWriteMemoryStoreTool$inboundSchema: z.ZodType<
  AgentToolInputRunWriteMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunWriteMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputRunWriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunWriteMemoryStoreTool
> = z.object({
  type:
    RunAgentAgentToolInputRunAgentsRequestRequestBodySettingsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunWriteMemoryStoreToolToJSON(
  agentToolInputRunWriteMemoryStoreTool: AgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      agentToolInputRunWriteMemoryStoreTool,
    ),
  );
}
export function agentToolInputRunWriteMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunWriteMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunWriteMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunWriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = z.nativeEnum(RunAgentAgentToolInputRunAgentsRequestRequestBodyType);
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof RunAgentAgentToolInputRunAgentsRequestRequestBodyType
  > = RunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const AgentToolInputRunQueryMemoryStoreTool$inboundSchema: z.ZodType<
  AgentToolInputRunQueryMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodyType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunQueryMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputRunQueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunQueryMemoryStoreTool
> = z.object({
  type: RunAgentAgentToolInputRunAgentsRequestRequestBodyType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunQueryMemoryStoreToolToJSON(
  agentToolInputRunQueryMemoryStoreTool: AgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      agentToolInputRunQueryMemoryStoreTool,
    ),
  );
}
export function agentToolInputRunQueryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunQueryMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunQueryMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunQueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestType$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentAgentToolInputRunAgentsRequestType> = z
    .nativeEnum(RunAgentAgentToolInputRunAgentsRequestType);
/** @internal */
export const RunAgentAgentToolInputRunAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentAgentToolInputRunAgentsRequestType> =
    RunAgentAgentToolInputRunAgentsRequestType$inboundSchema;

/** @internal */
export const AgentToolInputRunRetrieveAgentsTool$inboundSchema: z.ZodType<
  AgentToolInputRunRetrieveAgentsTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentAgentToolInputRunAgentsRequestType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunRetrieveAgentsTool$outboundSchema: z.ZodType<
  AgentToolInputRunRetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunRetrieveAgentsTool
> = z.object({
  type: RunAgentAgentToolInputRunAgentsRequestType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunRetrieveAgentsToolToJSON(
  agentToolInputRunRetrieveAgentsTool: AgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    AgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      agentToolInputRunRetrieveAgentsTool,
    ),
  );
}
export function agentToolInputRunRetrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunRetrieveAgentsTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunRetrieveAgentsTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunRetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentToolInputRunAgentsType
> = z.nativeEnum(RunAgentAgentToolInputRunAgentsType);
/** @internal */
export const RunAgentAgentToolInputRunAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentAgentToolInputRunAgentsType> =
    RunAgentAgentToolInputRunAgentsType$inboundSchema;

/** @internal */
export const AgentToolInputRunCallSubAgentTool$inboundSchema: z.ZodType<
  AgentToolInputRunCallSubAgentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentAgentToolInputRunAgentsType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunCallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunCallSubAgentTool$outboundSchema: z.ZodType<
  AgentToolInputRunCallSubAgentTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCallSubAgentTool
> = z.object({
  type: RunAgentAgentToolInputRunAgentsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCallSubAgentToolToJSON(
  agentToolInputRunCallSubAgentTool: AgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      agentToolInputRunCallSubAgentTool,
    ),
  );
}
export function agentToolInputRunCallSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCallSubAgentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCallSubAgentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentToolInputRunType$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentToolInputRunType
> = z.nativeEnum(RunAgentAgentToolInputRunType);
/** @internal */
export const RunAgentAgentToolInputRunType$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentToolInputRunType
> = RunAgentAgentToolInputRunType$inboundSchema;

/** @internal */
export const AgentToolInputRunWebScraperTool$inboundSchema: z.ZodType<
  AgentToolInputRunWebScraperTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: RunAgentAgentToolInputRunType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunWebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunWebScraperTool$outboundSchema: z.ZodType<
  AgentToolInputRunWebScraperTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunWebScraperTool
> = z.object({
  type: RunAgentAgentToolInputRunType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunWebScraperToolToJSON(
  agentToolInputRunWebScraperTool: AgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    AgentToolInputRunWebScraperTool$outboundSchema.parse(
      agentToolInputRunWebScraperTool,
    ),
  );
}
export function agentToolInputRunWebScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunWebScraperTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunWebScraperTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunWebScraperTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunType$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunType
> = z.nativeEnum(AgentToolInputRunType);
/** @internal */
export const AgentToolInputRunType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunType
> = AgentToolInputRunType$inboundSchema;

/** @internal */
export const AgentToolInputRunGoogleSearchTool$inboundSchema: z.ZodType<
  AgentToolInputRunGoogleSearchTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: AgentToolInputRunType$inboundSchema,
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunGoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputRunGoogleSearchTool$outboundSchema: z.ZodType<
  AgentToolInputRunGoogleSearchTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunGoogleSearchTool
> = z.object({
  type: AgentToolInputRunType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunGoogleSearchToolToJSON(
  agentToolInputRunGoogleSearchTool: AgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    AgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      agentToolInputRunGoogleSearchTool,
    ),
  );
}
export function agentToolInputRunGoogleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunGoogleSearchTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunGoogleSearchTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunGoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRun$inboundSchema: z.ZodType<
  AgentToolInputRun,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => HTTPToolRun$inboundSchema),
  z.lazy(() => CodeToolRun$inboundSchema),
  z.lazy(() => MCPToolRun$inboundSchema),
  z.lazy(() => FunctionToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunGoogleSearchTool$inboundSchema),
  z.lazy(() => AgentToolInputRunWebScraperTool$inboundSchema),
  z.lazy(() => AgentToolInputRunCallSubAgentTool$inboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveAgentsTool$inboundSchema),
  z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$inboundSchema),
  z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$inboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$inboundSchema),
  z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$inboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema),
  z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$inboundSchema),
  z.lazy(() => AgentToolInputRunCurrentDateTool$inboundSchema),
]);
/** @internal */
export type AgentToolInputRun$Outbound =
  | HTTPToolRun$Outbound
  | CodeToolRun$Outbound
  | MCPToolRun$Outbound
  | FunctionToolRun$Outbound
  | AgentToolInputRunGoogleSearchTool$Outbound
  | AgentToolInputRunWebScraperTool$Outbound
  | AgentToolInputRunCallSubAgentTool$Outbound
  | AgentToolInputRunRetrieveAgentsTool$Outbound
  | AgentToolInputRunQueryMemoryStoreTool$Outbound
  | AgentToolInputRunWriteMemoryStoreTool$Outbound
  | AgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | AgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | AgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | AgentToolInputRunCurrentDateTool$Outbound;

/** @internal */
export const AgentToolInputRun$outboundSchema: z.ZodType<
  AgentToolInputRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRun
> = z.union([
  z.lazy(() => HTTPToolRun$outboundSchema),
  z.lazy(() => CodeToolRun$outboundSchema),
  z.lazy(() => MCPToolRun$outboundSchema),
  z.lazy(() => FunctionToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => AgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => AgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveAgentsTool$outboundSchema),
  z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => AgentToolInputRunCurrentDateTool$outboundSchema),
]);

export function agentToolInputRunToJSON(
  agentToolInputRun: AgentToolInputRun,
): string {
  return JSON.stringify(
    AgentToolInputRun$outboundSchema.parse(agentToolInputRun),
  );
}
export function agentToolInputRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRun' from JSON`,
  );
}

/** @internal */
export const RunAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolApprovalRequired
> = z.nativeEnum(RunAgentToolApprovalRequired);
/** @internal */
export const RunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentToolApprovalRequired
> = RunAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const RunAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentExecuteOn
> = z.nativeEnum(RunAgentExecuteOn);
/** @internal */
export const RunAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentExecuteOn
> = RunAgentExecuteOn$inboundSchema;

/** @internal */
export const RunAgentEvaluators$inboundSchema: z.ZodType<
  RunAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: RunAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type RunAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RunAgentEvaluators$outboundSchema: z.ZodType<
  RunAgentEvaluators$Outbound,
  z.ZodTypeDef,
  RunAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RunAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function runAgentEvaluatorsToJSON(
  runAgentEvaluators: RunAgentEvaluators,
): string {
  return JSON.stringify(
    RunAgentEvaluators$outboundSchema.parse(runAgentEvaluators),
  );
}
export function runAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsExecuteOn
> = z.nativeEnum(RunAgentAgentsExecuteOn);
/** @internal */
export const RunAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsExecuteOn
> = RunAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const RunAgentGuardrails$inboundSchema: z.ZodType<
  RunAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: RunAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type RunAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const RunAgentGuardrails$outboundSchema: z.ZodType<
  RunAgentGuardrails$Outbound,
  z.ZodTypeDef,
  RunAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: RunAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function runAgentGuardrailsToJSON(
  runAgentGuardrails: RunAgentGuardrails,
): string {
  return JSON.stringify(
    RunAgentGuardrails$outboundSchema.parse(runAgentGuardrails),
  );
}
export function runAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const RunAgentSettings$inboundSchema: z.ZodType<
  RunAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => HTTPToolRun$inboundSchema),
      z.lazy(() => CodeToolRun$inboundSchema),
      z.lazy(() => MCPToolRun$inboundSchema),
      z.lazy(() => FunctionToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunGoogleSearchTool$inboundSchema),
      z.lazy(() => AgentToolInputRunWebScraperTool$inboundSchema),
      z.lazy(() => AgentToolInputRunCallSubAgentTool$inboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveAgentsTool$inboundSchema),
      z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$inboundSchema),
      z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$inboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$inboundSchema),
      z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$inboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema),
      z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$inboundSchema),
      z.lazy(() => AgentToolInputRunCurrentDateTool$inboundSchema),
    ]),
  ).optional(),
  tool_approval_required: RunAgentToolApprovalRequired$inboundSchema.default(
    "none",
  ),
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  evaluators: z.array(z.lazy(() => RunAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => RunAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});
/** @internal */
export type RunAgentSettings$Outbound = {
  tools?:
    | Array<
      | HTTPToolRun$Outbound
      | CodeToolRun$Outbound
      | MCPToolRun$Outbound
      | FunctionToolRun$Outbound
      | AgentToolInputRunGoogleSearchTool$Outbound
      | AgentToolInputRunWebScraperTool$Outbound
      | AgentToolInputRunCallSubAgentTool$Outbound
      | AgentToolInputRunRetrieveAgentsTool$Outbound
      | AgentToolInputRunQueryMemoryStoreTool$Outbound
      | AgentToolInputRunWriteMemoryStoreTool$Outbound
      | AgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | AgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | AgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | AgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | AgentToolInputRunCurrentDateTool$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
  evaluators?: Array<RunAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<RunAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const RunAgentSettings$outboundSchema: z.ZodType<
  RunAgentSettings$Outbound,
  z.ZodTypeDef,
  RunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() => HTTPToolRun$outboundSchema),
      z.lazy(() => CodeToolRun$outboundSchema),
      z.lazy(() => MCPToolRun$outboundSchema),
      z.lazy(() => FunctionToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunGoogleSearchTool$outboundSchema),
      z.lazy(() => AgentToolInputRunWebScraperTool$outboundSchema),
      z.lazy(() => AgentToolInputRunCallSubAgentTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveAgentsTool$outboundSchema),
      z.lazy(() => AgentToolInputRunQueryMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputRunWriteMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => AgentToolInputRunDeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => AgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => AgentToolInputRunQueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => AgentToolInputRunCurrentDateTool$outboundSchema),
    ]),
  ).optional(),
  toolApprovalRequired: RunAgentToolApprovalRequired$outboundSchema.default(
    "none",
  ),
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  evaluators: z.array(z.lazy(() => RunAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => RunAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

export function runAgentSettingsToJSON(
  runAgentSettings: RunAgentSettings,
): string {
  return JSON.stringify(
    RunAgentSettings$outboundSchema.parse(runAgentSettings),
  );
}
export function runAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentSettings' from JSON`,
  );
}

/** @internal */
export const RunAgentRequestBody$inboundSchema: z.ZodType<
  RunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  task_id: z.string().optional(),
  model: z.union([
    z.lazy(() => RunAgentModelConfiguration2$inboundSchema),
    z.string(),
  ]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => RunAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => RunAgentMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => RunAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => RunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => RunAgentMemory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(z.lazy(() => RunAgentKnowledgeBases$inboundSchema))
    .optional(),
  team_of_agents: z.array(z.lazy(() => RunAgentTeamOfAgents$inboundSchema))
    .optional(),
  settings: z.lazy(() => RunAgentSettings$inboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});
/** @internal */
export type RunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: RunAgentModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<RunAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: RunAgentMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: RunAgentContact$Outbound | undefined;
  thread?: RunAgentThread$Outbound | undefined;
  memory?: RunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<RunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<RunAgentTeamOfAgents$Outbound> | undefined;
  settings: RunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentRequestBody$outboundSchema: z.ZodType<
  RunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  RunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => RunAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => RunAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => RunAgentMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => RunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => RunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => RunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(z.lazy(() => RunAgentKnowledgeBases$outboundSchema))
    .optional(),
  teamOfAgents: z.array(z.lazy(() => RunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => RunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function runAgentRequestBodyToJSON(
  runAgentRequestBody: RunAgentRequestBody,
): string {
  return JSON.stringify(
    RunAgentRequestBody$outboundSchema.parse(runAgentRequestBody),
  );
}
export function runAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const RunAgentKind$inboundSchema: z.ZodNativeEnum<typeof RunAgentKind> =
  z.nativeEnum(RunAgentKind);
/** @internal */
export const RunAgentKind$outboundSchema: z.ZodNativeEnum<typeof RunAgentKind> =
  RunAgentKind$inboundSchema;

/** @internal */
export const RunAgentState$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentState
> = z.nativeEnum(RunAgentState);
/** @internal */
export const RunAgentState$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentState
> = RunAgentState$inboundSchema;

/** @internal */
export const RunAgentAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsKind
> = z.nativeEnum(RunAgentAgentsKind);
/** @internal */
export const RunAgentAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsKind
> = RunAgentAgentsKind$inboundSchema;

/** @internal */
export const RunAgentAgentsRole$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsRole
> = z.nativeEnum(RunAgentAgentsRole);
/** @internal */
export const RunAgentAgentsRole$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentAgentsRole
> = RunAgentAgentsRole$inboundSchema;

/** @internal */
export const RunAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema:
  z.ZodNativeEnum<typeof RunAgentPartsAgentsResponse200ApplicationJSONKind> = z
    .nativeEnum(RunAgentPartsAgentsResponse200ApplicationJSONKind);
/** @internal */
export const RunAgentPartsAgentsResponse200ApplicationJSONKind$outboundSchema:
  z.ZodNativeEnum<typeof RunAgentPartsAgentsResponse200ApplicationJSONKind> =
    RunAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema;

/** @internal */
export const RunAgentParts5$inboundSchema: z.ZodType<
  RunAgentParts5,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type RunAgentParts5$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentParts5$outboundSchema: z.ZodType<
  RunAgentParts5$Outbound,
  z.ZodTypeDef,
  RunAgentParts5
> = z.object({
  kind: RunAgentPartsAgentsResponse200ApplicationJSONKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function runAgentParts5ToJSON(runAgentParts5: RunAgentParts5): string {
  return JSON.stringify(RunAgentParts5$outboundSchema.parse(runAgentParts5));
}
export function runAgentParts5FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts5' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsAgentsResponse200Kind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsResponse200Kind
> = z.nativeEnum(RunAgentPartsAgentsResponse200Kind);
/** @internal */
export const RunAgentPartsAgentsResponse200Kind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsResponse200Kind
> = RunAgentPartsAgentsResponse200Kind$inboundSchema;

/** @internal */
export const RunAgentParts4$inboundSchema: z.ZodType<
  RunAgentParts4,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPartsAgentsResponse200Kind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type RunAgentParts4$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentParts4$outboundSchema: z.ZodType<
  RunAgentParts4$Outbound,
  z.ZodTypeDef,
  RunAgentParts4
> = z.object({
  kind: RunAgentPartsAgentsResponse200Kind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

export function runAgentParts4ToJSON(runAgentParts4: RunAgentParts4): string {
  return JSON.stringify(RunAgentParts4$outboundSchema.parse(runAgentParts4));
}
export function runAgentParts4FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts4' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsAgentsResponseKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsResponseKind
> = z.nativeEnum(RunAgentPartsAgentsResponseKind);
/** @internal */
export const RunAgentPartsAgentsResponseKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsResponseKind
> = RunAgentPartsAgentsResponseKind$inboundSchema;

/** @internal */
export const RunAgentFileFileInURIFormat$inboundSchema: z.ZodType<
  RunAgentFileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type RunAgentFileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const RunAgentFileFileInURIFormat$outboundSchema: z.ZodType<
  RunAgentFileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  RunAgentFileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function runAgentFileFileInURIFormatToJSON(
  runAgentFileFileInURIFormat: RunAgentFileFileInURIFormat,
): string {
  return JSON.stringify(
    RunAgentFileFileInURIFormat$outboundSchema.parse(
      runAgentFileFileInURIFormat,
    ),
  );
}
export function runAgentFileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentFileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentFileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentFileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const RunAgentFileBinaryFormat$inboundSchema: z.ZodType<
  RunAgentFileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type RunAgentFileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const RunAgentFileBinaryFormat$outboundSchema: z.ZodType<
  RunAgentFileBinaryFormat$Outbound,
  z.ZodTypeDef,
  RunAgentFileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function runAgentFileBinaryFormatToJSON(
  runAgentFileBinaryFormat: RunAgentFileBinaryFormat,
): string {
  return JSON.stringify(
    RunAgentFileBinaryFormat$outboundSchema.parse(runAgentFileBinaryFormat),
  );
}
export function runAgentFileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentFileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentFileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentFileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsFile$inboundSchema: z.ZodType<
  RunAgentPartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentFileBinaryFormat$inboundSchema),
  z.lazy(() => RunAgentFileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type RunAgentPartsFile$Outbound =
  | RunAgentFileBinaryFormat$Outbound
  | RunAgentFileFileInURIFormat$Outbound;

/** @internal */
export const RunAgentPartsFile$outboundSchema: z.ZodType<
  RunAgentPartsFile$Outbound,
  z.ZodTypeDef,
  RunAgentPartsFile
> = z.union([
  z.lazy(() => RunAgentFileBinaryFormat$outboundSchema),
  z.lazy(() => RunAgentFileFileInURIFormat$outboundSchema),
]);

export function runAgentPartsFileToJSON(
  runAgentPartsFile: RunAgentPartsFile,
): string {
  return JSON.stringify(
    RunAgentPartsFile$outboundSchema.parse(runAgentPartsFile),
  );
}
export function runAgentPartsFileFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentPartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentPartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentPartsFile' from JSON`,
  );
}

/** @internal */
export const RunAgentParts3$inboundSchema: z.ZodType<
  RunAgentParts3,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPartsAgentsResponseKind$inboundSchema,
  file: z.union([
    z.lazy(() => RunAgentFileBinaryFormat$inboundSchema),
    z.lazy(() => RunAgentFileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type RunAgentParts3$Outbound = {
  kind: string;
  file:
    | RunAgentFileBinaryFormat$Outbound
    | RunAgentFileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentParts3$outboundSchema: z.ZodType<
  RunAgentParts3$Outbound,
  z.ZodTypeDef,
  RunAgentParts3
> = z.object({
  kind: RunAgentPartsAgentsResponseKind$outboundSchema,
  file: z.union([
    z.lazy(() => RunAgentFileBinaryFormat$outboundSchema),
    z.lazy(() => RunAgentFileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function runAgentParts3ToJSON(runAgentParts3: RunAgentParts3): string {
  return JSON.stringify(RunAgentParts3$outboundSchema.parse(runAgentParts3));
}
export function runAgentParts3FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts3' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsKind
> = z.nativeEnum(RunAgentPartsAgentsKind);
/** @internal */
export const RunAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsAgentsKind
> = RunAgentPartsAgentsKind$inboundSchema;

/** @internal */
export const RunAgentParts2$inboundSchema: z.ZodType<
  RunAgentParts2,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPartsAgentsKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type RunAgentParts2$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentParts2$outboundSchema: z.ZodType<
  RunAgentParts2$Outbound,
  z.ZodTypeDef,
  RunAgentParts2
> = z.object({
  kind: RunAgentPartsAgentsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

export function runAgentParts2ToJSON(runAgentParts2: RunAgentParts2): string {
  return JSON.stringify(RunAgentParts2$outboundSchema.parse(runAgentParts2));
}
export function runAgentParts2FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts2' from JSON`,
  );
}

/** @internal */
export const RunAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsKind
> = z.nativeEnum(RunAgentPartsKind);
/** @internal */
export const RunAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof RunAgentPartsKind
> = RunAgentPartsKind$inboundSchema;

/** @internal */
export const RunAgentParts1$inboundSchema: z.ZodType<
  RunAgentParts1,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentPartsKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type RunAgentParts1$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const RunAgentParts1$outboundSchema: z.ZodType<
  RunAgentParts1$Outbound,
  z.ZodTypeDef,
  RunAgentParts1
> = z.object({
  kind: RunAgentPartsKind$outboundSchema,
  text: z.string(),
});

export function runAgentParts1ToJSON(runAgentParts1: RunAgentParts1): string {
  return JSON.stringify(RunAgentParts1$outboundSchema.parse(runAgentParts1));
}
export function runAgentParts1FromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts1' from JSON`,
  );
}

/** @internal */
export const RunAgentParts$inboundSchema: z.ZodType<
  RunAgentParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RunAgentParts4$inboundSchema),
  z.lazy(() => RunAgentParts1$inboundSchema),
  z.lazy(() => RunAgentParts2$inboundSchema),
  z.lazy(() => RunAgentParts3$inboundSchema),
  z.lazy(() => RunAgentParts5$inboundSchema),
]);
/** @internal */
export type RunAgentParts$Outbound =
  | RunAgentParts4$Outbound
  | RunAgentParts1$Outbound
  | RunAgentParts2$Outbound
  | RunAgentParts3$Outbound
  | RunAgentParts5$Outbound;

/** @internal */
export const RunAgentParts$outboundSchema: z.ZodType<
  RunAgentParts$Outbound,
  z.ZodTypeDef,
  RunAgentParts
> = z.union([
  z.lazy(() => RunAgentParts4$outboundSchema),
  z.lazy(() => RunAgentParts1$outboundSchema),
  z.lazy(() => RunAgentParts2$outboundSchema),
  z.lazy(() => RunAgentParts3$outboundSchema),
  z.lazy(() => RunAgentParts5$outboundSchema),
]);

export function runAgentPartsToJSON(runAgentParts: RunAgentParts): string {
  return JSON.stringify(RunAgentParts$outboundSchema.parse(runAgentParts));
}
export function runAgentPartsFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentParts' from JSON`,
  );
}

/** @internal */
export const RunAgentAgentsMessage$inboundSchema: z.ZodType<
  RunAgentAgentsMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: RunAgentAgentsKind$inboundSchema,
  messageId: z.string(),
  role: RunAgentAgentsRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => RunAgentParts4$inboundSchema),
      z.lazy(() => RunAgentParts1$inboundSchema),
      z.lazy(() => RunAgentParts2$inboundSchema),
      z.lazy(() => RunAgentParts3$inboundSchema),
      z.lazy(() => RunAgentParts5$inboundSchema),
    ]),
  ),
});
/** @internal */
export type RunAgentAgentsMessage$Outbound = {
  kind: string;
  messageId: string;
  role: string;
  parts: Array<
    | RunAgentParts4$Outbound
    | RunAgentParts1$Outbound
    | RunAgentParts2$Outbound
    | RunAgentParts3$Outbound
    | RunAgentParts5$Outbound
  >;
};

/** @internal */
export const RunAgentAgentsMessage$outboundSchema: z.ZodType<
  RunAgentAgentsMessage$Outbound,
  z.ZodTypeDef,
  RunAgentAgentsMessage
> = z.object({
  kind: RunAgentAgentsKind$outboundSchema,
  messageId: z.string(),
  role: RunAgentAgentsRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => RunAgentParts4$outboundSchema),
      z.lazy(() => RunAgentParts1$outboundSchema),
      z.lazy(() => RunAgentParts2$outboundSchema),
      z.lazy(() => RunAgentParts3$outboundSchema),
      z.lazy(() => RunAgentParts5$outboundSchema),
    ]),
  ),
});

export function runAgentAgentsMessageToJSON(
  runAgentAgentsMessage: RunAgentAgentsMessage,
): string {
  return JSON.stringify(
    RunAgentAgentsMessage$outboundSchema.parse(runAgentAgentsMessage),
  );
}
export function runAgentAgentsMessageFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentAgentsMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentAgentsMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentAgentsMessage' from JSON`,
  );
}

/** @internal */
export const RunAgentStatus$inboundSchema: z.ZodType<
  RunAgentStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: RunAgentState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => RunAgentAgentsMessage$inboundSchema).optional(),
});
/** @internal */
export type RunAgentStatus$Outbound = {
  state: string;
  timestamp?: string | undefined;
  message?: RunAgentAgentsMessage$Outbound | undefined;
};

/** @internal */
export const RunAgentStatus$outboundSchema: z.ZodType<
  RunAgentStatus$Outbound,
  z.ZodTypeDef,
  RunAgentStatus
> = z.object({
  state: RunAgentState$outboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => RunAgentAgentsMessage$outboundSchema).optional(),
});

export function runAgentStatusToJSON(runAgentStatus: RunAgentStatus): string {
  return JSON.stringify(RunAgentStatus$outboundSchema.parse(runAgentStatus));
}
export function runAgentStatusFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentStatus' from JSON`,
  );
}

/** @internal */
export const RunAgentResponseBody$inboundSchema: z.ZodType<
  RunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: RunAgentKind$inboundSchema,
  status: z.lazy(() => RunAgentStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type RunAgentResponseBody$Outbound = {
  id: string;
  contextId: string;
  kind: string;
  status: RunAgentStatus$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RunAgentResponseBody$outboundSchema: z.ZodType<
  RunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  RunAgentResponseBody
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: RunAgentKind$outboundSchema,
  status: z.lazy(() => RunAgentStatus$outboundSchema),
  metadata: z.record(z.any()).optional(),
});

export function runAgentResponseBodyToJSON(
  runAgentResponseBody: RunAgentResponseBody,
): string {
  return JSON.stringify(
    RunAgentResponseBody$outboundSchema.parse(runAgentResponseBody),
  );
}
export function runAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RunAgentResponseBody' from JSON`,
  );
}
