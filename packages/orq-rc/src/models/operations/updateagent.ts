/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ModelConfigurationVoice = ClosedEnum<
  typeof ModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ModelConfigurationFormat = ClosedEnum<
  typeof ModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ModelConfigurationFormat;
};

export type UpdateAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ModelConfigurationResponseFormat =
  | UpdateAgentResponseFormatText
  | UpdateAgentResponseFormatJSONObject
  | UpdateAgentResponseFormatJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type ModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceType = ClosedEnum<
  typeof UpdateAgentToolChoiceType
>;

export type UpdateAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceType | undefined;
  function: UpdateAgentToolChoiceFunction;
};

export const UpdateAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoice1 = ClosedEnum<typeof UpdateAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ModelConfigurationToolChoice =
  | UpdateAgentToolChoice2
  | UpdateAgentToolChoice1;

export const ModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ModelConfigurationModalities = ClosedEnum<
  typeof ModelConfigurationModalities
>;

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type ModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatText
    | UpdateAgentResponseFormatJSONObject
    | UpdateAgentResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ModelConfigurationStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: UpdateAgentToolChoice2 | UpdateAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ModelConfigurationModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type ModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type UpdateAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: ModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: ModelConfigurationRetry | undefined;
};

/**
 * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
 */
export type UpdateAgentModelConfiguration =
  | UpdateAgentModelConfiguration2
  | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFallbackModelConfigurationFormat;
};

export type UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsRequestJSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentFallbackModelConfigurationResponseFormat =
  | UpdateAgentResponseFormatAgentsText
  | UpdateAgentResponseFormatAgentsJSONObject
  | UpdateAgentResponseFormatAgentsRequestJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsType = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsType
>;

export type UpdateAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsType | undefined;
  function: UpdateAgentToolChoiceAgentsFunction;
};

export const UpdateAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgents1 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentFallbackModelConfigurationToolChoice =
  | UpdateAgentToolChoiceAgents2
  | UpdateAgentToolChoiceAgents1;

export const UpdateAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type UpdateAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsText
    | UpdateAgentResponseFormatAgentsJSONObject
    | UpdateAgentResponseFormatAgentsRequestJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | UpdateAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgents2
    | UpdateAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<UpdateAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type UpdateAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: UpdateAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type UpdateAgentFallbackModelConfiguration =
  | UpdateAgentFallbackModelConfiguration2
  | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const UpdateAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type UpdateAgentToolApprovalRequired = ClosedEnum<
  typeof UpdateAgentToolApprovalRequired
>;

/**
 * Executes tools from Model Context Protocol (MCP) servers. Specify the parent MCP tool using "key" or "id", and the specific nested tool using "tool_id".
 */
export type AgentToolInputCRUDMCPTool = {
  /**
   * MCP tool type
   */
  type: "mcp";
  /**
   * The key of the parent MCP tool
   */
  key?: string | undefined;
  /**
   * The ID of the parent MCP tool
   */
  id?: string | undefined;
  /**
   * The ID of the specific nested tool within the MCP server
   */
  toolId: string;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type AgentToolInputCRUDFunctionTool = {
  /**
   * Function tool type
   */
  type: "function";
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type AgentToolInputCRUDCodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type: "code";
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type AgentToolInputCRUDHTTPTool = {
  /**
   * HTTP tool type
   */
  type: "http";
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Returns the current date and time
 */
export type AgentToolInputCRUDCurrentDateTool = {
  type: "current_date";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries knowledge bases for information
 */
export type AgentToolInputCRUDQueryKnowledgeBaseTool = {
  type: "query_knowledge_base";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available knowledge bases
 */
export type AgentToolInputCRUDRetrieveKnowledgeBasesTool = {
  type: "retrieve_knowledge_bases";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Deletes documents from memory stores
 */
export type AgentToolInputCRUDDeleteMemoryDocumentTool = {
  type: "delete_memory_document";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available memory stores
 */
export type AgentToolInputCRUDRetrieveMemoryStoresTool = {
  type: "retrieve_memory_stores";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Writes information to agent memory stores
 */
export type AgentToolInputCRUDWriteMemoryStoreTool = {
  type: "write_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries agent memory stores for context
 */
export type AgentToolInputCRUDQueryMemoryStoreTool = {
  type: "query_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Retrieves available agents in the system
 */
export type AgentToolInputCRUDRetrieveAgentsTool = {
  type: "retrieve_agents";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Delegates tasks to specialized sub-agents
 */
export type AgentToolInputCRUDCallSubAgentTool = {
  type: "call_sub_agent";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Scrapes and extracts content from web pages
 */
export type AgentToolInputCRUDWebScraperTool = {
  type: "web_scraper";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Performs Google searches to retrieve web content
 */
export type AgentToolInputCRUDGoogleSearchTool = {
  type: "google_search";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function, MCP) must reference pre-created tools by key or id.
 */
export type UpdateAgentAgentToolInputCRUD =
  | AgentToolInputCRUDGoogleSearchTool
  | AgentToolInputCRUDWebScraperTool
  | AgentToolInputCRUDCallSubAgentTool
  | AgentToolInputCRUDRetrieveAgentsTool
  | AgentToolInputCRUDQueryMemoryStoreTool
  | AgentToolInputCRUDWriteMemoryStoreTool
  | AgentToolInputCRUDRetrieveMemoryStoresTool
  | AgentToolInputCRUDDeleteMemoryDocumentTool
  | AgentToolInputCRUDRetrieveKnowledgeBasesTool
  | AgentToolInputCRUDQueryKnowledgeBaseTool
  | AgentToolInputCRUDCurrentDateTool
  | AgentToolInputCRUDHTTPTool
  | AgentToolInputCRUDCodeExecutionTool
  | AgentToolInputCRUDFunctionTool
  | AgentToolInputCRUDMCPTool;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentExecuteOn = ClosedEnum<typeof UpdateAgentExecuteOn>;

export type UpdateAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsExecuteOn
>;

export type UpdateAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsExecuteOn;
};

export type UpdateAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: UpdateAgentToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | AgentToolInputCRUDGoogleSearchTool
      | AgentToolInputCRUDWebScraperTool
      | AgentToolInputCRUDCallSubAgentTool
      | AgentToolInputCRUDRetrieveAgentsTool
      | AgentToolInputCRUDQueryMemoryStoreTool
      | AgentToolInputCRUDWriteMemoryStoreTool
      | AgentToolInputCRUDRetrieveMemoryStoresTool
      | AgentToolInputCRUDDeleteMemoryDocumentTool
      | AgentToolInputCRUDRetrieveKnowledgeBasesTool
      | AgentToolInputCRUDQueryKnowledgeBaseTool
      | AgentToolInputCRUDCurrentDateTool
      | AgentToolInputCRUDHTTPTool
      | AgentToolInputCRUDCodeExecutionTool
      | AgentToolInputCRUDFunctionTool
      | AgentToolInputCRUDMCPTool
    >
    | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<UpdateAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<UpdateAgentGuardrails> | undefined;
};

export type UpdateAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type UpdateAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

/**
 * Request body for updating an existing agent via the API. Uses simplified tool input format.
 */
export type UpdateAgentUpdateAgentRequest = {
  key?: string | undefined;
  displayName?: string | undefined;
  projectId?: string | undefined;
  role?: string | undefined;
  description?: string | undefined;
  instructions?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
   */
  model?: UpdateAgentModelConfiguration2 | string | undefined;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<UpdateAgentFallbackModelConfiguration2 | string>
    | undefined;
  settings?: UpdateAgentSettings | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  knowledgeBases?: Array<UpdateAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<UpdateAgentTeamOfAgents> | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
};

export type UpdateAgentRequest = {
  /**
   * The unique key of the agent to update
   */
  agentKey: string;
  requestBody: UpdateAgentUpdateAgentRequest;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateAgentStatus = ClosedEnum<typeof UpdateAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const UpdateAgentAgentsToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type UpdateAgentAgentsToolApprovalRequired = ClosedEnum<
  typeof UpdateAgentAgentsToolApprovalRequired
>;

export type UpdateAgentConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type UpdateAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<UpdateAgentConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsResponseExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsResponseExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsResponseExecuteOn
>;

export type UpdateAgentAgentsEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsResponseExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsResponse200ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsResponse200ExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsResponse200ExecuteOn
>;

export type UpdateAgentAgentsGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsResponse200ExecuteOn;
};

export type UpdateAgentAgentsSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: UpdateAgentAgentsToolApprovalRequired | undefined;
  tools?: Array<UpdateAgentTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<UpdateAgentAgentsEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<UpdateAgentAgentsGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentVoice = ClosedEnum<typeof UpdateAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFormat = ClosedEnum<typeof UpdateAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFormat;
};

export type UpdateAgentResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsResponse200JSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsResponseJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsResponseText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentResponseFormat =
  | UpdateAgentResponseFormatAgentsResponseText
  | UpdateAgentResponseFormatAgentsResponseJSONObject
  | UpdateAgentResponseFormatAgentsResponse200JSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsResponseType = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponseType
>;

export type UpdateAgentToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsResponseType | undefined;
  function: UpdateAgentToolChoiceAgentsResponseFunction;
};

export const UpdateAgentToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgentsResponse1 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentToolChoice =
  | UpdateAgentToolChoiceAgentsResponse2
  | UpdateAgentToolChoiceAgentsResponse1;

export const UpdateAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentModalities = ClosedEnum<typeof UpdateAgentModalities>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type UpdateAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsResponseText
    | UpdateAgentResponseFormatAgentsResponseJSONObject
    | UpdateAgentResponseFormatAgentsResponse200JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: UpdateAgentStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgentsResponse2
    | UpdateAgentToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<UpdateAgentModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type UpdateAgentRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentFallbackModelConfigurationAgentsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentFallbackModelConfigurationAgentsVoice = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFallbackModelConfigurationAgentsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFallbackModelConfigurationAgentsFormat = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentFallbackModelConfigurationAgentsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentFallbackModelConfigurationAgentsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFallbackModelConfigurationAgentsFormat;
};

export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict?: boolean | undefined;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema =
  {
    type: "json_schema";
    jsonSchema:
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema;
  };

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsResponse200JSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsResponse200Text = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentFallbackModelConfigurationAgentsResponseFormat =
  | UpdateAgentResponseFormatAgentsResponse200Text
  | UpdateAgentResponseFormatAgentsResponse200JSONObject
  | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentFallbackModelConfigurationAgentsStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentFallbackModelConfigurationAgentsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentFallbackModelConfigurationAgentsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsResponse200Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsResponse200Type = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse200Type
>;

export type UpdateAgentToolChoiceAgentsResponse200Function = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgentsResponse2002 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsResponse200Type | undefined;
  function: UpdateAgentToolChoiceAgentsResponse200Function;
};

export const UpdateAgentToolChoiceAgentsResponse2001 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgentsResponse2001 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse2001
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentFallbackModelConfigurationAgentsToolChoice =
  | UpdateAgentToolChoiceAgentsResponse2002
  | UpdateAgentToolChoiceAgentsResponse2001;

export const UpdateAgentFallbackModelConfigurationAgentsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentFallbackModelConfigurationAgentsModalities = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type UpdateAgentFallbackModelConfigurationAgentsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentFallbackModelConfigurationAgentsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsResponse200Text
    | UpdateAgentResponseFormatAgentsResponse200JSONObject
    | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | UpdateAgentFallbackModelConfigurationAgentsStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgentsResponse2002
    | UpdateAgentToolChoiceAgentsResponse2001
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<UpdateAgentFallbackModelConfigurationAgentsModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type UpdateAgentFallbackModelConfigurationAgents2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?:
    | UpdateAgentFallbackModelConfigurationAgentsParameters
    | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type UpdateAgentAgentsFallbackModelConfiguration =
  | UpdateAgentFallbackModelConfigurationAgents2
  | string;

export type UpdateAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: UpdateAgentParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: UpdateAgentRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<UpdateAgentFallbackModelConfigurationAgents2 | string>
    | null
    | undefined;
};

export type UpdateAgentAgentsTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type UpdateAgentMetrics = {
  totalCost?: number | undefined;
};

export type UpdateAgentAgentsKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

/**
 * Agent configuration successfully updated. Returns the complete updated agent manifest reflecting all changes made.
 */
export type UpdateAgentResponseBody = {
  id: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  displayName: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateAgentStatus;
  settings?: UpdateAgentAgentsSettings | undefined;
  model: UpdateAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<UpdateAgentAgentsTeamOfAgents>;
  metrics?: UpdateAgentMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<UpdateAgentAgentsKnowledgeBases> | undefined;
};

/** @internal */
export const ModelConfigurationVoice$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationVoice
> = z.nativeEnum(ModelConfigurationVoice);
/** @internal */
export const ModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationVoice
> = ModelConfigurationVoice$inboundSchema;

/** @internal */
export const ModelConfigurationFormat$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationFormat
> = z.nativeEnum(ModelConfigurationFormat);
/** @internal */
export const ModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationFormat
> = ModelConfigurationFormat$inboundSchema;

/** @internal */
export const UpdateAgentModelConfigurationAudio$inboundSchema: z.ZodType<
  UpdateAgentModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ModelConfigurationVoice$inboundSchema,
  format: ModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type UpdateAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  UpdateAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfigurationAudio
> = z.object({
  voice: ModelConfigurationVoice$outboundSchema,
  format: ModelConfigurationFormat$outboundSchema,
});

export function updateAgentModelConfigurationAudioToJSON(
  updateAgentModelConfigurationAudio: UpdateAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    UpdateAgentModelConfigurationAudio$outboundSchema.parse(
      updateAgentModelConfigurationAudio,
    ),
  );
}
export function updateAgentModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsJsonSchema$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatAgentsJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().default(false),
});
/** @internal */
export type UpdateAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsJsonSchemaToJSON(
  updateAgentResponseFormatAgentsJsonSchema:
    UpdateAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function updateAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatJSONSchema$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  json_schema: z.lazy(() =>
    UpdateAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type UpdateAgentResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: UpdateAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const UpdateAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function updateAgentResponseFormatJSONSchemaToJSON(
  updateAgentResponseFormatJSONSchema: UpdateAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatJSONSchema$outboundSchema.parse(
      updateAgentResponseFormatJSONSchema,
    ),
  );
}
export function updateAgentResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type UpdateAgentResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function updateAgentResponseFormatJSONObjectToJSON(
  updateAgentResponseFormatJSONObject: UpdateAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatJSONObject$outboundSchema.parse(
      updateAgentResponseFormatJSONObject,
    ),
  );
}
export function updateAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatText$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type UpdateAgentResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatText$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function updateAgentResponseFormatTextToJSON(
  updateAgentResponseFormatText: UpdateAgentResponseFormatText,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatText$outboundSchema.parse(
      updateAgentResponseFormatText,
    ),
  );
}
export function updateAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationResponseFormat$inboundSchema: z.ZodType<
  ModelConfigurationResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatText$inboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONObject$inboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONSchema$inboundSchema),
]);
/** @internal */
export type ModelConfigurationResponseFormat$Outbound =
  | UpdateAgentResponseFormatText$Outbound
  | UpdateAgentResponseFormatJSONObject$Outbound
  | UpdateAgentResponseFormatJSONSchema$Outbound;

/** @internal */
export const ModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  ModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  ModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatText$outboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONObject$outboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONSchema$outboundSchema),
]);

export function modelConfigurationResponseFormatToJSON(
  modelConfigurationResponseFormat: ModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    ModelConfigurationResponseFormat$outboundSchema.parse(
      modelConfigurationResponseFormat,
    ),
  );
}
export function modelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationStop$inboundSchema: z.ZodType<
  ModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type ModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const ModelConfigurationStop$outboundSchema: z.ZodType<
  ModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  ModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function modelConfigurationStopToJSON(
  modelConfigurationStop: ModelConfigurationStop,
): string {
  return JSON.stringify(
    ModelConfigurationStop$outboundSchema.parse(modelConfigurationStop),
  );
}
export function modelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationStreamOptions$inboundSchema: z.ZodType<
  ModelConfigurationStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type ModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  ModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  ModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function modelConfigurationStreamOptionsToJSON(
  modelConfigurationStreamOptions: ModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    ModelConfigurationStreamOptions$outboundSchema.parse(
      modelConfigurationStreamOptions,
    ),
  );
}
export function modelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationThinking$inboundSchema: z.ZodType<
  ModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);
/** @internal */
export type ModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const ModelConfigurationThinking$outboundSchema: z.ZodType<
  ModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  ModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function modelConfigurationThinkingToJSON(
  modelConfigurationThinking: ModelConfigurationThinking,
): string {
  return JSON.stringify(
    ModelConfigurationThinking$outboundSchema.parse(modelConfigurationThinking),
  );
}
export function modelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceType
> = z.nativeEnum(UpdateAgentToolChoiceType);
/** @internal */
export const UpdateAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceType
> = UpdateAgentToolChoiceType$inboundSchema;

/** @internal */
export const UpdateAgentToolChoiceFunction$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type UpdateAgentToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceFunction$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function updateAgentToolChoiceFunctionToJSON(
  updateAgentToolChoiceFunction: UpdateAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceFunction$outboundSchema.parse(
      updateAgentToolChoiceFunction,
    ),
  );
}
export function updateAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoice2$inboundSchema: z.ZodType<
  UpdateAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type UpdateAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const UpdateAgentToolChoice2$outboundSchema: z.ZodType<
  UpdateAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoice2
> = z.object({
  type: UpdateAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceFunction$outboundSchema),
});

export function updateAgentToolChoice2ToJSON(
  updateAgentToolChoice2: UpdateAgentToolChoice2,
): string {
  return JSON.stringify(
    UpdateAgentToolChoice2$outboundSchema.parse(updateAgentToolChoice2),
  );
}
export function updateAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoice1
> = z.nativeEnum(UpdateAgentToolChoice1);
/** @internal */
export const UpdateAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoice1
> = UpdateAgentToolChoice1$inboundSchema;

/** @internal */
export const ModelConfigurationToolChoice$inboundSchema: z.ZodType<
  ModelConfigurationToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentToolChoice2$inboundSchema),
  UpdateAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type ModelConfigurationToolChoice$Outbound =
  | UpdateAgentToolChoice2$Outbound
  | string;

/** @internal */
export const ModelConfigurationToolChoice$outboundSchema: z.ZodType<
  ModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  ModelConfigurationToolChoice
> = z.union([
  z.lazy(() => UpdateAgentToolChoice2$outboundSchema),
  UpdateAgentToolChoice1$outboundSchema,
]);

export function modelConfigurationToolChoiceToJSON(
  modelConfigurationToolChoice: ModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    ModelConfigurationToolChoice$outboundSchema.parse(
      modelConfigurationToolChoice,
    ),
  );
}
export function modelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationModalities$inboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationModalities
> = z.nativeEnum(ModelConfigurationModalities);
/** @internal */
export const ModelConfigurationModalities$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationModalities
> = ModelConfigurationModalities$inboundSchema;

/** @internal */
export const ModelConfigurationParameters$inboundSchema: z.ZodType<
  ModelConfigurationParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(
    z.lazy(() => UpdateAgentModelConfigurationAudio$inboundSchema),
  ).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => UpdateAgentResponseFormatText$inboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONObject$inboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ModelConfigurationStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => UpdateAgentToolChoice2$inboundSchema),
    UpdateAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(ModelConfigurationModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type ModelConfigurationParameters$Outbound = {
  audio?: UpdateAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatText$Outbound
    | UpdateAgentResponseFormatJSONObject$Outbound
    | UpdateAgentResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: ModelConfigurationStreamOptions$Outbound | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: UpdateAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const ModelConfigurationParameters$outboundSchema: z.ZodType<
  ModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  ModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => UpdateAgentModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => UpdateAgentResponseFormatText$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONObject$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => UpdateAgentToolChoice2$outboundSchema),
    UpdateAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(ModelConfigurationModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function modelConfigurationParametersToJSON(
  modelConfigurationParameters: ModelConfigurationParameters,
): string {
  return JSON.stringify(
    ModelConfigurationParameters$outboundSchema.parse(
      modelConfigurationParameters,
    ),
  );
}
export function modelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const ModelConfigurationRetry$inboundSchema: z.ZodType<
  ModelConfigurationRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type ModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const ModelConfigurationRetry$outboundSchema: z.ZodType<
  ModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  ModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function modelConfigurationRetryToJSON(
  modelConfigurationRetry: ModelConfigurationRetry,
): string {
  return JSON.stringify(
    ModelConfigurationRetry$outboundSchema.parse(modelConfigurationRetry),
  );
}
export function modelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<ModelConfigurationRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ModelConfigurationRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModelConfiguration2$inboundSchema: z.ZodType<
  UpdateAgentModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ModelConfigurationParameters$inboundSchema)
    .optional(),
  retry: z.lazy(() => ModelConfigurationRetry$inboundSchema).optional(),
});
/** @internal */
export type UpdateAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: ModelConfigurationParameters$Outbound | undefined;
  retry?: ModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const UpdateAgentModelConfiguration2$outboundSchema: z.ZodType<
  UpdateAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ModelConfigurationParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => ModelConfigurationRetry$outboundSchema).optional(),
});

export function updateAgentModelConfiguration2ToJSON(
  updateAgentModelConfiguration2: UpdateAgentModelConfiguration2,
): string {
  return JSON.stringify(
    UpdateAgentModelConfiguration2$outboundSchema.parse(
      updateAgentModelConfiguration2,
    ),
  );
}
export function updateAgentModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModelConfiguration$inboundSchema: z.ZodType<
  UpdateAgentModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type UpdateAgentModelConfiguration$Outbound =
  | UpdateAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const UpdateAgentModelConfiguration$outboundSchema: z.ZodType<
  UpdateAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfiguration
> = z.union([
  z.lazy(() => UpdateAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function updateAgentModelConfigurationToJSON(
  updateAgentModelConfiguration: UpdateAgentModelConfiguration,
): string {
  return JSON.stringify(
    UpdateAgentModelConfiguration$outboundSchema.parse(
      updateAgentModelConfiguration,
    ),
  );
}
export function updateAgentModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentModelConfiguration' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationVoice);
/** @internal */
export const UpdateAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationVoice> =
    UpdateAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationFormat);
/** @internal */
export const UpdateAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationFormat> =
    UpdateAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<UpdateAgentFallbackModelConfigurationAudio, z.ZodTypeDef, unknown> =
    z.object({
      voice: UpdateAgentFallbackModelConfigurationVoice$inboundSchema,
      format: UpdateAgentFallbackModelConfigurationFormat$inboundSchema,
    });
/** @internal */
export type UpdateAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: UpdateAgentFallbackModelConfigurationVoice$outboundSchema,
    format: UpdateAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function updateAgentFallbackModelConfigurationAudioToJSON(
  updateAgentFallbackModelConfigurationAudio:
    UpdateAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  updateAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(updateAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}
export function updateAgentResponseFormatAgentsRequestRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestJSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function updateAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  updateAgentResponseFormatAgentsRequestJSONSchema:
    UpdateAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}
export function updateAgentResponseFormatAgentsRequestJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsRequestJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsRequestJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsRequestJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsJSONObject$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatAgentsJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type UpdateAgentResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsJSONObjectToJSON(
  updateAgentResponseFormatAgentsJSONObject:
    UpdateAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      updateAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function updateAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  UpdateAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type UpdateAgentResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatAgentsText
> = z.object({
  type: z.literal("text"),
});

export function updateAgentResponseFormatAgentsTextToJSON(
  updateAgentResponseFormatAgentsText: UpdateAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsText$outboundSchema.parse(
      updateAgentResponseFormatAgentsText,
    ),
  );
}
export function updateAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$inboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
    ),
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationResponseFormat$Outbound =
  | UpdateAgentResponseFormatAgentsText$Outbound
  | UpdateAgentResponseFormatAgentsJSONObject$Outbound
  | UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$outboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
    ),
  ]);

export function updateAgentFallbackModelConfigurationResponseFormatToJSON(
  updateAgentFallbackModelConfigurationResponseFormat:
    UpdateAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      updateAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function updateAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationStop$inboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const UpdateAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function updateAgentFallbackModelConfigurationStopToJSON(
  updateAgentFallbackModelConfigurationStop:
    UpdateAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationStop$outboundSchema.parse(
      updateAgentFallbackModelConfigurationStop,
    ),
  );
}
export function updateAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function updateAgentFallbackModelConfigurationStreamOptionsToJSON(
  updateAgentFallbackModelConfigurationStreamOptions:
    UpdateAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      updateAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function updateAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationThinkingToJSON(
  updateAgentFallbackModelConfigurationThinking:
    UpdateAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      updateAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function updateAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgentsType
> = z.nativeEnum(UpdateAgentToolChoiceAgentsType);
/** @internal */
export const UpdateAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgentsType
> = UpdateAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const UpdateAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type UpdateAgentToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string(),
});

export function updateAgentToolChoiceAgentsFunctionToJSON(
  updateAgentToolChoiceAgentsFunction: UpdateAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsFunction$outboundSchema.parse(
      updateAgentToolChoiceAgentsFunction,
    ),
  );
}
export function updateAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type UpdateAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const UpdateAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgents2
> = z.object({
  type: UpdateAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceAgentsFunction$outboundSchema),
});

export function updateAgentToolChoiceAgents2ToJSON(
  updateAgentToolChoiceAgents2: UpdateAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgents2$outboundSchema.parse(
      updateAgentToolChoiceAgents2,
    ),
  );
}
export function updateAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgents1
> = z.nativeEnum(UpdateAgentToolChoiceAgents1);
/** @internal */
export const UpdateAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgents1
> = UpdateAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgents2$inboundSchema),
    UpdateAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationToolChoice$Outbound =
  | UpdateAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const UpdateAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgents2$outboundSchema),
    UpdateAgentToolChoiceAgents1$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationToolChoiceToJSON(
  updateAgentFallbackModelConfigurationToolChoice:
    UpdateAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      updateAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function updateAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationModalities);
/** @internal */
export const UpdateAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationModalities> =
    UpdateAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => UpdateAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => UpdateAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$inboundSchema),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgents2$inboundSchema),
      UpdateAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(UpdateAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | UpdateAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatAgentsText$Outbound
    | UpdateAgentResponseFormatAgentsJSONObject$Outbound
    | UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | UpdateAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: UpdateAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => UpdateAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => UpdateAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$outboundSchema),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgents2$outboundSchema),
      UpdateAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(UpdateAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function updateAgentFallbackModelConfigurationParametersToJSON(
  updateAgentFallbackModelConfigurationParameters:
    UpdateAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      updateAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function updateAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    UpdateAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type UpdateAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | UpdateAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  UpdateAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    UpdateAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
});

export function updateAgentFallbackModelConfiguration2ToJSON(
  updateAgentFallbackModelConfiguration2:
    UpdateAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfiguration2$outboundSchema.parse(
      updateAgentFallbackModelConfiguration2,
    ),
  );
}
export function updateAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentFallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type UpdateAgentFallbackModelConfiguration$Outbound =
  | UpdateAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const UpdateAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  UpdateAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => UpdateAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function updateAgentFallbackModelConfigurationToJSON(
  updateAgentFallbackModelConfiguration: UpdateAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfiguration$outboundSchema.parse(
      updateAgentFallbackModelConfiguration,
    ),
  );
}
export function updateAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentFallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolApprovalRequired
> = z.nativeEnum(UpdateAgentToolApprovalRequired);
/** @internal */
export const UpdateAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolApprovalRequired
> = UpdateAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const AgentToolInputCRUDMCPTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("mcp"),
  key: z.string().optional(),
  id: z.string().optional(),
  tool_id: z.string(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDMCPTool$Outbound = {
  type: "mcp";
  key?: string | undefined;
  id?: string | undefined;
  tool_id: string;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDMCPTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDMCPTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDMCPTool
> = z.object({
  type: z.literal("mcp"),
  key: z.string().optional(),
  id: z.string().optional(),
  toolId: z.string(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDMCPToolToJSON(
  agentToolInputCRUDMCPTool: AgentToolInputCRUDMCPTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDMCPTool$outboundSchema.parse(agentToolInputCRUDMCPTool),
  );
}
export function agentToolInputCRUDMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUDMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDMCPTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDFunctionTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDFunctionTool$Outbound = {
  type: "function";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDFunctionTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDFunctionTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDFunctionTool
> = z.object({
  type: z.literal("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDFunctionToolToJSON(
  agentToolInputCRUDFunctionTool: AgentToolInputCRUDFunctionTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDFunctionTool$outboundSchema.parse(
      agentToolInputCRUDFunctionTool,
    ),
  );
}
export function agentToolInputCRUDFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUDFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDFunctionTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDCodeExecutionTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDCodeExecutionTool$Outbound = {
  type: "code";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDCodeExecutionTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCodeExecutionTool
> = z.object({
  type: z.literal("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCodeExecutionToolToJSON(
  agentToolInputCRUDCodeExecutionTool: AgentToolInputCRUDCodeExecutionTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCodeExecutionTool$outboundSchema.parse(
      agentToolInputCRUDCodeExecutionTool,
    ),
  );
}
export function agentToolInputCRUDCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDCodeExecutionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDCodeExecutionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDHTTPTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDHTTPTool$Outbound = {
  type: "http";
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDHTTPTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDHTTPTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDHTTPTool
> = z.object({
  type: z.literal("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDHTTPToolToJSON(
  agentToolInputCRUDHTTPTool: AgentToolInputCRUDHTTPTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDHTTPTool$outboundSchema.parse(agentToolInputCRUDHTTPTool),
  );
}
export function agentToolInputCRUDHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUDHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDHTTPTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDCurrentDateTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDCurrentDateTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("current_date"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDCurrentDateTool$Outbound = {
  type: "current_date";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDCurrentDateTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCurrentDateTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCurrentDateTool
> = z.object({
  type: z.literal("current_date"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCurrentDateToolToJSON(
  agentToolInputCRUDCurrentDateTool: AgentToolInputCRUDCurrentDateTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCurrentDateTool$outboundSchema.parse(
      agentToolInputCRUDCurrentDateTool,
    ),
  );
}
export function agentToolInputCRUDCurrentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDCurrentDateTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUDCurrentDateTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDCurrentDateTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDQueryKnowledgeBaseTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDQueryKnowledgeBaseTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("query_knowledge_base"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound = {
  type: "query_knowledge_base";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDQueryKnowledgeBaseTool
> = z.object({
  type: z.literal("query_knowledge_base"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDQueryKnowledgeBaseToolToJSON(
  agentToolInputCRUDQueryKnowledgeBaseTool:
    AgentToolInputCRUDQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema.parse(
      agentToolInputCRUDQueryKnowledgeBaseTool,
    ),
  );
}
export function agentToolInputCRUDQueryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputCRUDQueryKnowledgeBaseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDQueryKnowledgeBaseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputCRUDQueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDRetrieveKnowledgeBasesTool$inboundSchema:
  z.ZodType<
    AgentToolInputCRUDRetrieveKnowledgeBasesTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound = {
  type: "retrieve_knowledge_bases";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDRetrieveKnowledgeBasesTool
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDRetrieveKnowledgeBasesToolToJSON(
  agentToolInputCRUDRetrieveKnowledgeBasesTool:
    AgentToolInputCRUDRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveKnowledgeBasesTool,
    ),
  );
}
export function agentToolInputCRUDRetrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputCRUDRetrieveKnowledgeBasesTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDRetrieveKnowledgeBasesTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputCRUDRetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDDeleteMemoryDocumentTool$inboundSchema:
  z.ZodType<AgentToolInputCRUDDeleteMemoryDocumentTool, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("delete_memory_document"),
      requires_approval: z.boolean().optional(),
    }).transform((v) => {
      return remap$(v, {
        "requires_approval": "requiresApproval",
      });
    });
/** @internal */
export type AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound = {
  type: "delete_memory_document";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDDeleteMemoryDocumentTool
  > = z.object({
    type: z.literal("delete_memory_document"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDDeleteMemoryDocumentToolToJSON(
  agentToolInputCRUDDeleteMemoryDocumentTool:
    AgentToolInputCRUDDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema.parse(
      agentToolInputCRUDDeleteMemoryDocumentTool,
    ),
  );
}
export function agentToolInputCRUDDeleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputCRUDDeleteMemoryDocumentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDDeleteMemoryDocumentTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputCRUDDeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDRetrieveMemoryStoresTool$inboundSchema:
  z.ZodType<AgentToolInputCRUDRetrieveMemoryStoresTool, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("retrieve_memory_stores"),
      requires_approval: z.boolean().optional(),
    }).transform((v) => {
      return remap$(v, {
        "requires_approval": "requiresApproval",
      });
    });
/** @internal */
export type AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound = {
  type: "retrieve_memory_stores";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDRetrieveMemoryStoresTool
  > = z.object({
    type: z.literal("retrieve_memory_stores"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDRetrieveMemoryStoresToolToJSON(
  agentToolInputCRUDRetrieveMemoryStoresTool:
    AgentToolInputCRUDRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveMemoryStoresTool,
    ),
  );
}
export function agentToolInputCRUDRetrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<
  AgentToolInputCRUDRetrieveMemoryStoresTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDRetrieveMemoryStoresTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'AgentToolInputCRUDRetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDWriteMemoryStoreTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDWriteMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("write_memory_store"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDWriteMemoryStoreTool$Outbound = {
  type: "write_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDWriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDWriteMemoryStoreTool
> = z.object({
  type: z.literal("write_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDWriteMemoryStoreToolToJSON(
  agentToolInputCRUDWriteMemoryStoreTool:
    AgentToolInputCRUDWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema.parse(
      agentToolInputCRUDWriteMemoryStoreTool,
    ),
  );
}
export function agentToolInputCRUDWriteMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDWriteMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDWriteMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDWriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDQueryMemoryStoreTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDQueryMemoryStoreTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("query_memory_store"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDQueryMemoryStoreTool$Outbound = {
  type: "query_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDQueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDQueryMemoryStoreTool
> = z.object({
  type: z.literal("query_memory_store"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDQueryMemoryStoreToolToJSON(
  agentToolInputCRUDQueryMemoryStoreTool:
    AgentToolInputCRUDQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema.parse(
      agentToolInputCRUDQueryMemoryStoreTool,
    ),
  );
}
export function agentToolInputCRUDQueryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDQueryMemoryStoreTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDQueryMemoryStoreTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDQueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDRetrieveAgentsTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDRetrieveAgentsTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("retrieve_agents"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDRetrieveAgentsTool$Outbound = {
  type: "retrieve_agents";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveAgentsTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDRetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDRetrieveAgentsTool
> = z.object({
  type: z.literal("retrieve_agents"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDRetrieveAgentsToolToJSON(
  agentToolInputCRUDRetrieveAgentsTool: AgentToolInputCRUDRetrieveAgentsTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveAgentsTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveAgentsTool,
    ),
  );
}
export function agentToolInputCRUDRetrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDRetrieveAgentsTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDRetrieveAgentsTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDRetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDCallSubAgentTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDCallSubAgentTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("call_sub_agent"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDCallSubAgentTool$Outbound = {
  type: "call_sub_agent";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDCallSubAgentTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCallSubAgentTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCallSubAgentTool
> = z.object({
  type: z.literal("call_sub_agent"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCallSubAgentToolToJSON(
  agentToolInputCRUDCallSubAgentTool: AgentToolInputCRUDCallSubAgentTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCallSubAgentTool$outboundSchema.parse(
      agentToolInputCRUDCallSubAgentTool,
    ),
  );
}
export function agentToolInputCRUDCallSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDCallSubAgentTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDCallSubAgentTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDCallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDWebScraperTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDWebScraperTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("web_scraper"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDWebScraperTool$Outbound = {
  type: "web_scraper";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDWebScraperTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDWebScraperTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDWebScraperTool
> = z.object({
  type: z.literal("web_scraper"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDWebScraperToolToJSON(
  agentToolInputCRUDWebScraperTool: AgentToolInputCRUDWebScraperTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDWebScraperTool$outboundSchema.parse(
      agentToolInputCRUDWebScraperTool,
    ),
  );
}
export function agentToolInputCRUDWebScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDWebScraperTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputCRUDWebScraperTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDWebScraperTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputCRUDGoogleSearchTool$inboundSchema: z.ZodType<
  AgentToolInputCRUDGoogleSearchTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("google_search"),
  requires_approval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputCRUDGoogleSearchTool$Outbound = {
  type: "google_search";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDGoogleSearchTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDGoogleSearchTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDGoogleSearchTool
> = z.object({
  type: z.literal("google_search"),
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDGoogleSearchToolToJSON(
  agentToolInputCRUDGoogleSearchTool: AgentToolInputCRUDGoogleSearchTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDGoogleSearchTool$outboundSchema.parse(
      agentToolInputCRUDGoogleSearchTool,
    ),
  );
}
export function agentToolInputCRUDGoogleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputCRUDGoogleSearchTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputCRUDGoogleSearchTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputCRUDGoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUD$inboundSchema: z.ZodType<
  UpdateAgentAgentToolInputCRUD,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => AgentToolInputCRUDGoogleSearchTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDWebScraperTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDCallSubAgentTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDCurrentDateTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDHTTPTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDCodeExecutionTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDFunctionTool$inboundSchema),
  z.lazy(() => AgentToolInputCRUDMCPTool$inboundSchema),
]);
/** @internal */
export type UpdateAgentAgentToolInputCRUD$Outbound =
  | AgentToolInputCRUDGoogleSearchTool$Outbound
  | AgentToolInputCRUDWebScraperTool$Outbound
  | AgentToolInputCRUDCallSubAgentTool$Outbound
  | AgentToolInputCRUDRetrieveAgentsTool$Outbound
  | AgentToolInputCRUDQueryMemoryStoreTool$Outbound
  | AgentToolInputCRUDWriteMemoryStoreTool$Outbound
  | AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound
  | AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound
  | AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound
  | AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound
  | AgentToolInputCRUDCurrentDateTool$Outbound
  | AgentToolInputCRUDHTTPTool$Outbound
  | AgentToolInputCRUDCodeExecutionTool$Outbound
  | AgentToolInputCRUDFunctionTool$Outbound
  | AgentToolInputCRUDMCPTool$Outbound;

/** @internal */
export const UpdateAgentAgentToolInputCRUD$outboundSchema: z.ZodType<
  UpdateAgentAgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentToolInputCRUD
> = z.union([
  z.lazy(() => AgentToolInputCRUDGoogleSearchTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDWebScraperTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCallSubAgentTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCurrentDateTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDHTTPTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCodeExecutionTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDFunctionTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDMCPTool$outboundSchema),
]);

export function updateAgentAgentToolInputCRUDToJSON(
  updateAgentAgentToolInputCRUD: UpdateAgentAgentToolInputCRUD,
): string {
  return JSON.stringify(
    UpdateAgentAgentToolInputCRUD$outboundSchema.parse(
      updateAgentAgentToolInputCRUD,
    ),
  );
}
export function updateAgentAgentToolInputCRUDFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentToolInputCRUD, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentToolInputCRUD$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentToolInputCRUD' from JSON`,
  );
}

/** @internal */
export const UpdateAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentExecuteOn
> = z.nativeEnum(UpdateAgentExecuteOn);
/** @internal */
export const UpdateAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentExecuteOn
> = UpdateAgentExecuteOn$inboundSchema;

/** @internal */
export const UpdateAgentEvaluators$inboundSchema: z.ZodType<
  UpdateAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type UpdateAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentEvaluators$outboundSchema: z.ZodType<
  UpdateAgentEvaluators$Outbound,
  z.ZodTypeDef,
  UpdateAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentEvaluatorsToJSON(
  updateAgentEvaluators: UpdateAgentEvaluators,
): string {
  return JSON.stringify(
    UpdateAgentEvaluators$outboundSchema.parse(updateAgentEvaluators),
  );
}
export function updateAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsExecuteOn
> = z.nativeEnum(UpdateAgentAgentsExecuteOn);
/** @internal */
export const UpdateAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsExecuteOn
> = UpdateAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const UpdateAgentGuardrails$inboundSchema: z.ZodType<
  UpdateAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type UpdateAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentGuardrails$outboundSchema: z.ZodType<
  UpdateAgentGuardrails$Outbound,
  z.ZodTypeDef,
  UpdateAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentGuardrailsToJSON(
  updateAgentGuardrails: UpdateAgentGuardrails,
): string {
  return JSON.stringify(
    UpdateAgentGuardrails$outboundSchema.parse(updateAgentGuardrails),
  );
}
export function updateAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdateAgentSettings$inboundSchema: z.ZodType<
  UpdateAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: UpdateAgentToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputCRUDGoogleSearchTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDWebScraperTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDCallSubAgentTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDCurrentDateTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDHTTPTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDCodeExecutionTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDFunctionTool$inboundSchema),
      z.lazy(() => AgentToolInputCRUDMCPTool$inboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type UpdateAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | AgentToolInputCRUDGoogleSearchTool$Outbound
      | AgentToolInputCRUDWebScraperTool$Outbound
      | AgentToolInputCRUDCallSubAgentTool$Outbound
      | AgentToolInputCRUDRetrieveAgentsTool$Outbound
      | AgentToolInputCRUDQueryMemoryStoreTool$Outbound
      | AgentToolInputCRUDWriteMemoryStoreTool$Outbound
      | AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound
      | AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound
      | AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound
      | AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound
      | AgentToolInputCRUDCurrentDateTool$Outbound
      | AgentToolInputCRUDHTTPTool$Outbound
      | AgentToolInputCRUDCodeExecutionTool$Outbound
      | AgentToolInputCRUDFunctionTool$Outbound
      | AgentToolInputCRUDMCPTool$Outbound
    >
    | undefined;
  evaluators?: Array<UpdateAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<UpdateAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const UpdateAgentSettings$outboundSchema: z.ZodType<
  UpdateAgentSettings$Outbound,
  z.ZodTypeDef,
  UpdateAgentSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  toolApprovalRequired: UpdateAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputCRUDGoogleSearchTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDWebScraperTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCallSubAgentTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCurrentDateTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDHTTPTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCodeExecutionTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDFunctionTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDMCPTool$outboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function updateAgentSettingsToJSON(
  updateAgentSettings: UpdateAgentSettings,
): string {
  return JSON.stringify(
    UpdateAgentSettings$outboundSchema.parse(updateAgentSettings),
  );
}
export function updateAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentSettings' from JSON`,
  );
}

/** @internal */
export const UpdateAgentKnowledgeBases$inboundSchema: z.ZodType<
  UpdateAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type UpdateAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const UpdateAgentKnowledgeBases$outboundSchema: z.ZodType<
  UpdateAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  UpdateAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function updateAgentKnowledgeBasesToJSON(
  updateAgentKnowledgeBases: UpdateAgentKnowledgeBases,
): string {
  return JSON.stringify(
    UpdateAgentKnowledgeBases$outboundSchema.parse(updateAgentKnowledgeBases),
  );
}
export function updateAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const UpdateAgentTeamOfAgents$inboundSchema: z.ZodType<
  UpdateAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type UpdateAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const UpdateAgentTeamOfAgents$outboundSchema: z.ZodType<
  UpdateAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  UpdateAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function updateAgentTeamOfAgentsToJSON(
  updateAgentTeamOfAgents: UpdateAgentTeamOfAgents,
): string {
  return JSON.stringify(
    UpdateAgentTeamOfAgents$outboundSchema.parse(updateAgentTeamOfAgents),
  );
}
export function updateAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const UpdateAgentUpdateAgentRequest$inboundSchema: z.ZodType<
  UpdateAgentUpdateAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string().optional(),
  display_name: z.string().optional(),
  project_id: z.string().optional(),
  role: z.string().optional(),
  description: z.string().optional(),
  instructions: z.string().optional(),
  system_prompt: z.string().optional(),
  model: z.union([
    z.lazy(() => UpdateAgentModelConfiguration2$inboundSchema),
    z.string(),
  ]).optional(),
  fallback_models: z.array(
    z.union([
      z.lazy(() => UpdateAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => UpdateAgentSettings$inboundSchema).optional(),
  path: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => UpdateAgentKnowledgeBases$inboundSchema),
  ).optional(),
  team_of_agents: z.array(z.lazy(() => UpdateAgentTeamOfAgents$inboundSchema))
    .optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "project_id": "projectId",
    "system_prompt": "systemPrompt",
    "fallback_models": "fallbackModels",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
  });
});
/** @internal */
export type UpdateAgentUpdateAgentRequest$Outbound = {
  key?: string | undefined;
  display_name?: string | undefined;
  project_id?: string | undefined;
  role?: string | undefined;
  description?: string | undefined;
  instructions?: string | undefined;
  system_prompt?: string | undefined;
  model?: UpdateAgentModelConfiguration2$Outbound | string | undefined;
  fallback_models?:
    | Array<UpdateAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  settings?: UpdateAgentSettings$Outbound | undefined;
  path?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<UpdateAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<UpdateAgentTeamOfAgents$Outbound> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateAgentUpdateAgentRequest$outboundSchema: z.ZodType<
  UpdateAgentUpdateAgentRequest$Outbound,
  z.ZodTypeDef,
  UpdateAgentUpdateAgentRequest
> = z.object({
  key: z.string().optional(),
  displayName: z.string().optional(),
  projectId: z.string().optional(),
  role: z.string().optional(),
  description: z.string().optional(),
  instructions: z.string().optional(),
  systemPrompt: z.string().optional(),
  model: z.union([
    z.lazy(() => UpdateAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]).optional(),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => UpdateAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => UpdateAgentSettings$outboundSchema).optional(),
  path: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => UpdateAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => UpdateAgentTeamOfAgents$outboundSchema))
    .optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    projectId: "project_id",
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function updateAgentUpdateAgentRequestToJSON(
  updateAgentUpdateAgentRequest: UpdateAgentUpdateAgentRequest,
): string {
  return JSON.stringify(
    UpdateAgentUpdateAgentRequest$outboundSchema.parse(
      updateAgentUpdateAgentRequest,
    ),
  );
}
export function updateAgentUpdateAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentUpdateAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentUpdateAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentUpdateAgentRequest' from JSON`,
  );
}

/** @internal */
export const UpdateAgentRequest$inboundSchema: z.ZodType<
  UpdateAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  RequestBody: z.lazy(() => UpdateAgentUpdateAgentRequest$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateAgentRequest$Outbound = {
  agent_key: string;
  RequestBody: UpdateAgentUpdateAgentRequest$Outbound;
};

/** @internal */
export const UpdateAgentRequest$outboundSchema: z.ZodType<
  UpdateAgentRequest$Outbound,
  z.ZodTypeDef,
  UpdateAgentRequest
> = z.object({
  agentKey: z.string(),
  requestBody: z.lazy(() => UpdateAgentUpdateAgentRequest$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    requestBody: "RequestBody",
  });
});

export function updateAgentRequestToJSON(
  updateAgentRequest: UpdateAgentRequest,
): string {
  return JSON.stringify(
    UpdateAgentRequest$outboundSchema.parse(updateAgentRequest),
  );
}
export function updateAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentRequest' from JSON`,
  );
}

/** @internal */
export const UpdateAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentStatus
> = z.nativeEnum(UpdateAgentStatus);
/** @internal */
export const UpdateAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentStatus
> = UpdateAgentStatus$inboundSchema;

/** @internal */
export const UpdateAgentAgentsToolApprovalRequired$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsToolApprovalRequired> = z.nativeEnum(
    UpdateAgentAgentsToolApprovalRequired,
  );
/** @internal */
export const UpdateAgentAgentsToolApprovalRequired$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsToolApprovalRequired> =
    UpdateAgentAgentsToolApprovalRequired$inboundSchema;

/** @internal */
export const UpdateAgentConditions$inboundSchema: z.ZodType<
  UpdateAgentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type UpdateAgentConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const UpdateAgentConditions$outboundSchema: z.ZodType<
  UpdateAgentConditions$Outbound,
  z.ZodTypeDef,
  UpdateAgentConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function updateAgentConditionsToJSON(
  updateAgentConditions: UpdateAgentConditions,
): string {
  return JSON.stringify(
    UpdateAgentConditions$outboundSchema.parse(updateAgentConditions),
  );
}
export function updateAgentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentConditions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentTools$inboundSchema: z.ZodType<
  UpdateAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => UpdateAgentConditions$inboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});
/** @internal */
export type UpdateAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  tool_id?: string | undefined;
  conditions?: Array<UpdateAgentConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const UpdateAgentTools$outboundSchema: z.ZodType<
  UpdateAgentTools$Outbound,
  z.ZodTypeDef,
  UpdateAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  toolId: z.string().optional(),
  conditions: z.array(z.lazy(() => UpdateAgentConditions$outboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
    toolId: "tool_id",
  });
});

export function updateAgentToolsToJSON(
  updateAgentTools: UpdateAgentTools,
): string {
  return JSON.stringify(
    UpdateAgentTools$outboundSchema.parse(updateAgentTools),
  );
}
export function updateAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentTools' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsResponseExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsResponseExecuteOn
> = z.nativeEnum(UpdateAgentAgentsResponseExecuteOn);
/** @internal */
export const UpdateAgentAgentsResponseExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsResponseExecuteOn
> = UpdateAgentAgentsResponseExecuteOn$inboundSchema;

/** @internal */
export const UpdateAgentAgentsEvaluators$inboundSchema: z.ZodType<
  UpdateAgentAgentsEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentAgentsResponseExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type UpdateAgentAgentsEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentAgentsEvaluators$outboundSchema: z.ZodType<
  UpdateAgentAgentsEvaluators$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentsEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentAgentsResponseExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentAgentsEvaluatorsToJSON(
  updateAgentAgentsEvaluators: UpdateAgentAgentsEvaluators,
): string {
  return JSON.stringify(
    UpdateAgentAgentsEvaluators$outboundSchema.parse(
      updateAgentAgentsEvaluators,
    ),
  );
}
export function updateAgentAgentsEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsEvaluators' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsResponse200ExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsResponse200ExecuteOn> = z.nativeEnum(
    UpdateAgentAgentsResponse200ExecuteOn,
  );
/** @internal */
export const UpdateAgentAgentsResponse200ExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsResponse200ExecuteOn> =
    UpdateAgentAgentsResponse200ExecuteOn$inboundSchema;

/** @internal */
export const UpdateAgentAgentsGuardrails$inboundSchema: z.ZodType<
  UpdateAgentAgentsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentAgentsResponse200ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type UpdateAgentAgentsGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentAgentsGuardrails$outboundSchema: z.ZodType<
  UpdateAgentAgentsGuardrails$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentsGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentAgentsResponse200ExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentAgentsGuardrailsToJSON(
  updateAgentAgentsGuardrails: UpdateAgentAgentsGuardrails,
): string {
  return JSON.stringify(
    UpdateAgentAgentsGuardrails$outboundSchema.parse(
      updateAgentAgentsGuardrails,
    ),
  );
}
export function updateAgentAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsSettings$inboundSchema: z.ZodType<
  UpdateAgentAgentsSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: UpdateAgentAgentsToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => UpdateAgentTools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentAgentsEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentAgentsGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type UpdateAgentAgentsSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<UpdateAgentTools$Outbound> | undefined;
  evaluators?: Array<UpdateAgentAgentsEvaluators$Outbound> | undefined;
  guardrails?: Array<UpdateAgentAgentsGuardrails$Outbound> | undefined;
};

/** @internal */
export const UpdateAgentAgentsSettings$outboundSchema: z.ZodType<
  UpdateAgentAgentsSettings$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentsSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  toolApprovalRequired: UpdateAgentAgentsToolApprovalRequired$outboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => UpdateAgentTools$outboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentAgentsEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentAgentsGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function updateAgentAgentsSettingsToJSON(
  updateAgentAgentsSettings: UpdateAgentAgentsSettings,
): string {
  return JSON.stringify(
    UpdateAgentAgentsSettings$outboundSchema.parse(updateAgentAgentsSettings),
  );
}
export function updateAgentAgentsSettingsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsSettings' from JSON`,
  );
}

/** @internal */
export const UpdateAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentVoice
> = z.nativeEnum(UpdateAgentVoice);
/** @internal */
export const UpdateAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentVoice
> = UpdateAgentVoice$inboundSchema;

/** @internal */
export const UpdateAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentFormat
> = z.nativeEnum(UpdateAgentFormat);
/** @internal */
export const UpdateAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentFormat
> = UpdateAgentFormat$inboundSchema;

/** @internal */
export const UpdateAgentAudio$inboundSchema: z.ZodType<
  UpdateAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: UpdateAgentVoice$inboundSchema,
  format: UpdateAgentFormat$inboundSchema,
});
/** @internal */
export type UpdateAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentAudio$outboundSchema: z.ZodType<
  UpdateAgentAudio$Outbound,
  z.ZodTypeDef,
  UpdateAgentAudio
> = z.object({
  voice: UpdateAgentVoice$outboundSchema,
  format: UpdateAgentFormat$outboundSchema,
});

export function updateAgentAudioToJSON(
  updateAgentAudio: UpdateAgentAudio,
): string {
  return JSON.stringify(
    UpdateAgentAudio$outboundSchema.parse(updateAgentAudio),
  );
}
export function updateAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponseJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsResponseJsonSchemaToJSON(
  updateAgentResponseFormatAgentsResponseJsonSchema:
    UpdateAgentResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponseJsonSchema,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponse200JSONSchema$Outbound = {
  type: "json_schema";
  json_schema: UpdateAgentResponseFormatAgentsResponseJsonSchema$Outbound;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponse200JSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function updateAgentResponseFormatAgentsResponse200JSONSchemaToJSON(
  updateAgentResponseFormatAgentsResponse200JSONSchema:
    UpdateAgentResponseFormatAgentsResponse200JSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponse200JSONSchema,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponseJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJSONObject$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJSONObject$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponseJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsResponseJSONObjectToJSON(
  updateAgentResponseFormatAgentsResponseJSONObject:
    UpdateAgentResponseFormatAgentsResponseJSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponseJSONObject$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponseJSONObject,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponseJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseJSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseText$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseText,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("text"),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponseText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseText$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseText$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponseText
  > = z.object({
    type: z.literal("text"),
  });

export function updateAgentResponseFormatAgentsResponseTextToJSON(
  updateAgentResponseFormatAgentsResponseText:
    UpdateAgentResponseFormatAgentsResponseText,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponseText$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponseText,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponseTextFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseText,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseText$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseText' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormat$inboundSchema: z.ZodType<
  UpdateAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$inboundSchema),
  z.lazy(() => UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema),
  z.lazy(() =>
    UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
  ),
]);
/** @internal */
export type UpdateAgentResponseFormat$Outbound =
  | UpdateAgentResponseFormatAgentsResponseText$Outbound
  | UpdateAgentResponseFormatAgentsResponseJSONObject$Outbound
  | UpdateAgentResponseFormatAgentsResponse200JSONSchema$Outbound;

/** @internal */
export const UpdateAgentResponseFormat$outboundSchema: z.ZodType<
  UpdateAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormat
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$outboundSchema),
  z.lazy(() =>
    UpdateAgentResponseFormatAgentsResponseJSONObject$outboundSchema
  ),
  z.lazy(() =>
    UpdateAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema
  ),
]);

export function updateAgentResponseFormatToJSON(
  updateAgentResponseFormat: UpdateAgentResponseFormat,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormat$outboundSchema.parse(updateAgentResponseFormat),
  );
}
export function updateAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdateAgentStop$inboundSchema: z.ZodType<
  UpdateAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type UpdateAgentStop$Outbound = string | Array<string>;

/** @internal */
export const UpdateAgentStop$outboundSchema: z.ZodType<
  UpdateAgentStop$Outbound,
  z.ZodTypeDef,
  UpdateAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function updateAgentStopToJSON(
  updateAgentStop: UpdateAgentStop,
): string {
  return JSON.stringify(UpdateAgentStop$outboundSchema.parse(updateAgentStop));
}
export function updateAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentStop' from JSON`,
  );
}

/** @internal */
export const UpdateAgentStreamOptions$inboundSchema: z.ZodType<
  UpdateAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type UpdateAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const UpdateAgentStreamOptions$outboundSchema: z.ZodType<
  UpdateAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  UpdateAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function updateAgentStreamOptionsToJSON(
  updateAgentStreamOptions: UpdateAgentStreamOptions,
): string {
  return JSON.stringify(
    UpdateAgentStreamOptions$outboundSchema.parse(updateAgentStreamOptions),
  );
}
export function updateAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentThinking$inboundSchema: z.ZodType<
  UpdateAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);
/** @internal */
export type UpdateAgentThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const UpdateAgentThinking$outboundSchema: z.ZodType<
  UpdateAgentThinking$Outbound,
  z.ZodTypeDef,
  UpdateAgentThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function updateAgentThinkingToJSON(
  updateAgentThinking: UpdateAgentThinking,
): string {
  return JSON.stringify(
    UpdateAgentThinking$outboundSchema.parse(updateAgentThinking),
  );
}
export function updateAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponseType> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponseType);
/** @internal */
export const UpdateAgentToolChoiceAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponseType> =
    UpdateAgentToolChoiceAgentsResponseType$inboundSchema;

/** @internal */
export const UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });
/** @internal */
export type UpdateAgentToolChoiceAgentsResponseFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsResponseFunction$outboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponseFunction$Outbound,
    z.ZodTypeDef,
    UpdateAgentToolChoiceAgentsResponseFunction
  > = z.object({
    name: z.string(),
  });

export function updateAgentToolChoiceAgentsResponseFunctionToJSON(
  updateAgentToolChoiceAgentsResponseFunction:
    UpdateAgentToolChoiceAgentsResponseFunction,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsResponseFunction$outboundSchema.parse(
      updateAgentToolChoiceAgentsResponseFunction,
    ),
  );
}
export function updateAgentToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponseType$inboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema
  ),
});
/** @internal */
export type UpdateAgentToolChoiceAgentsResponse2$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceAgentsResponseFunction$Outbound;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgentsResponse2
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponseType$outboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponseFunction$outboundSchema
  ),
});

export function updateAgentToolChoiceAgentsResponse2ToJSON(
  updateAgentToolChoiceAgentsResponse2: UpdateAgentToolChoiceAgentsResponse2,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsResponse2$outboundSchema.parse(
      updateAgentToolChoiceAgentsResponse2,
    ),
  );
}
export function updateAgentToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoiceAgentsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse1> = z.nativeEnum(
    UpdateAgentToolChoiceAgentsResponse1,
  );
/** @internal */
export const UpdateAgentToolChoiceAgentsResponse1$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse1> =
    UpdateAgentToolChoiceAgentsResponse1$inboundSchema;

/** @internal */
export const UpdateAgentToolChoice$inboundSchema: z.ZodType<
  UpdateAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$inboundSchema),
  UpdateAgentToolChoiceAgentsResponse1$inboundSchema,
]);
/** @internal */
export type UpdateAgentToolChoice$Outbound =
  | UpdateAgentToolChoiceAgentsResponse2$Outbound
  | string;

/** @internal */
export const UpdateAgentToolChoice$outboundSchema: z.ZodType<
  UpdateAgentToolChoice$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoice
> = z.union([
  z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$outboundSchema),
  UpdateAgentToolChoiceAgentsResponse1$outboundSchema,
]);

export function updateAgentToolChoiceToJSON(
  updateAgentToolChoice: UpdateAgentToolChoice,
): string {
  return JSON.stringify(
    UpdateAgentToolChoice$outboundSchema.parse(updateAgentToolChoice),
  );
}
export function updateAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentModalities
> = z.nativeEnum(UpdateAgentModalities);
/** @internal */
export const UpdateAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentModalities
> = UpdateAgentModalities$inboundSchema;

/** @internal */
export const UpdateAgentParameters$inboundSchema: z.ZodType<
  UpdateAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => UpdateAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$inboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => UpdateAgentStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$inboundSchema),
    UpdateAgentToolChoiceAgentsResponse1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(UpdateAgentModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type UpdateAgentParameters$Outbound = {
  audio?: UpdateAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatAgentsResponseText$Outbound
    | UpdateAgentResponseFormatAgentsResponseJSONObject$Outbound
    | UpdateAgentResponseFormatAgentsResponse200JSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: UpdateAgentStreamOptions$Outbound | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | UpdateAgentToolChoiceAgentsResponse2$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const UpdateAgentParameters$outboundSchema: z.ZodType<
  UpdateAgentParameters$Outbound,
  z.ZodTypeDef,
  UpdateAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => UpdateAgentAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$outboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJSONObject$outboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema
    ),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => UpdateAgentStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$outboundSchema),
    UpdateAgentToolChoiceAgentsResponse1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(UpdateAgentModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function updateAgentParametersToJSON(
  updateAgentParameters: UpdateAgentParameters,
): string {
  return JSON.stringify(
    UpdateAgentParameters$outboundSchema.parse(updateAgentParameters),
  );
}
export function updateAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentParameters' from JSON`,
  );
}

/** @internal */
export const UpdateAgentRetry$inboundSchema: z.ZodType<
  UpdateAgentRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type UpdateAgentRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdateAgentRetry$outboundSchema: z.ZodType<
  UpdateAgentRetry$Outbound,
  z.ZodTypeDef,
  UpdateAgentRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function updateAgentRetryToJSON(
  updateAgentRetry: UpdateAgentRetry,
): string {
  return JSON.stringify(
    UpdateAgentRetry$outboundSchema.parse(updateAgentRetry),
  );
}
export function updateAgentRetryFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentRetry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsVoice$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsVoice> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationAgentsVoice);
/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsVoice$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsVoice> =
    UpdateAgentFallbackModelConfigurationAgentsVoice$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsFormat$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsFormat> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationAgentsFormat);
/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsFormat$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsFormat> =
    UpdateAgentFallbackModelConfigurationAgentsFormat$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: UpdateAgentFallbackModelConfigurationAgentsVoice$inboundSchema,
    format: UpdateAgentFallbackModelConfigurationAgentsFormat$inboundSchema,
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsAudio$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsAudio$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsAudio
  > = z.object({
    voice: UpdateAgentFallbackModelConfigurationAgentsVoice$outboundSchema,
    format: UpdateAgentFallbackModelConfigurationAgentsFormat$outboundSchema,
  });

export function updateAgentFallbackModelConfigurationAgentsAudioToJSON(
  updateAgentFallbackModelConfigurationAgentsAudio:
    UpdateAgentFallbackModelConfigurationAgentsAudio,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsAudio$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsAudio,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgentsAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchemaToJSON(
  updateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema:
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$outboundSchema
      .parse(
        updateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
      ),
  );
}
export function updateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$Outbound =
  {
    type: "json_schema";
    json_schema:
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$Outbound;
  };

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function updateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchemaToJSON(
  updateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema:
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$outboundSchema
      .parse(
        updateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
      ),
  );
}
export function updateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponse200JSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONObject$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONObject$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponse200JSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsResponse200JSONObjectToJSON(
  updateAgentResponseFormatAgentsResponse200JSONObject:
    UpdateAgentResponseFormatAgentsResponse200JSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponse200JSONObject$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponse200JSONObject,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponse200JSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200JSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200JSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200Text,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("text"),
  });
/** @internal */
export type UpdateAgentResponseFormatAgentsResponse200Text$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200Text$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200Text$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsResponse200Text
  > = z.object({
    type: z.literal("text"),
  });

export function updateAgentResponseFormatAgentsResponse200TextToJSON(
  updateAgentResponseFormatAgentsResponse200Text:
    UpdateAgentResponseFormatAgentsResponse200Text,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsResponse200Text$outboundSchema.parse(
      updateAgentResponseFormatAgentsResponse200Text,
    ),
  );
}
export function updateAgentResponseFormatAgentsResponse200TextFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200Text,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200Text' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsResponseFormat$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
    ),
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsResponseFormat$Outbound =
  | UpdateAgentResponseFormatAgentsResponse200Text$Outbound
  | UpdateAgentResponseFormatAgentsResponse200JSONObject$Outbound
  | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsResponseFormat$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponse200Text$outboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONObject$outboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$outboundSchema
    ),
  ]);

export function updateAgentFallbackModelConfigurationAgentsResponseFormatToJSON(
  updateAgentFallbackModelConfigurationAgentsResponseFormat:
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat$outboundSchema
      .parse(updateAgentFallbackModelConfigurationAgentsResponseFormat),
  );
}
export function updateAgentFallbackModelConfigurationAgentsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStop$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStop$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStop$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsStop
  > = z.union([z.string(), z.array(z.string())]);

export function updateAgentFallbackModelConfigurationAgentsStopToJSON(
  updateAgentFallbackModelConfigurationAgentsStop:
    UpdateAgentFallbackModelConfigurationAgentsStop,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsStop$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsStop,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgentsStopFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsStop' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsStreamOptions$Outbound =
  {
    include_usage?: boolean | undefined;
  };

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStreamOptions$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsStreamOptionsToJSON(
  updateAgentFallbackModelConfigurationAgentsStreamOptions:
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions$outboundSchema
      .parse(updateAgentFallbackModelConfigurationAgentsStreamOptions),
  );
}
export function updateAgentFallbackModelConfigurationAgentsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsThinking$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsThinking$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsThinking$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationAgentsThinkingToJSON(
  updateAgentFallbackModelConfigurationAgentsThinking:
    UpdateAgentFallbackModelConfigurationAgentsThinking,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsThinking$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsThinking,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgentsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse200Type> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponse200Type);
/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse200Type> =
    UpdateAgentToolChoiceAgentsResponse200Type$inboundSchema;

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponse200Function,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });
/** @internal */
export type UpdateAgentToolChoiceAgentsResponse200Function$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Function$outboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponse200Function$Outbound,
    z.ZodTypeDef,
    UpdateAgentToolChoiceAgentsResponse200Function
  > = z.object({
    name: z.string(),
  });

export function updateAgentToolChoiceAgentsResponse200FunctionToJSON(
  updateAgentToolChoiceAgentsResponse200Function:
    UpdateAgentToolChoiceAgentsResponse200Function,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsResponse200Function$outboundSchema.parse(
      updateAgentToolChoiceAgentsResponse200Function,
    ),
  );
}
export function updateAgentToolChoiceAgentsResponse200FunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponse200Function,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse200Function' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2002$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2002,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponse200Type$inboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema
  ),
});
/** @internal */
export type UpdateAgentToolChoiceAgentsResponse2002$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceAgentsResponse200Function$Outbound;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2002$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2002$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgentsResponse2002
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponse200Type$outboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponse200Function$outboundSchema
  ),
});

export function updateAgentToolChoiceAgentsResponse2002ToJSON(
  updateAgentToolChoiceAgentsResponse2002:
    UpdateAgentToolChoiceAgentsResponse2002,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsResponse2002$outboundSchema.parse(
      updateAgentToolChoiceAgentsResponse2002,
    ),
  );
}
export function updateAgentToolChoiceAgentsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse2002' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2001$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse2001> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponse2001);
/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2001$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse2001> =
    UpdateAgentToolChoiceAgentsResponse2001$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsToolChoice$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$inboundSchema),
    UpdateAgentToolChoiceAgentsResponse2001$inboundSchema,
  ]);
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsToolChoice$Outbound =
  | UpdateAgentToolChoiceAgentsResponse2002$Outbound
  | string;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsToolChoice$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsToolChoice$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsToolChoice
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$outboundSchema),
    UpdateAgentToolChoiceAgentsResponse2001$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationAgentsToolChoiceToJSON(
  updateAgentFallbackModelConfigurationAgentsToolChoice:
    UpdateAgentFallbackModelConfigurationAgentsToolChoice,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsToolChoice$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsToolChoice,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgentsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsModalities$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentFallbackModelConfigurationAgentsModalities
  > = z.nativeEnum(UpdateAgentFallbackModelConfigurationAgentsModalities);
/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsModalities$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentFallbackModelConfigurationAgentsModalities
  > = UpdateAgentFallbackModelConfigurationAgentsModalities$inboundSchema;

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema
      ),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$inboundSchema),
      UpdateAgentToolChoiceAgentsResponse2001$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        UpdateAgentFallbackModelConfigurationAgentsModalities$inboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsParameters$Outbound = {
  audio?:
    | UpdateAgentFallbackModelConfigurationAgentsAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatAgentsResponse200Text$Outbound
    | UpdateAgentResponseFormatAgentsResponse200JSONObject$Outbound
    | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | UpdateAgentFallbackModelConfigurationAgentsStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?:
    | UpdateAgentToolChoiceAgentsResponse2002$Outbound
    | string
    | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsParameters$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsParameters$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200Text$outboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200JSONObject$outboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$outboundSchema),
      UpdateAgentToolChoiceAgentsResponse2001$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        UpdateAgentFallbackModelConfigurationAgentsModalities$outboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsParametersToJSON(
  updateAgentFallbackModelConfigurationAgentsParameters:
    UpdateAgentFallbackModelConfigurationAgentsParameters,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsParameters$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsParameters,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsParameters' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgents2$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgents2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema
    ).optional(),
  });
/** @internal */
export type UpdateAgentFallbackModelConfigurationAgents2$Outbound = {
  id: string;
  parameters?:
    | UpdateAgentFallbackModelConfigurationAgentsParameters$Outbound
    | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgents2$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgents2$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgents2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsParameters$outboundSchema
    ).optional(),
  });

export function updateAgentFallbackModelConfigurationAgents2ToJSON(
  updateAgentFallbackModelConfigurationAgents2:
    UpdateAgentFallbackModelConfigurationAgents2,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgents2$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgents2,
    ),
  );
}
export function updateAgentFallbackModelConfigurationAgents2FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgents2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgents2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgents2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsFallbackModelConfiguration$inboundSchema:
  z.ZodType<
    UpdateAgentAgentsFallbackModelConfiguration,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$inboundSchema),
    z.string(),
  ]);
/** @internal */
export type UpdateAgentAgentsFallbackModelConfiguration$Outbound =
  | UpdateAgentFallbackModelConfigurationAgents2$Outbound
  | string;

/** @internal */
export const UpdateAgentAgentsFallbackModelConfiguration$outboundSchema:
  z.ZodType<
    UpdateAgentAgentsFallbackModelConfiguration$Outbound,
    z.ZodTypeDef,
    UpdateAgentAgentsFallbackModelConfiguration
  > = z.union([
    z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$outboundSchema),
    z.string(),
  ]);

export function updateAgentAgentsFallbackModelConfigurationToJSON(
  updateAgentAgentsFallbackModelConfiguration:
    UpdateAgentAgentsFallbackModelConfiguration,
): string {
  return JSON.stringify(
    UpdateAgentAgentsFallbackModelConfiguration$outboundSchema.parse(
      updateAgentAgentsFallbackModelConfiguration,
    ),
  );
}
export function updateAgentAgentsFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentAgentsFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentAgentsFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentAgentsFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModel$inboundSchema: z.ZodType<
  UpdateAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => UpdateAgentParameters$inboundSchema).optional(),
  retry: z.lazy(() => UpdateAgentRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type UpdateAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: UpdateAgentParameters$Outbound | undefined;
  retry?: UpdateAgentRetry$Outbound | undefined;
  fallback_models?:
    | Array<UpdateAgentFallbackModelConfigurationAgents2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const UpdateAgentModel$outboundSchema: z.ZodType<
  UpdateAgentModel$Outbound,
  z.ZodTypeDef,
  UpdateAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => UpdateAgentParameters$outboundSchema).optional(),
  retry: z.lazy(() => UpdateAgentRetry$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function updateAgentModelToJSON(
  updateAgentModel: UpdateAgentModel,
): string {
  return JSON.stringify(
    UpdateAgentModel$outboundSchema.parse(updateAgentModel),
  );
}
export function updateAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentModel' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsTeamOfAgents$inboundSchema: z.ZodType<
  UpdateAgentAgentsTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type UpdateAgentAgentsTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const UpdateAgentAgentsTeamOfAgents$outboundSchema: z.ZodType<
  UpdateAgentAgentsTeamOfAgents$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentsTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function updateAgentAgentsTeamOfAgentsToJSON(
  updateAgentAgentsTeamOfAgents: UpdateAgentAgentsTeamOfAgents,
): string {
  return JSON.stringify(
    UpdateAgentAgentsTeamOfAgents$outboundSchema.parse(
      updateAgentAgentsTeamOfAgents,
    ),
  );
}
export function updateAgentAgentsTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const UpdateAgentMetrics$inboundSchema: z.ZodType<
  UpdateAgentMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type UpdateAgentMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const UpdateAgentMetrics$outboundSchema: z.ZodType<
  UpdateAgentMetrics$Outbound,
  z.ZodTypeDef,
  UpdateAgentMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function updateAgentMetricsToJSON(
  updateAgentMetrics: UpdateAgentMetrics,
): string {
  return JSON.stringify(
    UpdateAgentMetrics$outboundSchema.parse(updateAgentMetrics),
  );
}
export function updateAgentMetricsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentMetrics' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsKnowledgeBases$inboundSchema: z.ZodType<
  UpdateAgentAgentsKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type UpdateAgentAgentsKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const UpdateAgentAgentsKnowledgeBases$outboundSchema: z.ZodType<
  UpdateAgentAgentsKnowledgeBases$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentsKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function updateAgentAgentsKnowledgeBasesToJSON(
  updateAgentAgentsKnowledgeBases: UpdateAgentAgentsKnowledgeBases,
): string {
  return JSON.stringify(
    UpdateAgentAgentsKnowledgeBases$outboundSchema.parse(
      updateAgentAgentsKnowledgeBases,
    ),
  );
}
export function updateAgentAgentsKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseBody$inboundSchema: z.ZodType<
  UpdateAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: UpdateAgentStatus$inboundSchema,
  settings: z.lazy(() => UpdateAgentAgentsSettings$inboundSchema).optional(),
  model: z.lazy(() => UpdateAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => UpdateAgentAgentsTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => UpdateAgentMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => UpdateAgentAgentsKnowledgeBases$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});
/** @internal */
export type UpdateAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  display_name: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: UpdateAgentAgentsSettings$Outbound | undefined;
  model: UpdateAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<UpdateAgentAgentsTeamOfAgents$Outbound>;
  metrics?: UpdateAgentMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<UpdateAgentAgentsKnowledgeBases$Outbound> | undefined;
};

/** @internal */
export const UpdateAgentResponseBody$outboundSchema: z.ZodType<
  UpdateAgentResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  displayName: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: UpdateAgentStatus$outboundSchema,
  settings: z.lazy(() => UpdateAgentAgentsSettings$outboundSchema).optional(),
  model: z.lazy(() => UpdateAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(
    z.lazy(() => UpdateAgentAgentsTeamOfAgents$outboundSchema),
  ),
  metrics: z.lazy(() => UpdateAgentMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => UpdateAgentAgentsKnowledgeBases$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
  });
});

export function updateAgentResponseBodyToJSON(
  updateAgentResponseBody: UpdateAgentResponseBody,
): string {
  return JSON.stringify(
    UpdateAgentResponseBody$outboundSchema.parse(updateAgentResponseBody),
  );
}
export function updateAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseBody' from JSON`,
  );
}
