/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ModelConfigurationVoice = ClosedEnum<
  typeof ModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ModelConfigurationFormat = ClosedEnum<
  typeof ModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ModelConfigurationFormat;
};

export type UpdateAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ModelConfigurationResponseFormat =
  | UpdateAgentResponseFormatText
  | UpdateAgentResponseFormatJSONObject
  | UpdateAgentResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const ModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type ModelConfigurationReasoningEffort = ClosedEnum<
  typeof ModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type ModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceType = ClosedEnum<
  typeof UpdateAgentToolChoiceType
>;

export type UpdateAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceType | undefined;
  function: UpdateAgentToolChoiceFunction;
};

export const UpdateAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoice1 = ClosedEnum<typeof UpdateAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ModelConfigurationToolChoice =
  | UpdateAgentToolChoice2
  | UpdateAgentToolChoice1;

export const ModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ModelConfigurationModalities = ClosedEnum<
  typeof ModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const UpdateAgentId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdateAgentId1 = ClosedEnum<typeof UpdateAgentId1>;

export type ModelConfigurationId = UpdateAgentId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const ModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type ModelConfigurationExecuteOn = ClosedEnum<
  typeof ModelConfigurationExecuteOn
>;

export type ModelConfigurationGuardrails = {
  id: UpdateAgentId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: ModelConfigurationExecuteOn;
};

export type ModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdateAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdateAgentModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type UpdateAgentModelConfigurationType = ClosedEnum<
  typeof UpdateAgentModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type ModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: UpdateAgentModelConfigurationType;
};

export const UpdateAgentLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type UpdateAgentLoadBalancerType = ClosedEnum<
  typeof UpdateAgentLoadBalancerType
>;

export type UpdateAgentLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type UpdateAgentLoadBalancer1 = {
  type: UpdateAgentLoadBalancerType;
  models: Array<UpdateAgentLoadBalancerModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type ModelConfigurationLoadBalancer = UpdateAgentLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type ModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type ModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatText
    | UpdateAgentResponseFormatJSONObject
    | UpdateAgentResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: ModelConfigurationReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ModelConfigurationStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: UpdateAgentToolChoice2 | UpdateAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ModelConfigurationModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<ModelConfigurationGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<ModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: UpdateAgentModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: ModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: UpdateAgentLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: ModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type UpdateAgentModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type UpdateAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: ModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: UpdateAgentModelConfigurationAgentsRetry | undefined;
};

/**
 * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
 */
export type UpdateAgentModelConfiguration =
  | UpdateAgentModelConfiguration2
  | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFallbackModelConfigurationFormat;
};

export type UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsRequestJSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentFallbackModelConfigurationResponseFormat =
  | UpdateAgentResponseFormatAgentsText
  | UpdateAgentResponseFormatAgentsJSONObject
  | UpdateAgentResponseFormatAgentsRequestJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const UpdateAgentFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type UpdateAgentFallbackModelConfigurationReasoningEffort = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsType = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsType
>;

export type UpdateAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsType | undefined;
  function: UpdateAgentToolChoiceAgentsFunction;
};

export const UpdateAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgents1 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentFallbackModelConfigurationToolChoice =
  | UpdateAgentToolChoiceAgents2
  | UpdateAgentToolChoiceAgents1;

export const UpdateAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const UpdateAgentIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdateAgentIdAgents1 = ClosedEnum<typeof UpdateAgentIdAgents1>;

export type UpdateAgentFallbackModelConfigurationId =
  | UpdateAgentIdAgents1
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const UpdateAgentFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type UpdateAgentFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationExecuteOn
>;

export type UpdateAgentFallbackModelConfigurationGuardrails = {
  id: UpdateAgentIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: UpdateAgentFallbackModelConfigurationExecuteOn;
};

export type UpdateAgentFallbackModelConfigurationFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdateAgentFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdateAgentFallbackModelConfigurationType = {
  ExactMatch: "exact_match",
} as const;
export type UpdateAgentFallbackModelConfigurationType = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationType
>;

/**
 * Cache configuration for the request.
 */
export type UpdateAgentFallbackModelConfigurationCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: UpdateAgentFallbackModelConfigurationType;
};

export const UpdateAgentLoadBalancerAgentsType = {
  WeightBased: "weight_based",
} as const;
export type UpdateAgentLoadBalancerAgentsType = ClosedEnum<
  typeof UpdateAgentLoadBalancerAgentsType
>;

export type UpdateAgentLoadBalancerAgentsModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type UpdateAgentLoadBalancerAgents1 = {
  type: UpdateAgentLoadBalancerAgentsType;
  models: Array<UpdateAgentLoadBalancerAgentsModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type UpdateAgentFallbackModelConfigurationLoadBalancer =
  UpdateAgentLoadBalancerAgents1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type UpdateAgentFallbackModelConfigurationTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type UpdateAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsText
    | UpdateAgentResponseFormatAgentsJSONObject
    | UpdateAgentResponseFormatAgentsRequestJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | UpdateAgentFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | UpdateAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgents2
    | UpdateAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<UpdateAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<UpdateAgentFallbackModelConfigurationGuardrails>
    | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<UpdateAgentFallbackModelConfigurationFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: UpdateAgentFallbackModelConfigurationRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: UpdateAgentFallbackModelConfigurationCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: UpdateAgentLoadBalancerAgents1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: UpdateAgentFallbackModelConfigurationTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type UpdateAgentFallbackModelConfigurationAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type UpdateAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: UpdateAgentFallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: UpdateAgentFallbackModelConfigurationAgentsRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type UpdateAgentFallbackModelConfiguration =
  | UpdateAgentFallbackModelConfiguration2
  | string;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const UpdateAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type UpdateAgentToolApprovalRequired = ClosedEnum<
  typeof UpdateAgentToolApprovalRequired
>;

/**
 * MCP tool type
 */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type =
  {
    Mcp: "mcp",
  } as const;
/**
 * MCP tool type
 */
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
  >;

/**
 * Executes tools from Model Context Protocol (MCP) servers. Specify the parent MCP tool using "key" or "id", and the specific nested tool using "tool_id".
 */
export type AgentToolInputCRUDMCPTool = {
  /**
   * MCP tool type
   */
  type?:
    | UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
    | undefined;
  /**
   * The key of the parent MCP tool
   */
  key?: string | undefined;
  /**
   * The ID of the parent MCP tool
   */
  id?: string | undefined;
  /**
   * The ID of the specific nested tool within the MCP server
   */
  toolId: string;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * JSON Schema tool type
 */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type =
  {
    JsonSchema: "json_schema",
  } as const;
/**
 * JSON Schema tool type
 */
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
  >;

/**
 * Enforces structured output format using JSON Schema. Must reference a pre-created JSON Schema tool by key or id.
 */
export type AgentToolInputCRUDJSONSchemaTool = {
  /**
   * JSON Schema tool type
   */
  type?:
    | UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
    | undefined;
  /**
   * The key of the pre-created JSON Schema tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created JSON Schema tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Function tool type
 */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  {
    Function: "function",
  } as const;
/**
 * Function tool type
 */
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  >;

/**
 * Calls custom function tools defined in the agent configuration. Must reference a pre-created function tool by key or id.
 */
export type AgentToolInputCRUDFunctionTool = {
  /**
   * Function tool type
   */
  type?:
    | UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
    | undefined;
  /**
   * The key of the pre-created function tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created function tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Code execution tool type
 */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  {
    Code: "code",
  } as const;
/**
 * Code execution tool type
 */
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  >;

/**
 * Executes code snippets in a sandboxed environment. Must reference a pre-created code tool by key or id.
 */
export type AgentToolInputCRUDCodeExecutionTool = {
  /**
   * Code execution tool type
   */
  type?:
    | UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
    | undefined;
  /**
   * The key of the pre-created code tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created code tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * HTTP tool type
 */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  {
    Http: "http",
  } as const;
/**
 * HTTP tool type
 */
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  >;

/**
 * Executes HTTP requests to interact with external APIs and web services. Must reference a pre-created HTTP tool by key or id.
 */
export type AgentToolInputCRUDHTTPTool = {
  /**
   * HTTP tool type
   */
  type?:
    | UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
    | undefined;
  /**
   * The key of the pre-created HTTP tool
   */
  key?: string | undefined;
  /**
   * The ID of the pre-created HTTP tool
   */
  id?: string | undefined;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  {
    CurrentDate: "current_date",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  >;

/**
 * Returns the current date and time
 */
export type AgentToolInputCRUDCurrentDateTool = {
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  {
    QueryKnowledgeBase: "query_knowledge_base",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  >;

/**
 * Queries knowledge bases for information
 */
export type AgentToolInputCRUDQueryKnowledgeBaseTool = {
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  {
    RetrieveKnowledgeBases: "retrieve_knowledge_bases",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  >;

/**
 * Lists available knowledge bases
 */
export type AgentToolInputCRUDRetrieveKnowledgeBasesTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  {
    DeleteMemoryDocument: "delete_memory_document",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  >;

/**
 * Deletes documents from memory stores
 */
export type AgentToolInputCRUDDeleteMemoryDocumentTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type =
  {
    RetrieveMemoryStores: "retrieve_memory_stores",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type
  >;

/**
 * Lists available memory stores
 */
export type AgentToolInputCRUDRetrieveMemoryStoresTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  {
    WriteMemoryStore: "write_memory_store",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  >;

/**
 * Writes information to agent memory stores
 */
export type AgentToolInputCRUDWriteMemoryStoreTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  {
    QueryMemoryStore: "query_memory_store",
  } as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType =
  ClosedEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  >;

/**
 * Queries agent memory stores for context
 */
export type AgentToolInputCRUDQueryMemoryStoreTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType = {
  RetrieveAgents: "retrieve_agents",
} as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType =
  ClosedEnum<typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType>;

/**
 * Retrieves available agents in the system
 */
export type AgentToolInputCRUDRetrieveAgentsTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsRequestType = {
  CallSubAgent: "call_sub_agent",
} as const;
export type UpdateAgentAgentToolInputCRUDAgentsRequestType = ClosedEnum<
  typeof UpdateAgentAgentToolInputCRUDAgentsRequestType
>;

/**
 * Delegates tasks to specialized sub-agents
 */
export type AgentToolInputCRUDCallSubAgentTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsRequestType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDAgentsType = {
  WebScraper: "web_scraper",
} as const;
export type UpdateAgentAgentToolInputCRUDAgentsType = ClosedEnum<
  typeof UpdateAgentAgentToolInputCRUDAgentsType
>;

/**
 * Scrapes and extracts content from web pages
 */
export type AgentToolInputCRUDWebScraperTool = {
  type: UpdateAgentAgentToolInputCRUDAgentsType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

export const UpdateAgentAgentToolInputCRUDType = {
  GoogleSearch: "google_search",
} as const;
export type UpdateAgentAgentToolInputCRUDType = ClosedEnum<
  typeof UpdateAgentAgentToolInputCRUDType
>;

/**
 * Performs Google searches to retrieve web content
 */
export type AgentToolInputCRUDGoogleSearchTool = {
  type: UpdateAgentAgentToolInputCRUDType;
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent create/update operations. Built-in tools only require a type, while custom tools (HTTP, Code, Function, JSON Schema, MCP) must reference pre-created tools by key or id.
 */
export type UpdateAgentAgentToolInputCRUD =
  | AgentToolInputCRUDGoogleSearchTool
  | AgentToolInputCRUDWebScraperTool
  | AgentToolInputCRUDCallSubAgentTool
  | AgentToolInputCRUDRetrieveAgentsTool
  | AgentToolInputCRUDQueryMemoryStoreTool
  | AgentToolInputCRUDWriteMemoryStoreTool
  | AgentToolInputCRUDRetrieveMemoryStoresTool
  | AgentToolInputCRUDDeleteMemoryDocumentTool
  | AgentToolInputCRUDRetrieveKnowledgeBasesTool
  | AgentToolInputCRUDQueryKnowledgeBaseTool
  | AgentToolInputCRUDCurrentDateTool
  | AgentToolInputCRUDMCPTool
  | AgentToolInputCRUDHTTPTool
  | AgentToolInputCRUDCodeExecutionTool
  | AgentToolInputCRUDFunctionTool
  | AgentToolInputCRUDJSONSchemaTool;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentExecuteOn = ClosedEnum<typeof UpdateAgentExecuteOn>;

export type UpdateAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsExecuteOn
>;

export type UpdateAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsExecuteOn;
};

export type UpdateAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: UpdateAgentToolApprovalRequired | undefined;
  /**
   * Tools available to the agent. Built-in tools only need a type, while custom tools (http, code, function) must reference pre-created tools by key or id.
   */
  tools?:
    | Array<
      | AgentToolInputCRUDGoogleSearchTool
      | AgentToolInputCRUDWebScraperTool
      | AgentToolInputCRUDCallSubAgentTool
      | AgentToolInputCRUDRetrieveAgentsTool
      | AgentToolInputCRUDQueryMemoryStoreTool
      | AgentToolInputCRUDWriteMemoryStoreTool
      | AgentToolInputCRUDRetrieveMemoryStoresTool
      | AgentToolInputCRUDDeleteMemoryDocumentTool
      | AgentToolInputCRUDRetrieveKnowledgeBasesTool
      | AgentToolInputCRUDQueryKnowledgeBaseTool
      | AgentToolInputCRUDCurrentDateTool
      | AgentToolInputCRUDMCPTool
      | AgentToolInputCRUDHTTPTool
      | AgentToolInputCRUDCodeExecutionTool
      | AgentToolInputCRUDFunctionTool
      | AgentToolInputCRUDJSONSchemaTool
    >
    | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<UpdateAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<UpdateAgentGuardrails> | undefined;
};

export type UpdateAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type UpdateAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

/**
 * Request body for updating an existing agent via the API. Uses simplified tool input format.
 */
export type UpdateAgentUpdateAgentRequest = {
  key?: string | undefined;
  displayName?: string | undefined;
  projectId?: string | undefined;
  role?: string | undefined;
  /**
   * A brief description of what the agent does
   */
  description?: string | undefined;
  instructions?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Model configuration for agent execution. Can be a simple model ID string or a configuration object with optional behavior parameters and retry settings.
   */
  model?: UpdateAgentModelConfiguration2 | string | undefined;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<UpdateAgentFallbackModelConfiguration2 | string>
    | undefined;
  settings?: UpdateAgentSettings | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  knowledgeBases?: Array<UpdateAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<UpdateAgentTeamOfAgents> | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
};

export type UpdateAgentRequest = {
  /**
   * The unique key of the agent to update
   */
  agentKey: string;
  requestBody: UpdateAgentUpdateAgentRequest;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const UpdateAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type UpdateAgentStatus = ClosedEnum<typeof UpdateAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const UpdateAgentAgentsToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type UpdateAgentAgentsToolApprovalRequired = ClosedEnum<
  typeof UpdateAgentAgentsToolApprovalRequired
>;

export type UpdateAgentConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type UpdateAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval: boolean;
  /**
   * Nested tool ID for MCP tools (identifies specific tool within MCP server)
   */
  toolId?: string | undefined;
  conditions?: Array<UpdateAgentConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout: number;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsResponseExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsResponseExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsResponseExecuteOn
>;

export type UpdateAgentAgentsEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsResponseExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const UpdateAgentAgentsResponse200ExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type UpdateAgentAgentsResponse200ExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsResponse200ExecuteOn
>;

export type UpdateAgentAgentsGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate: number;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: UpdateAgentAgentsResponse200ExecuteOn;
};

export type UpdateAgentAgentsSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations: number;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime: number;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired: UpdateAgentAgentsToolApprovalRequired;
  tools?: Array<UpdateAgentTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<UpdateAgentAgentsEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<UpdateAgentAgentsGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentVoice = ClosedEnum<typeof UpdateAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFormat = ClosedEnum<typeof UpdateAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFormat;
};

export type UpdateAgentResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsResponse200JSONSchema = {
  type: "json_schema";
  jsonSchema: UpdateAgentResponseFormatAgentsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsResponseJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsResponseText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentResponseFormat =
  | UpdateAgentResponseFormatAgentsResponseText
  | UpdateAgentResponseFormatAgentsResponseJSONObject
  | UpdateAgentResponseFormatAgentsResponse200JSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const UpdateAgentReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type UpdateAgentReasoningEffort = ClosedEnum<
  typeof UpdateAgentReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsResponseType = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponseType
>;

export type UpdateAgentToolChoiceAgentsResponseFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgentsResponse2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsResponseType | undefined;
  function: UpdateAgentToolChoiceAgentsResponseFunction;
};

export const UpdateAgentToolChoiceAgentsResponse1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgentsResponse1 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentToolChoice =
  | UpdateAgentToolChoiceAgentsResponse2
  | UpdateAgentToolChoiceAgentsResponse1;

export const UpdateAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentModalities = ClosedEnum<typeof UpdateAgentModalities>;

/**
 * The key of the guardrail.
 */
export const UpdateAgentIdAgentsResponse1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdateAgentIdAgentsResponse1 = ClosedEnum<
  typeof UpdateAgentIdAgentsResponse1
>;

export type UpdateAgentId = UpdateAgentIdAgentsResponse1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const UpdateAgentAgentsResponse200ApplicationJSONExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type UpdateAgentAgentsResponse200ApplicationJSONExecuteOn = ClosedEnum<
  typeof UpdateAgentAgentsResponse200ApplicationJSONExecuteOn
>;

export type UpdateAgentAgentsResponseGuardrails = {
  id: UpdateAgentIdAgentsResponse1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: UpdateAgentAgentsResponse200ApplicationJSONExecuteOn;
};

export type UpdateAgentFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdateAgentAgentsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdateAgentType = {
  ExactMatch: "exact_match",
} as const;
export type UpdateAgentType = ClosedEnum<typeof UpdateAgentType>;

/**
 * Cache configuration for the request.
 */
export type UpdateAgentCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: UpdateAgentType;
};

export const UpdateAgentLoadBalancerAgentsResponseType = {
  WeightBased: "weight_based",
} as const;
export type UpdateAgentLoadBalancerAgentsResponseType = ClosedEnum<
  typeof UpdateAgentLoadBalancerAgentsResponseType
>;

export type UpdateAgentLoadBalancerAgentsResponseModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type UpdateAgentLoadBalancerAgentsResponse1 = {
  type: UpdateAgentLoadBalancerAgentsResponseType;
  models: Array<UpdateAgentLoadBalancerAgentsResponseModels>;
};

/**
 * Load balancer configuration for the request.
 */
export type UpdateAgentLoadBalancer = UpdateAgentLoadBalancerAgentsResponse1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type UpdateAgentTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type UpdateAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsResponseText
    | UpdateAgentResponseFormatAgentsResponseJSONObject
    | UpdateAgentResponseFormatAgentsResponse200JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: UpdateAgentReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: UpdateAgentStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgentsResponse2
    | UpdateAgentToolChoiceAgentsResponse1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<UpdateAgentModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<UpdateAgentAgentsResponseGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<UpdateAgentFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: UpdateAgentAgentsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: UpdateAgentCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: UpdateAgentLoadBalancerAgentsResponse1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: UpdateAgentTimeout | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type UpdateAgentRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdateAgentFallbackModelConfigurationAgentsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdateAgentFallbackModelConfigurationAgentsVoice = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdateAgentFallbackModelConfigurationAgentsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdateAgentFallbackModelConfigurationAgentsFormat = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdateAgentFallbackModelConfigurationAgentsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdateAgentFallbackModelConfigurationAgentsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdateAgentFallbackModelConfigurationAgentsFormat;
};

export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema =
  {
    /**
     * A description of what the response format is for, used by the model to determine how to respond in the format.
     */
    description?: string | undefined;
    /**
     * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
     */
    name: string;
    /**
     * The schema for the response format, described as a JSON Schema object.
     */
    schema?: any | undefined;
    /**
     * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
     */
    strict: boolean;
  };

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema =
  {
    type: "json_schema";
    jsonSchema:
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema;
  };

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdateAgentResponseFormatAgentsResponse200JSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdateAgentResponseFormatAgentsResponse200Text = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdateAgentFallbackModelConfigurationAgentsResponseFormat =
  | UpdateAgentResponseFormatAgentsResponse200Text
  | UpdateAgentResponseFormatAgentsResponse200JSONObject
  | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const UpdateAgentFallbackModelConfigurationAgentsReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type UpdateAgentFallbackModelConfigurationAgentsReasoningEffort =
  ClosedEnum<typeof UpdateAgentFallbackModelConfigurationAgentsReasoningEffort>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdateAgentFallbackModelConfigurationAgentsStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdateAgentFallbackModelConfigurationAgentsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdateAgentFallbackModelConfigurationAgentsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdateAgentToolChoiceAgentsResponse200Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdateAgentToolChoiceAgentsResponse200Type = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse200Type
>;

export type UpdateAgentToolChoiceAgentsResponse200Function = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdateAgentToolChoiceAgentsResponse2002 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdateAgentToolChoiceAgentsResponse200Type | undefined;
  function: UpdateAgentToolChoiceAgentsResponse200Function;
};

export const UpdateAgentToolChoiceAgentsResponse2001 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdateAgentToolChoiceAgentsResponse2001 = ClosedEnum<
  typeof UpdateAgentToolChoiceAgentsResponse2001
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdateAgentFallbackModelConfigurationAgentsToolChoice =
  | UpdateAgentToolChoiceAgentsResponse2002
  | UpdateAgentToolChoiceAgentsResponse2001;

export const UpdateAgentFallbackModelConfigurationAgentsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdateAgentFallbackModelConfigurationAgentsModalities = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsModalities
>;

/**
 * The key of the guardrail.
 */
export const UpdateAgentIdAgentsResponse2001 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdateAgentIdAgentsResponse2001 = ClosedEnum<
  typeof UpdateAgentIdAgentsResponse2001
>;

export type UpdateAgentFallbackModelConfigurationAgentsId =
  | UpdateAgentIdAgentsResponse2001
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const UpdateAgentFallbackModelConfigurationAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type UpdateAgentFallbackModelConfigurationAgentsExecuteOn = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsExecuteOn
>;

export type UpdateAgentFallbackModelConfigurationAgentsGuardrails = {
  id: UpdateAgentIdAgentsResponse2001 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: UpdateAgentFallbackModelConfigurationAgentsExecuteOn;
};

export type UpdateAgentFallbackModelConfigurationAgentsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdateAgentFallbackModelConfigurationAgentsResponse200Retry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdateAgentFallbackModelConfigurationAgentsType = {
  ExactMatch: "exact_match",
} as const;
export type UpdateAgentFallbackModelConfigurationAgentsType = ClosedEnum<
  typeof UpdateAgentFallbackModelConfigurationAgentsType
>;

/**
 * Cache configuration for the request.
 */
export type UpdateAgentFallbackModelConfigurationAgentsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: UpdateAgentFallbackModelConfigurationAgentsType;
};

export const UpdateAgentLoadBalancerAgentsResponse200Type = {
  WeightBased: "weight_based",
} as const;
export type UpdateAgentLoadBalancerAgentsResponse200Type = ClosedEnum<
  typeof UpdateAgentLoadBalancerAgentsResponse200Type
>;

export type UpdateAgentLoadBalancerAgentsResponse200Models = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type UpdateAgentLoadBalancerAgentsResponse2001 = {
  type: UpdateAgentLoadBalancerAgentsResponse200Type;
  models: Array<UpdateAgentLoadBalancerAgentsResponse200Models>;
};

/**
 * Load balancer configuration for the request.
 */
export type UpdateAgentFallbackModelConfigurationAgentsLoadBalancer =
  UpdateAgentLoadBalancerAgentsResponse2001;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type UpdateAgentFallbackModelConfigurationAgentsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type UpdateAgentFallbackModelConfigurationAgentsParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdateAgentFallbackModelConfigurationAgentsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdateAgentResponseFormatAgentsResponse200Text
    | UpdateAgentResponseFormatAgentsResponse200JSONObject
    | UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | UpdateAgentFallbackModelConfigurationAgentsReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | UpdateAgentFallbackModelConfigurationAgentsStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdateAgentToolChoiceAgentsResponse2002
    | UpdateAgentToolChoiceAgentsResponse2001
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<UpdateAgentFallbackModelConfigurationAgentsModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<UpdateAgentFallbackModelConfigurationAgentsGuardrails>
    | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?:
    | Array<UpdateAgentFallbackModelConfigurationAgentsFallbacks>
    | undefined;
  /**
   * Retry configuration for the request
   */
  retry?:
    | UpdateAgentFallbackModelConfigurationAgentsResponse200Retry
    | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: UpdateAgentFallbackModelConfigurationAgentsCache | undefined;
  /**
   * Load balancer configuration for the request.
   */
  loadBalancer?: UpdateAgentLoadBalancerAgentsResponse2001 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: UpdateAgentFallbackModelConfigurationAgentsTimeout | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type UpdateAgentFallbackModelConfigurationAgentsResponseRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type UpdateAgentFallbackModelConfigurationAgents2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?:
    | UpdateAgentFallbackModelConfigurationAgentsParameters
    | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: UpdateAgentFallbackModelConfigurationAgentsResponseRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type UpdateAgentAgentsFallbackModelConfiguration =
  | UpdateAgentFallbackModelConfigurationAgents2
  | string;

export type UpdateAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: UpdateAgentParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: UpdateAgentRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<UpdateAgentFallbackModelConfigurationAgents2 | string>
    | null
    | undefined;
};

export type UpdateAgentAgentsTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type UpdateAgentMetrics = {
  totalCost: number;
};

export type UpdateAgentAgentsKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export const UpdateAgentSource = {
  Internal: "internal",
  External: "external",
  Experiment: "experiment",
} as const;
export type UpdateAgentSource = ClosedEnum<typeof UpdateAgentSource>;

/**
 * Agent configuration successfully updated. Returns the complete updated agent manifest reflecting all changes made.
 */
export type UpdateAgentResponseBody = {
  id: string;
  /**
   * Unique identifier for the agent within the workspace
   */
  key: string;
  displayName: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: UpdateAgentStatus;
  settings?: UpdateAgentAgentsSettings | undefined;
  model: UpdateAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<UpdateAgentAgentsTeamOfAgents>;
  metrics?: UpdateAgentMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<UpdateAgentAgentsKnowledgeBases> | undefined;
  source?: UpdateAgentSource | undefined;
};

/** @internal */
export const ModelConfigurationVoice$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationVoice
> = z.nativeEnum(ModelConfigurationVoice);

/** @internal */
export const ModelConfigurationFormat$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationFormat
> = z.nativeEnum(ModelConfigurationFormat);

/** @internal */
export type UpdateAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  UpdateAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfigurationAudio
> = z.object({
  voice: ModelConfigurationVoice$outboundSchema,
  format: ModelConfigurationFormat$outboundSchema,
});

export function updateAgentModelConfigurationAudioToJSON(
  updateAgentModelConfigurationAudio: UpdateAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    UpdateAgentModelConfigurationAudio$outboundSchema.parse(
      updateAgentModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsJsonSchemaToJSON(
  updateAgentResponseFormatAgentsJsonSchema:
    UpdateAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsJsonSchema,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: UpdateAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const UpdateAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    UpdateAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function updateAgentResponseFormatJSONSchemaToJSON(
  updateAgentResponseFormatJSONSchema: UpdateAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatJSONSchema$outboundSchema.parse(
      updateAgentResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function updateAgentResponseFormatJSONObjectToJSON(
  updateAgentResponseFormatJSONObject: UpdateAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatJSONObject$outboundSchema.parse(
      updateAgentResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatText$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function updateAgentResponseFormatTextToJSON(
  updateAgentResponseFormatText: UpdateAgentResponseFormatText,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatText$outboundSchema.parse(
      updateAgentResponseFormatText,
    ),
  );
}

/** @internal */
export type ModelConfigurationResponseFormat$Outbound =
  | UpdateAgentResponseFormatText$Outbound
  | UpdateAgentResponseFormatJSONObject$Outbound
  | UpdateAgentResponseFormatJSONSchema$Outbound;

/** @internal */
export const ModelConfigurationResponseFormat$outboundSchema: z.ZodType<
  ModelConfigurationResponseFormat$Outbound,
  z.ZodTypeDef,
  ModelConfigurationResponseFormat
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatText$outboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONObject$outboundSchema),
  z.lazy(() => UpdateAgentResponseFormatJSONSchema$outboundSchema),
]);

export function modelConfigurationResponseFormatToJSON(
  modelConfigurationResponseFormat: ModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    ModelConfigurationResponseFormat$outboundSchema.parse(
      modelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const ModelConfigurationReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationReasoningEffort
> = z.nativeEnum(ModelConfigurationReasoningEffort);

/** @internal */
export type ModelConfigurationStop$Outbound = string | Array<string>;

/** @internal */
export const ModelConfigurationStop$outboundSchema: z.ZodType<
  ModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  ModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function modelConfigurationStopToJSON(
  modelConfigurationStop: ModelConfigurationStop,
): string {
  return JSON.stringify(
    ModelConfigurationStop$outboundSchema.parse(modelConfigurationStop),
  );
}

/** @internal */
export type ModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const ModelConfigurationStreamOptions$outboundSchema: z.ZodType<
  ModelConfigurationStreamOptions$Outbound,
  z.ZodTypeDef,
  ModelConfigurationStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function modelConfigurationStreamOptionsToJSON(
  modelConfigurationStreamOptions: ModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    ModelConfigurationStreamOptions$outboundSchema.parse(
      modelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type ModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const ModelConfigurationThinking$outboundSchema: z.ZodType<
  ModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  ModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function modelConfigurationThinkingToJSON(
  modelConfigurationThinking: ModelConfigurationThinking,
): string {
  return JSON.stringify(
    ModelConfigurationThinking$outboundSchema.parse(modelConfigurationThinking),
  );
}

/** @internal */
export const UpdateAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceType
> = z.nativeEnum(UpdateAgentToolChoiceType);

/** @internal */
export type UpdateAgentToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceFunction$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function updateAgentToolChoiceFunctionToJSON(
  updateAgentToolChoiceFunction: UpdateAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceFunction$outboundSchema.parse(
      updateAgentToolChoiceFunction,
    ),
  );
}

/** @internal */
export type UpdateAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const UpdateAgentToolChoice2$outboundSchema: z.ZodType<
  UpdateAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoice2
> = z.object({
  type: UpdateAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceFunction$outboundSchema),
});

export function updateAgentToolChoice2ToJSON(
  updateAgentToolChoice2: UpdateAgentToolChoice2,
): string {
  return JSON.stringify(
    UpdateAgentToolChoice2$outboundSchema.parse(updateAgentToolChoice2),
  );
}

/** @internal */
export const UpdateAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoice1
> = z.nativeEnum(UpdateAgentToolChoice1);

/** @internal */
export type ModelConfigurationToolChoice$Outbound =
  | UpdateAgentToolChoice2$Outbound
  | string;

/** @internal */
export const ModelConfigurationToolChoice$outboundSchema: z.ZodType<
  ModelConfigurationToolChoice$Outbound,
  z.ZodTypeDef,
  ModelConfigurationToolChoice
> = z.union([
  z.lazy(() => UpdateAgentToolChoice2$outboundSchema),
  UpdateAgentToolChoice1$outboundSchema,
]);

export function modelConfigurationToolChoiceToJSON(
  modelConfigurationToolChoice: ModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    ModelConfigurationToolChoice$outboundSchema.parse(
      modelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const ModelConfigurationModalities$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationModalities
> = z.nativeEnum(ModelConfigurationModalities);

/** @internal */
export const UpdateAgentId1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentId1
> = z.nativeEnum(UpdateAgentId1);

/** @internal */
export type ModelConfigurationId$Outbound = string | string;

/** @internal */
export const ModelConfigurationId$outboundSchema: z.ZodType<
  ModelConfigurationId$Outbound,
  z.ZodTypeDef,
  ModelConfigurationId
> = z.union([UpdateAgentId1$outboundSchema, z.string()]);

export function modelConfigurationIdToJSON(
  modelConfigurationId: ModelConfigurationId,
): string {
  return JSON.stringify(
    ModelConfigurationId$outboundSchema.parse(modelConfigurationId),
  );
}

/** @internal */
export const ModelConfigurationExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof ModelConfigurationExecuteOn
> = z.nativeEnum(ModelConfigurationExecuteOn);

/** @internal */
export type ModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const ModelConfigurationGuardrails$outboundSchema: z.ZodType<
  ModelConfigurationGuardrails$Outbound,
  z.ZodTypeDef,
  ModelConfigurationGuardrails
> = z.object({
  id: z.union([UpdateAgentId1$outboundSchema, z.string()]),
  executeOn: ModelConfigurationExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function modelConfigurationGuardrailsToJSON(
  modelConfigurationGuardrails: ModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    ModelConfigurationGuardrails$outboundSchema.parse(
      modelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type ModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const ModelConfigurationFallbacks$outboundSchema: z.ZodType<
  ModelConfigurationFallbacks$Outbound,
  z.ZodTypeDef,
  ModelConfigurationFallbacks
> = z.object({
  model: z.string(),
});

export function modelConfigurationFallbacksToJSON(
  modelConfigurationFallbacks: ModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    ModelConfigurationFallbacks$outboundSchema.parse(
      modelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type UpdateAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdateAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  UpdateAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function updateAgentModelConfigurationRetryToJSON(
  updateAgentModelConfigurationRetry: UpdateAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    UpdateAgentModelConfigurationRetry$outboundSchema.parse(
      updateAgentModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const UpdateAgentModelConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentModelConfigurationType
> = z.nativeEnum(UpdateAgentModelConfigurationType);

/** @internal */
export type ModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const ModelConfigurationCache$outboundSchema: z.ZodType<
  ModelConfigurationCache$Outbound,
  z.ZodTypeDef,
  ModelConfigurationCache
> = z.object({
  ttl: z.number().default(1800),
  type: UpdateAgentModelConfigurationType$outboundSchema,
});

export function modelConfigurationCacheToJSON(
  modelConfigurationCache: ModelConfigurationCache,
): string {
  return JSON.stringify(
    ModelConfigurationCache$outboundSchema.parse(modelConfigurationCache),
  );
}

/** @internal */
export const UpdateAgentLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentLoadBalancerType
> = z.nativeEnum(UpdateAgentLoadBalancerType);

/** @internal */
export type UpdateAgentLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const UpdateAgentLoadBalancerModels$outboundSchema: z.ZodType<
  UpdateAgentLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  UpdateAgentLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function updateAgentLoadBalancerModelsToJSON(
  updateAgentLoadBalancerModels: UpdateAgentLoadBalancerModels,
): string {
  return JSON.stringify(
    UpdateAgentLoadBalancerModels$outboundSchema.parse(
      updateAgentLoadBalancerModels,
    ),
  );
}

/** @internal */
export type UpdateAgentLoadBalancer1$Outbound = {
  type: string;
  models: Array<UpdateAgentLoadBalancerModels$Outbound>;
};

/** @internal */
export const UpdateAgentLoadBalancer1$outboundSchema: z.ZodType<
  UpdateAgentLoadBalancer1$Outbound,
  z.ZodTypeDef,
  UpdateAgentLoadBalancer1
> = z.object({
  type: UpdateAgentLoadBalancerType$outboundSchema,
  models: z.array(z.lazy(() => UpdateAgentLoadBalancerModels$outboundSchema)),
});

export function updateAgentLoadBalancer1ToJSON(
  updateAgentLoadBalancer1: UpdateAgentLoadBalancer1,
): string {
  return JSON.stringify(
    UpdateAgentLoadBalancer1$outboundSchema.parse(updateAgentLoadBalancer1),
  );
}

/** @internal */
export type ModelConfigurationLoadBalancer$Outbound =
  UpdateAgentLoadBalancer1$Outbound;

/** @internal */
export const ModelConfigurationLoadBalancer$outboundSchema: z.ZodType<
  ModelConfigurationLoadBalancer$Outbound,
  z.ZodTypeDef,
  ModelConfigurationLoadBalancer
> = z.lazy(() => UpdateAgentLoadBalancer1$outboundSchema);

export function modelConfigurationLoadBalancerToJSON(
  modelConfigurationLoadBalancer: ModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    ModelConfigurationLoadBalancer$outboundSchema.parse(
      modelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type ModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const ModelConfigurationTimeout$outboundSchema: z.ZodType<
  ModelConfigurationTimeout$Outbound,
  z.ZodTypeDef,
  ModelConfigurationTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function modelConfigurationTimeoutToJSON(
  modelConfigurationTimeout: ModelConfigurationTimeout,
): string {
  return JSON.stringify(
    ModelConfigurationTimeout$outboundSchema.parse(modelConfigurationTimeout),
  );
}

/** @internal */
export type ModelConfigurationParameters$Outbound = {
  audio?: UpdateAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatText$Outbound
    | UpdateAgentResponseFormatJSONObject$Outbound
    | UpdateAgentResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: ModelConfigurationStreamOptions$Outbound | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: UpdateAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<ModelConfigurationGuardrails$Outbound> | undefined;
  fallbacks?: Array<ModelConfigurationFallbacks$Outbound> | undefined;
  retry?: UpdateAgentModelConfigurationRetry$Outbound | undefined;
  cache?: ModelConfigurationCache$Outbound | undefined;
  load_balancer?: UpdateAgentLoadBalancer1$Outbound | undefined;
  timeout?: ModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const ModelConfigurationParameters$outboundSchema: z.ZodType<
  ModelConfigurationParameters$Outbound,
  z.ZodTypeDef,
  ModelConfigurationParameters
> = z.object({
  audio: z.nullable(
    z.lazy(() => UpdateAgentModelConfigurationAudio$outboundSchema),
  ).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => UpdateAgentResponseFormatText$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONObject$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: ModelConfigurationReasoningEffort$outboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => ModelConfigurationStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => UpdateAgentToolChoice2$outboundSchema),
    UpdateAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(ModelConfigurationModalities$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => ModelConfigurationGuardrails$outboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => ModelConfigurationFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => UpdateAgentModelConfigurationRetry$outboundSchema)
    .optional(),
  cache: z.lazy(() => ModelConfigurationCache$outboundSchema).optional(),
  loadBalancer: z.lazy(() => UpdateAgentLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => ModelConfigurationTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function modelConfigurationParametersToJSON(
  modelConfigurationParameters: ModelConfigurationParameters,
): string {
  return JSON.stringify(
    ModelConfigurationParameters$outboundSchema.parse(
      modelConfigurationParameters,
    ),
  );
}

/** @internal */
export type UpdateAgentModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdateAgentModelConfigurationAgentsRetry$outboundSchema: z.ZodType<
  UpdateAgentModelConfigurationAgentsRetry$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfigurationAgentsRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function updateAgentModelConfigurationAgentsRetryToJSON(
  updateAgentModelConfigurationAgentsRetry:
    UpdateAgentModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    UpdateAgentModelConfigurationAgentsRetry$outboundSchema.parse(
      updateAgentModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type UpdateAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: ModelConfigurationParameters$Outbound | undefined;
  retry?: UpdateAgentModelConfigurationAgentsRetry$Outbound | undefined;
};

/** @internal */
export const UpdateAgentModelConfiguration2$outboundSchema: z.ZodType<
  UpdateAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() => ModelConfigurationParameters$outboundSchema)
    .optional(),
  retry: z.lazy(() => UpdateAgentModelConfigurationAgentsRetry$outboundSchema)
    .optional(),
});

export function updateAgentModelConfiguration2ToJSON(
  updateAgentModelConfiguration2: UpdateAgentModelConfiguration2,
): string {
  return JSON.stringify(
    UpdateAgentModelConfiguration2$outboundSchema.parse(
      updateAgentModelConfiguration2,
    ),
  );
}

/** @internal */
export type UpdateAgentModelConfiguration$Outbound =
  | UpdateAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const UpdateAgentModelConfiguration$outboundSchema: z.ZodType<
  UpdateAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  UpdateAgentModelConfiguration
> = z.union([
  z.lazy(() => UpdateAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function updateAgentModelConfigurationToJSON(
  updateAgentModelConfiguration: UpdateAgentModelConfiguration,
): string {
  return JSON.stringify(
    UpdateAgentModelConfiguration$outboundSchema.parse(
      updateAgentModelConfiguration,
    ),
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationVoice);

/** @internal */
export const UpdateAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationFormat);

/** @internal */
export type UpdateAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: UpdateAgentFallbackModelConfigurationVoice$outboundSchema,
    format: UpdateAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function updateAgentFallbackModelConfigurationAudioToJSON(
  updateAgentFallbackModelConfigurationAudio:
    UpdateAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAudio,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  updateAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(updateAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}

/** @internal */
export type UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function updateAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  updateAgentResponseFormatAgentsRequestJSONSchema:
    UpdateAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      updateAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    UpdateAgentResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsJSONObjectToJSON(
  updateAgentResponseFormatAgentsJSONObject:
    UpdateAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      updateAgentResponseFormatAgentsJSONObject,
    ),
  );
}

/** @internal */
export type UpdateAgentResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdateAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  UpdateAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  UpdateAgentResponseFormatAgentsText
> = z.object({
  type: z.literal("text"),
});

export function updateAgentResponseFormatAgentsTextToJSON(
  updateAgentResponseFormatAgentsText: UpdateAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    UpdateAgentResponseFormatAgentsText$outboundSchema.parse(
      updateAgentResponseFormatAgentsText,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationResponseFormat$Outbound =
  | UpdateAgentResponseFormatAgentsText$Outbound
  | UpdateAgentResponseFormatAgentsJSONObject$Outbound
  | UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$outboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
    ),
  ]);

export function updateAgentFallbackModelConfigurationResponseFormatToJSON(
  updateAgentFallbackModelConfigurationResponseFormat:
    UpdateAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      updateAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationReasoningEffort> =
    z.nativeEnum(UpdateAgentFallbackModelConfigurationReasoningEffort);

/** @internal */
export type UpdateAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const UpdateAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function updateAgentFallbackModelConfigurationStopToJSON(
  updateAgentFallbackModelConfigurationStop:
    UpdateAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationStop$outboundSchema.parse(
      updateAgentFallbackModelConfigurationStop,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function updateAgentFallbackModelConfigurationStreamOptionsToJSON(
  updateAgentFallbackModelConfigurationStreamOptions:
    UpdateAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      updateAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationThinkingToJSON(
  updateAgentFallbackModelConfigurationThinking:
    UpdateAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      updateAgentFallbackModelConfigurationThinking,
    ),
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgentsType
> = z.nativeEnum(UpdateAgentToolChoiceAgentsType);

/** @internal */
export type UpdateAgentToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdateAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string(),
});

export function updateAgentToolChoiceAgentsFunctionToJSON(
  updateAgentToolChoiceAgentsFunction: UpdateAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgentsFunction$outboundSchema.parse(
      updateAgentToolChoiceAgentsFunction,
    ),
  );
}

/** @internal */
export type UpdateAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: UpdateAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const UpdateAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  UpdateAgentToolChoiceAgents2
> = z.object({
  type: UpdateAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => UpdateAgentToolChoiceAgentsFunction$outboundSchema),
});

export function updateAgentToolChoiceAgents2ToJSON(
  updateAgentToolChoiceAgents2: UpdateAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    UpdateAgentToolChoiceAgents2$outboundSchema.parse(
      updateAgentToolChoiceAgents2,
    ),
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolChoiceAgents1
> = z.nativeEnum(UpdateAgentToolChoiceAgents1);

/** @internal */
export type UpdateAgentFallbackModelConfigurationToolChoice$Outbound =
  | UpdateAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const UpdateAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgents2$outboundSchema),
    UpdateAgentToolChoiceAgents1$outboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationToolChoiceToJSON(
  updateAgentFallbackModelConfigurationToolChoice:
    UpdateAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      updateAgentFallbackModelConfigurationToolChoice,
    ),
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationModalities);

/** @internal */
export const UpdateAgentIdAgents1$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentIdAgents1
> = z.nativeEnum(UpdateAgentIdAgents1);

/** @internal */
export type UpdateAgentFallbackModelConfigurationId$Outbound = string | string;

/** @internal */
export const UpdateAgentFallbackModelConfigurationId$outboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfigurationId$Outbound,
  z.ZodTypeDef,
  UpdateAgentFallbackModelConfigurationId
> = z.union([UpdateAgentIdAgents1$outboundSchema, z.string()]);

export function updateAgentFallbackModelConfigurationIdToJSON(
  updateAgentFallbackModelConfigurationId:
    UpdateAgentFallbackModelConfigurationId,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationId$outboundSchema.parse(
      updateAgentFallbackModelConfigurationId,
    ),
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationExecuteOn> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationExecuteOn);

/** @internal */
export type UpdateAgentFallbackModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationGuardrails
  > = z.object({
    id: z.union([UpdateAgentIdAgents1$outboundSchema, z.string()]),
    executeOn: UpdateAgentFallbackModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function updateAgentFallbackModelConfigurationGuardrailsToJSON(
  updateAgentFallbackModelConfigurationGuardrails:
    UpdateAgentFallbackModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationGuardrails$outboundSchema.parse(
      updateAgentFallbackModelConfigurationGuardrails,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationFallbacks$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationFallbacks$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationFallbacks
  > = z.object({
    model: z.string(),
  });

export function updateAgentFallbackModelConfigurationFallbacksToJSON(
  updateAgentFallbackModelConfigurationFallbacks:
    UpdateAgentFallbackModelConfigurationFallbacks,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationFallbacks$outboundSchema.parse(
      updateAgentFallbackModelConfigurationFallbacks,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationRetry$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationRetry$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function updateAgentFallbackModelConfigurationRetryToJSON(
  updateAgentFallbackModelConfigurationRetry:
    UpdateAgentFallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationRetry$outboundSchema.parse(
      updateAgentFallbackModelConfigurationRetry,
    ),
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationType> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationType);

/** @internal */
export type UpdateAgentFallbackModelConfigurationCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationCache$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationCache$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationCache
  > = z.object({
    ttl: z.number().default(1800),
    type: UpdateAgentFallbackModelConfigurationType$outboundSchema,
  });

export function updateAgentFallbackModelConfigurationCacheToJSON(
  updateAgentFallbackModelConfigurationCache:
    UpdateAgentFallbackModelConfigurationCache,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationCache$outboundSchema.parse(
      updateAgentFallbackModelConfigurationCache,
    ),
  );
}

/** @internal */
export const UpdateAgentLoadBalancerAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentLoadBalancerAgentsType
> = z.nativeEnum(UpdateAgentLoadBalancerAgentsType);

/** @internal */
export type UpdateAgentLoadBalancerAgentsModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const UpdateAgentLoadBalancerAgentsModels$outboundSchema: z.ZodType<
  UpdateAgentLoadBalancerAgentsModels$Outbound,
  z.ZodTypeDef,
  UpdateAgentLoadBalancerAgentsModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function updateAgentLoadBalancerAgentsModelsToJSON(
  updateAgentLoadBalancerAgentsModels: UpdateAgentLoadBalancerAgentsModels,
): string {
  return JSON.stringify(
    UpdateAgentLoadBalancerAgentsModels$outboundSchema.parse(
      updateAgentLoadBalancerAgentsModels,
    ),
  );
}

/** @internal */
export type UpdateAgentLoadBalancerAgents1$Outbound = {
  type: string;
  models: Array<UpdateAgentLoadBalancerAgentsModels$Outbound>;
};

/** @internal */
export const UpdateAgentLoadBalancerAgents1$outboundSchema: z.ZodType<
  UpdateAgentLoadBalancerAgents1$Outbound,
  z.ZodTypeDef,
  UpdateAgentLoadBalancerAgents1
> = z.object({
  type: UpdateAgentLoadBalancerAgentsType$outboundSchema,
  models: z.array(
    z.lazy(() => UpdateAgentLoadBalancerAgentsModels$outboundSchema),
  ),
});

export function updateAgentLoadBalancerAgents1ToJSON(
  updateAgentLoadBalancerAgents1: UpdateAgentLoadBalancerAgents1,
): string {
  return JSON.stringify(
    UpdateAgentLoadBalancerAgents1$outboundSchema.parse(
      updateAgentLoadBalancerAgents1,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationLoadBalancer$Outbound =
  UpdateAgentLoadBalancerAgents1$Outbound;

/** @internal */
export const UpdateAgentFallbackModelConfigurationLoadBalancer$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationLoadBalancer$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationLoadBalancer
  > = z.lazy(() => UpdateAgentLoadBalancerAgents1$outboundSchema);

export function updateAgentFallbackModelConfigurationLoadBalancerToJSON(
  updateAgentFallbackModelConfigurationLoadBalancer:
    UpdateAgentFallbackModelConfigurationLoadBalancer,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationLoadBalancer$outboundSchema.parse(
      updateAgentFallbackModelConfigurationLoadBalancer,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationTimeout$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationTimeout$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationTimeout
  > = z.object({
    callTimeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      callTimeout: "call_timeout",
    });
  });

export function updateAgentFallbackModelConfigurationTimeoutToJSON(
  updateAgentFallbackModelConfigurationTimeout:
    UpdateAgentFallbackModelConfigurationTimeout,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationTimeout$outboundSchema.parse(
      updateAgentFallbackModelConfigurationTimeout,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | UpdateAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdateAgentResponseFormatAgentsText$Outbound
    | UpdateAgentResponseFormatAgentsJSONObject$Outbound
    | UpdateAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | UpdateAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: UpdateAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<UpdateAgentFallbackModelConfigurationGuardrails$Outbound>
    | undefined;
  fallbacks?:
    | Array<UpdateAgentFallbackModelConfigurationFallbacks$Outbound>
    | undefined;
  retry?: UpdateAgentFallbackModelConfigurationRetry$Outbound | undefined;
  cache?: UpdateAgentFallbackModelConfigurationCache$Outbound | undefined;
  load_balancer?: UpdateAgentLoadBalancerAgents1$Outbound | undefined;
  timeout?: UpdateAgentFallbackModelConfigurationTimeout$Outbound | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => UpdateAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => UpdateAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => UpdateAgentResponseFormatAgentsJSONObject$outboundSchema),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort:
      UpdateAgentFallbackModelConfigurationReasoningEffort$outboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgents2$outboundSchema),
      UpdateAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(UpdateAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationGuardrails$outboundSchema
      ),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationFallbacks$outboundSchema
      ),
    ).optional(),
    retry: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationRetry$outboundSchema
    ).optional(),
    cache: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationCache$outboundSchema
    ).optional(),
    loadBalancer: z.lazy(() => UpdateAgentLoadBalancerAgents1$outboundSchema)
      .optional(),
    timeout: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationTimeout$outboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
      loadBalancer: "load_balancer",
    });
  });

export function updateAgentFallbackModelConfigurationParametersToJSON(
  updateAgentFallbackModelConfigurationParameters:
    UpdateAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      updateAgentFallbackModelConfigurationParameters,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfigurationAgentsRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsRetry$outboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsRetry$Outbound,
    z.ZodTypeDef,
    UpdateAgentFallbackModelConfigurationAgentsRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsRetryToJSON(
  updateAgentFallbackModelConfigurationAgentsRetry:
    UpdateAgentFallbackModelConfigurationAgentsRetry,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfigurationAgentsRetry$outboundSchema.parse(
      updateAgentFallbackModelConfigurationAgentsRetry,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | UpdateAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
  retry?: UpdateAgentFallbackModelConfigurationAgentsRetry$Outbound | undefined;
};

/** @internal */
export const UpdateAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  UpdateAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    UpdateAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
  retry: z.lazy(() =>
    UpdateAgentFallbackModelConfigurationAgentsRetry$outboundSchema
  ).optional(),
});

export function updateAgentFallbackModelConfiguration2ToJSON(
  updateAgentFallbackModelConfiguration2:
    UpdateAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfiguration2$outboundSchema.parse(
      updateAgentFallbackModelConfiguration2,
    ),
  );
}

/** @internal */
export type UpdateAgentFallbackModelConfiguration$Outbound =
  | UpdateAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const UpdateAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  UpdateAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  UpdateAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => UpdateAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function updateAgentFallbackModelConfigurationToJSON(
  updateAgentFallbackModelConfiguration: UpdateAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    UpdateAgentFallbackModelConfiguration$outboundSchema.parse(
      updateAgentFallbackModelConfiguration,
    ),
  );
}

/** @internal */
export const UpdateAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentToolApprovalRequired
> = z.nativeEnum(UpdateAgentToolApprovalRequired);

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type,
  );

/** @internal */
export type AgentToolInputCRUDMCPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  tool_id: string;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDMCPTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDMCPTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDMCPTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools16Type$outboundSchema
      .default("mcp"),
  key: z.string().optional(),
  id: z.string().optional(),
  toolId: z.string(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDMCPToolToJSON(
  agentToolInputCRUDMCPTool: AgentToolInputCRUDMCPTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDMCPTool$outboundSchema.parse(agentToolInputCRUDMCPTool),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type,
  );

/** @internal */
export type AgentToolInputCRUDJSONSchemaTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDJSONSchemaTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDJSONSchemaTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDJSONSchemaTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools15Type$outboundSchema
      .default("json_schema"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDJSONSchemaToolToJSON(
  agentToolInputCRUDJSONSchemaTool: AgentToolInputCRUDJSONSchemaTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDJSONSchemaTool$outboundSchema.parse(
      agentToolInputCRUDJSONSchemaTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type,
  );

/** @internal */
export type AgentToolInputCRUDFunctionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDFunctionTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDFunctionTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDFunctionTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools14Type$outboundSchema
      .default("function"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDFunctionToolToJSON(
  agentToolInputCRUDFunctionTool: AgentToolInputCRUDFunctionTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDFunctionTool$outboundSchema.parse(
      agentToolInputCRUDFunctionTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type,
  );

/** @internal */
export type AgentToolInputCRUDCodeExecutionTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDCodeExecutionTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCodeExecutionTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCodeExecutionTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools13Type$outboundSchema
      .default("code"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCodeExecutionToolToJSON(
  agentToolInputCRUDCodeExecutionTool: AgentToolInputCRUDCodeExecutionTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCodeExecutionTool$outboundSchema.parse(
      agentToolInputCRUDCodeExecutionTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type,
  );

/** @internal */
export type AgentToolInputCRUDHTTPTool$Outbound = {
  type: string;
  key?: string | undefined;
  id?: string | undefined;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputCRUDHTTPTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDHTTPTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDHTTPTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools12Type$outboundSchema
      .default("http"),
  key: z.string().optional(),
  id: z.string().optional(),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDHTTPToolToJSON(
  agentToolInputCRUDHTTPTool: AgentToolInputCRUDHTTPTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDHTTPTool$outboundSchema.parse(agentToolInputCRUDHTTPTool),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type,
  );

/** @internal */
export type AgentToolInputCRUDCurrentDateTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDCurrentDateTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCurrentDateTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCurrentDateTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools11Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCurrentDateToolToJSON(
  agentToolInputCRUDCurrentDateTool: AgentToolInputCRUDCurrentDateTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCurrentDateTool$outboundSchema.parse(
      agentToolInputCRUDCurrentDateTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type,
  );

/** @internal */
export type AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDQueryKnowledgeBaseTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools10Type$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDQueryKnowledgeBaseToolToJSON(
  agentToolInputCRUDQueryKnowledgeBaseTool:
    AgentToolInputCRUDQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema.parse(
      agentToolInputCRUDQueryKnowledgeBaseTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type,
  );

/** @internal */
export type AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDRetrieveKnowledgeBasesTool
  > = z.object({
    type:
      UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools9Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDRetrieveKnowledgeBasesToolToJSON(
  agentToolInputCRUDRetrieveKnowledgeBasesTool:
    AgentToolInputCRUDRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveKnowledgeBasesTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type,
  );

/** @internal */
export type AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDDeleteMemoryDocumentTool
  > = z.object({
    type:
      UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools8Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDDeleteMemoryDocumentToolToJSON(
  agentToolInputCRUDDeleteMemoryDocumentTool:
    AgentToolInputCRUDDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema.parse(
      agentToolInputCRUDDeleteMemoryDocumentTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type,
  );

/** @internal */
export type AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    AgentToolInputCRUDRetrieveMemoryStoresTool
  > = z.object({
    type:
      UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsTools7Type$outboundSchema,
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function agentToolInputCRUDRetrieveMemoryStoresToolToJSON(
  agentToolInputCRUDRetrieveMemoryStoresTool:
    AgentToolInputCRUDRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveMemoryStoresTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType,
  );

/** @internal */
export type AgentToolInputCRUDWriteMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDWriteMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDWriteMemoryStoreTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsToolsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDWriteMemoryStoreToolToJSON(
  agentToolInputCRUDWriteMemoryStoreTool:
    AgentToolInputCRUDWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema.parse(
      agentToolInputCRUDWriteMemoryStoreTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType
  > = z.nativeEnum(
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType,
  );

/** @internal */
export type AgentToolInputCRUDQueryMemoryStoreTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDQueryMemoryStoreTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDQueryMemoryStoreTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodySettingsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDQueryMemoryStoreToolToJSON(
  agentToolInputCRUDQueryMemoryStoreTool:
    AgentToolInputCRUDQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema.parse(
      agentToolInputCRUDQueryMemoryStoreTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType
  > = z.nativeEnum(UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType);

/** @internal */
export type AgentToolInputCRUDRetrieveAgentsTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDRetrieveAgentsTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDRetrieveAgentsTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDRetrieveAgentsTool
> = z.object({
  type:
    UpdateAgentAgentToolInputCRUDAgentsRequestRequestBodyType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDRetrieveAgentsToolToJSON(
  agentToolInputCRUDRetrieveAgentsTool: AgentToolInputCRUDRetrieveAgentsTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDRetrieveAgentsTool$outboundSchema.parse(
      agentToolInputCRUDRetrieveAgentsTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentToolInputCRUDAgentsRequestType> = z
    .nativeEnum(UpdateAgentAgentToolInputCRUDAgentsRequestType);

/** @internal */
export type AgentToolInputCRUDCallSubAgentTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDCallSubAgentTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDCallSubAgentTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDCallSubAgentTool
> = z.object({
  type: UpdateAgentAgentToolInputCRUDAgentsRequestType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDCallSubAgentToolToJSON(
  agentToolInputCRUDCallSubAgentTool: AgentToolInputCRUDCallSubAgentTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDCallSubAgentTool$outboundSchema.parse(
      agentToolInputCRUDCallSubAgentTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentToolInputCRUDAgentsType> = z
    .nativeEnum(UpdateAgentAgentToolInputCRUDAgentsType);

/** @internal */
export type AgentToolInputCRUDWebScraperTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDWebScraperTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDWebScraperTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDWebScraperTool
> = z.object({
  type: UpdateAgentAgentToolInputCRUDAgentsType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDWebScraperToolToJSON(
  agentToolInputCRUDWebScraperTool: AgentToolInputCRUDWebScraperTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDWebScraperTool$outboundSchema.parse(
      agentToolInputCRUDWebScraperTool,
    ),
  );
}

/** @internal */
export const UpdateAgentAgentToolInputCRUDType$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentToolInputCRUDType
> = z.nativeEnum(UpdateAgentAgentToolInputCRUDType);

/** @internal */
export type AgentToolInputCRUDGoogleSearchTool$Outbound = {
  type: string;
  requires_approval?: boolean | undefined;
};

/** @internal */
export const AgentToolInputCRUDGoogleSearchTool$outboundSchema: z.ZodType<
  AgentToolInputCRUDGoogleSearchTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputCRUDGoogleSearchTool
> = z.object({
  type: UpdateAgentAgentToolInputCRUDType$outboundSchema,
  requiresApproval: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputCRUDGoogleSearchToolToJSON(
  agentToolInputCRUDGoogleSearchTool: AgentToolInputCRUDGoogleSearchTool,
): string {
  return JSON.stringify(
    AgentToolInputCRUDGoogleSearchTool$outboundSchema.parse(
      agentToolInputCRUDGoogleSearchTool,
    ),
  );
}

/** @internal */
export type UpdateAgentAgentToolInputCRUD$Outbound =
  | AgentToolInputCRUDGoogleSearchTool$Outbound
  | AgentToolInputCRUDWebScraperTool$Outbound
  | AgentToolInputCRUDCallSubAgentTool$Outbound
  | AgentToolInputCRUDRetrieveAgentsTool$Outbound
  | AgentToolInputCRUDQueryMemoryStoreTool$Outbound
  | AgentToolInputCRUDWriteMemoryStoreTool$Outbound
  | AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound
  | AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound
  | AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound
  | AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound
  | AgentToolInputCRUDCurrentDateTool$Outbound
  | AgentToolInputCRUDMCPTool$Outbound
  | AgentToolInputCRUDHTTPTool$Outbound
  | AgentToolInputCRUDCodeExecutionTool$Outbound
  | AgentToolInputCRUDFunctionTool$Outbound
  | AgentToolInputCRUDJSONSchemaTool$Outbound;

/** @internal */
export const UpdateAgentAgentToolInputCRUD$outboundSchema: z.ZodType<
  UpdateAgentAgentToolInputCRUD$Outbound,
  z.ZodTypeDef,
  UpdateAgentAgentToolInputCRUD
> = z.union([
  z.lazy(() => AgentToolInputCRUDGoogleSearchTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDWebScraperTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCallSubAgentTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCurrentDateTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDMCPTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDHTTPTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDCodeExecutionTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDFunctionTool$outboundSchema),
  z.lazy(() => AgentToolInputCRUDJSONSchemaTool$outboundSchema),
]);

export function updateAgentAgentToolInputCRUDToJSON(
  updateAgentAgentToolInputCRUD: UpdateAgentAgentToolInputCRUD,
): string {
  return JSON.stringify(
    UpdateAgentAgentToolInputCRUD$outboundSchema.parse(
      updateAgentAgentToolInputCRUD,
    ),
  );
}

/** @internal */
export const UpdateAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentExecuteOn
> = z.nativeEnum(UpdateAgentExecuteOn);

/** @internal */
export type UpdateAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentEvaluators$outboundSchema: z.ZodType<
  UpdateAgentEvaluators$Outbound,
  z.ZodTypeDef,
  UpdateAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentEvaluatorsToJSON(
  updateAgentEvaluators: UpdateAgentEvaluators,
): string {
  return JSON.stringify(
    UpdateAgentEvaluators$outboundSchema.parse(updateAgentEvaluators),
  );
}

/** @internal */
export const UpdateAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsExecuteOn
> = z.nativeEnum(UpdateAgentAgentsExecuteOn);

/** @internal */
export type UpdateAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const UpdateAgentGuardrails$outboundSchema: z.ZodType<
  UpdateAgentGuardrails$Outbound,
  z.ZodTypeDef,
  UpdateAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: UpdateAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function updateAgentGuardrailsToJSON(
  updateAgentGuardrails: UpdateAgentGuardrails,
): string {
  return JSON.stringify(
    UpdateAgentGuardrails$outboundSchema.parse(updateAgentGuardrails),
  );
}

/** @internal */
export type UpdateAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?:
    | Array<
      | AgentToolInputCRUDGoogleSearchTool$Outbound
      | AgentToolInputCRUDWebScraperTool$Outbound
      | AgentToolInputCRUDCallSubAgentTool$Outbound
      | AgentToolInputCRUDRetrieveAgentsTool$Outbound
      | AgentToolInputCRUDQueryMemoryStoreTool$Outbound
      | AgentToolInputCRUDWriteMemoryStoreTool$Outbound
      | AgentToolInputCRUDRetrieveMemoryStoresTool$Outbound
      | AgentToolInputCRUDDeleteMemoryDocumentTool$Outbound
      | AgentToolInputCRUDRetrieveKnowledgeBasesTool$Outbound
      | AgentToolInputCRUDQueryKnowledgeBaseTool$Outbound
      | AgentToolInputCRUDCurrentDateTool$Outbound
      | AgentToolInputCRUDMCPTool$Outbound
      | AgentToolInputCRUDHTTPTool$Outbound
      | AgentToolInputCRUDCodeExecutionTool$Outbound
      | AgentToolInputCRUDFunctionTool$Outbound
      | AgentToolInputCRUDJSONSchemaTool$Outbound
    >
    | undefined;
  evaluators?: Array<UpdateAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<UpdateAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const UpdateAgentSettings$outboundSchema: z.ZodType<
  UpdateAgentSettings$Outbound,
  z.ZodTypeDef,
  UpdateAgentSettings
> = z.object({
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  toolApprovalRequired: UpdateAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(
    z.union([
      z.lazy(() => AgentToolInputCRUDGoogleSearchTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDWebScraperTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCallSubAgentTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveAgentsTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDWriteMemoryStoreTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveMemoryStoresTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDDeleteMemoryDocumentTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDRetrieveKnowledgeBasesTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDQueryKnowledgeBaseTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCurrentDateTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDMCPTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDHTTPTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDCodeExecutionTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDFunctionTool$outboundSchema),
      z.lazy(() => AgentToolInputCRUDJSONSchemaTool$outboundSchema),
    ]),
  ).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function updateAgentSettingsToJSON(
  updateAgentSettings: UpdateAgentSettings,
): string {
  return JSON.stringify(
    UpdateAgentSettings$outboundSchema.parse(updateAgentSettings),
  );
}

/** @internal */
export type UpdateAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const UpdateAgentKnowledgeBases$outboundSchema: z.ZodType<
  UpdateAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  UpdateAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function updateAgentKnowledgeBasesToJSON(
  updateAgentKnowledgeBases: UpdateAgentKnowledgeBases,
): string {
  return JSON.stringify(
    UpdateAgentKnowledgeBases$outboundSchema.parse(updateAgentKnowledgeBases),
  );
}

/** @internal */
export type UpdateAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const UpdateAgentTeamOfAgents$outboundSchema: z.ZodType<
  UpdateAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  UpdateAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function updateAgentTeamOfAgentsToJSON(
  updateAgentTeamOfAgents: UpdateAgentTeamOfAgents,
): string {
  return JSON.stringify(
    UpdateAgentTeamOfAgents$outboundSchema.parse(updateAgentTeamOfAgents),
  );
}

/** @internal */
export type UpdateAgentUpdateAgentRequest$Outbound = {
  key?: string | undefined;
  display_name?: string | undefined;
  project_id?: string | undefined;
  role?: string | undefined;
  description?: string | undefined;
  instructions?: string | undefined;
  system_prompt?: string | undefined;
  model?: UpdateAgentModelConfiguration2$Outbound | string | undefined;
  fallback_models?:
    | Array<UpdateAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  settings?: UpdateAgentSettings$Outbound | undefined;
  path?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<UpdateAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<UpdateAgentTeamOfAgents$Outbound> | undefined;
  variables?: { [k: string]: any } | undefined;
};

/** @internal */
export const UpdateAgentUpdateAgentRequest$outboundSchema: z.ZodType<
  UpdateAgentUpdateAgentRequest$Outbound,
  z.ZodTypeDef,
  UpdateAgentUpdateAgentRequest
> = z.object({
  key: z.string().optional(),
  displayName: z.string().optional(),
  projectId: z.string().optional(),
  role: z.string().optional(),
  description: z.string().optional(),
  instructions: z.string().optional(),
  systemPrompt: z.string().optional(),
  model: z.union([
    z.lazy(() => UpdateAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]).optional(),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => UpdateAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  settings: z.lazy(() => UpdateAgentSettings$outboundSchema).optional(),
  path: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => UpdateAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => UpdateAgentTeamOfAgents$outboundSchema))
    .optional(),
  variables: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    projectId: "project_id",
    systemPrompt: "system_prompt",
    fallbackModels: "fallback_models",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
  });
});

export function updateAgentUpdateAgentRequestToJSON(
  updateAgentUpdateAgentRequest: UpdateAgentUpdateAgentRequest,
): string {
  return JSON.stringify(
    UpdateAgentUpdateAgentRequest$outboundSchema.parse(
      updateAgentUpdateAgentRequest,
    ),
  );
}

/** @internal */
export type UpdateAgentRequest$Outbound = {
  agent_key: string;
  RequestBody: UpdateAgentUpdateAgentRequest$Outbound;
};

/** @internal */
export const UpdateAgentRequest$outboundSchema: z.ZodType<
  UpdateAgentRequest$Outbound,
  z.ZodTypeDef,
  UpdateAgentRequest
> = z.object({
  agentKey: z.string(),
  requestBody: z.lazy(() => UpdateAgentUpdateAgentRequest$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    requestBody: "RequestBody",
  });
});

export function updateAgentRequestToJSON(
  updateAgentRequest: UpdateAgentRequest,
): string {
  return JSON.stringify(
    UpdateAgentRequest$outboundSchema.parse(updateAgentRequest),
  );
}

/** @internal */
export const UpdateAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentStatus
> = z.nativeEnum(UpdateAgentStatus);

/** @internal */
export const UpdateAgentAgentsToolApprovalRequired$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsToolApprovalRequired> = z.nativeEnum(
    UpdateAgentAgentsToolApprovalRequired,
  );

/** @internal */
export const UpdateAgentConditions$inboundSchema: z.ZodType<
  UpdateAgentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function updateAgentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentConditions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentTools$inboundSchema: z.ZodType<
  UpdateAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  tool_id: z.string().optional(),
  conditions: z.array(z.lazy(() => UpdateAgentConditions$inboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
    "tool_id": "toolId",
  });
});

export function updateAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentTools' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsResponseExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentAgentsResponseExecuteOn
> = z.nativeEnum(UpdateAgentAgentsResponseExecuteOn);

/** @internal */
export const UpdateAgentAgentsEvaluators$inboundSchema: z.ZodType<
  UpdateAgentAgentsEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentAgentsResponseExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function updateAgentAgentsEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsEvaluators' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsResponse200ExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsResponse200ExecuteOn> = z.nativeEnum(
    UpdateAgentAgentsResponse200ExecuteOn,
  );

/** @internal */
export const UpdateAgentAgentsGuardrails$inboundSchema: z.ZodType<
  UpdateAgentAgentsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: UpdateAgentAgentsResponse200ExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});

export function updateAgentAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsSettings$inboundSchema: z.ZodType<
  UpdateAgentAgentsSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  tool_approval_required: UpdateAgentAgentsToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => UpdateAgentTools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => UpdateAgentAgentsEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdateAgentAgentsGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});

export function updateAgentAgentsSettingsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsSettings' from JSON`,
  );
}

/** @internal */
export const UpdateAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentVoice
> = z.nativeEnum(UpdateAgentVoice);

/** @internal */
export const UpdateAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentFormat
> = z.nativeEnum(UpdateAgentFormat);

/** @internal */
export const UpdateAgentAudio$inboundSchema: z.ZodType<
  UpdateAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: UpdateAgentVoice$inboundSchema,
  format: UpdateAgentFormat$inboundSchema,
});

export function updateAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function updateAgentResponseFormatAgentsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsResponseJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseJSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponseText$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponseText,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("text"),
  });

export function updateAgentResponseFormatAgentsResponseTextFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponseText,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponseText$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponseText' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormat$inboundSchema: z.ZodType<
  UpdateAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$inboundSchema),
  z.lazy(() => UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema),
  z.lazy(() =>
    UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
  ),
]);

export function updateAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdateAgentReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentReasoningEffort
> = z.nativeEnum(UpdateAgentReasoningEffort);

/** @internal */
export const UpdateAgentStop$inboundSchema: z.ZodType<
  UpdateAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function updateAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentStop' from JSON`,
  );
}

/** @internal */
export const UpdateAgentStreamOptions$inboundSchema: z.ZodType<
  UpdateAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function updateAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentThinking$inboundSchema: z.ZodType<
  UpdateAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function updateAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponseType> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponseType);

/** @internal */
export const UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponseFunction,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });

export function updateAgentToolChoiceAgentsResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponseFunction' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponseType$inboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponseFunction$inboundSchema
  ),
});

export function updateAgentToolChoiceAgentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoiceAgentsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse1$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse1> = z.nativeEnum(
    UpdateAgentToolChoiceAgentsResponse1,
  );

/** @internal */
export const UpdateAgentToolChoice$inboundSchema: z.ZodType<
  UpdateAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$inboundSchema),
  UpdateAgentToolChoiceAgentsResponse1$inboundSchema,
]);

export function updateAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentModalities
> = z.nativeEnum(UpdateAgentModalities);

/** @internal */
export const UpdateAgentIdAgentsResponse1$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentIdAgentsResponse1
> = z.nativeEnum(UpdateAgentIdAgentsResponse1);

/** @internal */
export const UpdateAgentId$inboundSchema: z.ZodType<
  UpdateAgentId,
  z.ZodTypeDef,
  unknown
> = z.union([UpdateAgentIdAgentsResponse1$inboundSchema, z.string()]);

export function updateAgentIdFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentId' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsResponse200ApplicationJSONExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentAgentsResponse200ApplicationJSONExecuteOn> =
    z.nativeEnum(UpdateAgentAgentsResponse200ApplicationJSONExecuteOn);

/** @internal */
export const UpdateAgentAgentsResponseGuardrails$inboundSchema: z.ZodType<
  UpdateAgentAgentsResponseGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([UpdateAgentIdAgentsResponse1$inboundSchema, z.string()]),
  execute_on:
    UpdateAgentAgentsResponse200ApplicationJSONExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});

export function updateAgentAgentsResponseGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsResponseGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentAgentsResponseGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsResponseGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbacks$inboundSchema: z.ZodType<
  UpdateAgentFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function updateAgentFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbacks' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsRetry$inboundSchema: z.ZodType<
  UpdateAgentAgentsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function updateAgentAgentsRetryFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsRetry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentType$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentType
> = z.nativeEnum(UpdateAgentType);

/** @internal */
export const UpdateAgentCache$inboundSchema: z.ZodType<
  UpdateAgentCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: UpdateAgentType$inboundSchema,
});

export function updateAgentCacheFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentCache' from JSON`,
  );
}

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentLoadBalancerAgentsResponseType> = z
    .nativeEnum(UpdateAgentLoadBalancerAgentsResponseType);

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponseModels$inboundSchema:
  z.ZodType<
    UpdateAgentLoadBalancerAgentsResponseModels,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function updateAgentLoadBalancerAgentsResponseModelsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentLoadBalancerAgentsResponseModels,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentLoadBalancerAgentsResponseModels$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentLoadBalancerAgentsResponseModels' from JSON`,
  );
}

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponse1$inboundSchema: z.ZodType<
  UpdateAgentLoadBalancerAgentsResponse1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentLoadBalancerAgentsResponseType$inboundSchema,
  models: z.array(
    z.lazy(() => UpdateAgentLoadBalancerAgentsResponseModels$inboundSchema),
  ),
});

export function updateAgentLoadBalancerAgentsResponse1FromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentLoadBalancerAgentsResponse1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentLoadBalancerAgentsResponse1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentLoadBalancerAgentsResponse1' from JSON`,
  );
}

/** @internal */
export const UpdateAgentLoadBalancer$inboundSchema: z.ZodType<
  UpdateAgentLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => UpdateAgentLoadBalancerAgentsResponse1$inboundSchema);

export function updateAgentLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentLoadBalancer' from JSON`,
  );
}

/** @internal */
export const UpdateAgentTimeout$inboundSchema: z.ZodType<
  UpdateAgentTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function updateAgentTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentTimeout' from JSON`,
  );
}

/** @internal */
export const UpdateAgentParameters$inboundSchema: z.ZodType<
  UpdateAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => UpdateAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponseText$inboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponseJSONObject$inboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: UpdateAgentReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => UpdateAgentStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2$inboundSchema),
    UpdateAgentToolChoiceAgentsResponse1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(UpdateAgentModalities$inboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => UpdateAgentAgentsResponseGuardrails$inboundSchema),
  ).optional(),
  fallbacks: z.array(z.lazy(() => UpdateAgentFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => UpdateAgentAgentsRetry$inboundSchema).optional(),
  cache: z.lazy(() => UpdateAgentCache$inboundSchema).optional(),
  load_balancer: z.lazy(() =>
    UpdateAgentLoadBalancerAgentsResponse1$inboundSchema
  ).optional(),
  timeout: z.lazy(() => UpdateAgentTimeout$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function updateAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentParameters' from JSON`,
  );
}

/** @internal */
export const UpdateAgentRetry$inboundSchema: z.ZodType<
  UpdateAgentRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function updateAgentRetryFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentRetry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsVoice$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsVoice> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationAgentsVoice);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsFormat$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsFormat> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationAgentsFormat);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: UpdateAgentFallbackModelConfigurationAgentsVoice$inboundSchema,
    format: UpdateAgentFallbackModelConfigurationAgentsFormat$inboundSchema,
  });

export function updateAgentFallbackModelConfigurationAgentsAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsAudio' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONJSONSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function updateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200JSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });

export function updateAgentResponseFormatAgentsResponse200JSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200JSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200JSONObject' from JSON`,
  );
}

/** @internal */
export const UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema:
  z.ZodType<
    UpdateAgentResponseFormatAgentsResponse200Text,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("text"),
  });

export function updateAgentResponseFormatAgentsResponse200TextFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentResponseFormatAgentsResponse200Text,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentResponseFormatAgentsResponse200Text' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsResponseFormat$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema
    ),
    z.lazy(() =>
      UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
    ),
  ]);

export function updateAgentFallbackModelConfigurationAgentsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsReasoningEffort$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentFallbackModelConfigurationAgentsReasoningEffort
  > = z.nativeEnum(UpdateAgentFallbackModelConfigurationAgentsReasoningEffort);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStop$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);

export function updateAgentFallbackModelConfigurationAgentsStopFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsStop' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsThinking$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationAgentsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsThinking' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse200Type> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponse200Type);

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema:
  z.ZodType<
    UpdateAgentToolChoiceAgentsResponse200Function,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
  });

export function updateAgentToolChoiceAgentsResponse200FunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponse200Function,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse200Function' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2002$inboundSchema: z.ZodType<
  UpdateAgentToolChoiceAgentsResponse2002,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentToolChoiceAgentsResponse200Type$inboundSchema.optional(),
  function: z.lazy(() =>
    UpdateAgentToolChoiceAgentsResponse200Function$inboundSchema
  ),
});

export function updateAgentToolChoiceAgentsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentToolChoiceAgentsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentToolChoiceAgentsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentToolChoiceAgentsResponse2002' from JSON`,
  );
}

/** @internal */
export const UpdateAgentToolChoiceAgentsResponse2001$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentToolChoiceAgentsResponse2001> = z
    .nativeEnum(UpdateAgentToolChoiceAgentsResponse2001);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsToolChoice$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$inboundSchema),
    UpdateAgentToolChoiceAgentsResponse2001$inboundSchema,
  ]);

export function updateAgentFallbackModelConfigurationAgentsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsModalities$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdateAgentFallbackModelConfigurationAgentsModalities
  > = z.nativeEnum(UpdateAgentFallbackModelConfigurationAgentsModalities);

/** @internal */
export const UpdateAgentIdAgentsResponse2001$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentIdAgentsResponse2001
> = z.nativeEnum(UpdateAgentIdAgentsResponse2001);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsId$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsId,
    z.ZodTypeDef,
    unknown
  > = z.union([UpdateAgentIdAgentsResponse2001$inboundSchema, z.string()]);

export function updateAgentFallbackModelConfigurationAgentsIdFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsId' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsExecuteOn> =
    z.nativeEnum(UpdateAgentFallbackModelConfigurationAgentsExecuteOn);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsGuardrails$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsGuardrails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.union([UpdateAgentIdAgentsResponse2001$inboundSchema, z.string()]),
    execute_on:
      UpdateAgentFallbackModelConfigurationAgentsExecuteOn$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "execute_on": "executeOn",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsGuardrails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsFallbacks$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsFallbacks,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
  });

export function updateAgentFallbackModelConfigurationAgentsFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsFallbacks,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsFallbacks$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsFallbacks' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsResponse200Retry$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsResponse200Retry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsResponse200RetryFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsResponse200Retry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsResponse200Retry$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsResponse200Retry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentFallbackModelConfigurationAgentsType> = z
    .nativeEnum(UpdateAgentFallbackModelConfigurationAgentsType);

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsCache$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsCache,
    z.ZodTypeDef,
    unknown
  > = z.object({
    ttl: z.number().default(1800),
    type: UpdateAgentFallbackModelConfigurationAgentsType$inboundSchema,
  });

export function updateAgentFallbackModelConfigurationAgentsCacheFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsCache,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsCache$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsCache' from JSON`,
  );
}

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdateAgentLoadBalancerAgentsResponse200Type> = z
    .nativeEnum(UpdateAgentLoadBalancerAgentsResponse200Type);

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponse200Models$inboundSchema:
  z.ZodType<
    UpdateAgentLoadBalancerAgentsResponse200Models,
    z.ZodTypeDef,
    unknown
  > = z.object({
    model: z.string(),
    weight: z.number().default(0.5),
  });

export function updateAgentLoadBalancerAgentsResponse200ModelsFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentLoadBalancerAgentsResponse200Models,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentLoadBalancerAgentsResponse200Models$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentLoadBalancerAgentsResponse200Models' from JSON`,
  );
}

/** @internal */
export const UpdateAgentLoadBalancerAgentsResponse2001$inboundSchema: z.ZodType<
  UpdateAgentLoadBalancerAgentsResponse2001,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdateAgentLoadBalancerAgentsResponse200Type$inboundSchema,
  models: z.array(
    z.lazy(() => UpdateAgentLoadBalancerAgentsResponse200Models$inboundSchema),
  ),
});

export function updateAgentLoadBalancerAgentsResponse2001FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentLoadBalancerAgentsResponse2001,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentLoadBalancerAgentsResponse2001$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentLoadBalancerAgentsResponse2001' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsLoadBalancer$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsLoadBalancer,
    z.ZodTypeDef,
    unknown
  > = z.lazy(() => UpdateAgentLoadBalancerAgentsResponse2001$inboundSchema);

export function updateAgentFallbackModelConfigurationAgentsLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsLoadBalancer,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsLoadBalancer$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsLoadBalancer' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsTimeout$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsTimeout,
    z.ZodTypeDef,
    unknown
  > = z.object({
    call_timeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "call_timeout": "callTimeout",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsTimeout,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsTimeout$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsTimeout' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsAudio$inboundSchema
      ),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200Text$inboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200JSONObject$inboundSchema
      ),
      z.lazy(() =>
        UpdateAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort:
      UpdateAgentFallbackModelConfigurationAgentsReasoningEffort$inboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => UpdateAgentToolChoiceAgentsResponse2002$inboundSchema),
      UpdateAgentToolChoiceAgentsResponse2001$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        UpdateAgentFallbackModelConfigurationAgentsModalities$inboundSchema,
      ),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsGuardrails$inboundSchema
      ),
    ).optional(),
    fallbacks: z.array(
      z.lazy(() =>
        UpdateAgentFallbackModelConfigurationAgentsFallbacks$inboundSchema
      ),
    ).optional(),
    retry: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsResponse200Retry$inboundSchema
    ).optional(),
    cache: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsCache$inboundSchema
    ).optional(),
    load_balancer: z.lazy(() =>
      UpdateAgentLoadBalancerAgentsResponse2001$inboundSchema
    ).optional(),
    timeout: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsTimeout$inboundSchema
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
      "load_balancer": "loadBalancer",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsParameters' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgentsResponseRetry$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgentsResponseRetry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });

export function updateAgentFallbackModelConfigurationAgentsResponseRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgentsResponseRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgentsResponseRetry$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgentsResponseRetry' from JSON`,
  );
}

/** @internal */
export const UpdateAgentFallbackModelConfigurationAgents2$inboundSchema:
  z.ZodType<
    UpdateAgentFallbackModelConfigurationAgents2,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsParameters$inboundSchema
    ).optional(),
    retry: z.lazy(() =>
      UpdateAgentFallbackModelConfigurationAgentsResponseRetry$inboundSchema
    ).optional(),
  });

export function updateAgentFallbackModelConfigurationAgents2FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentFallbackModelConfigurationAgents2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentFallbackModelConfigurationAgents2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentFallbackModelConfigurationAgents2' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsFallbackModelConfiguration$inboundSchema:
  z.ZodType<
    UpdateAgentAgentsFallbackModelConfiguration,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$inboundSchema),
    z.string(),
  ]);

export function updateAgentAgentsFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdateAgentAgentsFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdateAgentAgentsFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdateAgentAgentsFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const UpdateAgentModel$inboundSchema: z.ZodType<
  UpdateAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => UpdateAgentParameters$inboundSchema).optional(),
  retry: z.lazy(() => UpdateAgentRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => UpdateAgentFallbackModelConfigurationAgents2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});

export function updateAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentModel' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsTeamOfAgents$inboundSchema: z.ZodType<
  UpdateAgentAgentsTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function updateAgentAgentsTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const UpdateAgentMetrics$inboundSchema: z.ZodType<
  UpdateAgentMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});

export function updateAgentMetricsFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentMetrics' from JSON`,
  );
}

/** @internal */
export const UpdateAgentAgentsKnowledgeBases$inboundSchema: z.ZodType<
  UpdateAgentAgentsKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});

export function updateAgentAgentsKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentAgentsKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentAgentsKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentAgentsKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const UpdateAgentSource$inboundSchema: z.ZodNativeEnum<
  typeof UpdateAgentSource
> = z.nativeEnum(UpdateAgentSource);

/** @internal */
export const UpdateAgentResponseBody$inboundSchema: z.ZodType<
  UpdateAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: UpdateAgentStatus$inboundSchema,
  settings: z.lazy(() => UpdateAgentAgentsSettings$inboundSchema).optional(),
  model: z.lazy(() => UpdateAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => UpdateAgentAgentsTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => UpdateAgentMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => UpdateAgentAgentsKnowledgeBases$inboundSchema),
  ).optional(),
  source: UpdateAgentSource$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});

export function updateAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateAgentResponseBody' from JSON`,
  );
}
