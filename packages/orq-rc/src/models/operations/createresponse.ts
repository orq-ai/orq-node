/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The effort level for reasoning (o3-mini model only)
 */
export const Effort = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * The effort level for reasoning (o3-mini model only)
 */
export type Effort = ClosedEnum<typeof Effort>;

/**
 * Configuration for reasoning models
 */
export type Reasoning = {
  /**
   * The effort level for reasoning (o3-mini model only)
   */
  effort?: Effort | undefined;
};

export type Format3 = {
  /**
   * Ensures the response matches a supplied JSON schema
   */
  type: "json_schema";
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The JSON schema to validate the response against
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict `schema` adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when `strict` is `true`
   */
  strict?: boolean | undefined;
};

export type Format2 = {
  /**
   * Ensures the response is a valid JSON object
   */
  type: "json_object";
};

export type Format1 = {
  /**
   * Plain text response format
   */
  type: "text";
};

export type CreateResponseFormat = Format1 | Format2 | Format3;

export type CreateResponseText = {
  format: Format1 | Format2 | Format3;
};

/**
 * The type of input item
 */
export const CreateResponse2RouterResponsesRequestRequestBodyInputType = {
  FunctionCall: "function_call",
} as const;
/**
 * The type of input item
 */
export type CreateResponse2RouterResponsesRequestRequestBodyInputType =
  ClosedEnum<typeof CreateResponse2RouterResponsesRequestRequestBodyInputType>;

/**
 * Represents a function tool call, provided as input to the model.
 */
export type CreateResponse23 = {
  /**
   * The type of input item
   */
  type: CreateResponse2RouterResponsesRequestRequestBodyInputType;
  /**
   * The ID of the function call
   */
  callId: string;
  /**
   * The unique identifier for this function call
   */
  id: string;
  /**
   * The name of the function being called
   */
  name: string;
  /**
   * The arguments to the function as a JSON string
   */
  arguments: string;
  /**
   * The status of the function call
   */
  status: string;
};

/**
 * The type of input item
 */
export const CreateResponse2RouterResponsesRequestRequestBodyType = {
  FunctionCallOutput: "function_call_output",
} as const;
/**
 * The type of input item
 */
export type CreateResponse2RouterResponsesRequestRequestBodyType = ClosedEnum<
  typeof CreateResponse2RouterResponsesRequestRequestBodyType
>;

/**
 * Represents the output of a function tool call, provided as input to the model.
 */
export type CreateResponse2RouterResponses2 = {
  /**
   * The type of input item
   */
  type: CreateResponse2RouterResponsesRequestRequestBodyType;
  /**
   * The ID of the function call this output is for
   */
  callId: string;
  /**
   * The output from the function call
   */
  output: string;
};

/**
 * The role of the message author
 */
export const TwoRole = {
  User: "user",
  Assistant: "assistant",
  System: "system",
  Developer: "developer",
} as const;
/**
 * The role of the message author
 */
export type TwoRole = ClosedEnum<typeof TwoRole>;

/**
 * A file input content part.
 */
export type Two3 = {
  /**
   * The type of input content part
   */
  type: "input_file";
  /**
   * Base64 encoded file data
   */
  fileData?: string | undefined;
  /**
   * File ID from the Files API
   */
  fileId?: string | undefined;
  /**
   * Name of the file
   */
  filename?: string | undefined;
  /**
   * URL of the file to fetch
   */
  fileUrl?: string | undefined;
};

/**
 * Level of detail for image analysis
 */
export const Detail = {
  High: "high",
  Low: "low",
  Auto: "auto",
} as const;
/**
 * Level of detail for image analysis
 */
export type Detail = ClosedEnum<typeof Detail>;

/**
 * An image input content part.
 */
export type CreateResponse22 = {
  /**
   * The type of input content part
   */
  type: "input_image";
  /**
   * Level of detail for image analysis
   */
  detail?: Detail | undefined;
  /**
   * File ID for the image
   */
  fileId?: string | null | undefined;
  /**
   * URL of the image (can be http URL or data URL)
   */
  imageUrl?: string | null | undefined;
};

/**
 * A text input content part
 */
export type CreateResponse21 = {
  /**
   * The type of input content
   */
  type: "input_text";
  /**
   * The text content
   */
  text: string;
};

export type CreateResponseContent2 = CreateResponse21 | CreateResponse22 | Two3;

/**
 * The content of the message, either a string or an array of content parts
 */
export type TwoContent =
  | string
  | Array<CreateResponse21 | CreateResponse22 | Two3>;

/**
 * Represents a message in the conversation, with a role and content (string or rich content parts).
 */
export type Two1 = {
  /**
   * The role of the message author
   */
  role: TwoRole;
  /**
   * The content of the message, either a string or an array of content parts
   */
  content: string | Array<CreateResponse21 | CreateResponse22 | Two3>;
};

export type Input2 = CreateResponse23 | CreateResponse2RouterResponses2 | Two1;

/**
 * The actual user input(s) for the model. Can be a simple string, or an array of structured input items (messages, tool outputs) representing a conversation history or complex input.
 */
export type CreateResponseInput =
  | string
  | Array<CreateResponse23 | CreateResponse2RouterResponses2 | Two1>;

export const Include = {
  CodeInterpreterCallOutputs: "code_interpreter_call.outputs",
  ComputerCallOutputOutputImageUrl: "computer_call_output.output.image_url",
  FileSearchCallResults: "file_search_call.results",
  MessageInputImageImageUrl: "message.input_image.image_url",
  MessageOutputTextLogprobs: "message.output_text.logprobs",
  ReasoningEncryptedContent: "reasoning.encrypted_content",
} as const;
export type Include = ClosedEnum<typeof Include>;

/**
 * Specifies the latency tier to use for processing the request. Defaults to "auto".
 */
export const ServiceTier = {
  Auto: "auto",
  Default: "default",
  Flex: "flex",
  Priority: "priority",
} as const;
/**
 * Specifies the latency tier to use for processing the request. Defaults to "auto".
 */
export type ServiceTier = ClosedEnum<typeof ServiceTier>;

/**
 * The ranking algorithm
 */
export const Ranker = {
  Auto: "auto",
  Default20240821: "default_2024_08_21",
} as const;
/**
 * The ranking algorithm
 */
export type Ranker = ClosedEnum<typeof Ranker>;

/**
 * Options for ranking search results
 */
export type RankingOptions = {
  /**
   * The ranking algorithm
   */
  ranker?: Ranker | undefined;
  /**
   * Minimum relevance score
   */
  scoreThreshold?: number | undefined;
};

/**
 * Configuration for file search tool
 */
export type Tools3 = {
  /**
   * The type of tool
   */
  type: "file_search";
  /**
   * The vector stores to search
   */
  vectorStoreIds?: Array<string> | undefined;
  /**
   * Maximum number of results to return
   */
  maxNumResults?: number | undefined;
  /**
   * Filters to apply to the search
   */
  filters?: any | undefined;
  /**
   * Options for ranking search results
   */
  rankingOptions?: RankingOptions | undefined;
};

/**
 * Amount of context to retrieve for each search result
 */
export const SearchContextSize = {
  Small: "small",
  Medium: "medium",
  Large: "large",
} as const;
/**
 * Amount of context to retrieve for each search result
 */
export type SearchContextSize = ClosedEnum<typeof SearchContextSize>;

/**
 * The type of location
 */
export const CreateResponseToolsRouterResponsesRequestType = {
  Approximate: "approximate",
  Exact: "exact",
} as const;
/**
 * The type of location
 */
export type CreateResponseToolsRouterResponsesRequestType = ClosedEnum<
  typeof CreateResponseToolsRouterResponsesRequestType
>;

/**
 * User location for search localization
 */
export type UserLocation = {
  /**
   * The type of location
   */
  type?: CreateResponseToolsRouterResponsesRequestType | undefined;
  /**
   * The city name
   */
  city?: string | null | undefined;
  /**
   * The country code
   */
  country?: string | undefined;
  /**
   * The region/state
   */
  region?: string | null | undefined;
  /**
   * The timezone
   */
  timezone?: string | null | undefined;
};

/**
 * Configuration for web search tool
 */
export type Tools2 = {
  /**
   * The type of tool
   */
  type: "web_search_preview";
  /**
   * List of domains to restrict search to
   */
  domains?: Array<string> | undefined;
  /**
   * Amount of context to retrieve for each search result
   */
  searchContextSize?: SearchContextSize | undefined;
  /**
   * User location for search localization
   */
  userLocation?: UserLocation | undefined;
};

/**
 * The type of the parameters object
 */
export const CreateResponseToolsType = {
  Object: "object",
} as const;
/**
 * The type of the parameters object
 */
export type CreateResponseToolsType = ClosedEnum<
  typeof CreateResponseToolsType
>;

export type Properties = {
  type: string;
  description?: string | undefined;
  enum?: Array<string> | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

/**
 * The parameters the function accepts
 */
export type ToolsParameters = {
  /**
   * The type of the parameters object
   */
  type: CreateResponseToolsType;
  /**
   * The parameters the function accepts, described as a JSON Schema object
   */
  properties: { [k: string]: Properties };
  /**
   * List of required parameter names
   */
  required?: Array<string> | undefined;
  /**
   * Whether to allow properties not defined in the schema
   */
  additionalProperties?: boolean | undefined;
};

/**
 * A function tool definition
 */
export type Tools1 = {
  /**
   * The type of tool
   */
  type: "function";
  /**
   * The name of the function to be called
   */
  name: string;
  /**
   * A description of what the function does
   */
  description?: string | null | undefined;
  /**
   * The parameters the function accepts
   */
  parameters: ToolsParameters;
  /**
   * Whether to enable strict schema adherence when generating function calls
   */
  strict?: boolean | undefined;
};

export type CreateResponseTools = Tools1 | Tools2 | Tools3;

export const CreateResponseToolChoiceRouterResponsesRequestType = {
  Mcp: "mcp",
} as const;
export type CreateResponseToolChoiceRouterResponsesRequestType = ClosedEnum<
  typeof CreateResponseToolChoiceRouterResponsesRequestType
>;

export type ToolChoice4 = {
  type: CreateResponseToolChoiceRouterResponsesRequestType;
  serverLabel: string;
  name?: string | null | undefined;
};

export const CreateResponseToolChoiceRouterResponsesType = {
  Function: "function",
} as const;
export type CreateResponseToolChoiceRouterResponsesType = ClosedEnum<
  typeof CreateResponseToolChoiceRouterResponsesType
>;

export type ToolChoice3 = {
  type: CreateResponseToolChoiceRouterResponsesType;
  name: string;
};

export const CreateResponseToolChoiceType = {
  FileSearch: "file_search",
  WebSearchPreview: "web_search_preview",
  ComputerUsePreview: "computer_use_preview",
  CodeInterpreter: "code_interpreter",
  ImageGeneration: "image_generation",
} as const;
export type CreateResponseToolChoiceType = ClosedEnum<
  typeof CreateResponseToolChoiceType
>;

export type CreateResponseToolChoice2 = {
  type: CreateResponseToolChoiceType;
};

/**
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tool. `auto` means the model can pick between generating a message or calling a tool. `required` means the model must call a tool.
 */
export const CreateResponseToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
/**
 * Controls which (if any) tool is called by the model. `none` means the model will not call any tool. `auto` means the model can pick between generating a message or calling a tool. `required` means the model must call a tool.
 */
export type CreateResponseToolChoice1 = ClosedEnum<
  typeof CreateResponseToolChoice1
>;

/**
 * How the model should select which tool (or tools) to use when generating a response. Can be a string (`none`, `auto`, `required`) or an object to force a specific tool.
 */
export type CreateResponseToolChoice =
  | ToolChoice3
  | ToolChoice4
  | CreateResponseToolChoice2
  | CreateResponseToolChoice1;

export type CreateResponseRequestBody = {
  /**
   * ID of the model to use. You can use the List models API to see all of your available models.
   */
  model: string;
  /**
   * Developer-defined key-value pairs that will be included in response objects
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass. So 0.1 means only the tokens comprising the top 10% probability mass are considered.
   */
  topP?: number | null | undefined;
  /**
   * The ID of a previous response to continue the conversation from. The model will have access to the previous response context.
   */
  previousResponseId?: string | null | undefined;
  /**
   * Developer-provided instructions that the model should follow. Overwrites the default system message.
   */
  instructions?: string | null | undefined;
  /**
   * Configuration for reasoning models
   */
  reasoning?: Reasoning | null | undefined;
  /**
   * The maximum number of tokens that can be generated in the response
   */
  maxOutputTokens?: number | null | undefined;
  text?: CreateResponseText | null | undefined;
  /**
   * The actual user input(s) for the model. Can be a simple string, or an array of structured input items (messages, tool outputs) representing a conversation history or complex input.
   */
  input:
    | string
    | Array<CreateResponse23 | CreateResponse2RouterResponses2 | Two1>;
  /**
   * Specifies which (potentially large) fields to include in the response. By default, the results of Code Interpreter and file searches are excluded. Available options:
   *
   * @remarks
   * - code_interpreter_call.outputs: Include the outputs of Code Interpreter tool calls
   * - computer_call_output.output.image_url: Include the image URLs from computer use tool calls
   * - file_search_call.results: Include the results of file search tool calls
   * - message.input_image.image_url: Include URLs of input images
   * - message.output_text.logprobs: Include log probabilities for output text (when logprobs is enabled)
   * - reasoning.encrypted_content: Include encrypted reasoning content for reasoning models
   */
  include?: Array<Include> | null | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | null | undefined;
  /**
   * Whether to store this response for use in distillations or evals.
   */
  store?: boolean | null | undefined;
  /**
   * Specifies the latency tier to use for processing the request. Defaults to "auto".
   */
  serviceTier?: ServiceTier | null | undefined;
  /**
   * A list of tools the model may call. Use this to provide a list of functions the model may generate JSON inputs for.
   */
  tools?: Array<Tools1 | Tools2 | Tools3> | undefined;
  /**
   * How the model should select which tool (or tools) to use when generating a response. Can be a string (`none`, `auto`, `required`) or an object to force a specific tool.
   */
  toolChoice?:
    | ToolChoice3
    | ToolChoice4
    | CreateResponseToolChoice2
    | CreateResponseToolChoice1
    | undefined;
  stream?: boolean | undefined;
};

/**
 * One server-sent event emitted while the response streams
 */
export type CreateResponseData = {
  /**
   * The type of streaming event
   */
  type: string;
  additionalProperties?: { [k: string]: any } | undefined;
};

/**
 * One server-sent event emitted while the response streams
 */
export type CreateResponseRouterResponsesResponseBody = {
  /**
   * One server-sent event emitted while the response streams
   */
  data?: CreateResponseData | undefined;
};

/**
 * The object type, which is always "response"
 */
export const CreateResponseObject = {
  Response: "response",
} as const;
/**
 * The object type, which is always "response"
 */
export type CreateResponseObject = ClosedEnum<typeof CreateResponseObject>;

/**
 * The status of the response
 */
export const CreateResponseStatus = {
  Completed: "completed",
  Failed: "failed",
  InProgress: "in_progress",
  Incomplete: "incomplete",
} as const;
/**
 * The status of the response
 */
export type CreateResponseStatus = ClosedEnum<typeof CreateResponseStatus>;

/**
 * The error that occurred, if any
 */
export type ErrorT = {
  /**
   * The error code
   */
  code: string;
  /**
   * The error message
   */
  message: string;
};

/**
 * The reason the response is incomplete
 */
export const Reason = {
  MaxOutputTokens: "max_output_tokens",
  ContentFilter: "content_filter",
} as const;
/**
 * The reason the response is incomplete
 */
export type Reason = ClosedEnum<typeof Reason>;

/**
 * Details about why the response is incomplete
 */
export type IncompleteDetails = {
  /**
   * The reason the response is incomplete
   */
  reason: Reason;
};

/**
 * The status of the function call
 */
export const CreateResponseOutputRouterResponsesResponseStatus = {
  InProgress: "in_progress",
  Completed: "completed",
  Incomplete: "incomplete",
  Failed: "failed",
} as const;
/**
 * The status of the function call
 */
export type CreateResponseOutputRouterResponsesResponseStatus = ClosedEnum<
  typeof CreateResponseOutputRouterResponsesResponseStatus
>;

/**
 * A function tool call output
 */
export type Output4 = {
  /**
   * The unique identifier for this output item
   */
  id: string;
  /**
   * The type of output item
   */
  type: "function_call";
  /**
   * The ID of the function call
   */
  callId: string;
  /**
   * The name of the function being called
   */
  name: string;
  /**
   * The arguments to the function as a JSON string
   */
  arguments: string;
  /**
   * The status of the function call
   */
  status: CreateResponseOutputRouterResponsesResponseStatus;
};

/**
 * The status of the file search
 */
export const CreateResponseOutputRouterResponsesStatus = {
  InProgress: "in_progress",
  Completed: "completed",
  Incomplete: "incomplete",
  Failed: "failed",
} as const;
/**
 * The status of the file search
 */
export type CreateResponseOutputRouterResponsesStatus = ClosedEnum<
  typeof CreateResponseOutputRouterResponsesStatus
>;

/**
 * A file search tool call output
 */
export type Output3 = {
  /**
   * The unique identifier for this output item
   */
  id: string;
  /**
   * The type of output item
   */
  type: "file_search_call";
  /**
   * The status of the file search
   */
  status: CreateResponseOutputRouterResponsesStatus;
  /**
   * The search queries used
   */
  queries?: Array<string> | undefined;
  /**
   * The file search results
   */
  results?: any | undefined;
};

/**
 * The status of the web search
 */
export const CreateResponseOutputStatus = {
  InProgress: "in_progress",
  Completed: "completed",
  Incomplete: "incomplete",
  Failed: "failed",
} as const;
/**
 * The status of the web search
 */
export type CreateResponseOutputStatus = ClosedEnum<
  typeof CreateResponseOutputStatus
>;

/**
 * A web search tool call output
 */
export type Output2 = {
  /**
   * The unique identifier for this output item
   */
  id: string;
  /**
   * The type of output item
   */
  type: "web_search_call";
  /**
   * The status of the web search
   */
  status: CreateResponseOutputStatus;
};

/**
 * The role of the message author
 */
export const OutputRole = {
  Assistant: "assistant",
} as const;
/**
 * The role of the message author
 */
export type OutputRole = ClosedEnum<typeof OutputRole>;

/**
 * The status of the message
 */
export const OutputStatus = {
  InProgress: "in_progress",
  Completed: "completed",
  Incomplete: "incomplete",
  Failed: "failed",
} as const;
/**
 * The status of the message
 */
export type OutputStatus = ClosedEnum<typeof OutputStatus>;

/**
 * The type of content part
 */
export const ContentType = {
  OutputText: "output_text",
} as const;
/**
 * The type of content part
 */
export type ContentType = ClosedEnum<typeof ContentType>;

/**
 * A citation to a file
 */
export type Annotations2 = {
  type: "file_citation";
  /**
   * The index in the text where the citation appears
   */
  index: number;
  /**
   * The ID of the file being cited
   */
  fileId: string;
  /**
   * The name of the file being cited
   */
  filename: string;
};

/**
 * A citation to a URL
 */
export type Annotations1 = {
  type: "url_citation";
  /**
   * The start index of the citation in the text
   */
  startIndex: number;
  /**
   * The end index of the citation in the text
   */
  endIndex: number;
  /**
   * The URL being cited
   */
  url: string;
  /**
   * The title of the cited resource
   */
  title: string;
};

/**
 * An annotation in the output text
 */
export type Annotations = Annotations1 | Annotations2;

/**
 * Text output from the model
 */
export type Content1 = {
  /**
   * The type of content part
   */
  type: ContentType;
  /**
   * The text content
   */
  text: string;
  /**
   * Annotations in the text such as citations
   */
  annotations?: Array<Annotations1 | Annotations2> | undefined;
  /**
   * Log probabilities of the output tokens if requested
   */
  logprobs?: Array<any> | undefined;
};

export type OutputContent = Content1;

/**
 * An assistant message output
 */
export type Output1 = {
  /**
   * The unique identifier for this message
   */
  id: string;
  /**
   * The type of output item
   */
  type: "message";
  /**
   * The role of the message author
   */
  role: OutputRole;
  /**
   * The status of the message
   */
  status: OutputStatus;
  /**
   * The content parts of the message
   */
  content?: Array<Content1> | undefined;
};

export type Output = Output1 | Output2 | Output3 | Output4;

/**
 * Breakdown of input token usage
 */
export type CreateResponseInputTokensDetails = {
  /**
   * Number of tokens from cache
   */
  cachedTokens?: number | undefined;
};

/**
 * Breakdown of output token usage
 */
export type OutputTokensDetails = {
  /**
   * Number of tokens used for reasoning (o3 models)
   */
  reasoningTokens?: number | undefined;
  /**
   * Number of tokens generated by automatic prediction that were accepted
   */
  acceptedPredictionTokens?: number | undefined;
  /**
   * Number of tokens generated by automatic prediction that were rejected
   */
  rejectedPredictionTokens?: number | undefined;
};

/**
 * Usage statistics for the response
 */
export type CreateResponseUsage = {
  /**
   * Number of tokens in the input
   */
  inputTokens?: number | undefined;
  /**
   * Number of tokens in the generated output
   */
  outputTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (input + output)
   */
  totalTokens?: number | undefined;
  /**
   * Breakdown of input token usage
   */
  inputTokensDetails?: CreateResponseInputTokensDetails | undefined;
  /**
   * Breakdown of output token usage
   */
  outputTokensDetails?: OutputTokensDetails | undefined;
};

export const CreateResponseToolChoiceRouterResponsesResponseType = {
  Function: "function",
} as const;
export type CreateResponseToolChoiceRouterResponsesResponseType = ClosedEnum<
  typeof CreateResponseToolChoiceRouterResponsesResponseType
>;

export type CreateResponseToolChoiceFunction = {
  name: string;
};

export type CreateResponseToolChoiceRouterResponses2 = {
  type: CreateResponseToolChoiceRouterResponsesResponseType;
  function: CreateResponseToolChoiceFunction;
};

export const CreateResponseToolChoiceRouterResponses1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateResponseToolChoiceRouterResponses1 = ClosedEnum<
  typeof CreateResponseToolChoiceRouterResponses1
>;

/**
 * Controls which (if any) tool is called by the model
 */
export type CreateResponseRouterResponsesToolChoice =
  | CreateResponseToolChoiceRouterResponses2
  | CreateResponseToolChoiceRouterResponses1;

/**
 * The ranking algorithm
 */
export const ToolsRanker = {
  Auto: "auto",
  Default20240821: "default_2024_08_21",
} as const;
/**
 * The ranking algorithm
 */
export type ToolsRanker = ClosedEnum<typeof ToolsRanker>;

/**
 * Options for ranking search results
 */
export type ToolsRankingOptions = {
  /**
   * The ranking algorithm
   */
  ranker: ToolsRanker;
  /**
   * Minimum relevance score
   */
  scoreThreshold: number;
};

/**
 * Configuration for file search tool
 */
export type CreateResponseTools3 = {
  /**
   * The type of tool
   */
  type: "file_search";
  /**
   * The vector stores to search
   */
  vectorStoreIds?: Array<string> | undefined;
  /**
   * Maximum number of results to return
   */
  maxNumResults: number;
  /**
   * Filters to apply to the search
   */
  filters?: any | undefined;
  /**
   * Options for ranking search results
   */
  rankingOptions?: ToolsRankingOptions | undefined;
};

/**
 * Amount of context to retrieve for each search result
 */
export const ToolsSearchContextSize = {
  Small: "small",
  Medium: "medium",
  Large: "large",
} as const;
/**
 * Amount of context to retrieve for each search result
 */
export type ToolsSearchContextSize = ClosedEnum<typeof ToolsSearchContextSize>;

/**
 * The type of location
 */
export const CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType =
  {
    Approximate: "approximate",
    Exact: "exact",
  } as const;
/**
 * The type of location
 */
export type CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType
  >;

/**
 * User location for search localization
 */
export type ToolsUserLocation = {
  /**
   * The type of location
   */
  type?:
    | CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType
    | undefined;
  /**
   * The city name
   */
  city?: string | null | undefined;
  /**
   * The country code
   */
  country?: string | undefined;
  /**
   * The region/state
   */
  region?: string | null | undefined;
  /**
   * The timezone
   */
  timezone?: string | null | undefined;
};

/**
 * Configuration for web search tool
 */
export type CreateResponseTools2 = {
  /**
   * The type of tool
   */
  type: "web_search_preview";
  /**
   * List of domains to restrict search to
   */
  domains?: Array<string> | undefined;
  /**
   * Amount of context to retrieve for each search result
   */
  searchContextSize: ToolsSearchContextSize;
  /**
   * User location for search localization
   */
  userLocation?: ToolsUserLocation | undefined;
};

/**
 * The type of the parameters object
 */
export const CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type =
  {
    Object: "object",
  } as const;
/**
 * The type of the parameters object
 */
export type CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type =
  ClosedEnum<
    typeof CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type
  >;

export type ToolsProperties = {
  type: string;
  description?: string | undefined;
  enum?: Array<string> | undefined;
  additionalProperties?: { [k: string]: any } | undefined;
};

/**
 * The parameters the function accepts
 */
export type CreateResponseToolsParameters = {
  /**
   * The type of the parameters object
   */
  type:
    CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type;
  /**
   * The parameters the function accepts, described as a JSON Schema object
   */
  properties: { [k: string]: ToolsProperties };
  /**
   * List of required parameter names
   */
  required?: Array<string> | undefined;
  /**
   * Whether to allow properties not defined in the schema
   */
  additionalProperties?: boolean | undefined;
};

/**
 * A function tool definition
 */
export type CreateResponseTools1 = {
  /**
   * The type of tool
   */
  type: "function";
  /**
   * The name of the function to be called
   */
  name: string;
  /**
   * A description of what the function does
   */
  description?: string | null | undefined;
  /**
   * The parameters the function accepts
   */
  parameters: CreateResponseToolsParameters;
  /**
   * Whether to enable strict schema adherence when generating function calls
   */
  strict: boolean;
};

export type CreateResponseRouterResponsesTools =
  | CreateResponseTools1
  | CreateResponseTools2
  | CreateResponseTools3;

export type CreateResponseReasoning = {
  effort?: string | null | undefined;
  summary?: string | null | undefined;
};

export type CreateResponseFormat3 = {
  /**
   * Ensures the response matches a supplied JSON schema
   */
  type: "json_schema";
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The JSON schema to validate the response against
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict `schema` adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when `strict` is `true`
   */
  strict: boolean;
};

export type CreateResponseFormat2 = {
  /**
   * Ensures the response is a valid JSON object
   */
  type: "json_object";
};

export type CreateResponseFormat1 = {
  /**
   * Plain text response format
   */
  type: "text";
};

export type CreateResponseRouterResponsesFormat =
  | CreateResponseFormat1
  | CreateResponseFormat2
  | CreateResponseFormat3;

export type CreateResponseRouterResponsesText = {
  format: CreateResponseFormat1 | CreateResponseFormat2 | CreateResponseFormat3;
};

/**
 * Controls how the model handles inputs longer than the maximum token length
 */
export const Truncation = {
  Auto: "auto",
  Disabled: "disabled",
} as const;
/**
 * Controls how the model handles inputs longer than the maximum token length
 */
export type Truncation = ClosedEnum<typeof Truncation>;

/**
 * The service tier used for processing the request
 */
export const CreateResponseServiceTier = {
  Auto: "auto",
  Default: "default",
  Flex: "flex",
  Priority: "priority",
} as const;
/**
 * The service tier used for processing the request
 */
export type CreateResponseServiceTier = ClosedEnum<
  typeof CreateResponseServiceTier
>;

/**
 * Represents the completed model response returned when `stream` is false
 */
export type CreateResponseResponseBody = {
  /**
   * The unique identifier for the response
   */
  id: string;
  /**
   * The object type, which is always "response"
   */
  object: CreateResponseObject;
  /**
   * The Unix timestamp (in seconds) of when the response was created
   */
  createdAt: number;
  /**
   * The status of the response
   */
  status: CreateResponseStatus;
  /**
   * The error that occurred, if any
   */
  error: ErrorT | null;
  /**
   * Details about why the response is incomplete
   */
  incompleteDetails: IncompleteDetails | null;
  /**
   * The model used to generate the response
   */
  model: string;
  /**
   * The instructions provided for the response
   */
  instructions?: string | null | undefined;
  /**
   * The list of output items generated by the model
   */
  output: Array<Output1 | Output2 | Output3 | Output4>;
  /**
   * A convenience field with the concatenated text from all text content parts
   */
  outputText?: string | null | undefined;
  /**
   * Usage statistics for the response
   */
  usage?: CreateResponseUsage | undefined;
  temperature?: number | null | undefined;
  topP?: number | null | undefined;
  maxOutputTokens?: number | null | undefined;
  parallelToolCalls: boolean;
  previousResponseId?: string | null | undefined;
  metadata?: { [k: string]: string } | undefined;
  /**
   * Controls which (if any) tool is called by the model
   */
  toolChoice?:
    | CreateResponseToolChoiceRouterResponses2
    | CreateResponseToolChoiceRouterResponses1
    | undefined;
  tools?:
    | Array<CreateResponseTools1 | CreateResponseTools2 | CreateResponseTools3>
    | undefined;
  reasoning?: CreateResponseReasoning | null | undefined;
  store?: boolean | undefined;
  text?: CreateResponseRouterResponsesText | undefined;
  /**
   * Controls how the model handles inputs longer than the maximum token length
   */
  truncation: Truncation | null;
  /**
   * A unique identifier representing your end-user
   */
  user?: string | null | undefined;
  /**
   * The service tier used for processing the request
   */
  serviceTier?: CreateResponseServiceTier | null | undefined;
  /**
   * Whether the response was processed in the background
   */
  background?: boolean | null | undefined;
  /**
   * The number of top log probabilities to return for each output token
   */
  topLogprobs?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens
   */
  logprobs?: boolean | null | undefined;
};

export type CreateResponseResponse =
  | CreateResponseResponseBody
  | EventStream<CreateResponseRouterResponsesResponseBody>;

/** @internal */
export const Effort$outboundSchema: z.ZodNativeEnum<typeof Effort> = z
  .nativeEnum(Effort);

/** @internal */
export type Reasoning$Outbound = {
  effort?: string | undefined;
};

/** @internal */
export const Reasoning$outboundSchema: z.ZodType<
  Reasoning$Outbound,
  z.ZodTypeDef,
  Reasoning
> = z.object({
  effort: Effort$outboundSchema.optional(),
});

export function reasoningToJSON(reasoning: Reasoning): string {
  return JSON.stringify(Reasoning$outboundSchema.parse(reasoning));
}

/** @internal */
export type Format3$Outbound = {
  type: "json_schema";
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean;
};

/** @internal */
export const Format3$outboundSchema: z.ZodType<
  Format3$Outbound,
  z.ZodTypeDef,
  Format3
> = z.object({
  type: z.literal("json_schema"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().default(true),
});

export function format3ToJSON(format3: Format3): string {
  return JSON.stringify(Format3$outboundSchema.parse(format3));
}

/** @internal */
export type Format2$Outbound = {
  type: "json_object";
};

/** @internal */
export const Format2$outboundSchema: z.ZodType<
  Format2$Outbound,
  z.ZodTypeDef,
  Format2
> = z.object({
  type: z.literal("json_object"),
});

export function format2ToJSON(format2: Format2): string {
  return JSON.stringify(Format2$outboundSchema.parse(format2));
}

/** @internal */
export type Format1$Outbound = {
  type: "text";
};

/** @internal */
export const Format1$outboundSchema: z.ZodType<
  Format1$Outbound,
  z.ZodTypeDef,
  Format1
> = z.object({
  type: z.literal("text"),
});

export function format1ToJSON(format1: Format1): string {
  return JSON.stringify(Format1$outboundSchema.parse(format1));
}

/** @internal */
export type CreateResponseFormat$Outbound =
  | Format1$Outbound
  | Format2$Outbound
  | Format3$Outbound;

/** @internal */
export const CreateResponseFormat$outboundSchema: z.ZodType<
  CreateResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateResponseFormat
> = z.union([
  z.lazy(() => Format1$outboundSchema),
  z.lazy(() => Format2$outboundSchema),
  z.lazy(() => Format3$outboundSchema),
]);

export function createResponseFormatToJSON(
  createResponseFormat: CreateResponseFormat,
): string {
  return JSON.stringify(
    CreateResponseFormat$outboundSchema.parse(createResponseFormat),
  );
}

/** @internal */
export type CreateResponseText$Outbound = {
  format: Format1$Outbound | Format2$Outbound | Format3$Outbound;
};

/** @internal */
export const CreateResponseText$outboundSchema: z.ZodType<
  CreateResponseText$Outbound,
  z.ZodTypeDef,
  CreateResponseText
> = z.object({
  format: z.union([
    z.lazy(() => Format1$outboundSchema),
    z.lazy(() => Format2$outboundSchema),
    z.lazy(() => Format3$outboundSchema),
  ]),
});

export function createResponseTextToJSON(
  createResponseText: CreateResponseText,
): string {
  return JSON.stringify(
    CreateResponseText$outboundSchema.parse(createResponseText),
  );
}

/** @internal */
export const CreateResponse2RouterResponsesRequestRequestBodyInputType$outboundSchema:
  z.ZodNativeEnum<
    typeof CreateResponse2RouterResponsesRequestRequestBodyInputType
  > = z.nativeEnum(CreateResponse2RouterResponsesRequestRequestBodyInputType);

/** @internal */
export type CreateResponse23$Outbound = {
  type: string;
  call_id: string;
  id: string;
  name: string;
  arguments: string;
  status: string;
};

/** @internal */
export const CreateResponse23$outboundSchema: z.ZodType<
  CreateResponse23$Outbound,
  z.ZodTypeDef,
  CreateResponse23
> = z.object({
  type:
    CreateResponse2RouterResponsesRequestRequestBodyInputType$outboundSchema,
  callId: z.string(),
  id: z.string(),
  name: z.string(),
  arguments: z.string(),
  status: z.string(),
}).transform((v) => {
  return remap$(v, {
    callId: "call_id",
  });
});

export function createResponse23ToJSON(
  createResponse23: CreateResponse23,
): string {
  return JSON.stringify(
    CreateResponse23$outboundSchema.parse(createResponse23),
  );
}

/** @internal */
export const CreateResponse2RouterResponsesRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<typeof CreateResponse2RouterResponsesRequestRequestBodyType> =
    z.nativeEnum(CreateResponse2RouterResponsesRequestRequestBodyType);

/** @internal */
export type CreateResponse2RouterResponses2$Outbound = {
  type: string;
  call_id: string;
  output: string;
};

/** @internal */
export const CreateResponse2RouterResponses2$outboundSchema: z.ZodType<
  CreateResponse2RouterResponses2$Outbound,
  z.ZodTypeDef,
  CreateResponse2RouterResponses2
> = z.object({
  type: CreateResponse2RouterResponsesRequestRequestBodyType$outboundSchema,
  callId: z.string(),
  output: z.string(),
}).transform((v) => {
  return remap$(v, {
    callId: "call_id",
  });
});

export function createResponse2RouterResponses2ToJSON(
  createResponse2RouterResponses2: CreateResponse2RouterResponses2,
): string {
  return JSON.stringify(
    CreateResponse2RouterResponses2$outboundSchema.parse(
      createResponse2RouterResponses2,
    ),
  );
}

/** @internal */
export const TwoRole$outboundSchema: z.ZodNativeEnum<typeof TwoRole> = z
  .nativeEnum(TwoRole);

/** @internal */
export type Two3$Outbound = {
  type: "input_file";
  file_data?: string | undefined;
  file_id?: string | undefined;
  filename?: string | undefined;
  file_url?: string | undefined;
};

/** @internal */
export const Two3$outboundSchema: z.ZodType<Two3$Outbound, z.ZodTypeDef, Two3> =
  z.object({
    type: z.literal("input_file"),
    fileData: z.string().optional(),
    fileId: z.string().optional(),
    filename: z.string().optional(),
    fileUrl: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      fileData: "file_data",
      fileId: "file_id",
      fileUrl: "file_url",
    });
  });

export function two3ToJSON(two3: Two3): string {
  return JSON.stringify(Two3$outboundSchema.parse(two3));
}

/** @internal */
export const Detail$outboundSchema: z.ZodNativeEnum<typeof Detail> = z
  .nativeEnum(Detail);

/** @internal */
export type CreateResponse22$Outbound = {
  type: "input_image";
  detail: string;
  file_id?: string | null | undefined;
  image_url?: string | null | undefined;
};

/** @internal */
export const CreateResponse22$outboundSchema: z.ZodType<
  CreateResponse22$Outbound,
  z.ZodTypeDef,
  CreateResponse22
> = z.object({
  type: z.literal("input_image"),
  detail: Detail$outboundSchema.default("auto"),
  fileId: z.nullable(z.string()).optional(),
  imageUrl: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    fileId: "file_id",
    imageUrl: "image_url",
  });
});

export function createResponse22ToJSON(
  createResponse22: CreateResponse22,
): string {
  return JSON.stringify(
    CreateResponse22$outboundSchema.parse(createResponse22),
  );
}

/** @internal */
export type CreateResponse21$Outbound = {
  type: "input_text";
  text: string;
};

/** @internal */
export const CreateResponse21$outboundSchema: z.ZodType<
  CreateResponse21$Outbound,
  z.ZodTypeDef,
  CreateResponse21
> = z.object({
  type: z.literal("input_text"),
  text: z.string(),
});

export function createResponse21ToJSON(
  createResponse21: CreateResponse21,
): string {
  return JSON.stringify(
    CreateResponse21$outboundSchema.parse(createResponse21),
  );
}

/** @internal */
export type CreateResponseContent2$Outbound =
  | CreateResponse21$Outbound
  | CreateResponse22$Outbound
  | Two3$Outbound;

/** @internal */
export const CreateResponseContent2$outboundSchema: z.ZodType<
  CreateResponseContent2$Outbound,
  z.ZodTypeDef,
  CreateResponseContent2
> = z.union([
  z.lazy(() => CreateResponse21$outboundSchema),
  z.lazy(() => CreateResponse22$outboundSchema),
  z.lazy(() => Two3$outboundSchema),
]);

export function createResponseContent2ToJSON(
  createResponseContent2: CreateResponseContent2,
): string {
  return JSON.stringify(
    CreateResponseContent2$outboundSchema.parse(createResponseContent2),
  );
}

/** @internal */
export type TwoContent$Outbound =
  | string
  | Array<
    CreateResponse21$Outbound | CreateResponse22$Outbound | Two3$Outbound
  >;

/** @internal */
export const TwoContent$outboundSchema: z.ZodType<
  TwoContent$Outbound,
  z.ZodTypeDef,
  TwoContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => CreateResponse21$outboundSchema),
    z.lazy(() => CreateResponse22$outboundSchema),
    z.lazy(() => Two3$outboundSchema),
  ])),
]);

export function twoContentToJSON(twoContent: TwoContent): string {
  return JSON.stringify(TwoContent$outboundSchema.parse(twoContent));
}

/** @internal */
export type Two1$Outbound = {
  role: string;
  content:
    | string
    | Array<
      CreateResponse21$Outbound | CreateResponse22$Outbound | Two3$Outbound
    >;
};

/** @internal */
export const Two1$outboundSchema: z.ZodType<Two1$Outbound, z.ZodTypeDef, Two1> =
  z.object({
    role: TwoRole$outboundSchema,
    content: z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => CreateResponse21$outboundSchema),
        z.lazy(() => CreateResponse22$outboundSchema),
        z.lazy(() => Two3$outboundSchema),
      ])),
    ]),
  });

export function two1ToJSON(two1: Two1): string {
  return JSON.stringify(Two1$outboundSchema.parse(two1));
}

/** @internal */
export type Input2$Outbound =
  | CreateResponse23$Outbound
  | CreateResponse2RouterResponses2$Outbound
  | Two1$Outbound;

/** @internal */
export const Input2$outboundSchema: z.ZodType<
  Input2$Outbound,
  z.ZodTypeDef,
  Input2
> = z.union([
  z.lazy(() => CreateResponse23$outboundSchema),
  z.lazy(() => CreateResponse2RouterResponses2$outboundSchema),
  z.lazy(() => Two1$outboundSchema),
]);

export function input2ToJSON(input2: Input2): string {
  return JSON.stringify(Input2$outboundSchema.parse(input2));
}

/** @internal */
export type CreateResponseInput$Outbound =
  | string
  | Array<
    | CreateResponse23$Outbound
    | CreateResponse2RouterResponses2$Outbound
    | Two1$Outbound
  >;

/** @internal */
export const CreateResponseInput$outboundSchema: z.ZodType<
  CreateResponseInput$Outbound,
  z.ZodTypeDef,
  CreateResponseInput
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => CreateResponse23$outboundSchema),
    z.lazy(() => CreateResponse2RouterResponses2$outboundSchema),
    z.lazy(() => Two1$outboundSchema),
  ])),
]);

export function createResponseInputToJSON(
  createResponseInput: CreateResponseInput,
): string {
  return JSON.stringify(
    CreateResponseInput$outboundSchema.parse(createResponseInput),
  );
}

/** @internal */
export const Include$outboundSchema: z.ZodNativeEnum<typeof Include> = z
  .nativeEnum(Include);

/** @internal */
export const ServiceTier$outboundSchema: z.ZodNativeEnum<typeof ServiceTier> = z
  .nativeEnum(ServiceTier);

/** @internal */
export const Ranker$outboundSchema: z.ZodNativeEnum<typeof Ranker> = z
  .nativeEnum(Ranker);

/** @internal */
export type RankingOptions$Outbound = {
  ranker: string;
  score_threshold: number;
};

/** @internal */
export const RankingOptions$outboundSchema: z.ZodType<
  RankingOptions$Outbound,
  z.ZodTypeDef,
  RankingOptions
> = z.object({
  ranker: Ranker$outboundSchema.default("auto"),
  scoreThreshold: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    scoreThreshold: "score_threshold",
  });
});

export function rankingOptionsToJSON(rankingOptions: RankingOptions): string {
  return JSON.stringify(RankingOptions$outboundSchema.parse(rankingOptions));
}

/** @internal */
export type Tools3$Outbound = {
  type: "file_search";
  vector_store_ids?: Array<string> | undefined;
  max_num_results: number;
  filters?: any | undefined;
  ranking_options?: RankingOptions$Outbound | undefined;
};

/** @internal */
export const Tools3$outboundSchema: z.ZodType<
  Tools3$Outbound,
  z.ZodTypeDef,
  Tools3
> = z.object({
  type: z.literal("file_search"),
  vectorStoreIds: z.array(z.string()).optional(),
  maxNumResults: z.number().int().default(20),
  filters: z.any().optional(),
  rankingOptions: z.lazy(() => RankingOptions$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    vectorStoreIds: "vector_store_ids",
    maxNumResults: "max_num_results",
    rankingOptions: "ranking_options",
  });
});

export function tools3ToJSON(tools3: Tools3): string {
  return JSON.stringify(Tools3$outboundSchema.parse(tools3));
}

/** @internal */
export const SearchContextSize$outboundSchema: z.ZodNativeEnum<
  typeof SearchContextSize
> = z.nativeEnum(SearchContextSize);

/** @internal */
export const CreateResponseToolsRouterResponsesRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateResponseToolsRouterResponsesRequestType> = z
    .nativeEnum(CreateResponseToolsRouterResponsesRequestType);

/** @internal */
export type UserLocation$Outbound = {
  type?: string | undefined;
  city?: string | null | undefined;
  country?: string | undefined;
  region?: string | null | undefined;
  timezone?: string | null | undefined;
};

/** @internal */
export const UserLocation$outboundSchema: z.ZodType<
  UserLocation$Outbound,
  z.ZodTypeDef,
  UserLocation
> = z.object({
  type: CreateResponseToolsRouterResponsesRequestType$outboundSchema.optional(),
  city: z.nullable(z.string()).optional(),
  country: z.string().optional(),
  region: z.nullable(z.string()).optional(),
  timezone: z.nullable(z.string()).optional(),
});

export function userLocationToJSON(userLocation: UserLocation): string {
  return JSON.stringify(UserLocation$outboundSchema.parse(userLocation));
}

/** @internal */
export type Tools2$Outbound = {
  type: "web_search_preview";
  domains?: Array<string> | undefined;
  search_context_size: string;
  user_location?: UserLocation$Outbound | undefined;
};

/** @internal */
export const Tools2$outboundSchema: z.ZodType<
  Tools2$Outbound,
  z.ZodTypeDef,
  Tools2
> = z.object({
  type: z.literal("web_search_preview"),
  domains: z.array(z.string()).optional(),
  searchContextSize: SearchContextSize$outboundSchema.default("medium"),
  userLocation: z.lazy(() => UserLocation$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    searchContextSize: "search_context_size",
    userLocation: "user_location",
  });
});

export function tools2ToJSON(tools2: Tools2): string {
  return JSON.stringify(Tools2$outboundSchema.parse(tools2));
}

/** @internal */
export const CreateResponseToolsType$outboundSchema: z.ZodNativeEnum<
  typeof CreateResponseToolsType
> = z.nativeEnum(CreateResponseToolsType);

/** @internal */
export type Properties$Outbound = {
  type: string;
  description?: string | undefined;
  enum?: Array<string> | undefined;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const Properties$outboundSchema: z.ZodType<
  Properties$Outbound,
  z.ZodTypeDef,
  Properties
> = z.object({
  type: z.string(),
  description: z.string().optional(),
  enum: z.array(z.string()).optional(),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function propertiesToJSON(properties: Properties): string {
  return JSON.stringify(Properties$outboundSchema.parse(properties));
}

/** @internal */
export type ToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: Properties$Outbound };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

/** @internal */
export const ToolsParameters$outboundSchema: z.ZodType<
  ToolsParameters$Outbound,
  z.ZodTypeDef,
  ToolsParameters
> = z.object({
  type: CreateResponseToolsType$outboundSchema,
  properties: z.record(z.lazy(() => Properties$outboundSchema)),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});

export function toolsParametersToJSON(
  toolsParameters: ToolsParameters,
): string {
  return JSON.stringify(ToolsParameters$outboundSchema.parse(toolsParameters));
}

/** @internal */
export type Tools1$Outbound = {
  type: "function";
  name: string;
  description?: string | null | undefined;
  parameters: ToolsParameters$Outbound;
  strict: boolean;
};

/** @internal */
export const Tools1$outboundSchema: z.ZodType<
  Tools1$Outbound,
  z.ZodTypeDef,
  Tools1
> = z.object({
  type: z.literal("function"),
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => ToolsParameters$outboundSchema),
  strict: z.boolean().default(true),
});

export function tools1ToJSON(tools1: Tools1): string {
  return JSON.stringify(Tools1$outboundSchema.parse(tools1));
}

/** @internal */
export type CreateResponseTools$Outbound =
  | Tools1$Outbound
  | Tools2$Outbound
  | Tools3$Outbound;

/** @internal */
export const CreateResponseTools$outboundSchema: z.ZodType<
  CreateResponseTools$Outbound,
  z.ZodTypeDef,
  CreateResponseTools
> = z.union([
  z.lazy(() => Tools1$outboundSchema),
  z.lazy(() => Tools2$outboundSchema),
  z.lazy(() => Tools3$outboundSchema),
]);

export function createResponseToolsToJSON(
  createResponseTools: CreateResponseTools,
): string {
  return JSON.stringify(
    CreateResponseTools$outboundSchema.parse(createResponseTools),
  );
}

/** @internal */
export const CreateResponseToolChoiceRouterResponsesRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateResponseToolChoiceRouterResponsesRequestType> = z
    .nativeEnum(CreateResponseToolChoiceRouterResponsesRequestType);

/** @internal */
export type ToolChoice4$Outbound = {
  type: string;
  server_label: string;
  name?: string | null | undefined;
};

/** @internal */
export const ToolChoice4$outboundSchema: z.ZodType<
  ToolChoice4$Outbound,
  z.ZodTypeDef,
  ToolChoice4
> = z.object({
  type: CreateResponseToolChoiceRouterResponsesRequestType$outboundSchema,
  serverLabel: z.string(),
  name: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    serverLabel: "server_label",
  });
});

export function toolChoice4ToJSON(toolChoice4: ToolChoice4): string {
  return JSON.stringify(ToolChoice4$outboundSchema.parse(toolChoice4));
}

/** @internal */
export const CreateResponseToolChoiceRouterResponsesType$outboundSchema:
  z.ZodNativeEnum<typeof CreateResponseToolChoiceRouterResponsesType> = z
    .nativeEnum(CreateResponseToolChoiceRouterResponsesType);

/** @internal */
export type ToolChoice3$Outbound = {
  type: string;
  name: string;
};

/** @internal */
export const ToolChoice3$outboundSchema: z.ZodType<
  ToolChoice3$Outbound,
  z.ZodTypeDef,
  ToolChoice3
> = z.object({
  type: CreateResponseToolChoiceRouterResponsesType$outboundSchema,
  name: z.string(),
});

export function toolChoice3ToJSON(toolChoice3: ToolChoice3): string {
  return JSON.stringify(ToolChoice3$outboundSchema.parse(toolChoice3));
}

/** @internal */
export const CreateResponseToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateResponseToolChoiceType
> = z.nativeEnum(CreateResponseToolChoiceType);

/** @internal */
export type CreateResponseToolChoice2$Outbound = {
  type: string;
};

/** @internal */
export const CreateResponseToolChoice2$outboundSchema: z.ZodType<
  CreateResponseToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateResponseToolChoice2
> = z.object({
  type: CreateResponseToolChoiceType$outboundSchema,
});

export function createResponseToolChoice2ToJSON(
  createResponseToolChoice2: CreateResponseToolChoice2,
): string {
  return JSON.stringify(
    CreateResponseToolChoice2$outboundSchema.parse(createResponseToolChoice2),
  );
}

/** @internal */
export const CreateResponseToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateResponseToolChoice1
> = z.nativeEnum(CreateResponseToolChoice1);

/** @internal */
export type CreateResponseToolChoice$Outbound =
  | ToolChoice3$Outbound
  | ToolChoice4$Outbound
  | CreateResponseToolChoice2$Outbound
  | string;

/** @internal */
export const CreateResponseToolChoice$outboundSchema: z.ZodType<
  CreateResponseToolChoice$Outbound,
  z.ZodTypeDef,
  CreateResponseToolChoice
> = z.union([
  z.lazy(() => ToolChoice3$outboundSchema),
  z.lazy(() => ToolChoice4$outboundSchema),
  z.lazy(() => CreateResponseToolChoice2$outboundSchema),
  CreateResponseToolChoice1$outboundSchema,
]);

export function createResponseToolChoiceToJSON(
  createResponseToolChoice: CreateResponseToolChoice,
): string {
  return JSON.stringify(
    CreateResponseToolChoice$outboundSchema.parse(createResponseToolChoice),
  );
}

/** @internal */
export type CreateResponseRequestBody$Outbound = {
  model: string;
  metadata?: { [k: string]: string } | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  previous_response_id?: string | null | undefined;
  instructions?: string | null | undefined;
  reasoning?: Reasoning$Outbound | null | undefined;
  max_output_tokens?: number | null | undefined;
  text?: CreateResponseText$Outbound | null | undefined;
  input:
    | string
    | Array<
      | CreateResponse23$Outbound
      | CreateResponse2RouterResponses2$Outbound
      | Two1$Outbound
    >;
  include?: Array<string> | null | undefined;
  parallel_tool_calls?: boolean | null | undefined;
  store: boolean | null;
  service_tier?: string | null | undefined;
  tools?:
    | Array<Tools1$Outbound | Tools2$Outbound | Tools3$Outbound>
    | undefined;
  tool_choice?:
    | ToolChoice3$Outbound
    | ToolChoice4$Outbound
    | CreateResponseToolChoice2$Outbound
    | string
    | undefined;
  stream: boolean;
};

/** @internal */
export const CreateResponseRequestBody$outboundSchema: z.ZodType<
  CreateResponseRequestBody$Outbound,
  z.ZodTypeDef,
  CreateResponseRequestBody
> = z.object({
  model: z.string(),
  metadata: z.record(z.string()).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  previousResponseId: z.nullable(z.string()).optional(),
  instructions: z.nullable(z.string()).optional(),
  reasoning: z.nullable(z.lazy(() => Reasoning$outboundSchema)).optional(),
  maxOutputTokens: z.nullable(z.number().int()).optional(),
  text: z.nullable(z.lazy(() => CreateResponseText$outboundSchema)).optional(),
  input: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => CreateResponse23$outboundSchema),
      z.lazy(() => CreateResponse2RouterResponses2$outboundSchema),
      z.lazy(() => Two1$outboundSchema),
    ])),
  ]),
  include: z.nullable(z.array(Include$outboundSchema)).optional(),
  parallelToolCalls: z.nullable(z.boolean()).optional(),
  store: z.nullable(z.boolean().default(true)),
  serviceTier: z.nullable(ServiceTier$outboundSchema).optional(),
  tools: z.array(
    z.union([
      z.lazy(() => Tools1$outboundSchema),
      z.lazy(() => Tools2$outboundSchema),
      z.lazy(() => Tools3$outboundSchema),
    ]),
  ).optional(),
  toolChoice: z.union([
    z.lazy(() => ToolChoice3$outboundSchema),
    z.lazy(() => ToolChoice4$outboundSchema),
    z.lazy(() => CreateResponseToolChoice2$outboundSchema),
    CreateResponseToolChoice1$outboundSchema,
  ]).optional(),
  stream: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    topP: "top_p",
    previousResponseId: "previous_response_id",
    maxOutputTokens: "max_output_tokens",
    parallelToolCalls: "parallel_tool_calls",
    serviceTier: "service_tier",
    toolChoice: "tool_choice",
  });
});

export function createResponseRequestBodyToJSON(
  createResponseRequestBody: CreateResponseRequestBody,
): string {
  return JSON.stringify(
    CreateResponseRequestBody$outboundSchema.parse(createResponseRequestBody),
  );
}

/** @internal */
export const CreateResponseData$inboundSchema: z.ZodType<
  CreateResponseData,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function createResponseDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseData' from JSON`,
  );
}

/** @internal */
export const CreateResponseRouterResponsesResponseBody$inboundSchema: z.ZodType<
  CreateResponseRouterResponsesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().optional().transform((v, ctx) => {
    if (v === undefined) return undefined;
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => CreateResponseData$inboundSchema).optional()),
});

export function createResponseRouterResponsesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateResponseRouterResponsesResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateResponseRouterResponsesResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateResponseRouterResponsesResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateResponseObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateResponseObject
> = z.nativeEnum(CreateResponseObject);

/** @internal */
export const CreateResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateResponseStatus
> = z.nativeEnum(CreateResponseStatus);

/** @internal */
export const ErrorT$inboundSchema: z.ZodType<ErrorT, z.ZodTypeDef, unknown> = z
  .object({
    code: z.string(),
    message: z.string(),
  });

export function errorFromJSON(
  jsonString: string,
): SafeParseResult<ErrorT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ErrorT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ErrorT' from JSON`,
  );
}

/** @internal */
export const Reason$inboundSchema: z.ZodNativeEnum<typeof Reason> = z
  .nativeEnum(Reason);

/** @internal */
export const IncompleteDetails$inboundSchema: z.ZodType<
  IncompleteDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reason: Reason$inboundSchema,
});

export function incompleteDetailsFromJSON(
  jsonString: string,
): SafeParseResult<IncompleteDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => IncompleteDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'IncompleteDetails' from JSON`,
  );
}

/** @internal */
export const CreateResponseOutputRouterResponsesResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateResponseOutputRouterResponsesResponseStatus> = z
    .nativeEnum(CreateResponseOutputRouterResponsesResponseStatus);

/** @internal */
export const Output4$inboundSchema: z.ZodType<Output4, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: z.literal("function_call"),
    call_id: z.string(),
    name: z.string(),
    arguments: z.string(),
    status: CreateResponseOutputRouterResponsesResponseStatus$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "call_id": "callId",
    });
  });

export function output4FromJSON(
  jsonString: string,
): SafeParseResult<Output4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output4' from JSON`,
  );
}

/** @internal */
export const CreateResponseOutputRouterResponsesStatus$inboundSchema:
  z.ZodNativeEnum<typeof CreateResponseOutputRouterResponsesStatus> = z
    .nativeEnum(CreateResponseOutputRouterResponsesStatus);

/** @internal */
export const Output3$inboundSchema: z.ZodType<Output3, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: z.literal("file_search_call"),
    status: CreateResponseOutputRouterResponsesStatus$inboundSchema,
    queries: z.array(z.string()).optional(),
    results: z.any().optional(),
  });

export function output3FromJSON(
  jsonString: string,
): SafeParseResult<Output3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output3' from JSON`,
  );
}

/** @internal */
export const CreateResponseOutputStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateResponseOutputStatus
> = z.nativeEnum(CreateResponseOutputStatus);

/** @internal */
export const Output2$inboundSchema: z.ZodType<Output2, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: z.literal("web_search_call"),
    status: CreateResponseOutputStatus$inboundSchema,
  });

export function output2FromJSON(
  jsonString: string,
): SafeParseResult<Output2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output2' from JSON`,
  );
}

/** @internal */
export const OutputRole$inboundSchema: z.ZodNativeEnum<typeof OutputRole> = z
  .nativeEnum(OutputRole);

/** @internal */
export const OutputStatus$inboundSchema: z.ZodNativeEnum<typeof OutputStatus> =
  z.nativeEnum(OutputStatus);

/** @internal */
export const ContentType$inboundSchema: z.ZodNativeEnum<typeof ContentType> = z
  .nativeEnum(ContentType);

/** @internal */
export const Annotations2$inboundSchema: z.ZodType<
  Annotations2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file_citation"),
  index: z.number(),
  file_id: z.string(),
  filename: z.string(),
}).transform((v) => {
  return remap$(v, {
    "file_id": "fileId",
  });
});

export function annotations2FromJSON(
  jsonString: string,
): SafeParseResult<Annotations2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations2' from JSON`,
  );
}

/** @internal */
export const Annotations1$inboundSchema: z.ZodType<
  Annotations1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("url_citation"),
  start_index: z.number(),
  end_index: z.number(),
  url: z.string(),
  title: z.string(),
}).transform((v) => {
  return remap$(v, {
    "start_index": "startIndex",
    "end_index": "endIndex",
  });
});

export function annotations1FromJSON(
  jsonString: string,
): SafeParseResult<Annotations1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations1' from JSON`,
  );
}

/** @internal */
export const Annotations$inboundSchema: z.ZodType<
  Annotations,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Annotations1$inboundSchema),
  z.lazy(() => Annotations2$inboundSchema),
]);

export function annotationsFromJSON(
  jsonString: string,
): SafeParseResult<Annotations, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Annotations$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Annotations' from JSON`,
  );
}

/** @internal */
export const Content1$inboundSchema: z.ZodType<
  Content1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ContentType$inboundSchema,
  text: z.string(),
  annotations: z.array(
    z.union([
      z.lazy(() => Annotations1$inboundSchema),
      z.lazy(() => Annotations2$inboundSchema),
    ]),
  ).optional(),
  logprobs: z.array(z.any()).optional(),
});

export function content1FromJSON(
  jsonString: string,
): SafeParseResult<Content1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content1' from JSON`,
  );
}

/** @internal */
export const OutputContent$inboundSchema: z.ZodType<
  OutputContent,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => Content1$inboundSchema);

export function outputContentFromJSON(
  jsonString: string,
): SafeParseResult<OutputContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputContent' from JSON`,
  );
}

/** @internal */
export const Output1$inboundSchema: z.ZodType<Output1, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    type: z.literal("message"),
    role: OutputRole$inboundSchema,
    status: OutputStatus$inboundSchema,
    content: z.array(z.lazy(() => Content1$inboundSchema)).optional(),
  });

export function output1FromJSON(
  jsonString: string,
): SafeParseResult<Output1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output1' from JSON`,
  );
}

/** @internal */
export const Output$inboundSchema: z.ZodType<Output, z.ZodTypeDef, unknown> = z
  .union([
    z.lazy(() => Output1$inboundSchema),
    z.lazy(() => Output2$inboundSchema),
    z.lazy(() => Output3$inboundSchema),
    z.lazy(() => Output4$inboundSchema),
  ]);

export function outputFromJSON(
  jsonString: string,
): SafeParseResult<Output, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output' from JSON`,
  );
}

/** @internal */
export const CreateResponseInputTokensDetails$inboundSchema: z.ZodType<
  CreateResponseInputTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
  });
});

export function createResponseInputTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseInputTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseInputTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseInputTokensDetails' from JSON`,
  );
}

/** @internal */
export const OutputTokensDetails$inboundSchema: z.ZodType<
  OutputTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.number().int().optional(),
  accepted_prediction_tokens: z.number().int().optional(),
  rejected_prediction_tokens: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
  });
});

export function outputTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<OutputTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OutputTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OutputTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateResponseUsage$inboundSchema: z.ZodType<
  CreateResponseUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_tokens: z.number().optional(),
  output_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  input_tokens_details: z.lazy(() =>
    CreateResponseInputTokensDetails$inboundSchema
  ).optional(),
  output_tokens_details: z.lazy(() => OutputTokensDetails$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "input_tokens": "inputTokens",
    "output_tokens": "outputTokens",
    "total_tokens": "totalTokens",
    "input_tokens_details": "inputTokensDetails",
    "output_tokens_details": "outputTokensDetails",
  });
});

export function createResponseUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseUsage' from JSON`,
  );
}

/** @internal */
export const CreateResponseToolChoiceRouterResponsesResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateResponseToolChoiceRouterResponsesResponseType> =
    z.nativeEnum(CreateResponseToolChoiceRouterResponsesResponseType);

/** @internal */
export const CreateResponseToolChoiceFunction$inboundSchema: z.ZodType<
  CreateResponseToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function createResponseToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const CreateResponseToolChoiceRouterResponses2$inboundSchema: z.ZodType<
  CreateResponseToolChoiceRouterResponses2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateResponseToolChoiceRouterResponsesResponseType$inboundSchema,
  function: z.lazy(() => CreateResponseToolChoiceFunction$inboundSchema),
});

export function createResponseToolChoiceRouterResponses2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateResponseToolChoiceRouterResponses2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateResponseToolChoiceRouterResponses2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateResponseToolChoiceRouterResponses2' from JSON`,
  );
}

/** @internal */
export const CreateResponseToolChoiceRouterResponses1$inboundSchema:
  z.ZodNativeEnum<typeof CreateResponseToolChoiceRouterResponses1> = z
    .nativeEnum(CreateResponseToolChoiceRouterResponses1);

/** @internal */
export const CreateResponseRouterResponsesToolChoice$inboundSchema: z.ZodType<
  CreateResponseRouterResponsesToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateResponseToolChoiceRouterResponses2$inboundSchema),
  CreateResponseToolChoiceRouterResponses1$inboundSchema,
]);

export function createResponseRouterResponsesToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateResponseRouterResponsesToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateResponseRouterResponsesToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateResponseRouterResponsesToolChoice' from JSON`,
  );
}

/** @internal */
export const ToolsRanker$inboundSchema: z.ZodNativeEnum<typeof ToolsRanker> = z
  .nativeEnum(ToolsRanker);

/** @internal */
export const ToolsRankingOptions$inboundSchema: z.ZodType<
  ToolsRankingOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  ranker: ToolsRanker$inboundSchema.default("auto"),
  score_threshold: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "score_threshold": "scoreThreshold",
  });
});

export function toolsRankingOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ToolsRankingOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsRankingOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsRankingOptions' from JSON`,
  );
}

/** @internal */
export const CreateResponseTools3$inboundSchema: z.ZodType<
  CreateResponseTools3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file_search"),
  vector_store_ids: z.array(z.string()).optional(),
  max_num_results: z.number().int().default(20),
  filters: z.any().optional(),
  ranking_options: z.lazy(() => ToolsRankingOptions$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "vector_store_ids": "vectorStoreIds",
    "max_num_results": "maxNumResults",
    "ranking_options": "rankingOptions",
  });
});

export function createResponseTools3FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseTools3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseTools3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseTools3' from JSON`,
  );
}

/** @internal */
export const ToolsSearchContextSize$inboundSchema: z.ZodNativeEnum<
  typeof ToolsSearchContextSize
> = z.nativeEnum(ToolsSearchContextSize);

/** @internal */
export const CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const ToolsUserLocation$inboundSchema: z.ZodType<
  ToolsUserLocation,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBodyType$inboundSchema
      .optional(),
  city: z.nullable(z.string()).optional(),
  country: z.string().optional(),
  region: z.nullable(z.string()).optional(),
  timezone: z.nullable(z.string()).optional(),
});

export function toolsUserLocationFromJSON(
  jsonString: string,
): SafeParseResult<ToolsUserLocation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsUserLocation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsUserLocation' from JSON`,
  );
}

/** @internal */
export const CreateResponseTools2$inboundSchema: z.ZodType<
  CreateResponseTools2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("web_search_preview"),
  domains: z.array(z.string()).optional(),
  search_context_size: ToolsSearchContextSize$inboundSchema.default("medium"),
  user_location: z.lazy(() => ToolsUserLocation$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "search_context_size": "searchContextSize",
    "user_location": "userLocation",
  });
});

export function createResponseTools2FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseTools2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseTools2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseTools2' from JSON`,
  );
}

/** @internal */
export const CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type
  > = z.nativeEnum(
    CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type,
  );

/** @internal */
export const ToolsProperties$inboundSchema: z.ZodType<
  ToolsProperties,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    description: z.string().optional(),
    enum: z.array(z.string()).optional(),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function toolsPropertiesFromJSON(
  jsonString: string,
): SafeParseResult<ToolsProperties, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsProperties$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsProperties' from JSON`,
  );
}

/** @internal */
export const CreateResponseToolsParameters$inboundSchema: z.ZodType<
  CreateResponseToolsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    CreateResponseToolsRouterResponsesResponse200ApplicationJSONResponseBody1Type$inboundSchema,
  properties: z.record(z.lazy(() => ToolsProperties$inboundSchema)),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});

export function createResponseToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseToolsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseToolsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseToolsParameters' from JSON`,
  );
}

/** @internal */
export const CreateResponseTools1$inboundSchema: z.ZodType<
  CreateResponseTools1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("function"),
  name: z.string(),
  description: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => CreateResponseToolsParameters$inboundSchema),
  strict: z.boolean().default(true),
});

export function createResponseTools1FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseTools1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseTools1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseTools1' from JSON`,
  );
}

/** @internal */
export const CreateResponseRouterResponsesTools$inboundSchema: z.ZodType<
  CreateResponseRouterResponsesTools,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateResponseTools1$inboundSchema),
  z.lazy(() => CreateResponseTools2$inboundSchema),
  z.lazy(() => CreateResponseTools3$inboundSchema),
]);

export function createResponseRouterResponsesToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseRouterResponsesTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateResponseRouterResponsesTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseRouterResponsesTools' from JSON`,
  );
}

/** @internal */
export const CreateResponseReasoning$inboundSchema: z.ZodType<
  CreateResponseReasoning,
  z.ZodTypeDef,
  unknown
> = z.object({
  effort: z.nullable(z.string()).optional(),
  summary: z.nullable(z.string()).optional(),
});

export function createResponseReasoningFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseReasoning, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseReasoning$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseReasoning' from JSON`,
  );
}

/** @internal */
export const CreateResponseFormat3$inboundSchema: z.ZodType<
  CreateResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.boolean().default(true),
});

export function createResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseFormat3' from JSON`,
  );
}

/** @internal */
export const CreateResponseFormat2$inboundSchema: z.ZodType<
  CreateResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});

export function createResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseFormat2' from JSON`,
  );
}

/** @internal */
export const CreateResponseFormat1$inboundSchema: z.ZodType<
  CreateResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function createResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseFormat1' from JSON`,
  );
}

/** @internal */
export const CreateResponseRouterResponsesFormat$inboundSchema: z.ZodType<
  CreateResponseRouterResponsesFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateResponseFormat1$inboundSchema),
  z.lazy(() => CreateResponseFormat2$inboundSchema),
  z.lazy(() => CreateResponseFormat3$inboundSchema),
]);

export function createResponseRouterResponsesFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseRouterResponsesFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateResponseRouterResponsesFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseRouterResponsesFormat' from JSON`,
  );
}

/** @internal */
export const CreateResponseRouterResponsesText$inboundSchema: z.ZodType<
  CreateResponseRouterResponsesText,
  z.ZodTypeDef,
  unknown
> = z.object({
  format: z.union([
    z.lazy(() => CreateResponseFormat1$inboundSchema),
    z.lazy(() => CreateResponseFormat2$inboundSchema),
    z.lazy(() => CreateResponseFormat3$inboundSchema),
  ]),
});

export function createResponseRouterResponsesTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseRouterResponsesText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseRouterResponsesText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseRouterResponsesText' from JSON`,
  );
}

/** @internal */
export const Truncation$inboundSchema: z.ZodNativeEnum<typeof Truncation> = z
  .nativeEnum(Truncation);

/** @internal */
export const CreateResponseServiceTier$inboundSchema: z.ZodNativeEnum<
  typeof CreateResponseServiceTier
> = z.nativeEnum(CreateResponseServiceTier);

/** @internal */
export const CreateResponseResponseBody$inboundSchema: z.ZodType<
  CreateResponseResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: CreateResponseObject$inboundSchema,
  created_at: z.number(),
  status: CreateResponseStatus$inboundSchema,
  error: z.nullable(z.lazy(() => ErrorT$inboundSchema)),
  incomplete_details: z.nullable(z.lazy(() => IncompleteDetails$inboundSchema)),
  model: z.string(),
  instructions: z.nullable(z.string()).optional(),
  output: z.array(
    z.union([
      z.lazy(() => Output1$inboundSchema),
      z.lazy(() => Output2$inboundSchema),
      z.lazy(() => Output3$inboundSchema),
      z.lazy(() => Output4$inboundSchema),
    ]),
  ),
  output_text: z.nullable(z.string()).optional(),
  usage: z.lazy(() => CreateResponseUsage$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  max_output_tokens: z.nullable(z.number().int()).optional(),
  parallel_tool_calls: z.boolean(),
  previous_response_id: z.nullable(z.string()).optional(),
  metadata: z.record(z.string()).optional(),
  tool_choice: z.union([
    z.lazy(() => CreateResponseToolChoiceRouterResponses2$inboundSchema),
    CreateResponseToolChoiceRouterResponses1$inboundSchema,
  ]).optional(),
  tools: z.array(
    z.union([
      z.lazy(() => CreateResponseTools1$inboundSchema),
      z.lazy(() => CreateResponseTools2$inboundSchema),
      z.lazy(() => CreateResponseTools3$inboundSchema),
    ]),
  ).optional(),
  reasoning: z.nullable(z.lazy(() => CreateResponseReasoning$inboundSchema))
    .optional(),
  store: z.boolean().optional(),
  text: z.lazy(() => CreateResponseRouterResponsesText$inboundSchema)
    .optional(),
  truncation: z.nullable(Truncation$inboundSchema.default("disabled")),
  user: z.nullable(z.string()).optional(),
  service_tier: z.nullable(CreateResponseServiceTier$inboundSchema).optional(),
  background: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
}).transform((v) => {
  return remap$(v, {
    "created_at": "createdAt",
    "incomplete_details": "incompleteDetails",
    "output_text": "outputText",
    "top_p": "topP",
    "max_output_tokens": "maxOutputTokens",
    "parallel_tool_calls": "parallelToolCalls",
    "previous_response_id": "previousResponseId",
    "tool_choice": "toolChoice",
    "service_tier": "serviceTier",
    "top_logprobs": "topLogprobs",
  });
});

export function createResponseResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateResponseResponse$inboundSchema: z.ZodType<
  CreateResponseResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateResponseResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() =>
            CreateResponseRouterResponsesResponseBody$inboundSchema
          ).parse(rawEvent),
        };
      });
    }),
]);

export function createResponseResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateResponseResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateResponseResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateResponseResponse' from JSON`,
  );
}
