/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListKnowledgeBasesRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const ListKnowledgeBasesObject = {
  List: "list",
} as const;
export type ListKnowledgeBasesObject = ClosedEnum<
  typeof ListKnowledgeBasesObject
>;

export const ListKnowledgeBasesDataKnowledgeType = {
  External: "external",
} as const;
export type ListKnowledgeBasesDataKnowledgeType = ClosedEnum<
  typeof ListKnowledgeBasesDataKnowledgeType
>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type DataRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type DataAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base.
 */
export type DataRetrievalSettings = {
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: DataRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: DataAgenticRagConfig | null | undefined;
};

export type DataExternalConfig = {
  /**
   * The name of the external knowledge base.
   */
  name: string;
  /**
   * The API URL of the external knowledge base.
   */
  apiUrl: string;
};

export type Data2 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: ListKnowledgeBasesDataKnowledgeType | undefined;
  /**
   * The retrieval settings for the knowledge base.
   */
  retrievalSettings?: DataRetrievalSettings | undefined;
  externalConfig: DataExternalConfig;
};

export const ListKnowledgeBasesDataType = {
  Internal: "internal",
} as const;
export type ListKnowledgeBasesDataType = ClosedEnum<
  typeof ListKnowledgeBasesDataType
>;

/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export const DataRetrievalType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
 */
export type DataRetrievalType = ClosedEnum<typeof DataRetrievalType>;

/**
 * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
 */
export type ListKnowledgeBasesDataRerankConfig = {
  /**
   * The number of results to return by the reranking model
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  rerankThreshold?: number | undefined;
  /**
   * The rerank model to use for the knowledge base.
   */
  rerankModel: string;
};

/**
 * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
 */
export type ListKnowledgeBasesDataAgenticRagConfig = {
  /**
   * The model to use for the Agentic RAG
   */
  model: string;
};

/**
 * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
 */
export type ListKnowledgeBasesDataRetrievalSettings = {
  /**
   * The retrieval type to use for the knowledge base. If not provided, Hybrid Search will be used as a default query strategy.
   */
  retrievalType?: DataRetrievalType | undefined;
  /**
   * The number of results to return from the search.
   */
  topK?: number | undefined;
  /**
   * The threshold value used to filter the search results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The rerank configuration for the knowledge base. In case the model is provided it will be used to enhance the search precision.
   */
  rerankConfig?: ListKnowledgeBasesDataRerankConfig | null | undefined;
  /**
   * The Agentic RAG configuration for the knowledge base. If `null` is provided, Agentic RAG will be disabled.
   */
  agenticRagConfig?: ListKnowledgeBasesDataAgenticRagConfig | null | undefined;
};

export type Data1 = {
  /**
   * The unique identifier of the knowledge base.
   */
  id: string;
  /**
   * The creation date of the knowledge base.
   */
  created: string;
  /**
   * The description of the knowledge base.
   */
  description?: string | undefined;
  /**
   * The unique key of the knowledge base.
   */
  key: string;
  /**
   * The project/domain ID of the knowledge base.
   */
  domainId: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The last update date of the knowledge base.
   */
  updated: string;
  type?: ListKnowledgeBasesDataType | undefined;
  /**
   * The retrieval settings for the knowledge base. If not provider, Hybrid Search will be used as a default query strategy.
   */
  retrievalSettings?: ListKnowledgeBasesDataRetrievalSettings | undefined;
  /**
   * The embeddings model used for the knowledge base.
   */
  model: string;
};

export type ListKnowledgeBasesData = Data1 | Data2;

/**
 * Knowledge bases retrieved
 */
export type ListKnowledgeBasesResponseBody = {
  object: ListKnowledgeBasesObject;
  data: Array<Data1 | Data2>;
  hasMore: boolean;
};

/** @internal */
export const ListKnowledgeBasesRequest$inboundSchema: z.ZodType<
  ListKnowledgeBasesRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().default(10),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type ListKnowledgeBasesRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const ListKnowledgeBasesRequest$outboundSchema: z.ZodType<
  ListKnowledgeBasesRequest$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listKnowledgeBasesRequestToJSON(
  listKnowledgeBasesRequest: ListKnowledgeBasesRequest,
): string {
  return JSON.stringify(
    ListKnowledgeBasesRequest$outboundSchema.parse(listKnowledgeBasesRequest),
  );
}
export function listKnowledgeBasesRequestFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesRequest' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesObject$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesObject
> = z.nativeEnum(ListKnowledgeBasesObject);
/** @internal */
export const ListKnowledgeBasesObject$outboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesObject
> = ListKnowledgeBasesObject$inboundSchema;

/** @internal */
export const ListKnowledgeBasesDataKnowledgeType$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesDataKnowledgeType
> = z.nativeEnum(ListKnowledgeBasesDataKnowledgeType);
/** @internal */
export const ListKnowledgeBasesDataKnowledgeType$outboundSchema:
  z.ZodNativeEnum<typeof ListKnowledgeBasesDataKnowledgeType> =
    ListKnowledgeBasesDataKnowledgeType$inboundSchema;

/** @internal */
export const DataRerankConfig$inboundSchema: z.ZodType<
  DataRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type DataRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const DataRerankConfig$outboundSchema: z.ZodType<
  DataRerankConfig$Outbound,
  z.ZodTypeDef,
  DataRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function dataRerankConfigToJSON(
  dataRerankConfig: DataRerankConfig,
): string {
  return JSON.stringify(
    DataRerankConfig$outboundSchema.parse(dataRerankConfig),
  );
}
export function dataRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataRerankConfig' from JSON`,
  );
}

/** @internal */
export const DataAgenticRagConfig$inboundSchema: z.ZodType<
  DataAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type DataAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const DataAgenticRagConfig$outboundSchema: z.ZodType<
  DataAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  DataAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function dataAgenticRagConfigToJSON(
  dataAgenticRagConfig: DataAgenticRagConfig,
): string {
  return JSON.stringify(
    DataAgenticRagConfig$outboundSchema.parse(dataAgenticRagConfig),
  );
}
export function dataAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const DataRetrievalSettings$inboundSchema: z.ZodType<
  DataRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(z.lazy(() => DataRerankConfig$inboundSchema))
    .optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => DataAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});
/** @internal */
export type DataRetrievalSettings$Outbound = {
  top_k: number;
  threshold: number;
  rerank_config?: DataRerankConfig$Outbound | null | undefined;
  agentic_rag_config?: DataAgenticRagConfig$Outbound | null | undefined;
};

/** @internal */
export const DataRetrievalSettings$outboundSchema: z.ZodType<
  DataRetrievalSettings$Outbound,
  z.ZodTypeDef,
  DataRetrievalSettings
> = z.object({
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(z.lazy(() => DataRerankConfig$outboundSchema))
    .optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => DataAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function dataRetrievalSettingsToJSON(
  dataRetrievalSettings: DataRetrievalSettings,
): string {
  return JSON.stringify(
    DataRetrievalSettings$outboundSchema.parse(dataRetrievalSettings),
  );
}
export function dataRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<DataRetrievalSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataRetrievalSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const DataExternalConfig$inboundSchema: z.ZodType<
  DataExternalConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  api_url: z.string(),
}).transform((v) => {
  return remap$(v, {
    "api_url": "apiUrl",
  });
});
/** @internal */
export type DataExternalConfig$Outbound = {
  name: string;
  api_url: string;
};

/** @internal */
export const DataExternalConfig$outboundSchema: z.ZodType<
  DataExternalConfig$Outbound,
  z.ZodTypeDef,
  DataExternalConfig
> = z.object({
  name: z.string(),
  apiUrl: z.string(),
}).transform((v) => {
  return remap$(v, {
    apiUrl: "api_url",
  });
});

export function dataExternalConfigToJSON(
  dataExternalConfig: DataExternalConfig,
): string {
  return JSON.stringify(
    DataExternalConfig$outboundSchema.parse(dataExternalConfig),
  );
}
export function dataExternalConfigFromJSON(
  jsonString: string,
): SafeParseResult<DataExternalConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataExternalConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataExternalConfig' from JSON`,
  );
}

/** @internal */
export const Data2$inboundSchema: z.ZodType<Data2, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    created: z.string(),
    description: z.string().optional(),
    key: z.string(),
    domain_id: z.string(),
    path: z.string().optional(),
    created_by_id: z.nullable(z.string()).optional(),
    updated_by_id: z.nullable(z.string()).optional(),
    updated: z.string(),
    type: ListKnowledgeBasesDataKnowledgeType$inboundSchema.default("external"),
    retrieval_settings: z.lazy(() => DataRetrievalSettings$inboundSchema)
      .optional(),
    external_config: z.lazy(() => DataExternalConfig$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "domain_id": "domainId",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "retrieval_settings": "retrievalSettings",
      "external_config": "externalConfig",
    });
  });
/** @internal */
export type Data2$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?: DataRetrievalSettings$Outbound | undefined;
  external_config: DataExternalConfig$Outbound;
};

/** @internal */
export const Data2$outboundSchema: z.ZodType<
  Data2$Outbound,
  z.ZodTypeDef,
  Data2
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: ListKnowledgeBasesDataKnowledgeType$outboundSchema.default("external"),
  retrievalSettings: z.lazy(() => DataRetrievalSettings$outboundSchema)
    .optional(),
  externalConfig: z.lazy(() => DataExternalConfig$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
    externalConfig: "external_config",
  });
});

export function data2ToJSON(data2: Data2): string {
  return JSON.stringify(Data2$outboundSchema.parse(data2));
}
export function data2FromJSON(
  jsonString: string,
): SafeParseResult<Data2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data2' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataType$inboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesDataType
> = z.nativeEnum(ListKnowledgeBasesDataType);
/** @internal */
export const ListKnowledgeBasesDataType$outboundSchema: z.ZodNativeEnum<
  typeof ListKnowledgeBasesDataType
> = ListKnowledgeBasesDataType$inboundSchema;

/** @internal */
export const DataRetrievalType$inboundSchema: z.ZodNativeEnum<
  typeof DataRetrievalType
> = z.nativeEnum(DataRetrievalType);
/** @internal */
export const DataRetrievalType$outboundSchema: z.ZodNativeEnum<
  typeof DataRetrievalType
> = DataRetrievalType$inboundSchema;

/** @internal */
export const ListKnowledgeBasesDataRerankConfig$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().default(5),
  rerank_threshold: z.number().default(0.5),
  rerank_model: z.string(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "rerank_threshold": "rerankThreshold",
    "rerank_model": "rerankModel",
  });
});
/** @internal */
export type ListKnowledgeBasesDataRerankConfig$Outbound = {
  top_k: number;
  rerank_threshold: number;
  rerank_model: string;
};

/** @internal */
export const ListKnowledgeBasesDataRerankConfig$outboundSchema: z.ZodType<
  ListKnowledgeBasesDataRerankConfig$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesDataRerankConfig
> = z.object({
  topK: z.number().int().default(5),
  rerankThreshold: z.number().default(0.5),
  rerankModel: z.string(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    rerankThreshold: "rerank_threshold",
    rerankModel: "rerank_model",
  });
});

export function listKnowledgeBasesDataRerankConfigToJSON(
  listKnowledgeBasesDataRerankConfig: ListKnowledgeBasesDataRerankConfig,
): string {
  return JSON.stringify(
    ListKnowledgeBasesDataRerankConfig$outboundSchema.parse(
      listKnowledgeBasesDataRerankConfig,
    ),
  );
}
export function listKnowledgeBasesDataRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesDataRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesDataRerankConfig' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataAgenticRagConfig$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type ListKnowledgeBasesDataAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const ListKnowledgeBasesDataAgenticRagConfig$outboundSchema: z.ZodType<
  ListKnowledgeBasesDataAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesDataAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function listKnowledgeBasesDataAgenticRagConfigToJSON(
  listKnowledgeBasesDataAgenticRagConfig:
    ListKnowledgeBasesDataAgenticRagConfig,
): string {
  return JSON.stringify(
    ListKnowledgeBasesDataAgenticRagConfig$outboundSchema.parse(
      listKnowledgeBasesDataAgenticRagConfig,
    ),
  );
}
export function listKnowledgeBasesDataAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesDataAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesDataAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesDataRetrievalSettings$inboundSchema: z.ZodType<
  ListKnowledgeBasesDataRetrievalSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  retrieval_type: DataRetrievalType$inboundSchema.default("hybrid_search"),
  top_k: z.number().int().default(5),
  threshold: z.number().default(0),
  rerank_config: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataRerankConfig$inboundSchema),
  ).optional(),
  agentic_rag_config: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataAgenticRagConfig$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "retrieval_type": "retrievalType",
    "top_k": "topK",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
  });
});
/** @internal */
export type ListKnowledgeBasesDataRetrievalSettings$Outbound = {
  retrieval_type: string;
  top_k: number;
  threshold: number;
  rerank_config?:
    | ListKnowledgeBasesDataRerankConfig$Outbound
    | null
    | undefined;
  agentic_rag_config?:
    | ListKnowledgeBasesDataAgenticRagConfig$Outbound
    | null
    | undefined;
};

/** @internal */
export const ListKnowledgeBasesDataRetrievalSettings$outboundSchema: z.ZodType<
  ListKnowledgeBasesDataRetrievalSettings$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesDataRetrievalSettings
> = z.object({
  retrievalType: DataRetrievalType$outboundSchema.default("hybrid_search"),
  topK: z.number().int().default(5),
  threshold: z.number().default(0),
  rerankConfig: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataRerankConfig$outboundSchema),
  ).optional(),
  agenticRagConfig: z.nullable(
    z.lazy(() => ListKnowledgeBasesDataAgenticRagConfig$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    retrievalType: "retrieval_type",
    topK: "top_k",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
  });
});

export function listKnowledgeBasesDataRetrievalSettingsToJSON(
  listKnowledgeBasesDataRetrievalSettings:
    ListKnowledgeBasesDataRetrievalSettings,
): string {
  return JSON.stringify(
    ListKnowledgeBasesDataRetrievalSettings$outboundSchema.parse(
      listKnowledgeBasesDataRetrievalSettings,
    ),
  );
}
export function listKnowledgeBasesDataRetrievalSettingsFromJSON(
  jsonString: string,
): SafeParseResult<
  ListKnowledgeBasesDataRetrievalSettings,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListKnowledgeBasesDataRetrievalSettings$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListKnowledgeBasesDataRetrievalSettings' from JSON`,
  );
}

/** @internal */
export const Data1$inboundSchema: z.ZodType<Data1, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string(),
    created: z.string(),
    description: z.string().optional(),
    key: z.string(),
    domain_id: z.string(),
    path: z.string().optional(),
    created_by_id: z.nullable(z.string()).optional(),
    updated_by_id: z.nullable(z.string()).optional(),
    updated: z.string(),
    type: ListKnowledgeBasesDataType$inboundSchema.default("internal"),
    retrieval_settings: z.lazy(() =>
      ListKnowledgeBasesDataRetrievalSettings$inboundSchema
    ).optional(),
    model: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "domain_id": "domainId",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "retrieval_settings": "retrievalSettings",
    });
  });
/** @internal */
export type Data1$Outbound = {
  _id: string;
  created: string;
  description?: string | undefined;
  key: string;
  domain_id: string;
  path?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  updated: string;
  type: string;
  retrieval_settings?:
    | ListKnowledgeBasesDataRetrievalSettings$Outbound
    | undefined;
  model: string;
};

/** @internal */
export const Data1$outboundSchema: z.ZodType<
  Data1$Outbound,
  z.ZodTypeDef,
  Data1
> = z.object({
  id: z.string(),
  created: z.string(),
  description: z.string().optional(),
  key: z.string(),
  domainId: z.string(),
  path: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  updated: z.string(),
  type: ListKnowledgeBasesDataType$outboundSchema.default("internal"),
  retrievalSettings: z.lazy(() =>
    ListKnowledgeBasesDataRetrievalSettings$outboundSchema
  ).optional(),
  model: z.string(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    retrievalSettings: "retrieval_settings",
  });
});

export function data1ToJSON(data1: Data1): string {
  return JSON.stringify(Data1$outboundSchema.parse(data1));
}
export function data1FromJSON(
  jsonString: string,
): SafeParseResult<Data1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data1' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesData$inboundSchema: z.ZodType<
  ListKnowledgeBasesData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Data1$inboundSchema),
  z.lazy(() => Data2$inboundSchema),
]);
/** @internal */
export type ListKnowledgeBasesData$Outbound = Data1$Outbound | Data2$Outbound;

/** @internal */
export const ListKnowledgeBasesData$outboundSchema: z.ZodType<
  ListKnowledgeBasesData$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesData
> = z.union([
  z.lazy(() => Data1$outboundSchema),
  z.lazy(() => Data2$outboundSchema),
]);

export function listKnowledgeBasesDataToJSON(
  listKnowledgeBasesData: ListKnowledgeBasesData,
): string {
  return JSON.stringify(
    ListKnowledgeBasesData$outboundSchema.parse(listKnowledgeBasesData),
  );
}
export function listKnowledgeBasesDataFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesData' from JSON`,
  );
}

/** @internal */
export const ListKnowledgeBasesResponseBody$inboundSchema: z.ZodType<
  ListKnowledgeBasesResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ListKnowledgeBasesObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$inboundSchema),
      z.lazy(() => Data2$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});
/** @internal */
export type ListKnowledgeBasesResponseBody$Outbound = {
  object: string;
  data: Array<Data1$Outbound | Data2$Outbound>;
  has_more: boolean;
};

/** @internal */
export const ListKnowledgeBasesResponseBody$outboundSchema: z.ZodType<
  ListKnowledgeBasesResponseBody$Outbound,
  z.ZodTypeDef,
  ListKnowledgeBasesResponseBody
> = z.object({
  object: ListKnowledgeBasesObject$outboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$outboundSchema),
      z.lazy(() => Data2$outboundSchema),
    ]),
  ),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

export function listKnowledgeBasesResponseBodyToJSON(
  listKnowledgeBasesResponseBody: ListKnowledgeBasesResponseBody,
): string {
  return JSON.stringify(
    ListKnowledgeBasesResponseBody$outboundSchema.parse(
      listKnowledgeBasesResponseBody,
    ),
  );
}
export function listKnowledgeBasesResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListKnowledgeBasesResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListKnowledgeBasesResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListKnowledgeBasesResponseBody' from JSON`,
  );
}
