/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RetrieveToolRequest = {
  toolId: string;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

/**
 * The type must be "object"
 */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RetrieveToolResponseBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const RetrieveToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type RetrieveToolResponseBodyLanguage = ClosedEnum<
  typeof RetrieveToolResponseBodyLanguage
>;

export type RetrieveToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RetrieveToolResponseBodyToolsParameters | undefined;
  language: RetrieveToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Executes code snippets in a sandboxed environment, currently supporting Python.
 */
export type RetrieveToolResponseBodyCodeExecutionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus;
  versionHash?: string | undefined;
  type: "code";
  codeTool: RetrieveToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof RetrieveToolResponseBodyToolsResponse200Status
>;

export type RetrieveToolResponseBodyHeaders = {
  value: string;
  encrypted: boolean;
};

export const RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type
  >;

export type RetrieveToolResponseBodyToolsSchema = {
  type: RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type RetrieveToolResponseBodyTools = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: RetrieveToolResponseBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const RetrieveToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type RetrieveToolResponseBodyConnectionType = ClosedEnum<
  typeof RetrieveToolResponseBodyConnectionType
>;

export type RetrieveToolResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: RetrieveToolResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<RetrieveToolResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: RetrieveToolResponseBodyConnectionType;
};

/**
 * A tool from a Model Context Protocol (MCP) server that provides standardized access to external capabilities.
 */
export type RetrieveToolResponseBodyMCPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveToolResponseBodyToolsResponse200Status;
  versionHash?: string | undefined;
  type: "mcp";
  mcp: RetrieveToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof RetrieveToolResponseBodyToolsResponseStatus
>;

/**
 * The HTTP method to use.
 */
export const RetrieveToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type RetrieveToolResponseBodyMethod = ClosedEnum<
  typeof RetrieveToolResponseBodyMethod
>;

export type RetrieveToolHeaders2 = {
  value: string;
  encrypted: boolean;
};

export type RetrieveToolResponseBodyToolsHeaders =
  | RetrieveToolHeaders2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type RetrieveToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: RetrieveToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: RetrieveToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type
  >;

/**
 * The default value of the argument.
 */
export type RetrieveToolResponseBodyDefaultValue = string | number | boolean;

export type RetrieveToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel: boolean;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type RetrieveToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: RetrieveToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: RetrieveToolResponseBodyArguments } | undefined;
};

/**
 * Executes HTTP requests to interact with external APIs and web services using customizable blueprints.
 */
export type RetrieveToolResponseBodyHTTPTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveToolResponseBodyToolsResponseStatus;
  versionHash?: string | undefined;
  type: "http";
  http: RetrieveToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveToolResponseBodyToolsStatus = ClosedEnum<
  typeof RetrieveToolResponseBodyToolsStatus
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RetrieveToolResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RetrieveToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: RetrieveToolResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * A tool that enforces structured output format using JSON Schema for consistent response formatting.
 */
export type RetrieveToolResponseBodyJSONSchemaTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveToolResponseBodyToolsStatus;
  versionHash?: string | undefined;
  type: "json_schema";
  jsonSchema: RetrieveToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const RetrieveToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type RetrieveToolResponseBodyStatus = ClosedEnum<
  typeof RetrieveToolResponseBodyStatus
>;

/**
 * The type must be "object"
 */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type RetrieveToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type RetrieveToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: RetrieveToolResponseBodyParameters | undefined;
};

/**
 * A custom function tool that allows the model to call predefined functions with structured parameters.
 */
export type RetrieveToolResponseBodyFunctionTool = {
  id: string;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: RetrieveToolResponseBodyStatus;
  versionHash?: string | undefined;
  type: "function";
  function: RetrieveToolResponseBodyFunction;
};

/**
 * Successfully retrieved the tool.
 */
export type RetrieveToolResponseBody =
  | RetrieveToolResponseBodyFunctionTool
  | RetrieveToolResponseBodyJSONSchemaTool
  | RetrieveToolResponseBodyHTTPTool
  | RetrieveToolResponseBodyMCPTool
  | RetrieveToolResponseBodyCodeExecutionTool;

/** @internal */
export type RetrieveToolRequest$Outbound = {
  tool_id: string;
};

/** @internal */
export const RetrieveToolRequest$outboundSchema: z.ZodType<
  RetrieveToolRequest$Outbound,
  z.ZodTypeDef,
  RetrieveToolRequest
> = z.object({
  toolId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
  });
});

export function retrieveToolRequestToJSON(
  retrieveToolRequest: RetrieveToolRequest,
): string {
  return JSON.stringify(
    RetrieveToolRequest$outboundSchema.parse(retrieveToolRequest),
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(
    RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus,
  );

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(
    RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type,
  );

/** @internal */
export const RetrieveToolResponseBodyToolsParameters$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      RetrieveToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function retrieveToolResponseBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveToolResponseBodyToolsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyToolsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveToolResponseBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveToolResponseBodyLanguage
> = z.nativeEnum(RetrieveToolResponseBodyLanguage);

/** @internal */
export const RetrieveToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() =>
    RetrieveToolResponseBodyToolsParameters$inboundSchema
  ).optional(),
  language: RetrieveToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});

export function retrieveToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyCodeExecutionTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyCodeExecutionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KFZQC10DMDJTZ2CXY4NPFDHZ"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    RetrieveToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type: z.literal("code"),
  code_tool: z.lazy(() => RetrieveToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});

export function retrieveToolResponseBodyCodeExecutionToolFromJSON(
  jsonString: string,
): SafeParseResult<
  RetrieveToolResponseBodyCodeExecutionTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyCodeExecutionTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'RetrieveToolResponseBodyCodeExecutionTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(RetrieveToolResponseBodyToolsResponse200Status);

/** @internal */
export const RetrieveToolResponseBodyHeaders$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function retrieveToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(
    RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type,
  );

/** @internal */
export const RetrieveToolResponseBodyToolsSchema$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RetrieveToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function retrieveToolResponseBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyTools$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KFZQC10CGM827XV2XX27KB8A"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => RetrieveToolResponseBodyToolsSchema$inboundSchema),
});

export function retrieveToolResponseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveToolResponseBodyConnectionType> = z.nativeEnum(
    RetrieveToolResponseBodyConnectionType,
  );

/** @internal */
export const RetrieveToolResponseBodyMcp$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(z.lazy(() => RetrieveToolResponseBodyHeaders$inboundSchema))
    .optional(),
  tools: z.array(z.lazy(() => RetrieveToolResponseBodyTools$inboundSchema)),
  connection_type: RetrieveToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});

export function retrieveToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyMCPTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyMCPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KFZQC10A3KWP49E05EGNE6MF"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: RetrieveToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("mcp"),
  mcp: z.lazy(() => RetrieveToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function retrieveToolResponseBodyMCPToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyMCPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyMCPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyMCPTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof RetrieveToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(RetrieveToolResponseBodyToolsResponseStatus);

/** @internal */
export const RetrieveToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveToolResponseBodyMethod
> = z.nativeEnum(RetrieveToolResponseBodyMethod);

/** @internal */
export const RetrieveToolHeaders2$inboundSchema: z.ZodType<
  RetrieveToolHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function retrieveToolHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolHeaders2' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsHeaders$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => RetrieveToolHeaders2$inboundSchema), z.string()]);

export function retrieveToolResponseBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: RetrieveToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => RetrieveToolHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function retrieveToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(
    RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type,
  );

/** @internal */
export const RetrieveToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

export function retrieveToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyArguments$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    RetrieveToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

export function retrieveToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyHttp$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => RetrieveToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => RetrieveToolResponseBodyArguments$inboundSchema),
  ).optional(),
});

export function retrieveToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyHTTPTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyHTTPTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KFZQC1073P0XTVMG3TP1AYAB"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: RetrieveToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: z.literal("http"),
  http: z.lazy(() => RetrieveToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function retrieveToolResponseBodyHTTPToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyHTTPTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyHTTPTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyHTTPTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveToolResponseBodyToolsStatus
> = z.nativeEnum(RetrieveToolResponseBodyToolsStatus);

/** @internal */
export const RetrieveToolResponseBodySchema$inboundSchema: z.ZodType<
  RetrieveToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function retrieveToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => RetrieveToolResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});

export function retrieveToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyJSONSchemaTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyJSONSchemaTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KFZQC104M1B52AAGKHXD41TH"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: RetrieveToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("json_schema"),
  json_schema: z.lazy(() => RetrieveToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

export function retrieveToolResponseBodyJSONSchemaToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyJSONSchemaTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyJSONSchemaTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyJSONSchemaTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof RetrieveToolResponseBodyStatus
> = z.nativeEnum(RetrieveToolResponseBodyStatus);

/** @internal */
export const RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(
    RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type,
  );

/** @internal */
export const RetrieveToolResponseBodyParameters$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      RetrieveToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);

export function retrieveToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyFunction$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => RetrieveToolResponseBodyParameters$inboundSchema)
    .optional(),
});

export function retrieveToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBodyFunctionTool$inboundSchema: z.ZodType<
  RetrieveToolResponseBodyFunctionTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KFZQC102AASWG153MFGKT41H"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: RetrieveToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: z.literal("function"),
  function: z.lazy(() => RetrieveToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

export function retrieveToolResponseBodyFunctionToolFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBodyFunctionTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveToolResponseBodyFunctionTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBodyFunctionTool' from JSON`,
  );
}

/** @internal */
export const RetrieveToolResponseBody$inboundSchema: z.ZodType<
  RetrieveToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => RetrieveToolResponseBodyFunctionTool$inboundSchema),
  z.lazy(() => RetrieveToolResponseBodyJSONSchemaTool$inboundSchema),
  z.lazy(() => RetrieveToolResponseBodyHTTPTool$inboundSchema),
  z.lazy(() => RetrieveToolResponseBodyMCPTool$inboundSchema),
  z.lazy(() => RetrieveToolResponseBodyCodeExecutionTool$inboundSchema),
]);

export function retrieveToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveToolResponseBody' from JSON`,
  );
}
