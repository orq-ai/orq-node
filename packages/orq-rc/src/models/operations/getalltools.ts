/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllToolsRequest = {
  /**
   * Maximum number of tools per page (1-200). Omit to return all tools.
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllToolsObject = {
  List: "list",
} as const;
export type GetAllToolsObject = ClosedEnum<typeof GetAllToolsObject>;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponse200Status = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Status
>;

export const GetAllToolsDataToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONType = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200ApplicationJSONType
>;

export const DataLanguage = {
  Python: "python",
} as const;
export type DataLanguage = ClosedEnum<typeof DataLanguage>;

export type DataCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
  language: DataLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type Data5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponse200ApplicationJSONType;
  codeTool: DataCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsResponseStatus = ClosedEnum<
  typeof GetAllToolsDataToolsResponseStatus
>;

export const GetAllToolsDataToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type GetAllToolsDataToolsResponse200Type = ClosedEnum<
  typeof GetAllToolsDataToolsResponse200Type
>;

export type DataHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType = {
  Object: "object",
} as const;
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  >;

/**
 * The original MCP tool input schema for LLM conversion
 */
export type DataInputSchema = {
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/**
 * The connection type used by the MCP server
 */
export const DataConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DataConnectionType = ClosedEnum<typeof DataConnectionType>;

export type DataMcp = {
  /**
   * The ID of the MCP server this tool belongs to
   */
  serverId: string;
  /**
   * The original tool name from the MCP server
   */
  toolName: string;
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests (encrypted format)
   */
  headers?: { [k: string]: DataHeaders } | undefined;
  /**
   * The original MCP tool input schema for LLM conversion
   */
  inputSchema: DataInputSchema;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DataConnectionType;
};

export type Data4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponse200Type;
  mcp: DataMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsStatus = ClosedEnum<
  typeof GetAllToolsDataToolsStatus
>;

export const GetAllToolsDataToolsResponseType = {
  Http: "http",
} as const;
export type GetAllToolsDataToolsResponseType = ClosedEnum<
  typeof GetAllToolsDataToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const GetAllToolsDataMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type GetAllToolsDataMethod = ClosedEnum<typeof GetAllToolsDataMethod>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DataBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: GetAllToolsDataMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type =
  ClosedEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  >;

/**
 * The default value of the argument.
 */
export type DataDefaultValue = string | number | boolean;

export type DataArguments = {
  /**
   * The type of the argument.
   */
  type: GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type GetAllToolsDataHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DataBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DataArguments } | undefined;
};

export type Data3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataToolsStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsResponseType;
  http: GetAllToolsDataHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataStatus = ClosedEnum<typeof GetAllToolsDataStatus>;

export const GetAllToolsDataToolsType = {
  JsonSchema: "json_schema",
} as const;
export type GetAllToolsDataToolsType = ClosedEnum<
  typeof GetAllToolsDataToolsType
>;

export type DataJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type GetAllToolsData2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: GetAllToolsDataStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataToolsType;
  jsonSchema: DataJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DataStatus = ClosedEnum<typeof DataStatus>;

export const GetAllToolsDataType = {
  Function: "function",
} as const;
export type GetAllToolsDataType = ClosedEnum<typeof GetAllToolsDataType>;

export type GetAllToolsDataFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type GetAllToolsData1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DataStatus | undefined;
  versionHash?: string | undefined;
  type: GetAllToolsDataType;
  function: GetAllToolsDataFunction;
};

export type GetAllToolsData =
  | GetAllToolsData1
  | GetAllToolsData2
  | Data3
  | Data4
  | Data5;

/**
 * Successfully retrieved the list of tools.
 */
export type GetAllToolsResponseBody = {
  object: GetAllToolsObject;
  data: Array<GetAllToolsData1 | GetAllToolsData2 | Data3 | Data4 | Data5>;
  hasMore: boolean;
};

/** @internal */
export const GetAllToolsRequest$inboundSchema: z.ZodType<
  GetAllToolsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().optional(),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});

/** @internal */
export type GetAllToolsRequest$Outbound = {
  limit?: number | undefined;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllToolsRequest$outboundSchema: z.ZodType<
  GetAllToolsRequest$Outbound,
  z.ZodTypeDef,
  GetAllToolsRequest
> = z.object({
  limit: z.number().optional(),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsRequest$ {
  /** @deprecated use `GetAllToolsRequest$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsRequest$inboundSchema;
  /** @deprecated use `GetAllToolsRequest$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsRequest$outboundSchema;
  /** @deprecated use `GetAllToolsRequest$Outbound` instead. */
  export type Outbound = GetAllToolsRequest$Outbound;
}

export function getAllToolsRequestToJSON(
  getAllToolsRequest: GetAllToolsRequest,
): string {
  return JSON.stringify(
    GetAllToolsRequest$outboundSchema.parse(getAllToolsRequest),
  );
}

export function getAllToolsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsRequest' from JSON`,
  );
}

/** @internal */
export const GetAllToolsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = z.nativeEnum(GetAllToolsObject);

/** @internal */
export const GetAllToolsObject$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = GetAllToolsObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsObject$ {
  /** @deprecated use `GetAllToolsObject$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsObject$inboundSchema;
  /** @deprecated use `GetAllToolsObject$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsObject$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> = z.nativeEnum(
    GetAllToolsDataToolsResponse200Status,
  );

/** @internal */
export const GetAllToolsDataToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Status> =
    GetAllToolsDataToolsResponse200Status$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponse200Status$ {
  /** @deprecated use `GetAllToolsDataToolsResponse200Status$inboundSchema` instead. */
  export const inboundSchema =
    GetAllToolsDataToolsResponse200Status$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponse200Status$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponse200Status$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200ApplicationJSONType> = z
    .nativeEnum(GetAllToolsDataToolsResponse200ApplicationJSONType);

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200ApplicationJSONType> =
    GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponse200ApplicationJSONType$ {
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema` instead. */
  export const inboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema;
}

/** @internal */
export const DataLanguage$inboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  z.nativeEnum(DataLanguage);

/** @internal */
export const DataLanguage$outboundSchema: z.ZodNativeEnum<typeof DataLanguage> =
  DataLanguage$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataLanguage$ {
  /** @deprecated use `DataLanguage$inboundSchema` instead. */
  export const inboundSchema = DataLanguage$inboundSchema;
  /** @deprecated use `DataLanguage$outboundSchema` instead. */
  export const outboundSchema = DataLanguage$outboundSchema;
}

/** @internal */
export const DataCodeTool$inboundSchema: z.ZodType<
  DataCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DataLanguage$inboundSchema,
  code: z.string(),
});

/** @internal */
export type DataCodeTool$Outbound = {
  parameters?: { [k: string]: any } | undefined;
  language: string;
  code: string;
};

/** @internal */
export const DataCodeTool$outboundSchema: z.ZodType<
  DataCodeTool$Outbound,
  z.ZodTypeDef,
  DataCodeTool
> = z.object({
  parameters: z.record(z.any()).optional(),
  language: DataLanguage$outboundSchema,
  code: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataCodeTool$ {
  /** @deprecated use `DataCodeTool$inboundSchema` instead. */
  export const inboundSchema = DataCodeTool$inboundSchema;
  /** @deprecated use `DataCodeTool$outboundSchema` instead. */
  export const outboundSchema = DataCodeTool$outboundSchema;
  /** @deprecated use `DataCodeTool$Outbound` instead. */
  export type Outbound = DataCodeTool$Outbound;
}

export function dataCodeToolToJSON(dataCodeTool: DataCodeTool): string {
  return JSON.stringify(DataCodeTool$outboundSchema.parse(dataCodeTool));
}

export function dataCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DataCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataCodeTool' from JSON`,
  );
}

/** @internal */
export const Data5$inboundSchema: z.ZodType<Data5, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01K85KQZ1QXN23KZPCT8VHEGRC"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsResponse200Status$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponse200ApplicationJSONType$inboundSchema,
    code_tool: z.lazy(() => DataCodeTool$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
      "code_tool": "codeTool",
    });
  });

/** @internal */
export type Data5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: DataCodeTool$Outbound;
};

/** @internal */
export const Data5$outboundSchema: z.ZodType<
  Data5$Outbound,
  z.ZodTypeDef,
  Data5
> = z.object({
  id: z.string().default("01K85KQZ1QXN23KZPCT8VHEGRC"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponse200Status$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => DataCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data5$ {
  /** @deprecated use `Data5$inboundSchema` instead. */
  export const inboundSchema = Data5$inboundSchema;
  /** @deprecated use `Data5$outboundSchema` instead. */
  export const outboundSchema = Data5$outboundSchema;
  /** @deprecated use `Data5$Outbound` instead. */
  export type Outbound = Data5$Outbound;
}

export function data5ToJSON(data5: Data5): string {
  return JSON.stringify(Data5$outboundSchema.parse(data5));
}

export function data5FromJSON(
  jsonString: string,
): SafeParseResult<Data5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data5' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponseStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = z.nativeEnum(GetAllToolsDataToolsResponseStatus);

/** @internal */
export const GetAllToolsDataToolsResponseStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseStatus
> = GetAllToolsDataToolsResponseStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponseStatus$ {
  /** @deprecated use `GetAllToolsDataToolsResponseStatus$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsResponseStatus$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponseStatus$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponseStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsResponse200Type$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponse200Type
> = z.nativeEnum(GetAllToolsDataToolsResponse200Type);

/** @internal */
export const GetAllToolsDataToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof GetAllToolsDataToolsResponse200Type> =
    GetAllToolsDataToolsResponse200Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponse200Type$ {
  /** @deprecated use `GetAllToolsDataToolsResponse200Type$inboundSchema` instead. */
  export const inboundSchema =
    GetAllToolsDataToolsResponse200Type$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponse200Type$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponse200Type$outboundSchema;
}

/** @internal */
export const DataHeaders$inboundSchema: z.ZodType<
  DataHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/** @internal */
export type DataHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DataHeaders$outboundSchema: z.ZodType<
  DataHeaders$Outbound,
  z.ZodTypeDef,
  DataHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataHeaders$ {
  /** @deprecated use `DataHeaders$inboundSchema` instead. */
  export const inboundSchema = DataHeaders$inboundSchema;
  /** @deprecated use `DataHeaders$outboundSchema` instead. */
  export const outboundSchema = DataHeaders$outboundSchema;
  /** @deprecated use `DataHeaders$Outbound` instead. */
  export type Outbound = DataHeaders$Outbound;
}

export function dataHeadersToJSON(dataHeaders: DataHeaders): string {
  return JSON.stringify(DataHeaders$outboundSchema.parse(dataHeaders));
}

export function dataHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DataHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHeaders' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$ {
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema` instead. */
  export const inboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema;
}

/** @internal */
export const DataInputSchema$inboundSchema: z.ZodType<
  DataInputSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/** @internal */
export type DataInputSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const DataInputSchema$outboundSchema: z.ZodType<
  DataInputSchema$Outbound,
  z.ZodTypeDef,
  DataInputSchema
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBodyType$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataInputSchema$ {
  /** @deprecated use `DataInputSchema$inboundSchema` instead. */
  export const inboundSchema = DataInputSchema$inboundSchema;
  /** @deprecated use `DataInputSchema$outboundSchema` instead. */
  export const outboundSchema = DataInputSchema$outboundSchema;
  /** @deprecated use `DataInputSchema$Outbound` instead. */
  export type Outbound = DataInputSchema$Outbound;
}

export function dataInputSchemaToJSON(
  dataInputSchema: DataInputSchema,
): string {
  return JSON.stringify(DataInputSchema$outboundSchema.parse(dataInputSchema));
}

export function dataInputSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataInputSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataInputSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataInputSchema' from JSON`,
  );
}

/** @internal */
export const DataConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = z.nativeEnum(DataConnectionType);

/** @internal */
export const DataConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof DataConnectionType
> = DataConnectionType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataConnectionType$ {
  /** @deprecated use `DataConnectionType$inboundSchema` instead. */
  export const inboundSchema = DataConnectionType$inboundSchema;
  /** @deprecated use `DataConnectionType$outboundSchema` instead. */
  export const outboundSchema = DataConnectionType$outboundSchema;
}

/** @internal */
export const DataMcp$inboundSchema: z.ZodType<DataMcp, z.ZodTypeDef, unknown> =
  z.object({
    server_id: z.string(),
    tool_name: z.string(),
    server_url: z.string(),
    headers: z.record(z.lazy(() => DataHeaders$inboundSchema)).optional(),
    input_schema: z.lazy(() => DataInputSchema$inboundSchema),
    connection_type: DataConnectionType$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "server_id": "serverId",
      "tool_name": "toolName",
      "server_url": "serverUrl",
      "input_schema": "inputSchema",
      "connection_type": "connectionType",
    });
  });

/** @internal */
export type DataMcp$Outbound = {
  server_id: string;
  tool_name: string;
  server_url: string;
  headers?: { [k: string]: DataHeaders$Outbound } | undefined;
  input_schema: DataInputSchema$Outbound;
  connection_type: string;
};

/** @internal */
export const DataMcp$outboundSchema: z.ZodType<
  DataMcp$Outbound,
  z.ZodTypeDef,
  DataMcp
> = z.object({
  serverId: z.string(),
  toolName: z.string(),
  serverUrl: z.string(),
  headers: z.record(z.lazy(() => DataHeaders$outboundSchema)).optional(),
  inputSchema: z.lazy(() => DataInputSchema$outboundSchema),
  connectionType: DataConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverId: "server_id",
    toolName: "tool_name",
    serverUrl: "server_url",
    inputSchema: "input_schema",
    connectionType: "connection_type",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataMcp$ {
  /** @deprecated use `DataMcp$inboundSchema` instead. */
  export const inboundSchema = DataMcp$inboundSchema;
  /** @deprecated use `DataMcp$outboundSchema` instead. */
  export const outboundSchema = DataMcp$outboundSchema;
  /** @deprecated use `DataMcp$Outbound` instead. */
  export type Outbound = DataMcp$Outbound;
}

export function dataMcpToJSON(dataMcp: DataMcp): string {
  return JSON.stringify(DataMcp$outboundSchema.parse(dataMcp));
}

export function dataMcpFromJSON(
  jsonString: string,
): SafeParseResult<DataMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataMcp' from JSON`,
  );
}

/** @internal */
export const Data4$inboundSchema: z.ZodType<Data4, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01K85KQZ1QAFDSSN58TR3XKHVC"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsResponseStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponse200Type$inboundSchema,
    mcp: z.lazy(() => DataMcp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });

/** @internal */
export type Data4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: DataMcp$Outbound;
};

/** @internal */
export const Data4$outboundSchema: z.ZodType<
  Data4$Outbound,
  z.ZodTypeDef,
  Data4
> = z.object({
  id: z.string().default("01K85KQZ1QAFDSSN58TR3XKHVC"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsResponseStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => DataMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data4$ {
  /** @deprecated use `Data4$inboundSchema` instead. */
  export const inboundSchema = Data4$inboundSchema;
  /** @deprecated use `Data4$outboundSchema` instead. */
  export const outboundSchema = Data4$outboundSchema;
  /** @deprecated use `Data4$Outbound` instead. */
  export type Outbound = Data4$Outbound;
}

export function data4ToJSON(data4: Data4): string {
  return JSON.stringify(Data4$outboundSchema.parse(data4));
}

export function data4FromJSON(
  jsonString: string,
): SafeParseResult<Data4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data4' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = z.nativeEnum(GetAllToolsDataToolsStatus);

/** @internal */
export const GetAllToolsDataToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = GetAllToolsDataToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsStatus$ {
  /** @deprecated use `GetAllToolsDataToolsStatus$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsStatus$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsStatus$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = z.nativeEnum(GetAllToolsDataToolsResponseType);

/** @internal */
export const GetAllToolsDataToolsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = GetAllToolsDataToolsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponseType$ {
  /** @deprecated use `GetAllToolsDataToolsResponseType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsResponseType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponseType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsResponseType$outboundSchema;
}

/** @internal */
export const GetAllToolsDataMethod$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = z.nativeEnum(GetAllToolsDataMethod);

/** @internal */
export const GetAllToolsDataMethod$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataMethod
> = GetAllToolsDataMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataMethod$ {
  /** @deprecated use `GetAllToolsDataMethod$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataMethod$inboundSchema;
  /** @deprecated use `GetAllToolsDataMethod$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataMethod$outboundSchema;
}

/** @internal */
export const DataBlueprint$inboundSchema: z.ZodType<
  DataBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type DataBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataBlueprint$outboundSchema: z.ZodType<
  DataBlueprint$Outbound,
  z.ZodTypeDef,
  DataBlueprint
> = z.object({
  url: z.string(),
  method: GetAllToolsDataMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataBlueprint$ {
  /** @deprecated use `DataBlueprint$inboundSchema` instead. */
  export const inboundSchema = DataBlueprint$inboundSchema;
  /** @deprecated use `DataBlueprint$outboundSchema` instead. */
  export const outboundSchema = DataBlueprint$outboundSchema;
  /** @deprecated use `DataBlueprint$Outbound` instead. */
  export type Outbound = DataBlueprint$Outbound;
}

export function dataBlueprintToJSON(dataBlueprint: DataBlueprint): string {
  return JSON.stringify(DataBlueprint$outboundSchema.parse(dataBlueprint));
}

export function dataBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DataBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataBlueprint' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > = z.nativeEnum(
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type,
  );

/** @internal */
export const GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type
  > =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$ {
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema` instead. */
  export const inboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema` instead. */
  export const outboundSchema =
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema;
}

/** @internal */
export const DataDefaultValue$inboundSchema: z.ZodType<
  DataDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DataDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DataDefaultValue$outboundSchema: z.ZodType<
  DataDefaultValue$Outbound,
  z.ZodTypeDef,
  DataDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataDefaultValue$ {
  /** @deprecated use `DataDefaultValue$inboundSchema` instead. */
  export const inboundSchema = DataDefaultValue$inboundSchema;
  /** @deprecated use `DataDefaultValue$outboundSchema` instead. */
  export const outboundSchema = DataDefaultValue$outboundSchema;
  /** @deprecated use `DataDefaultValue$Outbound` instead. */
  export type Outbound = DataDefaultValue$Outbound;
}

export function dataDefaultValueToJSON(
  dataDefaultValue: DataDefaultValue,
): string {
  return JSON.stringify(
    DataDefaultValue$outboundSchema.parse(dataDefaultValue),
  );
}

export function dataDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DataDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataDefaultValue' from JSON`,
  );
}

/** @internal */
export const DataArguments$inboundSchema: z.ZodType<
  DataArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type DataArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DataArguments$outboundSchema: z.ZodType<
  DataArguments$Outbound,
  z.ZodTypeDef,
  DataArguments
> = z.object({
  type:
    GetAllToolsDataToolsResponse200ApplicationJSONResponseBody3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataArguments$ {
  /** @deprecated use `DataArguments$inboundSchema` instead. */
  export const inboundSchema = DataArguments$inboundSchema;
  /** @deprecated use `DataArguments$outboundSchema` instead. */
  export const outboundSchema = DataArguments$outboundSchema;
  /** @deprecated use `DataArguments$Outbound` instead. */
  export type Outbound = DataArguments$Outbound;
}

export function dataArgumentsToJSON(dataArguments: DataArguments): string {
  return JSON.stringify(DataArguments$outboundSchema.parse(dataArguments));
}

export function dataArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DataArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataArguments' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataHttp$inboundSchema: z.ZodType<
  GetAllToolsDataHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$inboundSchema)).optional(),
});

/** @internal */
export type GetAllToolsDataHttp$Outbound = {
  blueprint: DataBlueprint$Outbound;
  arguments?: { [k: string]: DataArguments$Outbound } | undefined;
};

/** @internal */
export const GetAllToolsDataHttp$outboundSchema: z.ZodType<
  GetAllToolsDataHttp$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataHttp
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataHttp$ {
  /** @deprecated use `GetAllToolsDataHttp$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataHttp$inboundSchema;
  /** @deprecated use `GetAllToolsDataHttp$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataHttp$outboundSchema;
  /** @deprecated use `GetAllToolsDataHttp$Outbound` instead. */
  export type Outbound = GetAllToolsDataHttp$Outbound;
}

export function getAllToolsDataHttpToJSON(
  getAllToolsDataHttp: GetAllToolsDataHttp,
): string {
  return JSON.stringify(
    GetAllToolsDataHttp$outboundSchema.parse(getAllToolsDataHttp),
  );
}

export function getAllToolsDataHttpFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataHttp' from JSON`,
  );
}

/** @internal */
export const Data3$inboundSchema: z.ZodType<Data3, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("01K85KQZ1P1HDZ162Q2AZC9SAB"),
    path: z.string(),
    key: z.string(),
    display_name: z.string().optional(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: GetAllToolsDataToolsResponseType$inboundSchema,
    http: z.lazy(() => GetAllToolsDataHttp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });

/** @internal */
export type Data3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: GetAllToolsDataHttp$Outbound;
};

/** @internal */
export const Data3$outboundSchema: z.ZodType<
  Data3$Outbound,
  z.ZodTypeDef,
  Data3
> = z.object({
  id: z.string().default("01K85KQZ1P1HDZ162Q2AZC9SAB"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsResponseType$outboundSchema,
  http: z.lazy(() => GetAllToolsDataHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data3$ {
  /** @deprecated use `Data3$inboundSchema` instead. */
  export const inboundSchema = Data3$inboundSchema;
  /** @deprecated use `Data3$outboundSchema` instead. */
  export const outboundSchema = Data3$outboundSchema;
  /** @deprecated use `Data3$Outbound` instead. */
  export type Outbound = Data3$Outbound;
}

export function data3ToJSON(data3: Data3): string {
  return JSON.stringify(Data3$outboundSchema.parse(data3));
}

export function data3FromJSON(
  jsonString: string,
): SafeParseResult<Data3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data3' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = z.nativeEnum(GetAllToolsDataStatus);

/** @internal */
export const GetAllToolsDataStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = GetAllToolsDataStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataStatus$ {
  /** @deprecated use `GetAllToolsDataStatus$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataStatus$inboundSchema;
  /** @deprecated use `GetAllToolsDataStatus$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = z.nativeEnum(GetAllToolsDataToolsType);

/** @internal */
export const GetAllToolsDataToolsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = GetAllToolsDataToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsType$ {
  /** @deprecated use `GetAllToolsDataToolsType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsType$outboundSchema;
}

/** @internal */
export const DataJsonSchema$inboundSchema: z.ZodType<
  DataJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type DataJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const DataJsonSchema$outboundSchema: z.ZodType<
  DataJsonSchema$Outbound,
  z.ZodTypeDef,
  DataJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataJsonSchema$ {
  /** @deprecated use `DataJsonSchema$inboundSchema` instead. */
  export const inboundSchema = DataJsonSchema$inboundSchema;
  /** @deprecated use `DataJsonSchema$outboundSchema` instead. */
  export const outboundSchema = DataJsonSchema$outboundSchema;
  /** @deprecated use `DataJsonSchema$Outbound` instead. */
  export type Outbound = DataJsonSchema$Outbound;
}

export function dataJsonSchemaToJSON(dataJsonSchema: DataJsonSchema): string {
  return JSON.stringify(DataJsonSchema$outboundSchema.parse(dataJsonSchema));
}

export function dataJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData2$inboundSchema: z.ZodType<
  GetAllToolsData2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K85KQZ1PWDBMZHHMZ8C9HW0Y"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: GetAllToolsDataToolsType$inboundSchema,
  json_schema: z.lazy(() => DataJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});

/** @internal */
export type GetAllToolsData2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: DataJsonSchema$Outbound;
};

/** @internal */
export const GetAllToolsData2$outboundSchema: z.ZodType<
  GetAllToolsData2$Outbound,
  z.ZodTypeDef,
  GetAllToolsData2
> = z.object({
  id: z.string().default("01K85KQZ1PWDBMZHHMZ8C9HW0Y"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataToolsType$outboundSchema,
  jsonSchema: z.lazy(() => DataJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsData2$ {
  /** @deprecated use `GetAllToolsData2$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsData2$inboundSchema;
  /** @deprecated use `GetAllToolsData2$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsData2$outboundSchema;
  /** @deprecated use `GetAllToolsData2$Outbound` instead. */
  export type Outbound = GetAllToolsData2$Outbound;
}

export function getAllToolsData2ToJSON(
  getAllToolsData2: GetAllToolsData2,
): string {
  return JSON.stringify(
    GetAllToolsData2$outboundSchema.parse(getAllToolsData2),
  );
}

export function getAllToolsData2FromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData2' from JSON`,
  );
}

/** @internal */
export const DataStatus$inboundSchema: z.ZodNativeEnum<typeof DataStatus> = z
  .nativeEnum(DataStatus);

/** @internal */
export const DataStatus$outboundSchema: z.ZodNativeEnum<typeof DataStatus> =
  DataStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataStatus$ {
  /** @deprecated use `DataStatus$inboundSchema` instead. */
  export const inboundSchema = DataStatus$inboundSchema;
  /** @deprecated use `DataStatus$outboundSchema` instead. */
  export const outboundSchema = DataStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = z.nativeEnum(GetAllToolsDataType);

/** @internal */
export const GetAllToolsDataType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = GetAllToolsDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataType$ {
  /** @deprecated use `GetAllToolsDataType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataType$inboundSchema;
  /** @deprecated use `GetAllToolsDataType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataType$outboundSchema;
}

/** @internal */
export const GetAllToolsDataFunction$inboundSchema: z.ZodType<
  GetAllToolsDataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type GetAllToolsDataFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const GetAllToolsDataFunction$outboundSchema: z.ZodType<
  GetAllToolsDataFunction$Outbound,
  z.ZodTypeDef,
  GetAllToolsDataFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataFunction$ {
  /** @deprecated use `GetAllToolsDataFunction$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataFunction$inboundSchema;
  /** @deprecated use `GetAllToolsDataFunction$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataFunction$outboundSchema;
  /** @deprecated use `GetAllToolsDataFunction$Outbound` instead. */
  export type Outbound = GetAllToolsDataFunction$Outbound;
}

export function getAllToolsDataFunctionToJSON(
  getAllToolsDataFunction: GetAllToolsDataFunction,
): string {
  return JSON.stringify(
    GetAllToolsDataFunction$outboundSchema.parse(getAllToolsDataFunction),
  );
}

export function getAllToolsDataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsDataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsDataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsDataFunction' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData1$inboundSchema: z.ZodType<
  GetAllToolsData1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("01K85KQZ1NE3WG4XMQ5ACH896E"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: GetAllToolsDataType$inboundSchema,
  function: z.lazy(() => GetAllToolsDataFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});

/** @internal */
export type GetAllToolsData1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: GetAllToolsDataFunction$Outbound;
};

/** @internal */
export const GetAllToolsData1$outboundSchema: z.ZodType<
  GetAllToolsData1$Outbound,
  z.ZodTypeDef,
  GetAllToolsData1
> = z.object({
  id: z.string().default("01K85KQZ1NE3WG4XMQ5ACH896E"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: GetAllToolsDataType$outboundSchema,
  function: z.lazy(() => GetAllToolsDataFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsData1$ {
  /** @deprecated use `GetAllToolsData1$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsData1$inboundSchema;
  /** @deprecated use `GetAllToolsData1$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsData1$outboundSchema;
  /** @deprecated use `GetAllToolsData1$Outbound` instead. */
  export type Outbound = GetAllToolsData1$Outbound;
}

export function getAllToolsData1ToJSON(
  getAllToolsData1: GetAllToolsData1,
): string {
  return JSON.stringify(
    GetAllToolsData1$outboundSchema.parse(getAllToolsData1),
  );
}

export function getAllToolsData1FromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData1' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData$inboundSchema: z.ZodType<
  GetAllToolsData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAllToolsData1$inboundSchema),
  z.lazy(() => GetAllToolsData2$inboundSchema),
  z.lazy(() => Data3$inboundSchema),
  z.lazy(() => Data4$inboundSchema),
  z.lazy(() => Data5$inboundSchema),
]);

/** @internal */
export type GetAllToolsData$Outbound =
  | GetAllToolsData1$Outbound
  | GetAllToolsData2$Outbound
  | Data3$Outbound
  | Data4$Outbound
  | Data5$Outbound;

/** @internal */
export const GetAllToolsData$outboundSchema: z.ZodType<
  GetAllToolsData$Outbound,
  z.ZodTypeDef,
  GetAllToolsData
> = z.union([
  z.lazy(() => GetAllToolsData1$outboundSchema),
  z.lazy(() => GetAllToolsData2$outboundSchema),
  z.lazy(() => Data3$outboundSchema),
  z.lazy(() => Data4$outboundSchema),
  z.lazy(() => Data5$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsData$ {
  /** @deprecated use `GetAllToolsData$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsData$inboundSchema;
  /** @deprecated use `GetAllToolsData$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsData$outboundSchema;
  /** @deprecated use `GetAllToolsData$Outbound` instead. */
  export type Outbound = GetAllToolsData$Outbound;
}

export function getAllToolsDataToJSON(
  getAllToolsData: GetAllToolsData,
): string {
  return JSON.stringify(GetAllToolsData$outboundSchema.parse(getAllToolsData));
}

export function getAllToolsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData' from JSON`,
  );
}

/** @internal */
export const GetAllToolsResponseBody$inboundSchema: z.ZodType<
  GetAllToolsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllToolsObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => GetAllToolsData1$inboundSchema),
      z.lazy(() => GetAllToolsData2$inboundSchema),
      z.lazy(() => Data3$inboundSchema),
      z.lazy(() => Data4$inboundSchema),
      z.lazy(() => Data5$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

/** @internal */
export type GetAllToolsResponseBody$Outbound = {
  object: string;
  data: Array<
    | GetAllToolsData1$Outbound
    | GetAllToolsData2$Outbound
    | Data3$Outbound
    | Data4$Outbound
    | Data5$Outbound
  >;
  has_more: boolean;
};

/** @internal */
export const GetAllToolsResponseBody$outboundSchema: z.ZodType<
  GetAllToolsResponseBody$Outbound,
  z.ZodTypeDef,
  GetAllToolsResponseBody
> = z.object({
  object: GetAllToolsObject$outboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => GetAllToolsData1$outboundSchema),
      z.lazy(() => GetAllToolsData2$outboundSchema),
      z.lazy(() => Data3$outboundSchema),
      z.lazy(() => Data4$outboundSchema),
      z.lazy(() => Data5$outboundSchema),
    ]),
  ),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsResponseBody$ {
  /** @deprecated use `GetAllToolsResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsResponseBody$inboundSchema;
  /** @deprecated use `GetAllToolsResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsResponseBody$outboundSchema;
  /** @deprecated use `GetAllToolsResponseBody$Outbound` instead. */
  export type Outbound = GetAllToolsResponseBody$Outbound;
}

export function getAllToolsResponseBodyToJSON(
  getAllToolsResponseBody: GetAllToolsResponseBody,
): string {
  return JSON.stringify(
    GetAllToolsResponseBody$outboundSchema.parse(getAllToolsResponseBody),
  );
}

export function getAllToolsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsResponseBody' from JSON`,
  );
}
