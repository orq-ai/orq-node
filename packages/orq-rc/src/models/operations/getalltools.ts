/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllToolsRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const GetAllToolsObject = {
  List: "list",
} as const;
export type GetAllToolsObject = ClosedEnum<typeof GetAllToolsObject>;

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataStatus = ClosedEnum<typeof GetAllToolsDataStatus>;

export const GetAllToolsDataToolsType = {
  OrqHttp: "orq_http",
} as const;
export type GetAllToolsDataToolsType = ClosedEnum<
  typeof GetAllToolsDataToolsType
>;

/**
 * The HTTP method to use.
 */
export const DataMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type DataMethod = ClosedEnum<typeof DataMethod>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DataBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: DataMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const GetAllToolsDataToolsResponseType = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type GetAllToolsDataToolsResponseType = ClosedEnum<
  typeof GetAllToolsDataToolsResponseType
>;

/**
 * The default value of the argument.
 */
export type DataDefaultValue = string | number | boolean;

export type DataArguments = {
  /**
   * The type of the argument.
   */
  type: GetAllToolsDataToolsResponseType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type DataHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DataBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DataArguments } | undefined;
};

export type Data3 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataStatus;
  versionHash: string;
  type: GetAllToolsDataToolsType;
  http: DataHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DataStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DataStatus = ClosedEnum<typeof DataStatus>;

export const GetAllToolsDataType = {
  JsonSchema: "json_schema",
} as const;
export type GetAllToolsDataType = ClosedEnum<typeof GetAllToolsDataType>;

export type DataJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description?: string | undefined;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: { [k: string]: any };
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | null | undefined;
};

export type Data2 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: DataStatus;
  versionHash: string;
  type: GetAllToolsDataType;
  jsonSchema: DataJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAllToolsDataToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAllToolsDataToolsStatus = ClosedEnum<
  typeof GetAllToolsDataToolsStatus
>;

export const DataType = {
  Function: "function",
} as const;
export type DataType = ClosedEnum<typeof DataType>;

export type DataFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type Data1 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAllToolsDataToolsStatus;
  versionHash: string;
  type: DataType;
  function: DataFunction;
};

export type GetAllToolsData = Data1 | Data2 | Data3;

/**
 * Successfully retrieved the list of tools.
 */
export type GetAllToolsResponseBody = {
  object: GetAllToolsObject;
  data: Array<Data1 | Data2 | Data3>;
  hasMore: boolean;
};

/** @internal */
export const GetAllToolsRequest$inboundSchema: z.ZodType<
  GetAllToolsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().default(10),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});

/** @internal */
export type GetAllToolsRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const GetAllToolsRequest$outboundSchema: z.ZodType<
  GetAllToolsRequest$Outbound,
  z.ZodTypeDef,
  GetAllToolsRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsRequest$ {
  /** @deprecated use `GetAllToolsRequest$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsRequest$inboundSchema;
  /** @deprecated use `GetAllToolsRequest$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsRequest$outboundSchema;
  /** @deprecated use `GetAllToolsRequest$Outbound` instead. */
  export type Outbound = GetAllToolsRequest$Outbound;
}

export function getAllToolsRequestToJSON(
  getAllToolsRequest: GetAllToolsRequest,
): string {
  return JSON.stringify(
    GetAllToolsRequest$outboundSchema.parse(getAllToolsRequest),
  );
}

export function getAllToolsRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsRequest' from JSON`,
  );
}

/** @internal */
export const GetAllToolsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = z.nativeEnum(GetAllToolsObject);

/** @internal */
export const GetAllToolsObject$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsObject
> = GetAllToolsObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsObject$ {
  /** @deprecated use `GetAllToolsObject$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsObject$inboundSchema;
  /** @deprecated use `GetAllToolsObject$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsObject$outboundSchema;
}

/** @internal */
export const GetAllToolsDataStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = z.nativeEnum(GetAllToolsDataStatus);

/** @internal */
export const GetAllToolsDataStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataStatus
> = GetAllToolsDataStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataStatus$ {
  /** @deprecated use `GetAllToolsDataStatus$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataStatus$inboundSchema;
  /** @deprecated use `GetAllToolsDataStatus$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataToolsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = z.nativeEnum(GetAllToolsDataToolsType);

/** @internal */
export const GetAllToolsDataToolsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsType
> = GetAllToolsDataToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsType$ {
  /** @deprecated use `GetAllToolsDataToolsType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsType$outboundSchema;
}

/** @internal */
export const DataMethod$inboundSchema: z.ZodNativeEnum<typeof DataMethod> = z
  .nativeEnum(DataMethod);

/** @internal */
export const DataMethod$outboundSchema: z.ZodNativeEnum<typeof DataMethod> =
  DataMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataMethod$ {
  /** @deprecated use `DataMethod$inboundSchema` instead. */
  export const inboundSchema = DataMethod$inboundSchema;
  /** @deprecated use `DataMethod$outboundSchema` instead. */
  export const outboundSchema = DataMethod$outboundSchema;
}

/** @internal */
export const DataBlueprint$inboundSchema: z.ZodType<
  DataBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: DataMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type DataBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataBlueprint$outboundSchema: z.ZodType<
  DataBlueprint$Outbound,
  z.ZodTypeDef,
  DataBlueprint
> = z.object({
  url: z.string(),
  method: DataMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataBlueprint$ {
  /** @deprecated use `DataBlueprint$inboundSchema` instead. */
  export const inboundSchema = DataBlueprint$inboundSchema;
  /** @deprecated use `DataBlueprint$outboundSchema` instead. */
  export const outboundSchema = DataBlueprint$outboundSchema;
  /** @deprecated use `DataBlueprint$Outbound` instead. */
  export type Outbound = DataBlueprint$Outbound;
}

export function dataBlueprintToJSON(dataBlueprint: DataBlueprint): string {
  return JSON.stringify(DataBlueprint$outboundSchema.parse(dataBlueprint));
}

export function dataBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DataBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataBlueprint' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = z.nativeEnum(GetAllToolsDataToolsResponseType);

/** @internal */
export const GetAllToolsDataToolsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsResponseType
> = GetAllToolsDataToolsResponseType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsResponseType$ {
  /** @deprecated use `GetAllToolsDataToolsResponseType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsResponseType$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsResponseType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsResponseType$outboundSchema;
}

/** @internal */
export const DataDefaultValue$inboundSchema: z.ZodType<
  DataDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DataDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const DataDefaultValue$outboundSchema: z.ZodType<
  DataDefaultValue$Outbound,
  z.ZodTypeDef,
  DataDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataDefaultValue$ {
  /** @deprecated use `DataDefaultValue$inboundSchema` instead. */
  export const inboundSchema = DataDefaultValue$inboundSchema;
  /** @deprecated use `DataDefaultValue$outboundSchema` instead. */
  export const outboundSchema = DataDefaultValue$outboundSchema;
  /** @deprecated use `DataDefaultValue$Outbound` instead. */
  export type Outbound = DataDefaultValue$Outbound;
}

export function dataDefaultValueToJSON(
  dataDefaultValue: DataDefaultValue,
): string {
  return JSON.stringify(
    DataDefaultValue$outboundSchema.parse(dataDefaultValue),
  );
}

export function dataDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DataDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataDefaultValue' from JSON`,
  );
}

/** @internal */
export const DataArguments$inboundSchema: z.ZodType<
  DataArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAllToolsDataToolsResponseType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type DataArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DataArguments$outboundSchema: z.ZodType<
  DataArguments$Outbound,
  z.ZodTypeDef,
  DataArguments
> = z.object({
  type: GetAllToolsDataToolsResponseType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataArguments$ {
  /** @deprecated use `DataArguments$inboundSchema` instead. */
  export const inboundSchema = DataArguments$inboundSchema;
  /** @deprecated use `DataArguments$outboundSchema` instead. */
  export const outboundSchema = DataArguments$outboundSchema;
  /** @deprecated use `DataArguments$Outbound` instead. */
  export type Outbound = DataArguments$Outbound;
}

export function dataArgumentsToJSON(dataArguments: DataArguments): string {
  return JSON.stringify(DataArguments$outboundSchema.parse(dataArguments));
}

export function dataArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DataArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataArguments' from JSON`,
  );
}

/** @internal */
export const DataHttp$inboundSchema: z.ZodType<
  DataHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$inboundSchema)).optional(),
});

/** @internal */
export type DataHttp$Outbound = {
  blueprint: DataBlueprint$Outbound;
  arguments?: { [k: string]: DataArguments$Outbound } | undefined;
};

/** @internal */
export const DataHttp$outboundSchema: z.ZodType<
  DataHttp$Outbound,
  z.ZodTypeDef,
  DataHttp
> = z.object({
  blueprint: z.lazy(() => DataBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => DataArguments$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataHttp$ {
  /** @deprecated use `DataHttp$inboundSchema` instead. */
  export const inboundSchema = DataHttp$inboundSchema;
  /** @deprecated use `DataHttp$outboundSchema` instead. */
  export const outboundSchema = DataHttp$outboundSchema;
  /** @deprecated use `DataHttp$Outbound` instead. */
  export type Outbound = DataHttp$Outbound;
}

export function dataHttpToJSON(dataHttp: DataHttp): string {
  return JSON.stringify(DataHttp$outboundSchema.parse(dataHttp));
}

export function dataHttpFromJSON(
  jsonString: string,
): SafeParseResult<DataHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataHttp' from JSON`,
  );
}

/** @internal */
export const Data3$inboundSchema: z.ZodType<Data3, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("tool_01JRZZ49DWFPH000Y3126KCFKP"),
    path: z.string(),
    key: z.string(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataStatus$inboundSchema,
    version_hash: z.string(),
    type: GetAllToolsDataToolsType$inboundSchema,
    http: z.lazy(() => DataHttp$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });

/** @internal */
export type Data3$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  http: DataHttp$Outbound;
};

/** @internal */
export const Data3$outboundSchema: z.ZodType<
  Data3$Outbound,
  z.ZodTypeDef,
  Data3
> = z.object({
  id: z.string().default("tool_01JRZZ49DWFPH000Y3126KCFKP"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataStatus$outboundSchema,
  versionHash: z.string(),
  type: GetAllToolsDataToolsType$outboundSchema,
  http: z.lazy(() => DataHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data3$ {
  /** @deprecated use `Data3$inboundSchema` instead. */
  export const inboundSchema = Data3$inboundSchema;
  /** @deprecated use `Data3$outboundSchema` instead. */
  export const outboundSchema = Data3$outboundSchema;
  /** @deprecated use `Data3$Outbound` instead. */
  export type Outbound = Data3$Outbound;
}

export function data3ToJSON(data3: Data3): string {
  return JSON.stringify(Data3$outboundSchema.parse(data3));
}

export function data3FromJSON(
  jsonString: string,
): SafeParseResult<Data3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data3' from JSON`,
  );
}

/** @internal */
export const DataStatus$inboundSchema: z.ZodNativeEnum<typeof DataStatus> = z
  .nativeEnum(DataStatus);

/** @internal */
export const DataStatus$outboundSchema: z.ZodNativeEnum<typeof DataStatus> =
  DataStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataStatus$ {
  /** @deprecated use `DataStatus$inboundSchema` instead. */
  export const inboundSchema = DataStatus$inboundSchema;
  /** @deprecated use `DataStatus$outboundSchema` instead. */
  export const outboundSchema = DataStatus$outboundSchema;
}

/** @internal */
export const GetAllToolsDataType$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = z.nativeEnum(GetAllToolsDataType);

/** @internal */
export const GetAllToolsDataType$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataType
> = GetAllToolsDataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataType$ {
  /** @deprecated use `GetAllToolsDataType$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataType$inboundSchema;
  /** @deprecated use `GetAllToolsDataType$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataType$outboundSchema;
}

/** @internal */
export const DataJsonSchema$inboundSchema: z.ZodType<
  DataJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/** @internal */
export type DataJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  schema: { [k: string]: any };
  strict: boolean | null;
};

/** @internal */
export const DataJsonSchema$outboundSchema: z.ZodType<
  DataJsonSchema$Outbound,
  z.ZodTypeDef,
  DataJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.record(z.any()),
  strict: z.nullable(z.boolean().default(false)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataJsonSchema$ {
  /** @deprecated use `DataJsonSchema$inboundSchema` instead. */
  export const inboundSchema = DataJsonSchema$inboundSchema;
  /** @deprecated use `DataJsonSchema$outboundSchema` instead. */
  export const outboundSchema = DataJsonSchema$outboundSchema;
  /** @deprecated use `DataJsonSchema$Outbound` instead. */
  export type Outbound = DataJsonSchema$Outbound;
}

export function dataJsonSchemaToJSON(dataJsonSchema: DataJsonSchema): string {
  return JSON.stringify(DataJsonSchema$outboundSchema.parse(dataJsonSchema));
}

export function dataJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DataJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataJsonSchema' from JSON`,
  );
}

/** @internal */
export const Data2$inboundSchema: z.ZodType<Data2, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("tool_01JRZZ49DWBVV24JMC4QC2MZB8"),
    path: z.string(),
    key: z.string(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: DataStatus$inboundSchema,
    version_hash: z.string(),
    type: GetAllToolsDataType$inboundSchema,
    json_schema: z.lazy(() => DataJsonSchema$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
      "json_schema": "jsonSchema",
    });
  });

/** @internal */
export type Data2$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  json_schema: DataJsonSchema$Outbound;
};

/** @internal */
export const Data2$outboundSchema: z.ZodType<
  Data2$Outbound,
  z.ZodTypeDef,
  Data2
> = z.object({
  id: z.string().default("tool_01JRZZ49DWBVV24JMC4QC2MZB8"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DataStatus$outboundSchema,
  versionHash: z.string(),
  type: GetAllToolsDataType$outboundSchema,
  jsonSchema: z.lazy(() => DataJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data2$ {
  /** @deprecated use `Data2$inboundSchema` instead. */
  export const inboundSchema = Data2$inboundSchema;
  /** @deprecated use `Data2$outboundSchema` instead. */
  export const outboundSchema = Data2$outboundSchema;
  /** @deprecated use `Data2$Outbound` instead. */
  export type Outbound = Data2$Outbound;
}

export function data2ToJSON(data2: Data2): string {
  return JSON.stringify(Data2$outboundSchema.parse(data2));
}

export function data2FromJSON(
  jsonString: string,
): SafeParseResult<Data2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data2' from JSON`,
  );
}

/** @internal */
export const GetAllToolsDataToolsStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = z.nativeEnum(GetAllToolsDataToolsStatus);

/** @internal */
export const GetAllToolsDataToolsStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAllToolsDataToolsStatus
> = GetAllToolsDataToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsDataToolsStatus$ {
  /** @deprecated use `GetAllToolsDataToolsStatus$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsDataToolsStatus$inboundSchema;
  /** @deprecated use `GetAllToolsDataToolsStatus$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsDataToolsStatus$outboundSchema;
}

/** @internal */
export const DataType$inboundSchema: z.ZodNativeEnum<typeof DataType> = z
  .nativeEnum(DataType);

/** @internal */
export const DataType$outboundSchema: z.ZodNativeEnum<typeof DataType> =
  DataType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataType$ {
  /** @deprecated use `DataType$inboundSchema` instead. */
  export const inboundSchema = DataType$inboundSchema;
  /** @deprecated use `DataType$outboundSchema` instead. */
  export const outboundSchema = DataType$outboundSchema;
}

/** @internal */
export const DataFunction$inboundSchema: z.ZodType<
  DataFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/** @internal */
export type DataFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const DataFunction$outboundSchema: z.ZodType<
  DataFunction$Outbound,
  z.ZodTypeDef,
  DataFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DataFunction$ {
  /** @deprecated use `DataFunction$inboundSchema` instead. */
  export const inboundSchema = DataFunction$inboundSchema;
  /** @deprecated use `DataFunction$outboundSchema` instead. */
  export const outboundSchema = DataFunction$outboundSchema;
  /** @deprecated use `DataFunction$Outbound` instead. */
  export type Outbound = DataFunction$Outbound;
}

export function dataFunctionToJSON(dataFunction: DataFunction): string {
  return JSON.stringify(DataFunction$outboundSchema.parse(dataFunction));
}

export function dataFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DataFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DataFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DataFunction' from JSON`,
  );
}

/** @internal */
export const Data1$inboundSchema: z.ZodType<Data1, z.ZodTypeDef, unknown> = z
  .object({
    _id: z.string().default("tool_01JRZZ49DVDXMQ200A4NH25JKV"),
    path: z.string(),
    key: z.string(),
    description: z.string(),
    created_by_id: z.string().optional(),
    updated_by_id: z.string().optional(),
    project_id: z.string(),
    workspace_id: z.string(),
    created: z.string(),
    updated: z.string(),
    status: GetAllToolsDataToolsStatus$inboundSchema,
    version_hash: z.string(),
    type: DataType$inboundSchema,
    function: z.lazy(() => DataFunction$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "created_by_id": "createdById",
      "updated_by_id": "updatedById",
      "project_id": "projectId",
      "workspace_id": "workspaceId",
      "version_hash": "versionHash",
    });
  });

/** @internal */
export type Data1$Outbound = {
  _id: string;
  path: string;
  key: string;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash: string;
  type: string;
  function: DataFunction$Outbound;
};

/** @internal */
export const Data1$outboundSchema: z.ZodType<
  Data1$Outbound,
  z.ZodTypeDef,
  Data1
> = z.object({
  id: z.string().default("tool_01JRZZ49DVDXMQ200A4NH25JKV"),
  path: z.string(),
  key: z.string(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: GetAllToolsDataToolsStatus$outboundSchema,
  versionHash: z.string(),
  type: DataType$outboundSchema,
  function: z.lazy(() => DataFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Data1$ {
  /** @deprecated use `Data1$inboundSchema` instead. */
  export const inboundSchema = Data1$inboundSchema;
  /** @deprecated use `Data1$outboundSchema` instead. */
  export const outboundSchema = Data1$outboundSchema;
  /** @deprecated use `Data1$Outbound` instead. */
  export type Outbound = Data1$Outbound;
}

export function data1ToJSON(data1: Data1): string {
  return JSON.stringify(Data1$outboundSchema.parse(data1));
}

export function data1FromJSON(
  jsonString: string,
): SafeParseResult<Data1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Data1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Data1' from JSON`,
  );
}

/** @internal */
export const GetAllToolsData$inboundSchema: z.ZodType<
  GetAllToolsData,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Data1$inboundSchema),
  z.lazy(() => Data2$inboundSchema),
  z.lazy(() => Data3$inboundSchema),
]);

/** @internal */
export type GetAllToolsData$Outbound =
  | Data1$Outbound
  | Data2$Outbound
  | Data3$Outbound;

/** @internal */
export const GetAllToolsData$outboundSchema: z.ZodType<
  GetAllToolsData$Outbound,
  z.ZodTypeDef,
  GetAllToolsData
> = z.union([
  z.lazy(() => Data1$outboundSchema),
  z.lazy(() => Data2$outboundSchema),
  z.lazy(() => Data3$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsData$ {
  /** @deprecated use `GetAllToolsData$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsData$inboundSchema;
  /** @deprecated use `GetAllToolsData$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsData$outboundSchema;
  /** @deprecated use `GetAllToolsData$Outbound` instead. */
  export type Outbound = GetAllToolsData$Outbound;
}

export function getAllToolsDataToJSON(
  getAllToolsData: GetAllToolsData,
): string {
  return JSON.stringify(GetAllToolsData$outboundSchema.parse(getAllToolsData));
}

export function getAllToolsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsData' from JSON`,
  );
}

/** @internal */
export const GetAllToolsResponseBody$inboundSchema: z.ZodType<
  GetAllToolsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllToolsObject$inboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$inboundSchema),
      z.lazy(() => Data2$inboundSchema),
      z.lazy(() => Data3$inboundSchema),
    ]),
  ),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

/** @internal */
export type GetAllToolsResponseBody$Outbound = {
  object: string;
  data: Array<Data1$Outbound | Data2$Outbound | Data3$Outbound>;
  has_more: boolean;
};

/** @internal */
export const GetAllToolsResponseBody$outboundSchema: z.ZodType<
  GetAllToolsResponseBody$Outbound,
  z.ZodTypeDef,
  GetAllToolsResponseBody
> = z.object({
  object: GetAllToolsObject$outboundSchema,
  data: z.array(
    z.union([
      z.lazy(() => Data1$outboundSchema),
      z.lazy(() => Data2$outboundSchema),
      z.lazy(() => Data3$outboundSchema),
    ]),
  ),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace GetAllToolsResponseBody$ {
  /** @deprecated use `GetAllToolsResponseBody$inboundSchema` instead. */
  export const inboundSchema = GetAllToolsResponseBody$inboundSchema;
  /** @deprecated use `GetAllToolsResponseBody$outboundSchema` instead. */
  export const outboundSchema = GetAllToolsResponseBody$outboundSchema;
  /** @deprecated use `GetAllToolsResponseBody$Outbound` instead. */
  export type Outbound = GetAllToolsResponseBody$Outbound;
}

export function getAllToolsResponseBodyToJSON(
  getAllToolsResponseBody: GetAllToolsResponseBody,
): string {
  return JSON.stringify(
    GetAllToolsResponseBody$outboundSchema.parse(getAllToolsResponseBody),
  );
}

export function getAllToolsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllToolsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllToolsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllToolsResponseBody' from JSON`,
  );
}
