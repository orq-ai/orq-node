/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateConversationMetadata = {
  generatingTitle?: boolean | undefined;
  /**
   * Identifier of the parent entity (agent, deployment, etc.) this conversation belongs to.
   */
  entityId: string;
};

export type CreateConversationRequestBody = {
  /**
   * Display name for the conversation. Defaults to "Untitled" if not provided.
   */
  displayName?: string | undefined;
  metadata: CreateConversationMetadata;
};

/**
 * Type discriminator indicating this is a conversation
 */
export const CreateConversationKind = {
  Conversation: "conversation",
} as const;
/**
 * Type discriminator indicating this is a conversation
 */
export type CreateConversationKind = ClosedEnum<typeof CreateConversationKind>;

/**
 * Optional metadata associated with the conversation.
 */
export type CreateConversationConversationsMetadata = {
  /**
   * Indicates whether the conversation title is currently being generated by AI.
   */
  generatingTitle?: boolean | undefined;
  /**
   * Identifier of the parent entity (agent, deployment, etc.) this conversation belongs to. Used for filtering conversations by entity.
   */
  entityId?: string | undefined;
};

/**
 * Conversation successfully created. Returns the complete conversation object including the generated ID and timestamps.
 */
export type CreateConversationResponseBody = {
  /**
   * Unique ULID (Universally Unique Lexicographically Sortable Identifier) for the conversation, prefixed with "conv_"
   */
  id?: string | undefined;
  /**
   * Identifier of the parent entity (agent, deployment, etc.) this conversation belongs to.
   */
  entityId: string;
  /**
   * Type discriminator indicating this is a conversation
   */
  kind: CreateConversationKind;
  /**
   * Display name for the conversation. Can be auto-generated or set by the user.
   */
  displayName: string;
  /**
   * Unix timestamp (in milliseconds) when the conversation was created
   */
  createdAt: number;
  /**
   * Unix timestamp (in milliseconds) when the conversation was last updated
   */
  updatedAt: number;
  /**
   * Optional identifier of the user or agent that created the conversation
   */
  createdById?: string | undefined;
  /**
   * Optional identifier of the user or agent that last updated the conversation
   */
  updatedById?: string | undefined;
  /**
   * Optional metadata associated with the conversation.
   */
  metadata?: CreateConversationConversationsMetadata | undefined;
};

/** @internal */
export const CreateConversationMetadata$inboundSchema: z.ZodType<
  CreateConversationMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  generating_title: z.boolean().optional(),
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "generating_title": "generatingTitle",
    "entity_id": "entityId",
  });
});
/** @internal */
export type CreateConversationMetadata$Outbound = {
  generating_title?: boolean | undefined;
  entity_id: string;
};

/** @internal */
export const CreateConversationMetadata$outboundSchema: z.ZodType<
  CreateConversationMetadata$Outbound,
  z.ZodTypeDef,
  CreateConversationMetadata
> = z.object({
  generatingTitle: z.boolean().optional(),
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    generatingTitle: "generating_title",
    entityId: "entity_id",
  });
});

export function createConversationMetadataToJSON(
  createConversationMetadata: CreateConversationMetadata,
): string {
  return JSON.stringify(
    CreateConversationMetadata$outboundSchema.parse(createConversationMetadata),
  );
}
export function createConversationMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateConversationMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationMetadata' from JSON`,
  );
}

/** @internal */
export const CreateConversationRequestBody$inboundSchema: z.ZodType<
  CreateConversationRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_name: z.string().default("Untitled"),
  metadata: z.lazy(() => CreateConversationMetadata$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type CreateConversationRequestBody$Outbound = {
  display_name: string;
  metadata: CreateConversationMetadata$Outbound;
};

/** @internal */
export const CreateConversationRequestBody$outboundSchema: z.ZodType<
  CreateConversationRequestBody$Outbound,
  z.ZodTypeDef,
  CreateConversationRequestBody
> = z.object({
  displayName: z.string().default("Untitled"),
  metadata: z.lazy(() => CreateConversationMetadata$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function createConversationRequestBodyToJSON(
  createConversationRequestBody: CreateConversationRequestBody,
): string {
  return JSON.stringify(
    CreateConversationRequestBody$outboundSchema.parse(
      createConversationRequestBody,
    ),
  );
}
export function createConversationRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateConversationRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateConversationKind$inboundSchema: z.ZodNativeEnum<
  typeof CreateConversationKind
> = z.nativeEnum(CreateConversationKind);
/** @internal */
export const CreateConversationKind$outboundSchema: z.ZodNativeEnum<
  typeof CreateConversationKind
> = CreateConversationKind$inboundSchema;

/** @internal */
export const CreateConversationConversationsMetadata$inboundSchema: z.ZodType<
  CreateConversationConversationsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  generating_title: z.boolean().optional(),
  entity_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "generating_title": "generatingTitle",
    "entity_id": "entityId",
  });
});
/** @internal */
export type CreateConversationConversationsMetadata$Outbound = {
  generating_title?: boolean | undefined;
  entity_id?: string | undefined;
};

/** @internal */
export const CreateConversationConversationsMetadata$outboundSchema: z.ZodType<
  CreateConversationConversationsMetadata$Outbound,
  z.ZodTypeDef,
  CreateConversationConversationsMetadata
> = z.object({
  generatingTitle: z.boolean().optional(),
  entityId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    generatingTitle: "generating_title",
    entityId: "entity_id",
  });
});

export function createConversationConversationsMetadataToJSON(
  createConversationConversationsMetadata:
    CreateConversationConversationsMetadata,
): string {
  return JSON.stringify(
    CreateConversationConversationsMetadata$outboundSchema.parse(
      createConversationConversationsMetadata,
    ),
  );
}
export function createConversationConversationsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateConversationConversationsMetadata,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateConversationConversationsMetadata$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateConversationConversationsMetadata' from JSON`,
  );
}

/** @internal */
export const CreateConversationResponseBody$inboundSchema: z.ZodType<
  CreateConversationResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("conv_01kc3pkd4709ft9xrmq3j52reh"),
  entity_id: z.string(),
  kind: CreateConversationKind$inboundSchema,
  display_name: z.string(),
  created_at: z.number(),
  updated_at: z.number(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  metadata: z.lazy(() => CreateConversationConversationsMetadata$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "entity_id": "entityId",
    "display_name": "displayName",
    "created_at": "createdAt",
    "updated_at": "updatedAt",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
  });
});
/** @internal */
export type CreateConversationResponseBody$Outbound = {
  _id: string;
  entity_id: string;
  kind: string;
  display_name: string;
  created_at: number;
  updated_at: number;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  metadata?: CreateConversationConversationsMetadata$Outbound | undefined;
};

/** @internal */
export const CreateConversationResponseBody$outboundSchema: z.ZodType<
  CreateConversationResponseBody$Outbound,
  z.ZodTypeDef,
  CreateConversationResponseBody
> = z.object({
  id: z.string().default("conv_01kc3pkd4709ft9xrmq3j52reh"),
  entityId: z.string(),
  kind: CreateConversationKind$outboundSchema,
  displayName: z.string(),
  createdAt: z.number(),
  updatedAt: z.number(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  metadata: z.lazy(() => CreateConversationConversationsMetadata$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    entityId: "entity_id",
    displayName: "display_name",
    createdAt: "created_at",
    updatedAt: "updated_at",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
  });
});

export function createConversationResponseBodyToJSON(
  createConversationResponseBody: CreateConversationResponseBody,
): string {
  return JSON.stringify(
    CreateConversationResponseBody$outboundSchema.parse(
      createConversationResponseBody,
    ),
  );
}
export function createConversationResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateConversationResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateConversationResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateConversationResponseBody' from JSON`,
  );
}
