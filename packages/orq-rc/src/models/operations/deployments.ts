/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DeploymentsRequest = {
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const DeploymentsObject = {
  List: "list",
} as const;
export type DeploymentsObject = ClosedEnum<typeof DeploymentsObject>;

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const DeploymentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type DeploymentsType = ClosedEnum<typeof DeploymentsType>;

export const DeploymentsDeploymentsResponseType = {
  Object: "object",
} as const;
export type DeploymentsDeploymentsResponseType = ClosedEnum<
  typeof DeploymentsDeploymentsResponseType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object.
 *
 * @remarks
 *
 *  Omitting `parameters` defines a function with an empty parameter list.
 */
export type DeploymentsParameters = {
  type: DeploymentsDeploymentsResponseType;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

export type DeploymentsFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object.
   *
   * @remarks
   *
   *  Omitting `parameters` defines a function with an empty parameter list.
   */
  parameters: DeploymentsParameters;
};

export type DeploymentsTools = {
  displayName?: string | undefined;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: DeploymentsType;
  function: DeploymentsFunction;
  id?: number | undefined;
};

/**
 * The modality of the model
 */
export const DeploymentsModelType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The modality of the model
 */
export type DeploymentsModelType = ClosedEnum<typeof DeploymentsModelType>;

/**
 * Only supported on `image` models.
 */
export const DeploymentsFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type DeploymentsFormat = ClosedEnum<typeof DeploymentsFormat>;

export const DeploymentsResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type DeploymentsResponseFormat6 = ClosedEnum<
  typeof DeploymentsResponseFormat6
>;

export const DeploymentsResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type DeploymentsResponseFormat5 = ClosedEnum<
  typeof DeploymentsResponseFormat5
>;

export const DeploymentsResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type DeploymentsResponseFormat4 = ClosedEnum<
  typeof DeploymentsResponseFormat4
>;

export const DeploymentsResponseFormatDeploymentsType = {
  Text: "text",
} as const;
export type DeploymentsResponseFormatDeploymentsType = ClosedEnum<
  typeof DeploymentsResponseFormatDeploymentsType
>;

export type DeploymentsResponseFormat3 = {
  type: DeploymentsResponseFormatDeploymentsType;
};

export const DeploymentsResponseFormatType = {
  JsonObject: "json_object",
} as const;
export type DeploymentsResponseFormatType = ClosedEnum<
  typeof DeploymentsResponseFormatType
>;

export type DeploymentsResponseFormat2 = {
  type: DeploymentsResponseFormatType;
};

export const DeploymentsResponseFormatDeploymentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type DeploymentsResponseFormatDeploymentsResponseType = ClosedEnum<
  typeof DeploymentsResponseFormatDeploymentsResponseType
>;

export type DeploymentsResponseFormatJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type DeploymentsResponseFormat1 = {
  type: DeploymentsResponseFormatDeploymentsResponseType;
  displayName?: string | undefined;
  jsonSchema: DeploymentsResponseFormatJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type DeploymentsResponseFormat =
  | DeploymentsResponseFormat1
  | DeploymentsResponseFormat2
  | DeploymentsResponseFormat3
  | DeploymentsResponseFormat4
  | DeploymentsResponseFormat5
  | DeploymentsResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const DeploymentsPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type DeploymentsPhotoRealVersion = ClosedEnum<
  typeof DeploymentsPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const DeploymentsEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type DeploymentsEncodingFormat = ClosedEnum<
  typeof DeploymentsEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const DeploymentsReasoningEffort = {
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type DeploymentsReasoningEffort = ClosedEnum<
  typeof DeploymentsReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const DeploymentsVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type DeploymentsVerbosity = ClosedEnum<typeof DeploymentsVerbosity>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type DeploymentsModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: DeploymentsFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | DeploymentsResponseFormat1
    | DeploymentsResponseFormat2
    | DeploymentsResponseFormat3
    | DeploymentsResponseFormat4
    | DeploymentsResponseFormat5
    | DeploymentsResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: DeploymentsPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: DeploymentsEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: DeploymentsReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: DeploymentsVerbosity | undefined;
};

export const DeploymentsProvider = {
  Cohere: "cohere",
  Openai: "openai",
  Anthropic: "anthropic",
  Huggingface: "huggingface",
  Replicate: "replicate",
  Google: "google",
  GoogleAi: "google-ai",
  Azure: "azure",
  Aws: "aws",
  Anyscale: "anyscale",
  Perplexity: "perplexity",
  Groq: "groq",
  Fal: "fal",
  Leonardoai: "leonardoai",
  Nvidia: "nvidia",
  Jina: "jina",
  Togetherai: "togetherai",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Openailike: "openailike",
  Cerebras: "cerebras",
  Bytedance: "bytedance",
  Mistral: "mistral",
} as const;
export type DeploymentsProvider = ClosedEnum<typeof DeploymentsProvider>;

/**
 * The role of the prompt message
 */
export const DeploymentsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentsRole = ClosedEnum<typeof DeploymentsRole>;

/**
 * The type of the content part. Always `file`.
 */
export const Deployments2DeploymentsType = {
  File: "file",
} as const;
/**
 * The type of the content part. Always `file`.
 */
export type Deployments2DeploymentsType = ClosedEnum<
  typeof Deployments2DeploymentsType
>;

export type Deployments2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Deployments23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: Deployments2DeploymentsType;
  file: Deployments2File;
};

export const Deployments2Type = {
  ImageUrl: "image_url",
} as const;
export type Deployments2Type = ClosedEnum<typeof Deployments2Type>;

export type Deployments2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type Deployments22 = {
  type: Deployments2Type;
  imageUrl: Deployments2ImageUrl;
};

export const Deployments2DeploymentsResponseType = {
  Text: "text",
} as const;
export type Deployments2DeploymentsResponseType = ClosedEnum<
  typeof Deployments2DeploymentsResponseType
>;

/**
 * Text content part of a prompt message
 */
export type Deployments21 = {
  type: Deployments2DeploymentsResponseType;
  text: string;
};

export type DeploymentsContent2 = Deployments21 | Deployments22 | Deployments23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type DeploymentsContent =
  | string
  | Array<Deployments21 | Deployments22 | Deployments23>;

export const DeploymentsDeploymentsType = {
  Function: "function",
} as const;
export type DeploymentsDeploymentsType = ClosedEnum<
  typeof DeploymentsDeploymentsType
>;

export type DeploymentsDeploymentsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type DeploymentsToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentsDeploymentsType;
  function: DeploymentsDeploymentsFunction;
};

export type DeploymentsMessages = {
  /**
   * The role of the prompt message
   */
  role: DeploymentsRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content: string | Array<Deployments21 | Deployments22 | Deployments23> | null;
  toolCalls?: Array<DeploymentsToolCalls> | undefined;
  toolCallId?: string | undefined;
};

export type DeploymentsPromptConfig = {
  tools: Array<DeploymentsTools>;
  model: string;
  /**
   * The modality of the model
   */
  modelType: DeploymentsModelType;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  modelParameters: DeploymentsModelParameters;
  provider: DeploymentsProvider;
  messages: Array<DeploymentsMessages>;
};

export type DeploymentsData = {
  /**
   * Unique identifier for the object.
   */
  id: string;
  /**
   * Date in ISO 8601 format at which the object was created.
   */
  created: string;
  /**
   * Date in ISO 8601 format at which the object was last updated.
   */
  updated: string;
  /**
   * The deployment unique key
   */
  key: string;
  /**
   * An arbitrary string attached to the object. Often useful for displaying to users.
   */
  description: string;
  promptConfig: DeploymentsPromptConfig;
  /**
   * THe version of the deployment
   */
  version: string;
};

/**
 * List all deployments
 */
export type DeploymentsResponseBody = {
  object: DeploymentsObject;
  data: Array<DeploymentsData>;
  hasMore: boolean;
};

/** @internal */
export const DeploymentsRequest$inboundSchema: z.ZodType<
  DeploymentsRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  limit: z.number().default(10),
  starting_after: z.string().optional(),
  ending_before: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "starting_after": "startingAfter",
    "ending_before": "endingBefore",
  });
});
/** @internal */
export type DeploymentsRequest$Outbound = {
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const DeploymentsRequest$outboundSchema: z.ZodType<
  DeploymentsRequest$Outbound,
  z.ZodTypeDef,
  DeploymentsRequest
> = z.object({
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function deploymentsRequestToJSON(
  deploymentsRequest: DeploymentsRequest,
): string {
  return JSON.stringify(
    DeploymentsRequest$outboundSchema.parse(deploymentsRequest),
  );
}
export function deploymentsRequestFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsRequest' from JSON`,
  );
}

/** @internal */
export const DeploymentsObject$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsObject
> = z.nativeEnum(DeploymentsObject);
/** @internal */
export const DeploymentsObject$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsObject
> = DeploymentsObject$inboundSchema;

/** @internal */
export const DeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsType
> = z.nativeEnum(DeploymentsType);
/** @internal */
export const DeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsType
> = DeploymentsType$inboundSchema;

/** @internal */
export const DeploymentsDeploymentsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsDeploymentsResponseType
> = z.nativeEnum(DeploymentsDeploymentsResponseType);
/** @internal */
export const DeploymentsDeploymentsResponseType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsDeploymentsResponseType
> = DeploymentsDeploymentsResponseType$inboundSchema;

/** @internal */
export const DeploymentsParameters$inboundSchema: z.ZodType<
  DeploymentsParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentsDeploymentsResponseType$inboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});
/** @internal */
export type DeploymentsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

/** @internal */
export const DeploymentsParameters$outboundSchema: z.ZodType<
  DeploymentsParameters$Outbound,
  z.ZodTypeDef,
  DeploymentsParameters
> = z.object({
  type: DeploymentsDeploymentsResponseType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});

export function deploymentsParametersToJSON(
  deploymentsParameters: DeploymentsParameters,
): string {
  return JSON.stringify(
    DeploymentsParameters$outboundSchema.parse(deploymentsParameters),
  );
}
export function deploymentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsParameters' from JSON`,
  );
}

/** @internal */
export const DeploymentsFunction$inboundSchema: z.ZodType<
  DeploymentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DeploymentsParameters$inboundSchema),
});
/** @internal */
export type DeploymentsFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters: DeploymentsParameters$Outbound;
};

/** @internal */
export const DeploymentsFunction$outboundSchema: z.ZodType<
  DeploymentsFunction$Outbound,
  z.ZodTypeDef,
  DeploymentsFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DeploymentsParameters$outboundSchema),
});

export function deploymentsFunctionToJSON(
  deploymentsFunction: DeploymentsFunction,
): string {
  return JSON.stringify(
    DeploymentsFunction$outboundSchema.parse(deploymentsFunction),
  );
}
export function deploymentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentsTools$inboundSchema: z.ZodType<
  DeploymentsTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_name: z.string().optional(),
  type: DeploymentsType$inboundSchema,
  function: z.lazy(() => DeploymentsFunction$inboundSchema),
  id: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type DeploymentsTools$Outbound = {
  display_name?: string | undefined;
  type: string;
  function: DeploymentsFunction$Outbound;
  id?: number | undefined;
};

/** @internal */
export const DeploymentsTools$outboundSchema: z.ZodType<
  DeploymentsTools$Outbound,
  z.ZodTypeDef,
  DeploymentsTools
> = z.object({
  displayName: z.string().optional(),
  type: DeploymentsType$outboundSchema,
  function: z.lazy(() => DeploymentsFunction$outboundSchema),
  id: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function deploymentsToolsToJSON(
  deploymentsTools: DeploymentsTools,
): string {
  return JSON.stringify(
    DeploymentsTools$outboundSchema.parse(deploymentsTools),
  );
}
export function deploymentsToolsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsTools' from JSON`,
  );
}

/** @internal */
export const DeploymentsModelType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsModelType
> = z.nativeEnum(DeploymentsModelType);
/** @internal */
export const DeploymentsModelType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsModelType
> = DeploymentsModelType$inboundSchema;

/** @internal */
export const DeploymentsFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsFormat
> = z.nativeEnum(DeploymentsFormat);
/** @internal */
export const DeploymentsFormat$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsFormat
> = DeploymentsFormat$inboundSchema;

/** @internal */
export const DeploymentsResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat6
> = z.nativeEnum(DeploymentsResponseFormat6);
/** @internal */
export const DeploymentsResponseFormat6$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat6
> = DeploymentsResponseFormat6$inboundSchema;

/** @internal */
export const DeploymentsResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat5
> = z.nativeEnum(DeploymentsResponseFormat5);
/** @internal */
export const DeploymentsResponseFormat5$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat5
> = DeploymentsResponseFormat5$inboundSchema;

/** @internal */
export const DeploymentsResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat4
> = z.nativeEnum(DeploymentsResponseFormat4);
/** @internal */
export const DeploymentsResponseFormat4$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormat4
> = DeploymentsResponseFormat4$inboundSchema;

/** @internal */
export const DeploymentsResponseFormatDeploymentsType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentsResponseFormatDeploymentsType> = z
    .nativeEnum(DeploymentsResponseFormatDeploymentsType);
/** @internal */
export const DeploymentsResponseFormatDeploymentsType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentsResponseFormatDeploymentsType> =
    DeploymentsResponseFormatDeploymentsType$inboundSchema;

/** @internal */
export const DeploymentsResponseFormat3$inboundSchema: z.ZodType<
  DeploymentsResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentsResponseFormatDeploymentsType$inboundSchema,
});
/** @internal */
export type DeploymentsResponseFormat3$Outbound = {
  type: string;
};

/** @internal */
export const DeploymentsResponseFormat3$outboundSchema: z.ZodType<
  DeploymentsResponseFormat3$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseFormat3
> = z.object({
  type: DeploymentsResponseFormatDeploymentsType$outboundSchema,
});

export function deploymentsResponseFormat3ToJSON(
  deploymentsResponseFormat3: DeploymentsResponseFormat3,
): string {
  return JSON.stringify(
    DeploymentsResponseFormat3$outboundSchema.parse(deploymentsResponseFormat3),
  );
}
export function deploymentsResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseFormat3' from JSON`,
  );
}

/** @internal */
export const DeploymentsResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormatType
> = z.nativeEnum(DeploymentsResponseFormatType);
/** @internal */
export const DeploymentsResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsResponseFormatType
> = DeploymentsResponseFormatType$inboundSchema;

/** @internal */
export const DeploymentsResponseFormat2$inboundSchema: z.ZodType<
  DeploymentsResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentsResponseFormatType$inboundSchema,
});
/** @internal */
export type DeploymentsResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const DeploymentsResponseFormat2$outboundSchema: z.ZodType<
  DeploymentsResponseFormat2$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseFormat2
> = z.object({
  type: DeploymentsResponseFormatType$outboundSchema,
});

export function deploymentsResponseFormat2ToJSON(
  deploymentsResponseFormat2: DeploymentsResponseFormat2,
): string {
  return JSON.stringify(
    DeploymentsResponseFormat2$outboundSchema.parse(deploymentsResponseFormat2),
  );
}
export function deploymentsResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseFormat2' from JSON`,
  );
}

/** @internal */
export const DeploymentsResponseFormatDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentsResponseFormatDeploymentsResponseType> = z
    .nativeEnum(DeploymentsResponseFormatDeploymentsResponseType);
/** @internal */
export const DeploymentsResponseFormatDeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentsResponseFormatDeploymentsResponseType> =
    DeploymentsResponseFormatDeploymentsResponseType$inboundSchema;

/** @internal */
export const DeploymentsResponseFormatJsonSchema$inboundSchema: z.ZodType<
  DeploymentsResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  schema: z.record(z.any()),
});
/** @internal */
export type DeploymentsResponseFormatJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

/** @internal */
export const DeploymentsResponseFormatJsonSchema$outboundSchema: z.ZodType<
  DeploymentsResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseFormatJsonSchema
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  schema: z.record(z.any()),
});

export function deploymentsResponseFormatJsonSchemaToJSON(
  deploymentsResponseFormatJsonSchema: DeploymentsResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    DeploymentsResponseFormatJsonSchema$outboundSchema.parse(
      deploymentsResponseFormatJsonSchema,
    ),
  );
}
export function deploymentsResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentsResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const DeploymentsResponseFormat1$inboundSchema: z.ZodType<
  DeploymentsResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentsResponseFormatDeploymentsResponseType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() => DeploymentsResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type DeploymentsResponseFormat1$Outbound = {
  type: string;
  display_name?: string | undefined;
  json_schema: DeploymentsResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const DeploymentsResponseFormat1$outboundSchema: z.ZodType<
  DeploymentsResponseFormat1$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseFormat1
> = z.object({
  type: DeploymentsResponseFormatDeploymentsResponseType$outboundSchema,
  displayName: z.string().optional(),
  jsonSchema: z.lazy(() => DeploymentsResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function deploymentsResponseFormat1ToJSON(
  deploymentsResponseFormat1: DeploymentsResponseFormat1,
): string {
  return JSON.stringify(
    DeploymentsResponseFormat1$outboundSchema.parse(deploymentsResponseFormat1),
  );
}
export function deploymentsResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseFormat1' from JSON`,
  );
}

/** @internal */
export const DeploymentsResponseFormat$inboundSchema: z.ZodType<
  DeploymentsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DeploymentsResponseFormat1$inboundSchema),
  z.lazy(() => DeploymentsResponseFormat2$inboundSchema),
  z.lazy(() => DeploymentsResponseFormat3$inboundSchema),
  DeploymentsResponseFormat4$inboundSchema,
  DeploymentsResponseFormat5$inboundSchema,
  DeploymentsResponseFormat6$inboundSchema,
]);
/** @internal */
export type DeploymentsResponseFormat$Outbound =
  | DeploymentsResponseFormat1$Outbound
  | DeploymentsResponseFormat2$Outbound
  | DeploymentsResponseFormat3$Outbound
  | string
  | string
  | string;

/** @internal */
export const DeploymentsResponseFormat$outboundSchema: z.ZodType<
  DeploymentsResponseFormat$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseFormat
> = z.union([
  z.lazy(() => DeploymentsResponseFormat1$outboundSchema),
  z.lazy(() => DeploymentsResponseFormat2$outboundSchema),
  z.lazy(() => DeploymentsResponseFormat3$outboundSchema),
  DeploymentsResponseFormat4$outboundSchema,
  DeploymentsResponseFormat5$outboundSchema,
  DeploymentsResponseFormat6$outboundSchema,
]);

export function deploymentsResponseFormatToJSON(
  deploymentsResponseFormat: DeploymentsResponseFormat,
): string {
  return JSON.stringify(
    DeploymentsResponseFormat$outboundSchema.parse(deploymentsResponseFormat),
  );
}
export function deploymentsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseFormat' from JSON`,
  );
}

/** @internal */
export const DeploymentsPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPhotoRealVersion
> = z.nativeEnum(DeploymentsPhotoRealVersion);
/** @internal */
export const DeploymentsPhotoRealVersion$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPhotoRealVersion
> = DeploymentsPhotoRealVersion$inboundSchema;

/** @internal */
export const DeploymentsEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsEncodingFormat
> = z.nativeEnum(DeploymentsEncodingFormat);
/** @internal */
export const DeploymentsEncodingFormat$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsEncodingFormat
> = DeploymentsEncodingFormat$inboundSchema;

/** @internal */
export const DeploymentsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsReasoningEffort
> = z.nativeEnum(DeploymentsReasoningEffort);
/** @internal */
export const DeploymentsReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsReasoningEffort
> = DeploymentsReasoningEffort$inboundSchema;

/** @internal */
export const DeploymentsVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsVerbosity
> = z.nativeEnum(DeploymentsVerbosity);
/** @internal */
export const DeploymentsVerbosity$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsVerbosity
> = DeploymentsVerbosity$inboundSchema;

/** @internal */
export const DeploymentsModelParameters$inboundSchema: z.ZodType<
  DeploymentsModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: DeploymentsFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => DeploymentsResponseFormat1$inboundSchema),
      z.lazy(() => DeploymentsResponseFormat2$inboundSchema),
      z.lazy(() => DeploymentsResponseFormat3$inboundSchema),
      DeploymentsResponseFormat4$inboundSchema,
      DeploymentsResponseFormat5$inboundSchema,
      DeploymentsResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: DeploymentsPhotoRealVersion$inboundSchema.optional(),
  encoding_format: DeploymentsEncodingFormat$inboundSchema.optional(),
  reasoningEffort: DeploymentsReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: DeploymentsVerbosity$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});
/** @internal */
export type DeploymentsModelParameters$Outbound = {
  temperature?: number | undefined;
  maxTokens?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  frequencyPenalty?: number | undefined;
  presencePenalty?: number | undefined;
  numImages?: number | undefined;
  seed?: number | undefined;
  format?: string | undefined;
  dimensions?: string | undefined;
  quality?: string | undefined;
  style?: string | undefined;
  responseFormat?:
    | DeploymentsResponseFormat1$Outbound
    | DeploymentsResponseFormat2$Outbound
    | DeploymentsResponseFormat3$Outbound
    | string
    | string
    | string
    | null
    | undefined;
  photoRealVersion?: string | undefined;
  encoding_format?: string | undefined;
  reasoningEffort?: string | undefined;
  budgetTokens?: number | undefined;
  verbosity?: string | undefined;
};

/** @internal */
export const DeploymentsModelParameters$outboundSchema: z.ZodType<
  DeploymentsModelParameters$Outbound,
  z.ZodTypeDef,
  DeploymentsModelParameters
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: DeploymentsFormat$outboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => DeploymentsResponseFormat1$outboundSchema),
      z.lazy(() => DeploymentsResponseFormat2$outboundSchema),
      z.lazy(() => DeploymentsResponseFormat3$outboundSchema),
      DeploymentsResponseFormat4$outboundSchema,
      DeploymentsResponseFormat5$outboundSchema,
      DeploymentsResponseFormat6$outboundSchema,
    ]),
  ).optional(),
  photoRealVersion: DeploymentsPhotoRealVersion$outboundSchema.optional(),
  encodingFormat: DeploymentsEncodingFormat$outboundSchema.optional(),
  reasoningEffort: DeploymentsReasoningEffort$outboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: DeploymentsVerbosity$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

export function deploymentsModelParametersToJSON(
  deploymentsModelParameters: DeploymentsModelParameters,
): string {
  return JSON.stringify(
    DeploymentsModelParameters$outboundSchema.parse(deploymentsModelParameters),
  );
}
export function deploymentsModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsModelParameters' from JSON`,
  );
}

/** @internal */
export const DeploymentsProvider$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsProvider
> = z.nativeEnum(DeploymentsProvider);
/** @internal */
export const DeploymentsProvider$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsProvider
> = DeploymentsProvider$inboundSchema;

/** @internal */
export const DeploymentsRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsRole
> = z.nativeEnum(DeploymentsRole);
/** @internal */
export const DeploymentsRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsRole
> = DeploymentsRole$inboundSchema;

/** @internal */
export const Deployments2DeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2DeploymentsType
> = z.nativeEnum(Deployments2DeploymentsType);
/** @internal */
export const Deployments2DeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2DeploymentsType
> = Deployments2DeploymentsType$inboundSchema;

/** @internal */
export const Deployments2File$inboundSchema: z.ZodType<
  Deployments2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});
/** @internal */
export type Deployments2File$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const Deployments2File$outboundSchema: z.ZodType<
  Deployments2File$Outbound,
  z.ZodTypeDef,
  Deployments2File
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function deployments2FileToJSON(
  deployments2File: Deployments2File,
): string {
  return JSON.stringify(
    Deployments2File$outboundSchema.parse(deployments2File),
  );
}
export function deployments2FileFromJSON(
  jsonString: string,
): SafeParseResult<Deployments2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments2File' from JSON`,
  );
}

/** @internal */
export const Deployments23$inboundSchema: z.ZodType<
  Deployments23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2DeploymentsType$inboundSchema,
  file: z.lazy(() => Deployments2File$inboundSchema),
});
/** @internal */
export type Deployments23$Outbound = {
  type: string;
  file: Deployments2File$Outbound;
};

/** @internal */
export const Deployments23$outboundSchema: z.ZodType<
  Deployments23$Outbound,
  z.ZodTypeDef,
  Deployments23
> = z.object({
  type: Deployments2DeploymentsType$outboundSchema,
  file: z.lazy(() => Deployments2File$outboundSchema),
});

export function deployments23ToJSON(deployments23: Deployments23): string {
  return JSON.stringify(Deployments23$outboundSchema.parse(deployments23));
}
export function deployments23FromJSON(
  jsonString: string,
): SafeParseResult<Deployments23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments23' from JSON`,
  );
}

/** @internal */
export const Deployments2Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = z.nativeEnum(Deployments2Type);
/** @internal */
export const Deployments2Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = Deployments2Type$inboundSchema;

/** @internal */
export const Deployments2ImageUrl$inboundSchema: z.ZodType<
  Deployments2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});
/** @internal */
export type Deployments2ImageUrl$Outbound = {
  id?: string | undefined;
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const Deployments2ImageUrl$outboundSchema: z.ZodType<
  Deployments2ImageUrl$Outbound,
  z.ZodTypeDef,
  Deployments2ImageUrl
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function deployments2ImageUrlToJSON(
  deployments2ImageUrl: Deployments2ImageUrl,
): string {
  return JSON.stringify(
    Deployments2ImageUrl$outboundSchema.parse(deployments2ImageUrl),
  );
}
export function deployments2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<Deployments2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments2ImageUrl' from JSON`,
  );
}

/** @internal */
export const Deployments22$inboundSchema: z.ZodType<
  Deployments22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2Type$inboundSchema,
  image_url: z.lazy(() => Deployments2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});
/** @internal */
export type Deployments22$Outbound = {
  type: string;
  image_url: Deployments2ImageUrl$Outbound;
};

/** @internal */
export const Deployments22$outboundSchema: z.ZodType<
  Deployments22$Outbound,
  z.ZodTypeDef,
  Deployments22
> = z.object({
  type: Deployments2Type$outboundSchema,
  imageUrl: z.lazy(() => Deployments2ImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function deployments22ToJSON(deployments22: Deployments22): string {
  return JSON.stringify(Deployments22$outboundSchema.parse(deployments22));
}
export function deployments22FromJSON(
  jsonString: string,
): SafeParseResult<Deployments22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments22' from JSON`,
  );
}

/** @internal */
export const Deployments2DeploymentsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2DeploymentsResponseType
> = z.nativeEnum(Deployments2DeploymentsResponseType);
/** @internal */
export const Deployments2DeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof Deployments2DeploymentsResponseType> =
    Deployments2DeploymentsResponseType$inboundSchema;

/** @internal */
export const Deployments21$inboundSchema: z.ZodType<
  Deployments21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2DeploymentsResponseType$inboundSchema,
  text: z.string(),
});
/** @internal */
export type Deployments21$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const Deployments21$outboundSchema: z.ZodType<
  Deployments21$Outbound,
  z.ZodTypeDef,
  Deployments21
> = z.object({
  type: Deployments2DeploymentsResponseType$outboundSchema,
  text: z.string(),
});

export function deployments21ToJSON(deployments21: Deployments21): string {
  return JSON.stringify(Deployments21$outboundSchema.parse(deployments21));
}
export function deployments21FromJSON(
  jsonString: string,
): SafeParseResult<Deployments21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments21' from JSON`,
  );
}

/** @internal */
export const DeploymentsContent2$inboundSchema: z.ZodType<
  DeploymentsContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Deployments21$inboundSchema),
  z.lazy(() => Deployments22$inboundSchema),
  z.lazy(() => Deployments23$inboundSchema),
]);
/** @internal */
export type DeploymentsContent2$Outbound =
  | Deployments21$Outbound
  | Deployments22$Outbound
  | Deployments23$Outbound;

/** @internal */
export const DeploymentsContent2$outboundSchema: z.ZodType<
  DeploymentsContent2$Outbound,
  z.ZodTypeDef,
  DeploymentsContent2
> = z.union([
  z.lazy(() => Deployments21$outboundSchema),
  z.lazy(() => Deployments22$outboundSchema),
  z.lazy(() => Deployments23$outboundSchema),
]);

export function deploymentsContent2ToJSON(
  deploymentsContent2: DeploymentsContent2,
): string {
  return JSON.stringify(
    DeploymentsContent2$outboundSchema.parse(deploymentsContent2),
  );
}
export function deploymentsContent2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsContent2' from JSON`,
  );
}

/** @internal */
export const DeploymentsContent$inboundSchema: z.ZodType<
  DeploymentsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Deployments21$inboundSchema),
    z.lazy(() => Deployments22$inboundSchema),
    z.lazy(() => Deployments23$inboundSchema),
  ])),
]);
/** @internal */
export type DeploymentsContent$Outbound =
  | string
  | Array<
    Deployments21$Outbound | Deployments22$Outbound | Deployments23$Outbound
  >;

/** @internal */
export const DeploymentsContent$outboundSchema: z.ZodType<
  DeploymentsContent$Outbound,
  z.ZodTypeDef,
  DeploymentsContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Deployments21$outboundSchema),
    z.lazy(() => Deployments22$outboundSchema),
    z.lazy(() => Deployments23$outboundSchema),
  ])),
]);

export function deploymentsContentToJSON(
  deploymentsContent: DeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentsContent$outboundSchema.parse(deploymentsContent),
  );
}
export function deploymentsContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsContent' from JSON`,
  );
}

/** @internal */
export const DeploymentsDeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsDeploymentsType
> = z.nativeEnum(DeploymentsDeploymentsType);
/** @internal */
export const DeploymentsDeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsDeploymentsType
> = DeploymentsDeploymentsType$inboundSchema;

/** @internal */
export const DeploymentsDeploymentsFunction$inboundSchema: z.ZodType<
  DeploymentsDeploymentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});
/** @internal */
export type DeploymentsDeploymentsFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const DeploymentsDeploymentsFunction$outboundSchema: z.ZodType<
  DeploymentsDeploymentsFunction$Outbound,
  z.ZodTypeDef,
  DeploymentsDeploymentsFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function deploymentsDeploymentsFunctionToJSON(
  deploymentsDeploymentsFunction: DeploymentsDeploymentsFunction,
): string {
  return JSON.stringify(
    DeploymentsDeploymentsFunction$outboundSchema.parse(
      deploymentsDeploymentsFunction,
    ),
  );
}
export function deploymentsDeploymentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDeploymentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDeploymentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDeploymentsFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentsToolCalls$inboundSchema: z.ZodType<
  DeploymentsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentsDeploymentsType$inboundSchema,
  function: z.lazy(() => DeploymentsDeploymentsFunction$inboundSchema),
});
/** @internal */
export type DeploymentsToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: DeploymentsDeploymentsFunction$Outbound;
};

/** @internal */
export const DeploymentsToolCalls$outboundSchema: z.ZodType<
  DeploymentsToolCalls$Outbound,
  z.ZodTypeDef,
  DeploymentsToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentsDeploymentsType$outboundSchema,
  function: z.lazy(() => DeploymentsDeploymentsFunction$outboundSchema),
});

export function deploymentsToolCallsToJSON(
  deploymentsToolCalls: DeploymentsToolCalls,
): string {
  return JSON.stringify(
    DeploymentsToolCalls$outboundSchema.parse(deploymentsToolCalls),
  );
}
export function deploymentsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsToolCalls' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessages$inboundSchema: z.ZodType<
  DeploymentsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => Deployments21$inboundSchema),
        z.lazy(() => Deployments22$inboundSchema),
        z.lazy(() => Deployments23$inboundSchema),
      ])),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => DeploymentsToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type DeploymentsMessages$Outbound = {
  role: string;
  content:
    | string
    | Array<
      Deployments21$Outbound | Deployments22$Outbound | Deployments23$Outbound
    >
    | null;
  tool_calls?: Array<DeploymentsToolCalls$Outbound> | undefined;
  tool_call_id?: string | undefined;
};

/** @internal */
export const DeploymentsMessages$outboundSchema: z.ZodType<
  DeploymentsMessages$Outbound,
  z.ZodTypeDef,
  DeploymentsMessages
> = z.object({
  role: DeploymentsRole$outboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => Deployments21$outboundSchema),
        z.lazy(() => Deployments22$outboundSchema),
        z.lazy(() => Deployments23$outboundSchema),
      ])),
    ]),
  ),
  toolCalls: z.array(z.lazy(() => DeploymentsToolCalls$outboundSchema))
    .optional(),
  toolCallId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    toolCallId: "tool_call_id",
  });
});

export function deploymentsMessagesToJSON(
  deploymentsMessages: DeploymentsMessages,
): string {
  return JSON.stringify(
    DeploymentsMessages$outboundSchema.parse(deploymentsMessages),
  );
}
export function deploymentsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentsPromptConfig$inboundSchema: z.ZodType<
  DeploymentsPromptConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(z.lazy(() => DeploymentsTools$inboundSchema)),
  model: z.string(),
  model_type: DeploymentsModelType$inboundSchema,
  model_parameters: z.lazy(() => DeploymentsModelParameters$inboundSchema),
  provider: DeploymentsProvider$inboundSchema,
  messages: z.array(z.lazy(() => DeploymentsMessages$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "model_type": "modelType",
    "model_parameters": "modelParameters",
  });
});
/** @internal */
export type DeploymentsPromptConfig$Outbound = {
  tools: Array<DeploymentsTools$Outbound>;
  model: string;
  model_type: string;
  model_parameters: DeploymentsModelParameters$Outbound;
  provider: string;
  messages: Array<DeploymentsMessages$Outbound>;
};

/** @internal */
export const DeploymentsPromptConfig$outboundSchema: z.ZodType<
  DeploymentsPromptConfig$Outbound,
  z.ZodTypeDef,
  DeploymentsPromptConfig
> = z.object({
  tools: z.array(z.lazy(() => DeploymentsTools$outboundSchema)),
  model: z.string(),
  modelType: DeploymentsModelType$outboundSchema,
  modelParameters: z.lazy(() => DeploymentsModelParameters$outboundSchema),
  provider: DeploymentsProvider$outboundSchema,
  messages: z.array(z.lazy(() => DeploymentsMessages$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    modelType: "model_type",
    modelParameters: "model_parameters",
  });
});

export function deploymentsPromptConfigToJSON(
  deploymentsPromptConfig: DeploymentsPromptConfig,
): string {
  return JSON.stringify(
    DeploymentsPromptConfig$outboundSchema.parse(deploymentsPromptConfig),
  );
}
export function deploymentsPromptConfigFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsPromptConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsPromptConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsPromptConfig' from JSON`,
  );
}

/** @internal */
export const DeploymentsData$inboundSchema: z.ZodType<
  DeploymentsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  created: z.string(),
  updated: z.string(),
  key: z.string(),
  description: z.string(),
  prompt_config: z.lazy(() => DeploymentsPromptConfig$inboundSchema),
  version: z.string(),
}).transform((v) => {
  return remap$(v, {
    "prompt_config": "promptConfig",
  });
});
/** @internal */
export type DeploymentsData$Outbound = {
  id: string;
  created: string;
  updated: string;
  key: string;
  description: string;
  prompt_config: DeploymentsPromptConfig$Outbound;
  version: string;
};

/** @internal */
export const DeploymentsData$outboundSchema: z.ZodType<
  DeploymentsData$Outbound,
  z.ZodTypeDef,
  DeploymentsData
> = z.object({
  id: z.string(),
  created: z.string(),
  updated: z.string(),
  key: z.string(),
  description: z.string(),
  promptConfig: z.lazy(() => DeploymentsPromptConfig$outboundSchema),
  version: z.string(),
}).transform((v) => {
  return remap$(v, {
    promptConfig: "prompt_config",
  });
});

export function deploymentsDataToJSON(
  deploymentsData: DeploymentsData,
): string {
  return JSON.stringify(DeploymentsData$outboundSchema.parse(deploymentsData));
}
export function deploymentsDataFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsData' from JSON`,
  );
}

/** @internal */
export const DeploymentsResponseBody$inboundSchema: z.ZodType<
  DeploymentsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: DeploymentsObject$inboundSchema,
  data: z.array(z.lazy(() => DeploymentsData$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});
/** @internal */
export type DeploymentsResponseBody$Outbound = {
  object: string;
  data: Array<DeploymentsData$Outbound>;
  has_more: boolean;
};

/** @internal */
export const DeploymentsResponseBody$outboundSchema: z.ZodType<
  DeploymentsResponseBody$Outbound,
  z.ZodTypeDef,
  DeploymentsResponseBody
> = z.object({
  object: DeploymentsObject$outboundSchema,
  data: z.array(z.lazy(() => DeploymentsData$outboundSchema)),
  hasMore: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    hasMore: "has_more",
  });
});

export function deploymentsResponseBodyToJSON(
  deploymentsResponseBody: DeploymentsResponseBody,
): string {
  return JSON.stringify(
    DeploymentsResponseBody$outboundSchema.parse(deploymentsResponseBody),
  );
}
export function deploymentsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsResponseBody' from JSON`,
  );
}
