/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type UpdatePromptContentPromptsRequest2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type UpdatePromptMessagesPromptsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const UpdatePromptMessagesPromptsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type UpdatePromptMessagesPromptsType = ClosedEnum<
  typeof UpdatePromptMessagesPromptsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const UpdatePromptMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type UpdatePromptMessagesTtl = ClosedEnum<
  typeof UpdatePromptMessagesTtl
>;

export type UpdatePromptMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: UpdatePromptMessagesPromptsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: UpdatePromptMessagesTtl | undefined;
};

export type UpdatePromptMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: UpdatePromptMessagesCacheControl | undefined;
};

export type UpdatePromptContentPrompts2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type UpdatePromptMessagesPromptsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type UpdatePromptMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const UpdatePromptMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type UpdatePromptMessagesType = ClosedEnum<
  typeof UpdatePromptMessagesType
>;

export type UpdatePromptMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type UpdatePromptMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: UpdatePromptMessagesType;
  function: UpdatePromptMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type UpdatePromptMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: UpdatePromptMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<UpdatePromptMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const UpdatePrompt2PromptsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type UpdatePrompt2PromptsType = ClosedEnum<
  typeof UpdatePrompt2PromptsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const UpdatePrompt2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type UpdatePrompt2Ttl = ClosedEnum<typeof UpdatePrompt2Ttl>;

export type UpdatePrompt2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: UpdatePrompt2PromptsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: UpdatePrompt2Ttl | undefined;
};

export type UpdatePrompt24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: UpdatePrompt2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type UpdatePromptContent2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | UpdatePrompt24;

/**
 * The contents of the user message.
 */
export type UpdatePromptMessagesPromptsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | UpdatePrompt24
  >;

export type UpdatePromptMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | UpdatePrompt24
    >;
};

/**
 * The contents of the system message.
 */
export type UpdatePromptMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type UpdatePromptMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type UpdatePromptMessages =
  | UpdatePromptMessagesSystemMessage
  | UpdatePromptMessagesUserMessage
  | UpdatePromptMessagesAssistantMessage
  | UpdatePromptMessagesToolMessage;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdatePromptVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdatePromptVoice = ClosedEnum<typeof UpdatePromptVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdatePromptFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdatePromptFormat = ClosedEnum<typeof UpdatePromptFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdatePromptAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdatePromptVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdatePromptFormat;
};

export type UpdatePromptResponseFormatPromptsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdatePromptResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: UpdatePromptResponseFormatPromptsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdatePromptResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdatePromptResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdatePromptResponseFormat =
  | UpdatePromptResponseFormatText
  | UpdatePromptResponseFormatJSONObject
  | UpdatePromptResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const UpdatePromptReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type UpdatePromptReasoningEffort = ClosedEnum<
  typeof UpdatePromptReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdatePromptStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdatePromptStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdatePromptThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdatePromptToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdatePromptToolChoiceType = ClosedEnum<
  typeof UpdatePromptToolChoiceType
>;

export type UpdatePromptToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdatePromptToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdatePromptToolChoiceType | undefined;
  function: UpdatePromptToolChoiceFunction;
};

export const UpdatePromptToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdatePromptToolChoice1 = ClosedEnum<
  typeof UpdatePromptToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdatePromptToolChoice =
  | UpdatePromptToolChoice2
  | UpdatePromptToolChoice1;

export const UpdatePromptModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdatePromptModalities = ClosedEnum<typeof UpdatePromptModalities>;

/**
 * The key of the guardrail.
 */
export const UpdatePromptId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdatePromptId1 = ClosedEnum<typeof UpdatePromptId1>;

export type UpdatePromptId = UpdatePromptId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const UpdatePromptExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type UpdatePromptExecuteOn = ClosedEnum<typeof UpdatePromptExecuteOn>;

export type UpdatePromptGuardrails = {
  id: UpdatePromptId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: UpdatePromptExecuteOn;
};

export type UpdatePromptFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdatePromptRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdatePromptType = {
  ExactMatch: "exact_match",
} as const;
export type UpdatePromptType = ClosedEnum<typeof UpdatePromptType>;

/**
 * Cache configuration for the request.
 */
export type UpdatePromptCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: UpdatePromptType;
};

export const UpdatePromptLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type UpdatePromptLoadBalancerType = ClosedEnum<
  typeof UpdatePromptLoadBalancerType
>;

export type UpdatePromptLoadBalancer1 = {
  type: UpdatePromptLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type UpdatePromptLoadBalancer = UpdatePromptLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type UpdatePromptTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Prompt configuration with model and messages. Use this to update the prompt.
 */
export type UpdatePromptPromptInput = {
  /**
   * Array of messages that make up the conversation. Each message has a role (system, user, assistant, or tool) and content.
   */
  messages?:
    | Array<
      | UpdatePromptMessagesSystemMessage
      | UpdatePromptMessagesUserMessage
      | UpdatePromptMessagesAssistantMessage
      | UpdatePromptMessagesToolMessage
    >
    | undefined;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-3-5-sonnet-20241022`. For private models, use format: `{workspaceKey}@{provider}/{model}`. The full list of models can be found at https://docs.orq.ai/docs/ai-gateway-supported-models. Only chat models are supported.
   */
  model?: string | null | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdatePromptAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdatePromptResponseFormatText
    | UpdatePromptResponseFormatJSONObject
    | UpdatePromptResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: UpdatePromptReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: UpdatePromptStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: UpdatePromptToolChoice2 | UpdatePromptToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<UpdatePromptModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<UpdatePromptGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<UpdatePromptFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: UpdatePromptRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: UpdatePromptCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<UpdatePromptLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: UpdatePromptTimeout | undefined;
};

export const UpdatePromptUseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type UpdatePromptUseCases = ClosedEnum<typeof UpdatePromptUseCases>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const UpdatePromptLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type UpdatePromptLanguage = ClosedEnum<typeof UpdatePromptLanguage>;

export type UpdatePromptMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<UpdatePromptUseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: UpdatePromptLanguage | null | undefined;
};

export type UpdatePromptRequestBody = {
  owner?: string | undefined;
  domainId?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The prompt’s name, meant to be displayable in the UI.
   */
  displayName?: string | undefined;
  /**
   * The prompt’s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  /**
   * Prompt configuration with model and messages. Use this to update the prompt.
   */
  prompt?: UpdatePromptPromptInput | undefined;
  metadata?: UpdatePromptMetadata | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path?: string | undefined;
};

export type UpdatePromptRequest = {
  /**
   * Unique identifier of the prompt
   */
  id: string;
  requestBody?: UpdatePromptRequestBody | undefined;
};

export const UpdatePromptPromptsType = {
  Prompt: "prompt",
} as const;
export type UpdatePromptPromptsType = ClosedEnum<
  typeof UpdatePromptPromptsType
>;

/**
 * The modality of the model
 */
export const UpdatePromptModelType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Ocr: "ocr",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The modality of the model
 */
export type UpdatePromptModelType = ClosedEnum<typeof UpdatePromptModelType>;

/**
 * Only supported on `image` models.
 */
export const UpdatePromptPromptsFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type UpdatePromptPromptsFormat = ClosedEnum<
  typeof UpdatePromptPromptsFormat
>;

export const UpdatePromptResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type UpdatePromptResponseFormat6 = ClosedEnum<
  typeof UpdatePromptResponseFormat6
>;

export const UpdatePromptResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type UpdatePromptResponseFormat5 = ClosedEnum<
  typeof UpdatePromptResponseFormat5
>;

export const UpdatePromptResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type UpdatePromptResponseFormat4 = ClosedEnum<
  typeof UpdatePromptResponseFormat4
>;

export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType =
  {
    Text: "text",
  } as const;
export type UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType =
  ClosedEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType
  >;

export type UpdatePromptResponseFormat3 = {
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType;
};

export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType =
  {
    JsonObject: "json_object",
  } as const;
export type UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType =
  ClosedEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType
  >;

export type UpdatePromptResponseFormat2 = {
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType;
};

export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  >;

export type UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema =
  {
    name: string;
    description?: string | undefined;
    strict?: boolean | undefined;
    schema: { [k: string]: any };
  };

export type UpdatePromptResponseFormat1 = {
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType;
  displayName?: string | undefined;
  jsonSchema:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type UpdatePromptPromptsResponseResponseFormat =
  | UpdatePromptResponseFormat1
  | UpdatePromptResponseFormat2
  | UpdatePromptResponseFormat3
  | UpdatePromptResponseFormat4
  | UpdatePromptResponseFormat5
  | UpdatePromptResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const UpdatePromptPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type UpdatePromptPhotoRealVersion = ClosedEnum<
  typeof UpdatePromptPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const UpdatePromptEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type UpdatePromptEncodingFormat = ClosedEnum<
  typeof UpdatePromptEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const UpdatePromptPromptsResponseReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type UpdatePromptPromptsResponseReasoningEffort = ClosedEnum<
  typeof UpdatePromptPromptsResponseReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const UpdatePromptVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type UpdatePromptVerbosity = ClosedEnum<typeof UpdatePromptVerbosity>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const UpdatePromptThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type UpdatePromptThinkingLevel = ClosedEnum<
  typeof UpdatePromptThinkingLevel
>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type UpdatePromptModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: UpdatePromptPromptsFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | UpdatePromptResponseFormat1
    | UpdatePromptResponseFormat2
    | UpdatePromptResponseFormat3
    | UpdatePromptResponseFormat4
    | UpdatePromptResponseFormat5
    | UpdatePromptResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: UpdatePromptPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: UpdatePromptEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: UpdatePromptPromptsResponseReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: UpdatePromptVerbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: UpdatePromptThinkingLevel | undefined;
};

export const UpdatePromptProvider = {
  Openai: "openai",
  Groq: "groq",
  Cohere: "cohere",
  Azure: "azure",
  Aws: "aws",
  Google: "google",
  GoogleAi: "google-ai",
  Huggingface: "huggingface",
  Togetherai: "togetherai",
  Perplexity: "perplexity",
  Anthropic: "anthropic",
  Leonardoai: "leonardoai",
  Fal: "fal",
  Nvidia: "nvidia",
  Jina: "jina",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Cerebras: "cerebras",
  Openailike: "openailike",
  Bytedance: "bytedance",
  Mistral: "mistral",
  Deepseek: "deepseek",
  Contextualai: "contextualai",
  Moonshotai: "moonshotai",
  Zai: "zai",
  Slack: "slack",
} as const;
export type UpdatePromptProvider = ClosedEnum<typeof UpdatePromptProvider>;

/**
 * The role of the prompt message
 */
export const UpdatePromptRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type UpdatePromptRole = ClosedEnum<typeof UpdatePromptRole>;

export type UpdatePrompt2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type UpdatePrompt23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: UpdatePrompt2File;
};

export type UpdatePrompt2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type UpdatePrompt22 = {
  type: "image_url";
  imageUrl: UpdatePrompt2ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type UpdatePrompt21 = {
  type: "text";
  text: string;
};

export type UpdatePromptContentPromptsResponse2 =
  | UpdatePrompt21
  | UpdatePrompt22
  | UpdatePrompt23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type UpdatePromptContent =
  | string
  | Array<UpdatePrompt21 | UpdatePrompt22 | UpdatePrompt23>;

export const UpdatePromptPromptsResponse200Type = {
  Function: "function",
} as const;
export type UpdatePromptPromptsResponse200Type = ClosedEnum<
  typeof UpdatePromptPromptsResponse200Type
>;

export type UpdatePromptFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type UpdatePromptToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: UpdatePromptPromptsResponse200Type;
  function: UpdatePromptFunction;
};

export type UpdatePromptPromptsMessages = {
  /**
   * The role of the prompt message
   */
  role: UpdatePromptRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<UpdatePrompt21 | UpdatePrompt22 | UpdatePrompt23>
    | null;
  toolCalls?: Array<UpdatePromptToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type UpdatePromptPromptConfig = {
  stream?: boolean | undefined;
  model?: string | null | undefined;
  /**
   * The id of the resource
   */
  modelDbId?: string | null | undefined;
  /**
   * The modality of the model
   */
  modelType?: UpdatePromptModelType | null | undefined;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  modelParameters?: UpdatePromptModelParameters | undefined;
  provider?: UpdatePromptProvider | null | undefined;
  /**
   * The ID of the integration to use
   */
  integrationId?: string | null | undefined;
  version?: string | undefined;
  messages: Array<UpdatePromptPromptsMessages>;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const UpdatePromptPromptsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type UpdatePromptPromptsVoice = ClosedEnum<
  typeof UpdatePromptPromptsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const UpdatePromptPromptsResponse200Format = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type UpdatePromptPromptsResponse200Format = ClosedEnum<
  typeof UpdatePromptPromptsResponse200Format
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type UpdatePromptPromptsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: UpdatePromptPromptsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: UpdatePromptPromptsResponse200Format;
};

export type UpdatePromptResponseFormatPromptsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type UpdatePromptResponseFormatPromptsResponse200JSONSchema = {
  type: "json_schema";
  jsonSchema: UpdatePromptResponseFormatPromptsResponseJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type UpdatePromptResponseFormatPromptsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type UpdatePromptResponseFormatPromptsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type UpdatePromptPromptsResponseFormat =
  | UpdatePromptResponseFormatPromptsText
  | UpdatePromptResponseFormatPromptsJSONObject
  | UpdatePromptResponseFormatPromptsResponse200JSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const UpdatePromptPromptsReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type UpdatePromptPromptsReasoningEffort = ClosedEnum<
  typeof UpdatePromptPromptsReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type UpdatePromptPromptsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type UpdatePromptPromptsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type UpdatePromptPromptsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const UpdatePromptToolChoicePromptsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type UpdatePromptToolChoicePromptsType = ClosedEnum<
  typeof UpdatePromptToolChoicePromptsType
>;

export type UpdatePromptToolChoicePromptsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type UpdatePromptToolChoicePrompts2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: UpdatePromptToolChoicePromptsType | undefined;
  function: UpdatePromptToolChoicePromptsFunction;
};

export const UpdatePromptToolChoicePrompts1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type UpdatePromptToolChoicePrompts1 = ClosedEnum<
  typeof UpdatePromptToolChoicePrompts1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type UpdatePromptPromptsToolChoice =
  | UpdatePromptToolChoicePrompts2
  | UpdatePromptToolChoicePrompts1;

export const UpdatePromptPromptsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type UpdatePromptPromptsModalities = ClosedEnum<
  typeof UpdatePromptPromptsModalities
>;

/**
 * The key of the guardrail.
 */
export const UpdatePromptIdPrompts1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type UpdatePromptIdPrompts1 = ClosedEnum<typeof UpdatePromptIdPrompts1>;

export type UpdatePromptPromptsId = UpdatePromptIdPrompts1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const UpdatePromptPromptsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type UpdatePromptPromptsExecuteOn = ClosedEnum<
  typeof UpdatePromptPromptsExecuteOn
>;

export type UpdatePromptPromptsGuardrails = {
  id: UpdatePromptIdPrompts1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: UpdatePromptPromptsExecuteOn;
};

export type UpdatePromptPromptsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type UpdatePromptPromptsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const UpdatePromptPromptsResponseType = {
  ExactMatch: "exact_match",
} as const;
export type UpdatePromptPromptsResponseType = ClosedEnum<
  typeof UpdatePromptPromptsResponseType
>;

/**
 * Cache configuration for the request.
 */
export type UpdatePromptPromptsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: UpdatePromptPromptsResponseType;
};

export const UpdatePromptLoadBalancerPromptsType = {
  WeightBased: "weight_based",
} as const;
export type UpdatePromptLoadBalancerPromptsType = ClosedEnum<
  typeof UpdatePromptLoadBalancerPromptsType
>;

export type UpdatePromptLoadBalancerPrompts1 = {
  type: UpdatePromptLoadBalancerPromptsType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type UpdatePromptPromptsLoadBalancer = UpdatePromptLoadBalancerPrompts1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type UpdatePromptPromptsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const UpdatePromptMessagesPromptsResponse200Type = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type UpdatePromptMessagesPromptsResponse200Type = ClosedEnum<
  typeof UpdatePromptMessagesPromptsResponse200Type
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const UpdatePromptMessagesPromptsTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type UpdatePromptMessagesPromptsTtl = ClosedEnum<
  typeof UpdatePromptMessagesPromptsTtl
>;

export type UpdatePromptMessagesPromptsCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: UpdatePromptMessagesPromptsResponse200Type;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: UpdatePromptMessagesPromptsTtl;
};

export type UpdatePromptMessagesPromptsToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: UpdatePromptMessagesPromptsCacheControl | undefined;
};

export type UpdatePromptContentPromptsResponse200ApplicationJson2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type UpdatePromptMessagesPromptsResponse200ApplicationJSONContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type UpdatePromptMessagesPromptsAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const UpdatePromptMessagesPromptsResponseType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type UpdatePromptMessagesPromptsResponseType = ClosedEnum<
  typeof UpdatePromptMessagesPromptsResponseType
>;

export type UpdatePromptMessagesPromptsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type UpdatePromptMessagesPromptsToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: UpdatePromptMessagesPromptsResponseType;
  function: UpdatePromptMessagesPromptsFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type UpdatePromptMessagesPromptsAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: UpdatePromptMessagesPromptsAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<UpdatePromptMessagesPromptsToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType =
  {
    Ephemeral: "ephemeral",
  } as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType =
  ClosedEnum<
    typeof UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType
  >;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const UpdatePrompt2PromptsTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type UpdatePrompt2PromptsTtl = ClosedEnum<
  typeof UpdatePrompt2PromptsTtl
>;

export type UpdatePrompt2PromptsCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: UpdatePrompt2PromptsTtl;
};

export type UpdatePrompt2Prompts4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: UpdatePrompt2PromptsCacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type UpdatePromptContentPromptsResponse2002 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | UpdatePrompt2Prompts4;

/**
 * The contents of the user message.
 */
export type UpdatePromptMessagesPromptsResponse200Content =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | UpdatePrompt2Prompts4
  >;

export type UpdatePromptMessagesPromptsUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | UpdatePrompt2Prompts4
    >;
};

/**
 * The contents of the system message.
 */
export type UpdatePromptMessagesPromptsResponseContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type UpdatePromptMessagesPromptsSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type UpdatePromptPromptsResponseMessages =
  | UpdatePromptMessagesPromptsSystemMessage
  | UpdatePromptMessagesPromptsUserMessage
  | UpdatePromptMessagesPromptsAssistantMessage
  | UpdatePromptMessagesPromptsToolMessage;

/**
 * Prompt configuration with model and messages. Use this instead of prompt_config.
 */
export type UpdatePromptPromptField = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: UpdatePromptPromptsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | UpdatePromptResponseFormatPromptsText
    | UpdatePromptResponseFormatPromptsJSONObject
    | UpdatePromptResponseFormatPromptsResponse200JSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: UpdatePromptPromptsReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: UpdatePromptPromptsStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | UpdatePromptToolChoicePrompts2
    | UpdatePromptToolChoicePrompts1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<UpdatePromptPromptsModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<UpdatePromptPromptsGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<UpdatePromptPromptsFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: UpdatePromptPromptsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: UpdatePromptPromptsCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<UpdatePromptLoadBalancerPrompts1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: UpdatePromptPromptsTimeout | undefined;
  /**
   * Array of messages that make up the conversation. Each message has a role (system, user, assistant, or tool) and content.
   */
  messages?:
    | Array<
      | UpdatePromptMessagesPromptsSystemMessage
      | UpdatePromptMessagesPromptsUserMessage
      | UpdatePromptMessagesPromptsAssistantMessage
      | UpdatePromptMessagesPromptsToolMessage
    >
    | undefined;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-3-5-sonnet-20241022`. For private models, use format: `{workspaceKey}@{provider}/{model}`.
   */
  model?: string | null | undefined;
  version?: string | undefined;
};

export const UpdatePromptPromptsUseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type UpdatePromptPromptsUseCases = ClosedEnum<
  typeof UpdatePromptPromptsUseCases
>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const UpdatePromptPromptsLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type UpdatePromptPromptsLanguage = ClosedEnum<
  typeof UpdatePromptPromptsLanguage
>;

export type UpdatePromptPromptsMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<UpdatePromptPromptsUseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: UpdatePromptPromptsLanguage | null | undefined;
};

/**
 * A prompt entity with configuration, metadata, and versioning.
 */
export type UpdatePromptPrompt = {
  id: string;
  type: UpdatePromptPromptsType;
  owner: string;
  domainId: string;
  created: string;
  updated: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The prompt’s name, meant to be displayable in the UI.
   */
  displayName: string;
  /**
   * The prompt’s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  /**
   * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  promptConfig?: UpdatePromptPromptConfig | undefined;
  /**
   * Prompt configuration with model and messages. Use this instead of prompt_config.
   */
  prompt: UpdatePromptPromptField;
  metadata?: UpdatePromptPromptsMetadata | undefined;
};

/** @internal */
export type UpdatePromptContentPromptsRequest2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const UpdatePromptContentPromptsRequest2$outboundSchema: z.ZodType<
  UpdatePromptContentPromptsRequest2$Outbound,
  z.ZodTypeDef,
  UpdatePromptContentPromptsRequest2
> = components.TextContentPartSchema$outboundSchema;

export function updatePromptContentPromptsRequest2ToJSON(
  updatePromptContentPromptsRequest2: UpdatePromptContentPromptsRequest2,
): string {
  return JSON.stringify(
    UpdatePromptContentPromptsRequest2$outboundSchema.parse(
      updatePromptContentPromptsRequest2,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesPromptsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const UpdatePromptMessagesPromptsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    UpdatePromptMessagesPromptsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function updatePromptMessagesPromptsRequestRequestBodyContentToJSON(
  updatePromptMessagesPromptsRequestRequestBodyContent:
    UpdatePromptMessagesPromptsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    UpdatePromptMessagesPromptsRequestRequestBodyContent$outboundSchema.parse(
      updatePromptMessagesPromptsRequestRequestBodyContent,
    ),
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptMessagesPromptsType
> = z.nativeEnum(UpdatePromptMessagesPromptsType);

/** @internal */
export const UpdatePromptMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptMessagesTtl
> = z.nativeEnum(UpdatePromptMessagesTtl);

/** @internal */
export type UpdatePromptMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const UpdatePromptMessagesCacheControl$outboundSchema: z.ZodType<
  UpdatePromptMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesCacheControl
> = z.object({
  type: UpdatePromptMessagesPromptsType$outboundSchema,
  ttl: UpdatePromptMessagesTtl$outboundSchema.default("5m"),
});

export function updatePromptMessagesCacheControlToJSON(
  updatePromptMessagesCacheControl: UpdatePromptMessagesCacheControl,
): string {
  return JSON.stringify(
    UpdatePromptMessagesCacheControl$outboundSchema.parse(
      updatePromptMessagesCacheControl,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: UpdatePromptMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const UpdatePromptMessagesToolMessage$outboundSchema: z.ZodType<
  UpdatePromptMessagesToolMessage$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() => UpdatePromptMessagesCacheControl$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function updatePromptMessagesToolMessageToJSON(
  updatePromptMessagesToolMessage: UpdatePromptMessagesToolMessage,
): string {
  return JSON.stringify(
    UpdatePromptMessagesToolMessage$outboundSchema.parse(
      updatePromptMessagesToolMessage,
    ),
  );
}

/** @internal */
export type UpdatePromptContentPrompts2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const UpdatePromptContentPrompts2$outboundSchema: z.ZodType<
  UpdatePromptContentPrompts2$Outbound,
  z.ZodTypeDef,
  UpdatePromptContentPrompts2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$outboundSchema,
  components.ReasoningPartSchema$outboundSchema,
  components.RedactedReasoningPartSchema$outboundSchema,
]);

export function updatePromptContentPrompts2ToJSON(
  updatePromptContentPrompts2: UpdatePromptContentPrompts2,
): string {
  return JSON.stringify(
    UpdatePromptContentPrompts2$outboundSchema.parse(
      updatePromptContentPrompts2,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesPromptsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const UpdatePromptMessagesPromptsRequestContent$outboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsRequestContent$Outbound,
    z.ZodTypeDef,
    UpdatePromptMessagesPromptsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function updatePromptMessagesPromptsRequestContentToJSON(
  updatePromptMessagesPromptsRequestContent:
    UpdatePromptMessagesPromptsRequestContent,
): string {
  return JSON.stringify(
    UpdatePromptMessagesPromptsRequestContent$outboundSchema.parse(
      updatePromptMessagesPromptsRequestContent,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const UpdatePromptMessagesAudio$outboundSchema: z.ZodType<
  UpdatePromptMessagesAudio$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesAudio
> = z.object({
  id: z.string(),
});

export function updatePromptMessagesAudioToJSON(
  updatePromptMessagesAudio: UpdatePromptMessagesAudio,
): string {
  return JSON.stringify(
    UpdatePromptMessagesAudio$outboundSchema.parse(updatePromptMessagesAudio),
  );
}

/** @internal */
export const UpdatePromptMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptMessagesType
> = z.nativeEnum(UpdatePromptMessagesType);

/** @internal */
export type UpdatePromptMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const UpdatePromptMessagesFunction$outboundSchema: z.ZodType<
  UpdatePromptMessagesFunction$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function updatePromptMessagesFunctionToJSON(
  updatePromptMessagesFunction: UpdatePromptMessagesFunction,
): string {
  return JSON.stringify(
    UpdatePromptMessagesFunction$outboundSchema.parse(
      updatePromptMessagesFunction,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: UpdatePromptMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const UpdatePromptMessagesToolCalls$outboundSchema: z.ZodType<
  UpdatePromptMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesToolCalls
> = z.object({
  id: z.string(),
  type: UpdatePromptMessagesType$outboundSchema,
  function: z.lazy(() => UpdatePromptMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function updatePromptMessagesToolCallsToJSON(
  updatePromptMessagesToolCalls: UpdatePromptMessagesToolCalls,
): string {
  return JSON.stringify(
    UpdatePromptMessagesToolCalls$outboundSchema.parse(
      updatePromptMessagesToolCalls,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: UpdatePromptMessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<UpdatePromptMessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const UpdatePromptMessagesAssistantMessage$outboundSchema: z.ZodType<
  UpdatePromptMessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => UpdatePromptMessagesAudio$outboundSchema))
    .optional(),
  toolCalls: z.array(z.lazy(() => UpdatePromptMessagesToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function updatePromptMessagesAssistantMessageToJSON(
  updatePromptMessagesAssistantMessage: UpdatePromptMessagesAssistantMessage,
): string {
  return JSON.stringify(
    UpdatePromptMessagesAssistantMessage$outboundSchema.parse(
      updatePromptMessagesAssistantMessage,
    ),
  );
}

/** @internal */
export const UpdatePrompt2PromptsType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePrompt2PromptsType
> = z.nativeEnum(UpdatePrompt2PromptsType);

/** @internal */
export const UpdatePrompt2Ttl$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePrompt2Ttl
> = z.nativeEnum(UpdatePrompt2Ttl);

/** @internal */
export type UpdatePrompt2CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const UpdatePrompt2CacheControl$outboundSchema: z.ZodType<
  UpdatePrompt2CacheControl$Outbound,
  z.ZodTypeDef,
  UpdatePrompt2CacheControl
> = z.object({
  type: UpdatePrompt2PromptsType$outboundSchema,
  ttl: UpdatePrompt2Ttl$outboundSchema.default("5m"),
});

export function updatePrompt2CacheControlToJSON(
  updatePrompt2CacheControl: UpdatePrompt2CacheControl,
): string {
  return JSON.stringify(
    UpdatePrompt2CacheControl$outboundSchema.parse(updatePrompt2CacheControl),
  );
}

/** @internal */
export type UpdatePrompt24$Outbound = {
  type: "file";
  cache_control?: UpdatePrompt2CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const UpdatePrompt24$outboundSchema: z.ZodType<
  UpdatePrompt24$Outbound,
  z.ZodTypeDef,
  UpdatePrompt24
> = z.object({
  type: z.literal("file"),
  cacheControl: z.lazy(() => UpdatePrompt2CacheControl$outboundSchema)
    .optional(),
  file: components.FileContentPartSchema$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    cacheControl: "cache_control",
  });
});

export function updatePrompt24ToJSON(updatePrompt24: UpdatePrompt24): string {
  return JSON.stringify(UpdatePrompt24$outboundSchema.parse(updatePrompt24));
}

/** @internal */
export type UpdatePromptContent2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | UpdatePrompt24$Outbound;

/** @internal */
export const UpdatePromptContent2$outboundSchema: z.ZodType<
  UpdatePromptContent2$Outbound,
  z.ZodTypeDef,
  UpdatePromptContent2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => UpdatePrompt24$outboundSchema),
]);

export function updatePromptContent2ToJSON(
  updatePromptContent2: UpdatePromptContent2,
): string {
  return JSON.stringify(
    UpdatePromptContent2$outboundSchema.parse(updatePromptContent2),
  );
}

/** @internal */
export type UpdatePromptMessagesPromptsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | UpdatePrompt24$Outbound
  >;

/** @internal */
export const UpdatePromptMessagesPromptsContent$outboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsContent$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesPromptsContent
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$outboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.ImageContentPartSchema$outboundSchema,
      components.AudioContentPartSchema$outboundSchema,
      z.lazy(() => UpdatePrompt24$outboundSchema),
    ]),
  ),
]);

export function updatePromptMessagesPromptsContentToJSON(
  updatePromptMessagesPromptsContent: UpdatePromptMessagesPromptsContent,
): string {
  return JSON.stringify(
    UpdatePromptMessagesPromptsContent$outboundSchema.parse(
      updatePromptMessagesPromptsContent,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | UpdatePrompt24$Outbound
    >;
};

/** @internal */
export const UpdatePromptMessagesUserMessage$outboundSchema: z.ZodType<
  UpdatePromptMessagesUserMessage$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => UpdatePrompt24$outboundSchema),
      ]),
    ),
  ]),
});

export function updatePromptMessagesUserMessageToJSON(
  updatePromptMessagesUserMessage: UpdatePromptMessagesUserMessage,
): string {
  return JSON.stringify(
    UpdatePromptMessagesUserMessage$outboundSchema.parse(
      updatePromptMessagesUserMessage,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const UpdatePromptMessagesContent$outboundSchema: z.ZodType<
  UpdatePromptMessagesContent$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function updatePromptMessagesContentToJSON(
  updatePromptMessagesContent: UpdatePromptMessagesContent,
): string {
  return JSON.stringify(
    UpdatePromptMessagesContent$outboundSchema.parse(
      updatePromptMessagesContent,
    ),
  );
}

/** @internal */
export type UpdatePromptMessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const UpdatePromptMessagesSystemMessage$outboundSchema: z.ZodType<
  UpdatePromptMessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessagesSystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function updatePromptMessagesSystemMessageToJSON(
  updatePromptMessagesSystemMessage: UpdatePromptMessagesSystemMessage,
): string {
  return JSON.stringify(
    UpdatePromptMessagesSystemMessage$outboundSchema.parse(
      updatePromptMessagesSystemMessage,
    ),
  );
}

/** @internal */
export type UpdatePromptMessages$Outbound =
  | UpdatePromptMessagesSystemMessage$Outbound
  | UpdatePromptMessagesUserMessage$Outbound
  | UpdatePromptMessagesAssistantMessage$Outbound
  | UpdatePromptMessagesToolMessage$Outbound;

/** @internal */
export const UpdatePromptMessages$outboundSchema: z.ZodType<
  UpdatePromptMessages$Outbound,
  z.ZodTypeDef,
  UpdatePromptMessages
> = z.union([
  z.lazy(() => UpdatePromptMessagesSystemMessage$outboundSchema),
  z.lazy(() => UpdatePromptMessagesUserMessage$outboundSchema),
  z.lazy(() => UpdatePromptMessagesAssistantMessage$outboundSchema),
  z.lazy(() => UpdatePromptMessagesToolMessage$outboundSchema),
]);

export function updatePromptMessagesToJSON(
  updatePromptMessages: UpdatePromptMessages,
): string {
  return JSON.stringify(
    UpdatePromptMessages$outboundSchema.parse(updatePromptMessages),
  );
}

/** @internal */
export const UpdatePromptVoice$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptVoice
> = z.nativeEnum(UpdatePromptVoice);

/** @internal */
export const UpdatePromptFormat$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptFormat
> = z.nativeEnum(UpdatePromptFormat);

/** @internal */
export type UpdatePromptAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const UpdatePromptAudio$outboundSchema: z.ZodType<
  UpdatePromptAudio$Outbound,
  z.ZodTypeDef,
  UpdatePromptAudio
> = z.object({
  voice: UpdatePromptVoice$outboundSchema,
  format: UpdatePromptFormat$outboundSchema,
});

export function updatePromptAudioToJSON(
  updatePromptAudio: UpdatePromptAudio,
): string {
  return JSON.stringify(
    UpdatePromptAudio$outboundSchema.parse(updatePromptAudio),
  );
}

/** @internal */
export type UpdatePromptResponseFormatPromptsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const UpdatePromptResponseFormatPromptsJsonSchema$outboundSchema:
  z.ZodType<
    UpdatePromptResponseFormatPromptsJsonSchema$Outbound,
    z.ZodTypeDef,
    UpdatePromptResponseFormatPromptsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updatePromptResponseFormatPromptsJsonSchemaToJSON(
  updatePromptResponseFormatPromptsJsonSchema:
    UpdatePromptResponseFormatPromptsJsonSchema,
): string {
  return JSON.stringify(
    UpdatePromptResponseFormatPromptsJsonSchema$outboundSchema.parse(
      updatePromptResponseFormatPromptsJsonSchema,
    ),
  );
}

/** @internal */
export type UpdatePromptResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: UpdatePromptResponseFormatPromptsJsonSchema$Outbound;
};

/** @internal */
export const UpdatePromptResponseFormatJSONSchema$outboundSchema: z.ZodType<
  UpdatePromptResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  UpdatePromptResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    UpdatePromptResponseFormatPromptsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function updatePromptResponseFormatJSONSchemaToJSON(
  updatePromptResponseFormatJSONSchema: UpdatePromptResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    UpdatePromptResponseFormatJSONSchema$outboundSchema.parse(
      updatePromptResponseFormatJSONSchema,
    ),
  );
}

/** @internal */
export type UpdatePromptResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const UpdatePromptResponseFormatJSONObject$outboundSchema: z.ZodType<
  UpdatePromptResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  UpdatePromptResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function updatePromptResponseFormatJSONObjectToJSON(
  updatePromptResponseFormatJSONObject: UpdatePromptResponseFormatJSONObject,
): string {
  return JSON.stringify(
    UpdatePromptResponseFormatJSONObject$outboundSchema.parse(
      updatePromptResponseFormatJSONObject,
    ),
  );
}

/** @internal */
export type UpdatePromptResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const UpdatePromptResponseFormatText$outboundSchema: z.ZodType<
  UpdatePromptResponseFormatText$Outbound,
  z.ZodTypeDef,
  UpdatePromptResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function updatePromptResponseFormatTextToJSON(
  updatePromptResponseFormatText: UpdatePromptResponseFormatText,
): string {
  return JSON.stringify(
    UpdatePromptResponseFormatText$outboundSchema.parse(
      updatePromptResponseFormatText,
    ),
  );
}

/** @internal */
export type UpdatePromptResponseFormat$Outbound =
  | UpdatePromptResponseFormatText$Outbound
  | UpdatePromptResponseFormatJSONObject$Outbound
  | UpdatePromptResponseFormatJSONSchema$Outbound;

/** @internal */
export const UpdatePromptResponseFormat$outboundSchema: z.ZodType<
  UpdatePromptResponseFormat$Outbound,
  z.ZodTypeDef,
  UpdatePromptResponseFormat
> = z.union([
  z.lazy(() => UpdatePromptResponseFormatText$outboundSchema),
  z.lazy(() => UpdatePromptResponseFormatJSONObject$outboundSchema),
  z.lazy(() => UpdatePromptResponseFormatJSONSchema$outboundSchema),
]);

export function updatePromptResponseFormatToJSON(
  updatePromptResponseFormat: UpdatePromptResponseFormat,
): string {
  return JSON.stringify(
    UpdatePromptResponseFormat$outboundSchema.parse(updatePromptResponseFormat),
  );
}

/** @internal */
export const UpdatePromptReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptReasoningEffort
> = z.nativeEnum(UpdatePromptReasoningEffort);

/** @internal */
export type UpdatePromptStop$Outbound = string | Array<string>;

/** @internal */
export const UpdatePromptStop$outboundSchema: z.ZodType<
  UpdatePromptStop$Outbound,
  z.ZodTypeDef,
  UpdatePromptStop
> = z.union([z.string(), z.array(z.string())]);

export function updatePromptStopToJSON(
  updatePromptStop: UpdatePromptStop,
): string {
  return JSON.stringify(
    UpdatePromptStop$outboundSchema.parse(updatePromptStop),
  );
}

/** @internal */
export type UpdatePromptStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const UpdatePromptStreamOptions$outboundSchema: z.ZodType<
  UpdatePromptStreamOptions$Outbound,
  z.ZodTypeDef,
  UpdatePromptStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function updatePromptStreamOptionsToJSON(
  updatePromptStreamOptions: UpdatePromptStreamOptions,
): string {
  return JSON.stringify(
    UpdatePromptStreamOptions$outboundSchema.parse(updatePromptStreamOptions),
  );
}

/** @internal */
export type UpdatePromptThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const UpdatePromptThinking$outboundSchema: z.ZodType<
  UpdatePromptThinking$Outbound,
  z.ZodTypeDef,
  UpdatePromptThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function updatePromptThinkingToJSON(
  updatePromptThinking: UpdatePromptThinking,
): string {
  return JSON.stringify(
    UpdatePromptThinking$outboundSchema.parse(updatePromptThinking),
  );
}

/** @internal */
export const UpdatePromptToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptToolChoiceType
> = z.nativeEnum(UpdatePromptToolChoiceType);

/** @internal */
export type UpdatePromptToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const UpdatePromptToolChoiceFunction$outboundSchema: z.ZodType<
  UpdatePromptToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  UpdatePromptToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function updatePromptToolChoiceFunctionToJSON(
  updatePromptToolChoiceFunction: UpdatePromptToolChoiceFunction,
): string {
  return JSON.stringify(
    UpdatePromptToolChoiceFunction$outboundSchema.parse(
      updatePromptToolChoiceFunction,
    ),
  );
}

/** @internal */
export type UpdatePromptToolChoice2$Outbound = {
  type?: string | undefined;
  function: UpdatePromptToolChoiceFunction$Outbound;
};

/** @internal */
export const UpdatePromptToolChoice2$outboundSchema: z.ZodType<
  UpdatePromptToolChoice2$Outbound,
  z.ZodTypeDef,
  UpdatePromptToolChoice2
> = z.object({
  type: UpdatePromptToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => UpdatePromptToolChoiceFunction$outboundSchema),
});

export function updatePromptToolChoice2ToJSON(
  updatePromptToolChoice2: UpdatePromptToolChoice2,
): string {
  return JSON.stringify(
    UpdatePromptToolChoice2$outboundSchema.parse(updatePromptToolChoice2),
  );
}

/** @internal */
export const UpdatePromptToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptToolChoice1
> = z.nativeEnum(UpdatePromptToolChoice1);

/** @internal */
export type UpdatePromptToolChoice$Outbound =
  | UpdatePromptToolChoice2$Outbound
  | string;

/** @internal */
export const UpdatePromptToolChoice$outboundSchema: z.ZodType<
  UpdatePromptToolChoice$Outbound,
  z.ZodTypeDef,
  UpdatePromptToolChoice
> = z.union([
  z.lazy(() => UpdatePromptToolChoice2$outboundSchema),
  UpdatePromptToolChoice1$outboundSchema,
]);

export function updatePromptToolChoiceToJSON(
  updatePromptToolChoice: UpdatePromptToolChoice,
): string {
  return JSON.stringify(
    UpdatePromptToolChoice$outboundSchema.parse(updatePromptToolChoice),
  );
}

/** @internal */
export const UpdatePromptModalities$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptModalities
> = z.nativeEnum(UpdatePromptModalities);

/** @internal */
export const UpdatePromptId1$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptId1
> = z.nativeEnum(UpdatePromptId1);

/** @internal */
export type UpdatePromptId$Outbound = string | string;

/** @internal */
export const UpdatePromptId$outboundSchema: z.ZodType<
  UpdatePromptId$Outbound,
  z.ZodTypeDef,
  UpdatePromptId
> = z.union([UpdatePromptId1$outboundSchema, z.string()]);

export function updatePromptIdToJSON(updatePromptId: UpdatePromptId): string {
  return JSON.stringify(UpdatePromptId$outboundSchema.parse(updatePromptId));
}

/** @internal */
export const UpdatePromptExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptExecuteOn
> = z.nativeEnum(UpdatePromptExecuteOn);

/** @internal */
export type UpdatePromptGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const UpdatePromptGuardrails$outboundSchema: z.ZodType<
  UpdatePromptGuardrails$Outbound,
  z.ZodTypeDef,
  UpdatePromptGuardrails
> = z.object({
  id: z.union([UpdatePromptId1$outboundSchema, z.string()]),
  executeOn: UpdatePromptExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function updatePromptGuardrailsToJSON(
  updatePromptGuardrails: UpdatePromptGuardrails,
): string {
  return JSON.stringify(
    UpdatePromptGuardrails$outboundSchema.parse(updatePromptGuardrails),
  );
}

/** @internal */
export type UpdatePromptFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const UpdatePromptFallbacks$outboundSchema: z.ZodType<
  UpdatePromptFallbacks$Outbound,
  z.ZodTypeDef,
  UpdatePromptFallbacks
> = z.object({
  model: z.string(),
});

export function updatePromptFallbacksToJSON(
  updatePromptFallbacks: UpdatePromptFallbacks,
): string {
  return JSON.stringify(
    UpdatePromptFallbacks$outboundSchema.parse(updatePromptFallbacks),
  );
}

/** @internal */
export type UpdatePromptRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const UpdatePromptRetry$outboundSchema: z.ZodType<
  UpdatePromptRetry$Outbound,
  z.ZodTypeDef,
  UpdatePromptRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function updatePromptRetryToJSON(
  updatePromptRetry: UpdatePromptRetry,
): string {
  return JSON.stringify(
    UpdatePromptRetry$outboundSchema.parse(updatePromptRetry),
  );
}

/** @internal */
export const UpdatePromptType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptType
> = z.nativeEnum(UpdatePromptType);

/** @internal */
export type UpdatePromptCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const UpdatePromptCache$outboundSchema: z.ZodType<
  UpdatePromptCache$Outbound,
  z.ZodTypeDef,
  UpdatePromptCache
> = z.object({
  ttl: z.number().default(1800),
  type: UpdatePromptType$outboundSchema,
});

export function updatePromptCacheToJSON(
  updatePromptCache: UpdatePromptCache,
): string {
  return JSON.stringify(
    UpdatePromptCache$outboundSchema.parse(updatePromptCache),
  );
}

/** @internal */
export const UpdatePromptLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptLoadBalancerType
> = z.nativeEnum(UpdatePromptLoadBalancerType);

/** @internal */
export type UpdatePromptLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const UpdatePromptLoadBalancer1$outboundSchema: z.ZodType<
  UpdatePromptLoadBalancer1$Outbound,
  z.ZodTypeDef,
  UpdatePromptLoadBalancer1
> = z.object({
  type: UpdatePromptLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function updatePromptLoadBalancer1ToJSON(
  updatePromptLoadBalancer1: UpdatePromptLoadBalancer1,
): string {
  return JSON.stringify(
    UpdatePromptLoadBalancer1$outboundSchema.parse(updatePromptLoadBalancer1),
  );
}

/** @internal */
export type UpdatePromptLoadBalancer$Outbound =
  UpdatePromptLoadBalancer1$Outbound;

/** @internal */
export const UpdatePromptLoadBalancer$outboundSchema: z.ZodType<
  UpdatePromptLoadBalancer$Outbound,
  z.ZodTypeDef,
  UpdatePromptLoadBalancer
> = z.lazy(() => UpdatePromptLoadBalancer1$outboundSchema);

export function updatePromptLoadBalancerToJSON(
  updatePromptLoadBalancer: UpdatePromptLoadBalancer,
): string {
  return JSON.stringify(
    UpdatePromptLoadBalancer$outboundSchema.parse(updatePromptLoadBalancer),
  );
}

/** @internal */
export type UpdatePromptTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const UpdatePromptTimeout$outboundSchema: z.ZodType<
  UpdatePromptTimeout$Outbound,
  z.ZodTypeDef,
  UpdatePromptTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function updatePromptTimeoutToJSON(
  updatePromptTimeout: UpdatePromptTimeout,
): string {
  return JSON.stringify(
    UpdatePromptTimeout$outboundSchema.parse(updatePromptTimeout),
  );
}

/** @internal */
export type UpdatePromptPromptInput$Outbound = {
  messages?:
    | Array<
      | UpdatePromptMessagesSystemMessage$Outbound
      | UpdatePromptMessagesUserMessage$Outbound
      | UpdatePromptMessagesAssistantMessage$Outbound
      | UpdatePromptMessagesToolMessage$Outbound
    >
    | undefined;
  model?: string | null | undefined;
  audio?: UpdatePromptAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | UpdatePromptResponseFormatText$Outbound
    | UpdatePromptResponseFormatJSONObject$Outbound
    | UpdatePromptResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: UpdatePromptStreamOptions$Outbound | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: UpdatePromptToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<UpdatePromptGuardrails$Outbound> | undefined;
  fallbacks?: Array<UpdatePromptFallbacks$Outbound> | undefined;
  retry?: UpdatePromptRetry$Outbound | undefined;
  cache?: UpdatePromptCache$Outbound | undefined;
  load_balancer?: Array<UpdatePromptLoadBalancer1$Outbound> | undefined;
  timeout?: UpdatePromptTimeout$Outbound | undefined;
};

/** @internal */
export const UpdatePromptPromptInput$outboundSchema: z.ZodType<
  UpdatePromptPromptInput$Outbound,
  z.ZodTypeDef,
  UpdatePromptPromptInput
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => UpdatePromptMessagesSystemMessage$outboundSchema),
      z.lazy(() => UpdatePromptMessagesUserMessage$outboundSchema),
      z.lazy(() => UpdatePromptMessagesAssistantMessage$outboundSchema),
      z.lazy(() => UpdatePromptMessagesToolMessage$outboundSchema),
    ]),
  ).optional(),
  model: z.nullable(z.string()).optional(),
  audio: z.nullable(z.lazy(() => UpdatePromptAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => UpdatePromptResponseFormatText$outboundSchema),
    z.lazy(() => UpdatePromptResponseFormatJSONObject$outboundSchema),
    z.lazy(() => UpdatePromptResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: UpdatePromptReasoningEffort$outboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => UpdatePromptStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => UpdatePromptToolChoice2$outboundSchema),
    UpdatePromptToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(UpdatePromptModalities$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdatePromptGuardrails$outboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => UpdatePromptFallbacks$outboundSchema))
    .optional(),
  retry: z.lazy(() => UpdatePromptRetry$outboundSchema).optional(),
  cache: z.lazy(() => UpdatePromptCache$outboundSchema).optional(),
  loadBalancer: z.array(z.lazy(() => UpdatePromptLoadBalancer1$outboundSchema))
    .optional(),
  timeout: z.lazy(() => UpdatePromptTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
    loadBalancer: "load_balancer",
  });
});

export function updatePromptPromptInputToJSON(
  updatePromptPromptInput: UpdatePromptPromptInput,
): string {
  return JSON.stringify(
    UpdatePromptPromptInput$outboundSchema.parse(updatePromptPromptInput),
  );
}

/** @internal */
export const UpdatePromptUseCases$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptUseCases
> = z.nativeEnum(UpdatePromptUseCases);

/** @internal */
export const UpdatePromptLanguage$outboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptLanguage
> = z.nativeEnum(UpdatePromptLanguage);

/** @internal */
export type UpdatePromptMetadata$Outbound = {
  use_cases?: Array<string> | undefined;
  language?: string | null | undefined;
};

/** @internal */
export const UpdatePromptMetadata$outboundSchema: z.ZodType<
  UpdatePromptMetadata$Outbound,
  z.ZodTypeDef,
  UpdatePromptMetadata
> = z.object({
  useCases: z.array(UpdatePromptUseCases$outboundSchema).optional(),
  language: z.nullable(UpdatePromptLanguage$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    useCases: "use_cases",
  });
});

export function updatePromptMetadataToJSON(
  updatePromptMetadata: UpdatePromptMetadata,
): string {
  return JSON.stringify(
    UpdatePromptMetadata$outboundSchema.parse(updatePromptMetadata),
  );
}

/** @internal */
export type UpdatePromptRequestBody$Outbound = {
  owner?: string | undefined;
  domain_id?: string | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  display_name?: string | undefined;
  description?: string | null | undefined;
  prompt?: UpdatePromptPromptInput$Outbound | undefined;
  metadata?: UpdatePromptMetadata$Outbound | undefined;
  path?: string | undefined;
};

/** @internal */
export const UpdatePromptRequestBody$outboundSchema: z.ZodType<
  UpdatePromptRequestBody$Outbound,
  z.ZodTypeDef,
  UpdatePromptRequestBody
> = z.object({
  owner: z.string().optional(),
  domainId: z.string().optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  displayName: z.string().optional(),
  description: z.nullable(z.string()).optional(),
  prompt: z.lazy(() => UpdatePromptPromptInput$outboundSchema).optional(),
  metadata: z.lazy(() => UpdatePromptMetadata$outboundSchema).optional(),
  path: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    domainId: "domain_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    displayName: "display_name",
  });
});

export function updatePromptRequestBodyToJSON(
  updatePromptRequestBody: UpdatePromptRequestBody,
): string {
  return JSON.stringify(
    UpdatePromptRequestBody$outboundSchema.parse(updatePromptRequestBody),
  );
}

/** @internal */
export type UpdatePromptRequest$Outbound = {
  id: string;
  RequestBody?: UpdatePromptRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdatePromptRequest$outboundSchema: z.ZodType<
  UpdatePromptRequest$Outbound,
  z.ZodTypeDef,
  UpdatePromptRequest
> = z.object({
  id: z.string(),
  requestBody: z.lazy(() => UpdatePromptRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function updatePromptRequestToJSON(
  updatePromptRequest: UpdatePromptRequest,
): string {
  return JSON.stringify(
    UpdatePromptRequest$outboundSchema.parse(updatePromptRequest),
  );
}

/** @internal */
export const UpdatePromptPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsType
> = z.nativeEnum(UpdatePromptPromptsType);

/** @internal */
export const UpdatePromptModelType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptModelType
> = z.nativeEnum(UpdatePromptModelType);

/** @internal */
export const UpdatePromptPromptsFormat$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsFormat
> = z.nativeEnum(UpdatePromptPromptsFormat);

/** @internal */
export const UpdatePromptResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptResponseFormat6
> = z.nativeEnum(UpdatePromptResponseFormat6);

/** @internal */
export const UpdatePromptResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptResponseFormat5
> = z.nativeEnum(UpdatePromptResponseFormat5);

/** @internal */
export const UpdatePromptResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptResponseFormat4
> = z.nativeEnum(UpdatePromptResponseFormat4);

/** @internal */
export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType
  > = z.nativeEnum(
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType,
  );

/** @internal */
export const UpdatePromptResponseFormat3$inboundSchema: z.ZodType<
  UpdatePromptResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigModelParametersType$inboundSchema,
});

export function updatePromptResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormat3' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType
  > = z.nativeEnum(
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType,
  );

/** @internal */
export const UpdatePromptResponseFormat2$inboundSchema: z.ZodType<
  UpdatePromptResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyPromptConfigType$inboundSchema,
});

export function updatePromptResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormat2' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema$inboundSchema:
  z.ZodType<
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function updatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormat1$inboundSchema: z.ZodType<
  UpdatePromptResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    UpdatePromptResponseFormatPromptsResponse200ApplicationJSONJSONSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});

export function updatePromptResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormat1' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsResponseResponseFormat$inboundSchema: z.ZodType<
  UpdatePromptPromptsResponseResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePromptResponseFormat1$inboundSchema),
  z.lazy(() => UpdatePromptResponseFormat2$inboundSchema),
  z.lazy(() => UpdatePromptResponseFormat3$inboundSchema),
  UpdatePromptResponseFormat4$inboundSchema,
  UpdatePromptResponseFormat5$inboundSchema,
  UpdatePromptResponseFormat6$inboundSchema,
]);

export function updatePromptPromptsResponseResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptPromptsResponseResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptPromptsResponseResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptPromptsResponseResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPhotoRealVersion
> = z.nativeEnum(UpdatePromptPhotoRealVersion);

/** @internal */
export const UpdatePromptEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptEncodingFormat
> = z.nativeEnum(UpdatePromptEncodingFormat);

/** @internal */
export const UpdatePromptPromptsResponseReasoningEffort$inboundSchema:
  z.ZodNativeEnum<typeof UpdatePromptPromptsResponseReasoningEffort> = z
    .nativeEnum(UpdatePromptPromptsResponseReasoningEffort);

/** @internal */
export const UpdatePromptVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptVerbosity
> = z.nativeEnum(UpdatePromptVerbosity);

/** @internal */
export const UpdatePromptThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptThinkingLevel
> = z.nativeEnum(UpdatePromptThinkingLevel);

/** @internal */
export const UpdatePromptModelParameters$inboundSchema: z.ZodType<
  UpdatePromptModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: UpdatePromptPromptsFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => UpdatePromptResponseFormat1$inboundSchema),
      z.lazy(() => UpdatePromptResponseFormat2$inboundSchema),
      z.lazy(() => UpdatePromptResponseFormat3$inboundSchema),
      UpdatePromptResponseFormat4$inboundSchema,
      UpdatePromptResponseFormat5$inboundSchema,
      UpdatePromptResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: UpdatePromptPhotoRealVersion$inboundSchema.optional(),
  encoding_format: UpdatePromptEncodingFormat$inboundSchema.optional(),
  reasoningEffort: UpdatePromptPromptsResponseReasoningEffort$inboundSchema
    .optional(),
  budgetTokens: z.number().optional(),
  verbosity: UpdatePromptVerbosity$inboundSchema.optional(),
  thinkingLevel: UpdatePromptThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

export function updatePromptModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptModelParameters' from JSON`,
  );
}

/** @internal */
export const UpdatePromptProvider$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptProvider
> = z.nativeEnum(UpdatePromptProvider);

/** @internal */
export const UpdatePromptRole$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptRole
> = z.nativeEnum(UpdatePromptRole);

/** @internal */
export const UpdatePrompt2File$inboundSchema: z.ZodType<
  UpdatePrompt2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});

export function updatePrompt2FileFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt2File' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt23$inboundSchema: z.ZodType<
  UpdatePrompt23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => UpdatePrompt2File$inboundSchema),
});

export function updatePrompt23FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt23' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt2ImageUrl$inboundSchema: z.ZodType<
  UpdatePrompt2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function updatePrompt2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt2ImageUrl' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt22$inboundSchema: z.ZodType<
  UpdatePrompt22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => UpdatePrompt2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

export function updatePrompt22FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt22' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt21$inboundSchema: z.ZodType<
  UpdatePrompt21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function updatePrompt21FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt21' from JSON`,
  );
}

/** @internal */
export const UpdatePromptContentPromptsResponse2$inboundSchema: z.ZodType<
  UpdatePromptContentPromptsResponse2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePrompt21$inboundSchema),
  z.lazy(() => UpdatePrompt22$inboundSchema),
  z.lazy(() => UpdatePrompt23$inboundSchema),
]);

export function updatePromptContentPromptsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptContentPromptsResponse2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptContentPromptsResponse2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptContentPromptsResponse2' from JSON`,
  );
}

/** @internal */
export const UpdatePromptContent$inboundSchema: z.ZodType<
  UpdatePromptContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => UpdatePrompt21$inboundSchema),
    z.lazy(() => UpdatePrompt22$inboundSchema),
    z.lazy(() => UpdatePrompt23$inboundSchema),
  ])),
]);

export function updatePromptContentFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptContent' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsResponse200Type$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsResponse200Type
> = z.nativeEnum(UpdatePromptPromptsResponse200Type);

/** @internal */
export const UpdatePromptFunction$inboundSchema: z.ZodType<
  UpdatePromptFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function updatePromptFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptFunction' from JSON`,
  );
}

/** @internal */
export const UpdatePromptToolCalls$inboundSchema: z.ZodType<
  UpdatePromptToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: UpdatePromptPromptsResponse200Type$inboundSchema,
  function: z.lazy(() => UpdatePromptFunction$inboundSchema),
});

export function updatePromptToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptToolCalls' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsMessages$inboundSchema: z.ZodType<
  UpdatePromptPromptsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: UpdatePromptRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => UpdatePrompt21$inboundSchema),
        z.lazy(() => UpdatePrompt22$inboundSchema),
        z.lazy(() => UpdatePrompt23$inboundSchema),
      ])),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => UpdatePromptToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});

export function updatePromptPromptsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsMessages' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptConfig$inboundSchema: z.ZodType<
  UpdatePromptPromptConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  stream: z.boolean().optional(),
  model: z.nullable(z.string()).optional(),
  model_db_id: z.nullable(z.string()).optional(),
  model_type: z.nullable(UpdatePromptModelType$inboundSchema).optional(),
  model_parameters: z.lazy(() => UpdatePromptModelParameters$inboundSchema)
    .optional(),
  provider: z.nullable(UpdatePromptProvider$inboundSchema).optional(),
  integration_id: z.nullable(z.string()).optional(),
  version: z.string().optional(),
  messages: z.array(z.lazy(() => UpdatePromptPromptsMessages$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "model_db_id": "modelDbId",
    "model_type": "modelType",
    "model_parameters": "modelParameters",
    "integration_id": "integrationId",
  });
});

export function updatePromptPromptConfigFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptConfig' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsVoice$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsVoice
> = z.nativeEnum(UpdatePromptPromptsVoice);

/** @internal */
export const UpdatePromptPromptsResponse200Format$inboundSchema:
  z.ZodNativeEnum<typeof UpdatePromptPromptsResponse200Format> = z.nativeEnum(
    UpdatePromptPromptsResponse200Format,
  );

/** @internal */
export const UpdatePromptPromptsAudio$inboundSchema: z.ZodType<
  UpdatePromptPromptsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: UpdatePromptPromptsVoice$inboundSchema,
  format: UpdatePromptPromptsResponse200Format$inboundSchema,
});

export function updatePromptPromptsAudioFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsAudio' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema:
  z.ZodType<
    UpdatePromptResponseFormatPromptsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function updatePromptResponseFormatPromptsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptResponseFormatPromptsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptResponseFormatPromptsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    UpdatePromptResponseFormatPromptsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      UpdatePromptResponseFormatPromptsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function updatePromptResponseFormatPromptsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptResponseFormatPromptsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptResponseFormatPromptsResponse200JSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormatPromptsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsJSONObject$inboundSchema:
  z.ZodType<
    UpdatePromptResponseFormatPromptsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });

export function updatePromptResponseFormatPromptsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptResponseFormatPromptsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptResponseFormatPromptsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptResponseFormatPromptsJSONObject' from JSON`,
  );
}

/** @internal */
export const UpdatePromptResponseFormatPromptsText$inboundSchema: z.ZodType<
  UpdatePromptResponseFormatPromptsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function updatePromptResponseFormatPromptsTextFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptResponseFormatPromptsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptResponseFormatPromptsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptResponseFormatPromptsText' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsResponseFormat$inboundSchema: z.ZodType<
  UpdatePromptPromptsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePromptResponseFormatPromptsText$inboundSchema),
  z.lazy(() => UpdatePromptResponseFormatPromptsJSONObject$inboundSchema),
  z.lazy(() =>
    UpdatePromptResponseFormatPromptsResponse200JSONSchema$inboundSchema
  ),
]);

export function updatePromptPromptsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsResponseFormat' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsReasoningEffort
> = z.nativeEnum(UpdatePromptPromptsReasoningEffort);

/** @internal */
export const UpdatePromptPromptsStop$inboundSchema: z.ZodType<
  UpdatePromptPromptsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function updatePromptPromptsStopFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsStop' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsStreamOptions$inboundSchema: z.ZodType<
  UpdatePromptPromptsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function updatePromptPromptsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsStreamOptions' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsThinking$inboundSchema: z.ZodType<
  UpdatePromptPromptsThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function updatePromptPromptsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsThinking' from JSON`,
  );
}

/** @internal */
export const UpdatePromptToolChoicePromptsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptToolChoicePromptsType
> = z.nativeEnum(UpdatePromptToolChoicePromptsType);

/** @internal */
export const UpdatePromptToolChoicePromptsFunction$inboundSchema: z.ZodType<
  UpdatePromptToolChoicePromptsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function updatePromptToolChoicePromptsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptToolChoicePromptsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptToolChoicePromptsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptToolChoicePromptsFunction' from JSON`,
  );
}

/** @internal */
export const UpdatePromptToolChoicePrompts2$inboundSchema: z.ZodType<
  UpdatePromptToolChoicePrompts2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdatePromptToolChoicePromptsType$inboundSchema.optional(),
  function: z.lazy(() => UpdatePromptToolChoicePromptsFunction$inboundSchema),
});

export function updatePromptToolChoicePrompts2FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptToolChoicePrompts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptToolChoicePrompts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptToolChoicePrompts2' from JSON`,
  );
}

/** @internal */
export const UpdatePromptToolChoicePrompts1$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptToolChoicePrompts1
> = z.nativeEnum(UpdatePromptToolChoicePrompts1);

/** @internal */
export const UpdatePromptPromptsToolChoice$inboundSchema: z.ZodType<
  UpdatePromptPromptsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePromptToolChoicePrompts2$inboundSchema),
  UpdatePromptToolChoicePrompts1$inboundSchema,
]);

export function updatePromptPromptsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsToolChoice' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsModalities$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsModalities
> = z.nativeEnum(UpdatePromptPromptsModalities);

/** @internal */
export const UpdatePromptIdPrompts1$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptIdPrompts1
> = z.nativeEnum(UpdatePromptIdPrompts1);

/** @internal */
export const UpdatePromptPromptsId$inboundSchema: z.ZodType<
  UpdatePromptPromptsId,
  z.ZodTypeDef,
  unknown
> = z.union([UpdatePromptIdPrompts1$inboundSchema, z.string()]);

export function updatePromptPromptsIdFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsId' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsExecuteOn
> = z.nativeEnum(UpdatePromptPromptsExecuteOn);

/** @internal */
export const UpdatePromptPromptsGuardrails$inboundSchema: z.ZodType<
  UpdatePromptPromptsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([UpdatePromptIdPrompts1$inboundSchema, z.string()]),
  execute_on: UpdatePromptPromptsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});

export function updatePromptPromptsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsGuardrails' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsFallbacks$inboundSchema: z.ZodType<
  UpdatePromptPromptsFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function updatePromptPromptsFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsFallbacks' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsRetry$inboundSchema: z.ZodType<
  UpdatePromptPromptsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function updatePromptPromptsRetryFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsRetry' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsResponseType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsResponseType
> = z.nativeEnum(UpdatePromptPromptsResponseType);

/** @internal */
export const UpdatePromptPromptsCache$inboundSchema: z.ZodType<
  UpdatePromptPromptsCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: UpdatePromptPromptsResponseType$inboundSchema,
});

export function updatePromptPromptsCacheFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsCache' from JSON`,
  );
}

/** @internal */
export const UpdatePromptLoadBalancerPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptLoadBalancerPromptsType
> = z.nativeEnum(UpdatePromptLoadBalancerPromptsType);

/** @internal */
export const UpdatePromptLoadBalancerPrompts1$inboundSchema: z.ZodType<
  UpdatePromptLoadBalancerPrompts1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdatePromptLoadBalancerPromptsType$inboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function updatePromptLoadBalancerPrompts1FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptLoadBalancerPrompts1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptLoadBalancerPrompts1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptLoadBalancerPrompts1' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsLoadBalancer$inboundSchema: z.ZodType<
  UpdatePromptPromptsLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => UpdatePromptLoadBalancerPrompts1$inboundSchema);

export function updatePromptPromptsLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsLoadBalancer' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsTimeout$inboundSchema: z.ZodType<
  UpdatePromptPromptsTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function updatePromptPromptsTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsTimeout' from JSON`,
  );
}

/** @internal */
export const UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2$inboundSchema:
  z.ZodType<
    UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2,
    z.ZodTypeDef,
    unknown
  > = components.TextContentPartSchema$inboundSchema;

export function updatePromptContentPromptsResponse200ApplicationJSONResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptContentPromptsResponse200ApplicationJSONResponseBody2' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent$inboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);

export function updatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContentFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsResponse200ApplicationJSONResponseBodyContent' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof UpdatePromptMessagesPromptsResponse200Type> = z
    .nativeEnum(UpdatePromptMessagesPromptsResponse200Type);

/** @internal */
export const UpdatePromptMessagesPromptsTtl$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptMessagesPromptsTtl
> = z.nativeEnum(UpdatePromptMessagesPromptsTtl);

/** @internal */
export const UpdatePromptMessagesPromptsCacheControl$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: UpdatePromptMessagesPromptsResponse200Type$inboundSchema,
  ttl: UpdatePromptMessagesPromptsTtl$inboundSchema.default("5m"),
});

export function updatePromptMessagesPromptsCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsCacheControl,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsCacheControl$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptMessagesPromptsCacheControl' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsToolMessage$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.nullable(z.string()),
  cache_control: z.lazy(() =>
    UpdatePromptMessagesPromptsCacheControl$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});

export function updatePromptMessagesPromptsToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptMessagesPromptsToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsToolMessage' from JSON`,
  );
}

/** @internal */
export const UpdatePromptContentPromptsResponse200ApplicationJson2$inboundSchema:
  z.ZodType<
    UpdatePromptContentPromptsResponse200ApplicationJson2,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.TextContentPartSchema$inboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.RefusalPartSchema$inboundSchema,
    components.ReasoningPartSchema$inboundSchema,
    components.RedactedReasoningPartSchema$inboundSchema,
  ]);

export function updatePromptContentPromptsResponse200ApplicationJSON2FromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptContentPromptsResponse200ApplicationJson2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptContentPromptsResponse200ApplicationJson2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptContentPromptsResponse200ApplicationJson2' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponse200ApplicationJSONContent$inboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsResponse200ApplicationJSONContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);

export function updatePromptMessagesPromptsResponse200ApplicationJSONContentFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsResponse200ApplicationJSONContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsResponse200ApplicationJSONContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsResponse200ApplicationJSONContent' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsAudio$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

export function updatePromptMessagesPromptsAudioFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptMessagesPromptsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptMessagesPromptsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsAudio' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof UpdatePromptMessagesPromptsResponseType> = z
    .nativeEnum(UpdatePromptMessagesPromptsResponseType);

/** @internal */
export const UpdatePromptMessagesPromptsFunction$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function updatePromptMessagesPromptsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptMessagesPromptsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsFunction' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsToolCalls$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: UpdatePromptMessagesPromptsResponseType$inboundSchema,
  function: z.lazy(() => UpdatePromptMessagesPromptsFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});

export function updatePromptMessagesPromptsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptMessagesPromptsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsToolCalls' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsAssistantMessage$inboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsAssistantMessage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    content: z.nullable(
      z.union([
        z.string(),
        z.array(
          z.union([
            components.TextContentPartSchema$inboundSchema.and(
              z.object({ type: z.literal("text") }),
            ),
            components.RefusalPartSchema$inboundSchema,
            components.ReasoningPartSchema$inboundSchema,
            components.RedactedReasoningPartSchema$inboundSchema,
          ]),
        ),
      ]),
    ).optional(),
    refusal: z.nullable(z.string()).optional(),
    role: z.literal("assistant"),
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => UpdatePromptMessagesPromptsAudio$inboundSchema),
    ).optional(),
    tool_calls: z.array(
      z.lazy(() => UpdatePromptMessagesPromptsToolCalls$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_calls": "toolCalls",
    });
  });

export function updatePromptMessagesPromptsAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsAssistantMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsAssistantMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptMessagesPromptsAssistantMessage' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType$inboundSchema:
  z.ZodNativeEnum<
    typeof UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType
  > = z.nativeEnum(
    UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType,
  );

/** @internal */
export const UpdatePrompt2PromptsTtl$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePrompt2PromptsTtl
> = z.nativeEnum(UpdatePrompt2PromptsTtl);

/** @internal */
export const UpdatePrompt2PromptsCacheControl$inboundSchema: z.ZodType<
  UpdatePrompt2PromptsCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    UpdatePrompt2PromptsResponse200ApplicationJSONResponseBodyPromptType$inboundSchema,
  ttl: UpdatePrompt2PromptsTtl$inboundSchema.default("5m"),
});

export function updatePrompt2PromptsCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt2PromptsCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt2PromptsCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt2PromptsCacheControl' from JSON`,
  );
}

/** @internal */
export const UpdatePrompt2Prompts4$inboundSchema: z.ZodType<
  UpdatePrompt2Prompts4,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  cache_control: z.lazy(() => UpdatePrompt2PromptsCacheControl$inboundSchema)
    .optional(),
  file: components.FileContentPartSchema$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});

export function updatePrompt2Prompts4FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePrompt2Prompts4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePrompt2Prompts4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePrompt2Prompts4' from JSON`,
  );
}

/** @internal */
export const UpdatePromptContentPromptsResponse2002$inboundSchema: z.ZodType<
  UpdatePromptContentPromptsResponse2002,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => UpdatePrompt2Prompts4$inboundSchema),
]);

export function updatePromptContentPromptsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptContentPromptsResponse2002, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptContentPromptsResponse2002$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptContentPromptsResponse2002' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponse200Content$inboundSchema:
  z.ZodType<
    UpdatePromptMessagesPromptsResponse200Content,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => UpdatePrompt2Prompts4$inboundSchema),
      ]),
    ),
  ]);

export function updatePromptMessagesPromptsResponse200ContentFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsResponse200Content,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsResponse200Content$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptMessagesPromptsResponse200Content' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsUserMessage$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => UpdatePrompt2Prompts4$inboundSchema),
      ]),
    ),
  ]),
});

export function updatePromptMessagesPromptsUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptMessagesPromptsUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptMessagesPromptsUserMessage' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsResponseContent$inboundSchema:
  z.ZodType<UpdatePromptMessagesPromptsResponseContent, z.ZodTypeDef, unknown> =
    z.union([
      z.string(),
      z.array(components.TextContentPartSchema$inboundSchema),
    ]);

export function updatePromptMessagesPromptsResponseContentFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsResponseContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsResponseContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptMessagesPromptsResponseContent' from JSON`,
  );
}

/** @internal */
export const UpdatePromptMessagesPromptsSystemMessage$inboundSchema: z.ZodType<
  UpdatePromptMessagesPromptsSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});

export function updatePromptMessagesPromptsSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  UpdatePromptMessagesPromptsSystemMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptMessagesPromptsSystemMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'UpdatePromptMessagesPromptsSystemMessage' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsResponseMessages$inboundSchema: z.ZodType<
  UpdatePromptPromptsResponseMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => UpdatePromptMessagesPromptsSystemMessage$inboundSchema),
  z.lazy(() => UpdatePromptMessagesPromptsUserMessage$inboundSchema),
  z.lazy(() => UpdatePromptMessagesPromptsAssistantMessage$inboundSchema),
  z.lazy(() => UpdatePromptMessagesPromptsToolMessage$inboundSchema),
]);

export function updatePromptPromptsResponseMessagesFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsResponseMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      UpdatePromptPromptsResponseMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsResponseMessages' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptField$inboundSchema: z.ZodType<
  UpdatePromptPromptField,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => UpdatePromptPromptsAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => UpdatePromptResponseFormatPromptsText$inboundSchema),
    z.lazy(() => UpdatePromptResponseFormatPromptsJSONObject$inboundSchema),
    z.lazy(() =>
      UpdatePromptResponseFormatPromptsResponse200JSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: UpdatePromptPromptsReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => UpdatePromptPromptsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => UpdatePromptToolChoicePrompts2$inboundSchema),
    UpdatePromptToolChoicePrompts1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(UpdatePromptPromptsModalities$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => UpdatePromptPromptsGuardrails$inboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => UpdatePromptPromptsFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => UpdatePromptPromptsRetry$inboundSchema).optional(),
  cache: z.lazy(() => UpdatePromptPromptsCache$inboundSchema).optional(),
  load_balancer: z.array(
    z.lazy(() => UpdatePromptLoadBalancerPrompts1$inboundSchema),
  ).optional(),
  timeout: z.lazy(() => UpdatePromptPromptsTimeout$inboundSchema).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => UpdatePromptMessagesPromptsSystemMessage$inboundSchema),
      z.lazy(() => UpdatePromptMessagesPromptsUserMessage$inboundSchema),
      z.lazy(() => UpdatePromptMessagesPromptsAssistantMessage$inboundSchema),
      z.lazy(() => UpdatePromptMessagesPromptsToolMessage$inboundSchema),
    ]),
  ).optional(),
  model: z.nullable(z.string()).optional(),
  version: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function updatePromptPromptFieldFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptField' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPromptsUseCases$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsUseCases
> = z.nativeEnum(UpdatePromptPromptsUseCases);

/** @internal */
export const UpdatePromptPromptsLanguage$inboundSchema: z.ZodNativeEnum<
  typeof UpdatePromptPromptsLanguage
> = z.nativeEnum(UpdatePromptPromptsLanguage);

/** @internal */
export const UpdatePromptPromptsMetadata$inboundSchema: z.ZodType<
  UpdatePromptPromptsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  use_cases: z.array(UpdatePromptPromptsUseCases$inboundSchema).optional(),
  language: z.nullable(UpdatePromptPromptsLanguage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "use_cases": "useCases",
  });
});

export function updatePromptPromptsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPromptsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPromptsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPromptsMetadata' from JSON`,
  );
}

/** @internal */
export const UpdatePromptPrompt$inboundSchema: z.ZodType<
  UpdatePromptPrompt,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  type: UpdatePromptPromptsType$inboundSchema,
  owner: z.string(),
  domain_id: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  display_name: z.string(),
  description: z.nullable(z.string()).optional(),
  prompt_config: z.lazy(() => UpdatePromptPromptConfig$inboundSchema)
    .optional(),
  prompt: z.lazy(() => UpdatePromptPromptField$inboundSchema),
  metadata: z.lazy(() => UpdatePromptPromptsMetadata$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "domain_id": "domainId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "display_name": "displayName",
    "prompt_config": "promptConfig",
  });
});

export function updatePromptPromptFromJSON(
  jsonString: string,
): SafeParseResult<UpdatePromptPrompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdatePromptPrompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdatePromptPrompt' from JSON`,
  );
}
