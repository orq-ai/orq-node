/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CancelBatchRequest = {
  batchId: string;
};

/**
 * The object type, which is always batch.
 */
export const CancelBatchObject = {
  Batch: "batch",
} as const;
/**
 * The object type, which is always batch.
 */
export type CancelBatchObject = ClosedEnum<typeof CancelBatchObject>;

/**
 * Errors associated with the batch.
 */
export type CancelBatchErrors = {};

/**
 * The request counts for different statuses within the batch.
 */
export type CancelBatchRequestCounts = {
  /**
   * Total number of requests in the batch.
   */
  total: number;
  /**
   * Number of requests that have been completed successfully.
   */
  completed: number;
  /**
   * Number of requests that have failed.
   */
  failed: number;
};

/**
 * A list of paginated Batch objects.
 */
export type CancelBatchResponseBody = {
  /**
   * The ID of the batch job.
   */
  id: string;
  /**
   * The object type, which is always batch.
   */
  object: CancelBatchObject;
  /**
   * The OpenAI API endpoint used by the batch.
   */
  endpoint: string;
  /**
   * Errors associated with the batch.
   */
  errors: CancelBatchErrors;
  /**
   * The ID of the input file for the batch.
   */
  inputFileId: string;
  /**
   * The time frame within which the batch should be processed.
   */
  completionWindow: string;
  /**
   * The current status of the batch.
   */
  status: string;
  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  outputFileId: string | null;
  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  errorFileId: string | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  createdAt: number;
  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  inProgressAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expiresAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizingAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completedAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failedAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expiredAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancellingAt: number | null;
  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelledAt: number | null;
  /**
   * The request counts for different statuses within the batch.
   */
  requestCounts: CancelBatchRequestCounts;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format, and querying for objects via API or the dashboard.
   *
   * @remarks
   *
   * Keys are strings with a maximum length of 64 characters. Values are strings with a maximum length of 512 characters.
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CancelBatchRequest$inboundSchema: z.ZodType<
  CancelBatchRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  batch_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "batch_id": "batchId",
  });
});

/** @internal */
export type CancelBatchRequest$Outbound = {
  batch_id: string;
};

/** @internal */
export const CancelBatchRequest$outboundSchema: z.ZodType<
  CancelBatchRequest$Outbound,
  z.ZodTypeDef,
  CancelBatchRequest
> = z.object({
  batchId: z.string(),
}).transform((v) => {
  return remap$(v, {
    batchId: "batch_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelBatchRequest$ {
  /** @deprecated use `CancelBatchRequest$inboundSchema` instead. */
  export const inboundSchema = CancelBatchRequest$inboundSchema;
  /** @deprecated use `CancelBatchRequest$outboundSchema` instead. */
  export const outboundSchema = CancelBatchRequest$outboundSchema;
  /** @deprecated use `CancelBatchRequest$Outbound` instead. */
  export type Outbound = CancelBatchRequest$Outbound;
}

export function cancelBatchRequestToJSON(
  cancelBatchRequest: CancelBatchRequest,
): string {
  return JSON.stringify(
    CancelBatchRequest$outboundSchema.parse(cancelBatchRequest),
  );
}

export function cancelBatchRequestFromJSON(
  jsonString: string,
): SafeParseResult<CancelBatchRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelBatchRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelBatchRequest' from JSON`,
  );
}

/** @internal */
export const CancelBatchObject$inboundSchema: z.ZodNativeEnum<
  typeof CancelBatchObject
> = z.nativeEnum(CancelBatchObject);

/** @internal */
export const CancelBatchObject$outboundSchema: z.ZodNativeEnum<
  typeof CancelBatchObject
> = CancelBatchObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelBatchObject$ {
  /** @deprecated use `CancelBatchObject$inboundSchema` instead. */
  export const inboundSchema = CancelBatchObject$inboundSchema;
  /** @deprecated use `CancelBatchObject$outboundSchema` instead. */
  export const outboundSchema = CancelBatchObject$outboundSchema;
}

/** @internal */
export const CancelBatchErrors$inboundSchema: z.ZodType<
  CancelBatchErrors,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type CancelBatchErrors$Outbound = {};

/** @internal */
export const CancelBatchErrors$outboundSchema: z.ZodType<
  CancelBatchErrors$Outbound,
  z.ZodTypeDef,
  CancelBatchErrors
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelBatchErrors$ {
  /** @deprecated use `CancelBatchErrors$inboundSchema` instead. */
  export const inboundSchema = CancelBatchErrors$inboundSchema;
  /** @deprecated use `CancelBatchErrors$outboundSchema` instead. */
  export const outboundSchema = CancelBatchErrors$outboundSchema;
  /** @deprecated use `CancelBatchErrors$Outbound` instead. */
  export type Outbound = CancelBatchErrors$Outbound;
}

export function cancelBatchErrorsToJSON(
  cancelBatchErrors: CancelBatchErrors,
): string {
  return JSON.stringify(
    CancelBatchErrors$outboundSchema.parse(cancelBatchErrors),
  );
}

export function cancelBatchErrorsFromJSON(
  jsonString: string,
): SafeParseResult<CancelBatchErrors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelBatchErrors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelBatchErrors' from JSON`,
  );
}

/** @internal */
export const CancelBatchRequestCounts$inboundSchema: z.ZodType<
  CancelBatchRequestCounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/** @internal */
export type CancelBatchRequestCounts$Outbound = {
  total: number;
  completed: number;
  failed: number;
};

/** @internal */
export const CancelBatchRequestCounts$outboundSchema: z.ZodType<
  CancelBatchRequestCounts$Outbound,
  z.ZodTypeDef,
  CancelBatchRequestCounts
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelBatchRequestCounts$ {
  /** @deprecated use `CancelBatchRequestCounts$inboundSchema` instead. */
  export const inboundSchema = CancelBatchRequestCounts$inboundSchema;
  /** @deprecated use `CancelBatchRequestCounts$outboundSchema` instead. */
  export const outboundSchema = CancelBatchRequestCounts$outboundSchema;
  /** @deprecated use `CancelBatchRequestCounts$Outbound` instead. */
  export type Outbound = CancelBatchRequestCounts$Outbound;
}

export function cancelBatchRequestCountsToJSON(
  cancelBatchRequestCounts: CancelBatchRequestCounts,
): string {
  return JSON.stringify(
    CancelBatchRequestCounts$outboundSchema.parse(cancelBatchRequestCounts),
  );
}

export function cancelBatchRequestCountsFromJSON(
  jsonString: string,
): SafeParseResult<CancelBatchRequestCounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelBatchRequestCounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelBatchRequestCounts' from JSON`,
  );
}

/** @internal */
export const CancelBatchResponseBody$inboundSchema: z.ZodType<
  CancelBatchResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  object: CancelBatchObject$inboundSchema,
  endpoint: z.string(),
  errors: z.lazy(() => CancelBatchErrors$inboundSchema),
  input_file_id: z.string(),
  completion_window: z.string(),
  status: z.string(),
  output_file_id: z.nullable(z.string()),
  error_file_id: z.nullable(z.string()),
  created_at: z.number().int(),
  in_progress_at: z.nullable(z.number().int()),
  expires_at: z.nullable(z.number().int()),
  finalizing_at: z.nullable(z.number().int()),
  completed_at: z.nullable(z.number().int()),
  failed_at: z.nullable(z.number().int()),
  expired_at: z.nullable(z.number().int()),
  cancelling_at: z.nullable(z.number().int()),
  cancelled_at: z.nullable(z.number().int()),
  request_counts: z.lazy(() => CancelBatchRequestCounts$inboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "input_file_id": "inputFileId",
    "completion_window": "completionWindow",
    "output_file_id": "outputFileId",
    "error_file_id": "errorFileId",
    "created_at": "createdAt",
    "in_progress_at": "inProgressAt",
    "expires_at": "expiresAt",
    "finalizing_at": "finalizingAt",
    "completed_at": "completedAt",
    "failed_at": "failedAt",
    "expired_at": "expiredAt",
    "cancelling_at": "cancellingAt",
    "cancelled_at": "cancelledAt",
    "request_counts": "requestCounts",
  });
});

/** @internal */
export type CancelBatchResponseBody$Outbound = {
  id: string;
  object: string;
  endpoint: string;
  errors: CancelBatchErrors$Outbound;
  input_file_id: string;
  completion_window: string;
  status: string;
  output_file_id: string | null;
  error_file_id: string | null;
  created_at: number;
  in_progress_at: number | null;
  expires_at: number | null;
  finalizing_at: number | null;
  completed_at: number | null;
  failed_at: number | null;
  expired_at: number | null;
  cancelling_at: number | null;
  cancelled_at: number | null;
  request_counts: CancelBatchRequestCounts$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const CancelBatchResponseBody$outboundSchema: z.ZodType<
  CancelBatchResponseBody$Outbound,
  z.ZodTypeDef,
  CancelBatchResponseBody
> = z.object({
  id: z.string(),
  object: CancelBatchObject$outboundSchema,
  endpoint: z.string(),
  errors: z.lazy(() => CancelBatchErrors$outboundSchema),
  inputFileId: z.string(),
  completionWindow: z.string(),
  status: z.string(),
  outputFileId: z.nullable(z.string()),
  errorFileId: z.nullable(z.string()),
  createdAt: z.number().int(),
  inProgressAt: z.nullable(z.number().int()),
  expiresAt: z.nullable(z.number().int()),
  finalizingAt: z.nullable(z.number().int()),
  completedAt: z.nullable(z.number().int()),
  failedAt: z.nullable(z.number().int()),
  expiredAt: z.nullable(z.number().int()),
  cancellingAt: z.nullable(z.number().int()),
  cancelledAt: z.nullable(z.number().int()),
  requestCounts: z.lazy(() => CancelBatchRequestCounts$outboundSchema),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    inputFileId: "input_file_id",
    completionWindow: "completion_window",
    outputFileId: "output_file_id",
    errorFileId: "error_file_id",
    createdAt: "created_at",
    inProgressAt: "in_progress_at",
    expiresAt: "expires_at",
    finalizingAt: "finalizing_at",
    completedAt: "completed_at",
    failedAt: "failed_at",
    expiredAt: "expired_at",
    cancellingAt: "cancelling_at",
    cancelledAt: "cancelled_at",
    requestCounts: "request_counts",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CancelBatchResponseBody$ {
  /** @deprecated use `CancelBatchResponseBody$inboundSchema` instead. */
  export const inboundSchema = CancelBatchResponseBody$inboundSchema;
  /** @deprecated use `CancelBatchResponseBody$outboundSchema` instead. */
  export const outboundSchema = CancelBatchResponseBody$outboundSchema;
  /** @deprecated use `CancelBatchResponseBody$Outbound` instead. */
  export type Outbound = CancelBatchResponseBody$Outbound;
}

export function cancelBatchResponseBodyToJSON(
  cancelBatchResponseBody: CancelBatchResponseBody,
): string {
  return JSON.stringify(
    CancelBatchResponseBody$outboundSchema.parse(cancelBatchResponseBody),
  );
}

export function cancelBatchResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CancelBatchResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CancelBatchResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CancelBatchResponseBody' from JSON`,
  );
}
