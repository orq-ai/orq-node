/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The role of the prompt message
 */
export const Role = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type Role = ClosedEnum<typeof Role>;

export type FileT = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Three = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: FileT;
};

export type ImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type Two2 = {
  type: "image_url";
  imageUrl: ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type One = {
  type: "text";
  text: string;
};

export type Two = One | Two2 | Three;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type Content = string | Array<One | Two2 | Three>;

export const InvokeEvalType = {
  Function: "function",
} as const;
export type InvokeEvalType = ClosedEnum<typeof InvokeEvalType>;

export type FunctionT = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type ToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: InvokeEvalType;
  function: FunctionT;
};

export type Messages = {
  /**
   * The role of the prompt message
   */
  role: Role;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content: string | Array<One | Two2 | Three> | null;
  toolCalls?: Array<ToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

export type InvokeEvalRequestBody = {
  /**
   * Latest user message
   */
  query?: string | undefined;
  /**
   * The generated response from the model
   */
  output?: string | undefined;
  /**
   * The reference used to compare the output
   */
  reference?: string | undefined;
  /**
   * Knowledge base retrievals
   */
  retrievals?: Array<string> | undefined;
  /**
   * The messages used to generate the output, without the last user message
   */
  messages?: Array<Messages> | undefined;
  /**
   * Model to use for LLM-based evaluators (e.g. "openai/gpt-4o")
   */
  model?: string | undefined;
};

export type InvokeEvalRequest = {
  /**
   * Evaluator ID
   */
  id: string;
  requestBody?: InvokeEvalRequestBody | undefined;
};

export type InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue =
  | number
  | boolean;

export type InvokeEvalResponseBodyEvalsResponse200Value = {
  type: string;
  value: number | boolean;
};

export type InvokeEvalResponseBodyHTTP = {
  type: "http_eval";
  value?: InvokeEvalResponseBodyEvalsResponse200Value | null | undefined;
};

export type InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value =
  | number
  | boolean
  | string;

export type OriginalValue = number | boolean | string;

export type InvokeEvalResponseBodyEvalsResponseValue = {
  workflowRunId: string;
  value: number | boolean | string | null;
  explanation?: string | null | undefined;
  originalValue?: number | boolean | string | null | undefined;
  originalExplanation?: string | null | undefined;
};

export type InvokeEvalResponseBodyLLM = {
  type: "llm_evaluator";
  value: InvokeEvalResponseBodyEvalsResponseValue | null;
};

export type InvokeEvalResponseBodyEvalsValue = {
  f1: number;
  precision: number;
  recall: number;
};

export type BERTScore = {
  type: "bert_score";
  value: InvokeEvalResponseBodyEvalsValue;
};

export type Rouge1 = {
  f1: number;
  precision: number;
  recall: number;
};

export type Rouge2 = {
  f1: number;
  precision: number;
  recall: number;
};

export type RougeL = {
  f1: number;
  precision: number;
  recall: number;
};

export type InvokeEvalResponseBodyValue = {
  rouge1: Rouge1;
  rouge2: Rouge2;
  rougeL: RougeL;
};

export type RougeN = {
  type: "rouge_n";
  value: InvokeEvalResponseBodyValue;
};

export type StringArray = {
  type: "string_array";
  values: Array<string | null>;
};

export type ResponseBodyValue = boolean | string | number;

export type ResponseBodyBoolean = {
  type: "boolean";
  value: boolean | string | number | null;
};

export const FormatOptionsStyle = {
  Currency: "currency",
} as const;
export type FormatOptionsStyle = ClosedEnum<typeof FormatOptionsStyle>;

export const Currency = {
  Usd: "USD",
} as const;
export type Currency = ClosedEnum<typeof Currency>;

export type FormatOptions2 = {
  style: FormatOptionsStyle;
  currency: Currency;
};

export type FormatOptions1 = {
  significantDigits: number;
};

export type FormatOptions = FormatOptions2 | FormatOptions1;

export type ResponseBodyNumber = {
  type: "number";
  originalValue?: number | null | undefined;
  value: number | null;
  formatOptions?: FormatOptions2 | FormatOptions1 | undefined;
};

export type String = {
  type: "string";
  originalValue?: string | null | undefined;
  value?: string | null | undefined;
};

/**
 * Returns the result of the evaluator run
 */
export type InvokeEvalResponseBody =
  | String
  | ResponseBodyNumber
  | ResponseBodyBoolean
  | StringArray
  | RougeN
  | BERTScore
  | InvokeEvalResponseBodyLLM
  | InvokeEvalResponseBodyHTTP;

/** @internal */
export const Role$outboundSchema: z.ZodNativeEnum<typeof Role> = z.nativeEnum(
  Role,
);

/** @internal */
export type FileT$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

/** @internal */
export type Three$Outbound = {
  type: "file";
  file: FileT$Outbound;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<
  Three$Outbound,
  z.ZodTypeDef,
  Three
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => FileT$outboundSchema),
});

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

/** @internal */
export type Two2$Outbound = {
  type: "image_url";
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const Two2$outboundSchema: z.ZodType<Two2$Outbound, z.ZodTypeDef, Two2> =
  z.object({
    type: z.literal("image_url"),
    imageUrl: z.lazy(() => ImageUrl$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      imageUrl: "image_url",
    });
  });

export function two2ToJSON(two2: Two2): string {
  return JSON.stringify(Two2$outboundSchema.parse(two2));
}

/** @internal */
export type One$Outbound = {
  type: "text";
  text: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: z.literal("text"),
    text: z.string(),
  });

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

/** @internal */
export type Two$Outbound = One$Outbound | Two2$Outbound | Three$Outbound;

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .union([
    z.lazy(() => One$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Three$outboundSchema),
  ]);

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

/** @internal */
export type Content$Outbound =
  | string
  | Array<One$Outbound | Two2$Outbound | Three$Outbound>;

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => One$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Three$outboundSchema),
  ])),
]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

/** @internal */
export const InvokeEvalType$outboundSchema: z.ZodNativeEnum<
  typeof InvokeEvalType
> = z.nativeEnum(InvokeEvalType);

/** @internal */
export type FunctionT$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const FunctionT$outboundSchema: z.ZodType<
  FunctionT$Outbound,
  z.ZodTypeDef,
  FunctionT
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function functionToJSON(functionT: FunctionT): string {
  return JSON.stringify(FunctionT$outboundSchema.parse(functionT));
}

/** @internal */
export type ToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: FunctionT$Outbound;
};

/** @internal */
export const ToolCalls$outboundSchema: z.ZodType<
  ToolCalls$Outbound,
  z.ZodTypeDef,
  ToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: InvokeEvalType$outboundSchema,
  function: z.lazy(() => FunctionT$outboundSchema),
});

export function toolCallsToJSON(toolCalls: ToolCalls): string {
  return JSON.stringify(ToolCalls$outboundSchema.parse(toolCalls));
}

/** @internal */
export type Messages$Outbound = {
  role: string;
  content: string | Array<One$Outbound | Two2$Outbound | Three$Outbound> | null;
  tool_calls?: Array<ToolCalls$Outbound> | undefined;
  tool_call_id?: string | null | undefined;
};

/** @internal */
export const Messages$outboundSchema: z.ZodType<
  Messages$Outbound,
  z.ZodTypeDef,
  Messages
> = z.object({
  role: Role$outboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => One$outboundSchema),
        z.lazy(() => Two2$outboundSchema),
        z.lazy(() => Three$outboundSchema),
      ])),
    ]),
  ),
  toolCalls: z.array(z.lazy(() => ToolCalls$outboundSchema)).optional(),
  toolCallId: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    toolCallId: "tool_call_id",
  });
});

export function messagesToJSON(messages: Messages): string {
  return JSON.stringify(Messages$outboundSchema.parse(messages));
}

/** @internal */
export type InvokeEvalRequestBody$Outbound = {
  query?: string | undefined;
  output?: string | undefined;
  reference?: string | undefined;
  retrievals?: Array<string> | undefined;
  messages?: Array<Messages$Outbound> | undefined;
  model?: string | undefined;
};

/** @internal */
export const InvokeEvalRequestBody$outboundSchema: z.ZodType<
  InvokeEvalRequestBody$Outbound,
  z.ZodTypeDef,
  InvokeEvalRequestBody
> = z.object({
  query: z.string().optional(),
  output: z.string().optional(),
  reference: z.string().optional(),
  retrievals: z.array(z.string()).optional(),
  messages: z.array(z.lazy(() => Messages$outboundSchema)).optional(),
  model: z.string().optional(),
});

export function invokeEvalRequestBodyToJSON(
  invokeEvalRequestBody: InvokeEvalRequestBody,
): string {
  return JSON.stringify(
    InvokeEvalRequestBody$outboundSchema.parse(invokeEvalRequestBody),
  );
}

/** @internal */
export type InvokeEvalRequest$Outbound = {
  id: string;
  RequestBody?: InvokeEvalRequestBody$Outbound | undefined;
};

/** @internal */
export const InvokeEvalRequest$outboundSchema: z.ZodType<
  InvokeEvalRequest$Outbound,
  z.ZodTypeDef,
  InvokeEvalRequest
> = z.object({
  id: z.string(),
  requestBody: z.lazy(() => InvokeEvalRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function invokeEvalRequestToJSON(
  invokeEvalRequest: InvokeEvalRequest,
): string {
  return JSON.stringify(
    InvokeEvalRequest$outboundSchema.parse(invokeEvalRequest),
  );
}

/** @internal */
export const InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue$inboundSchema:
  z.ZodType<
    InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue,
    z.ZodTypeDef,
    unknown
  > = z.union([z.number(), z.boolean()]);

export function invokeEvalResponseBodyEvalsResponse200ApplicationJSONValueFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyEvalsResponse200ApplicationJSONValue' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyEvalsResponse200Value$inboundSchema:
  z.ZodType<
    InvokeEvalResponseBodyEvalsResponse200Value,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.string(),
    value: z.union([z.number(), z.boolean()]),
  });

export function invokeEvalResponseBodyEvalsResponse200ValueFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeEvalResponseBodyEvalsResponse200Value,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeEvalResponseBodyEvalsResponse200Value$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InvokeEvalResponseBodyEvalsResponse200Value' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyHTTP$inboundSchema: z.ZodType<
  InvokeEvalResponseBodyHTTP,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("http_eval"),
  value: z.nullable(
    z.lazy(() => InvokeEvalResponseBodyEvalsResponse200Value$inboundSchema),
  ).optional(),
});

export function invokeEvalResponseBodyHTTPFromJSON(
  jsonString: string,
): SafeParseResult<InvokeEvalResponseBodyHTTP, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeEvalResponseBodyHTTP$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyHTTP' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value$inboundSchema:
  z.ZodType<
    InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value,
    z.ZodTypeDef,
    unknown
  > = z.union([z.number(), z.boolean(), z.string()]);

export function invokeEvalResponseBodyEvalsResponse200ApplicationJSON7ValueFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyEvalsResponse200ApplicationJson7Value' from JSON`,
  );
}

/** @internal */
export const OriginalValue$inboundSchema: z.ZodType<
  OriginalValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), z.boolean(), z.string()]);

export function originalValueFromJSON(
  jsonString: string,
): SafeParseResult<OriginalValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OriginalValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OriginalValue' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyEvalsResponseValue$inboundSchema: z.ZodType<
  InvokeEvalResponseBodyEvalsResponseValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  workflow_run_id: z.string(),
  value: z.nullable(z.union([z.number(), z.boolean(), z.string()])),
  explanation: z.nullable(z.string()).optional(),
  original_value: z.nullable(z.union([z.number(), z.boolean(), z.string()]))
    .optional(),
  original_explanation: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "workflow_run_id": "workflowRunId",
    "original_value": "originalValue",
    "original_explanation": "originalExplanation",
  });
});

export function invokeEvalResponseBodyEvalsResponseValueFromJSON(
  jsonString: string,
): SafeParseResult<
  InvokeEvalResponseBodyEvalsResponseValue,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      InvokeEvalResponseBodyEvalsResponseValue$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'InvokeEvalResponseBodyEvalsResponseValue' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyLLM$inboundSchema: z.ZodType<
  InvokeEvalResponseBodyLLM,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("llm_evaluator"),
  value: z.nullable(
    z.lazy(() => InvokeEvalResponseBodyEvalsResponseValue$inboundSchema),
  ),
});

export function invokeEvalResponseBodyLLMFromJSON(
  jsonString: string,
): SafeParseResult<InvokeEvalResponseBodyLLM, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeEvalResponseBodyLLM$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyLLM' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyEvalsValue$inboundSchema: z.ZodType<
  InvokeEvalResponseBodyEvalsValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  f1: z.number(),
  precision: z.number(),
  recall: z.number(),
});

export function invokeEvalResponseBodyEvalsValueFromJSON(
  jsonString: string,
): SafeParseResult<InvokeEvalResponseBodyEvalsValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeEvalResponseBodyEvalsValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyEvalsValue' from JSON`,
  );
}

/** @internal */
export const BERTScore$inboundSchema: z.ZodType<
  BERTScore,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("bert_score"),
  value: z.lazy(() => InvokeEvalResponseBodyEvalsValue$inboundSchema),
});

export function bertScoreFromJSON(
  jsonString: string,
): SafeParseResult<BERTScore, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BERTScore$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BERTScore' from JSON`,
  );
}

/** @internal */
export const Rouge1$inboundSchema: z.ZodType<Rouge1, z.ZodTypeDef, unknown> = z
  .object({
    f1: z.number(),
    precision: z.number(),
    recall: z.number(),
  });

export function rouge1FromJSON(
  jsonString: string,
): SafeParseResult<Rouge1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rouge1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rouge1' from JSON`,
  );
}

/** @internal */
export const Rouge2$inboundSchema: z.ZodType<Rouge2, z.ZodTypeDef, unknown> = z
  .object({
    f1: z.number(),
    precision: z.number(),
    recall: z.number(),
  });

export function rouge2FromJSON(
  jsonString: string,
): SafeParseResult<Rouge2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Rouge2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Rouge2' from JSON`,
  );
}

/** @internal */
export const RougeL$inboundSchema: z.ZodType<RougeL, z.ZodTypeDef, unknown> = z
  .object({
    f1: z.number(),
    precision: z.number(),
    recall: z.number(),
  });

export function rougeLFromJSON(
  jsonString: string,
): SafeParseResult<RougeL, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RougeL$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RougeL' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBodyValue$inboundSchema: z.ZodType<
  InvokeEvalResponseBodyValue,
  z.ZodTypeDef,
  unknown
> = z.object({
  rouge_1: z.lazy(() => Rouge1$inboundSchema),
  rouge_2: z.lazy(() => Rouge2$inboundSchema),
  rouge_l: z.lazy(() => RougeL$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "rouge_1": "rouge1",
    "rouge_2": "rouge2",
    "rouge_l": "rougeL",
  });
});

export function invokeEvalResponseBodyValueFromJSON(
  jsonString: string,
): SafeParseResult<InvokeEvalResponseBodyValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeEvalResponseBodyValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBodyValue' from JSON`,
  );
}

/** @internal */
export const RougeN$inboundSchema: z.ZodType<RougeN, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("rouge_n"),
    value: z.lazy(() => InvokeEvalResponseBodyValue$inboundSchema),
  });

export function rougeNFromJSON(
  jsonString: string,
): SafeParseResult<RougeN, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RougeN$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RougeN' from JSON`,
  );
}

/** @internal */
export const StringArray$inboundSchema: z.ZodType<
  StringArray,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("string_array"),
  values: z.array(z.nullable(z.string())),
});

export function stringArrayFromJSON(
  jsonString: string,
): SafeParseResult<StringArray, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StringArray$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StringArray' from JSON`,
  );
}

/** @internal */
export const ResponseBodyValue$inboundSchema: z.ZodType<
  ResponseBodyValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.boolean(), z.string(), z.number()]);

export function responseBodyValueFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyValue' from JSON`,
  );
}

/** @internal */
export const ResponseBodyBoolean$inboundSchema: z.ZodType<
  ResponseBodyBoolean,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("boolean"),
  value: z.nullable(z.union([z.boolean(), z.string(), z.number()])),
});

export function responseBodyBooleanFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyBoolean, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyBoolean$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyBoolean' from JSON`,
  );
}

/** @internal */
export const FormatOptionsStyle$inboundSchema: z.ZodNativeEnum<
  typeof FormatOptionsStyle
> = z.nativeEnum(FormatOptionsStyle);

/** @internal */
export const Currency$inboundSchema: z.ZodNativeEnum<typeof Currency> = z
  .nativeEnum(Currency);

/** @internal */
export const FormatOptions2$inboundSchema: z.ZodType<
  FormatOptions2,
  z.ZodTypeDef,
  unknown
> = z.object({
  style: FormatOptionsStyle$inboundSchema,
  currency: Currency$inboundSchema,
});

export function formatOptions2FromJSON(
  jsonString: string,
): SafeParseResult<FormatOptions2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatOptions2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatOptions2' from JSON`,
  );
}

/** @internal */
export const FormatOptions1$inboundSchema: z.ZodType<
  FormatOptions1,
  z.ZodTypeDef,
  unknown
> = z.object({
  significant_digits: z.number(),
}).transform((v) => {
  return remap$(v, {
    "significant_digits": "significantDigits",
  });
});

export function formatOptions1FromJSON(
  jsonString: string,
): SafeParseResult<FormatOptions1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatOptions1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatOptions1' from JSON`,
  );
}

/** @internal */
export const FormatOptions$inboundSchema: z.ZodType<
  FormatOptions,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => FormatOptions2$inboundSchema),
  z.lazy(() => FormatOptions1$inboundSchema),
]);

export function formatOptionsFromJSON(
  jsonString: string,
): SafeParseResult<FormatOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FormatOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FormatOptions' from JSON`,
  );
}

/** @internal */
export const ResponseBodyNumber$inboundSchema: z.ZodType<
  ResponseBodyNumber,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("number"),
  original_value: z.nullable(z.number()).optional(),
  value: z.nullable(z.number()),
  format_options: z.union([
    z.lazy(() => FormatOptions2$inboundSchema),
    z.lazy(() => FormatOptions1$inboundSchema),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "original_value": "originalValue",
    "format_options": "formatOptions",
  });
});

export function responseBodyNumberFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyNumber, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyNumber$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyNumber' from JSON`,
  );
}

/** @internal */
export const String$inboundSchema: z.ZodType<String, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("string"),
    original_value: z.nullable(z.string()).optional(),
    value: z.nullable(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "original_value": "originalValue",
    });
  });

export function stringFromJSON(
  jsonString: string,
): SafeParseResult<String, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => String$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'String' from JSON`,
  );
}

/** @internal */
export const InvokeEvalResponseBody$inboundSchema: z.ZodType<
  InvokeEvalResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => String$inboundSchema),
  z.lazy(() => ResponseBodyNumber$inboundSchema),
  z.lazy(() => ResponseBodyBoolean$inboundSchema),
  z.lazy(() => StringArray$inboundSchema),
  z.lazy(() => RougeN$inboundSchema),
  z.lazy(() => BERTScore$inboundSchema),
  z.lazy(() => InvokeEvalResponseBodyLLM$inboundSchema),
  z.lazy(() => InvokeEvalResponseBodyHTTP$inboundSchema),
]);

export function invokeEvalResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<InvokeEvalResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeEvalResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeEvalResponseBody' from JSON`,
  );
}
