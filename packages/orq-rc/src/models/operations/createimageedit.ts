/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The quality of the image that will be generated. Auto will automatically select the best quality for the given model.
 */
export const CreateImageEditQuality = {
  Auto: "auto",
  High: "high",
  Medium: "medium",
  Low: "low",
  Standard: "standard",
} as const;
/**
 * The quality of the image that will be generated. Auto will automatically select the best quality for the given model.
 */
export type CreateImageEditQuality = ClosedEnum<typeof CreateImageEditQuality>;

/**
 * The format in which the generated images are returned. Some of the models only return the image in base64 format.
 */
export const CreateImageEditResponseFormat = {
  Url: "url",
  B64Json: "b64_json",
} as const;
/**
 * The format in which the generated images are returned. Some of the models only return the image in base64 format.
 */
export type CreateImageEditResponseFormat = ClosedEnum<
  typeof CreateImageEditResponseFormat
>;

/**
 * Retry configuration for the request
 */
export type CreateImageEditRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateImageEditFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export const CreateImageEditVersion = {
  Latest: "latest",
} as const;
/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export type CreateImageEditVersion = ClosedEnum<typeof CreateImageEditVersion>;

/**
 * Prompt configuration for the request
 */
export type CreateImageEditPrompt = {
  /**
   * Unique identifier of the prompt to use
   */
  id: string;
  /**
   * Version of the prompt to use (currently only "latest" supported)
   */
  version: CreateImageEditVersion;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateImageEditContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

export const CreateImageEditType = {
  ExactMatch: "exact_match",
} as const;
export type CreateImageEditType = ClosedEnum<typeof CreateImageEditType>;

/**
 * Cache configuration for the request.
 */
export type CreateImageEditCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateImageEditType;
};

export const CreateImageEditLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateImageEditLoadBalancerType = ClosedEnum<
  typeof CreateImageEditLoadBalancerType
>;

export type CreateImageEditLoadBalancer1 = {
  type: CreateImageEditLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateImageEditLoadBalancer = CreateImageEditLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateImageEditTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateImageEditOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateImageEditRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateImageEditFallbacks> | undefined;
  /**
   * Prompt configuration for the request
   */
  prompt?: CreateImageEditPrompt | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateImageEditContact | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateImageEditCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<CreateImageEditLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateImageEditTimeout | undefined;
};

export type CreateImageEditRequestBody = {
  /**
   * The model to use for image edit. [Check models](https://docs.orq.ai/docs/ai-gateway-supported-models#image-models)
   */
  model: string;
  /**
   * The image(s) to edit. Must be a supported image file or an array of images.  Each image should be a png, webp, or jpg file less than 50MB. You can provide up to 16 images.
   */
  image?: any | undefined;
  /**
   * A text description of the desired image(s).
   */
  prompt: string;
  /**
   * The number of images to generate. Must be between 1 and 10.
   */
  n?: number | null | undefined;
  /**
   * The size of the generated images
   */
  size?: string | null | undefined;
  /**
   * The quality of the image that will be generated. Auto will automatically select the best quality for the given model.
   */
  quality?: CreateImageEditQuality | null | undefined;
  /**
   * The format in which the generated images are returned. Some of the models only return the image in base64 format.
   */
  responseFormat?: CreateImageEditResponseFormat | undefined;
  /**
   * A unique identifier representing your end-user, which can help to monitor and detect abuse.
   */
  user?: string | undefined;
  orq?: CreateImageEditOrq | undefined;
};

export type CreateImageEditData = {
  /**
   * The base64-encoded JSON of the generated image, if response_format is b64_json
   */
  b64Json?: string | undefined;
  /**
   * The URL of the generated image, if response_format is url (default)
   */
  url?: string | undefined;
};

/**
 * The input tokens detailed information for the image generation.
 */
export type CreateImageEditInputTokensDetails = {
  /**
   * The number of text tokens in the input prompt.
   */
  textTokens: number;
  /**
   * The number of image tokens in the input prompt.
   */
  imageTokens: number;
};

/**
 * The token usage information for the image generation.
 */
export type CreateImageEditUsage = {
  /**
   * The total number of tokens (images and text) used for the image generation.
   */
  totalTokens: number;
  /**
   * The number of tokens (images and text) in the input prompt.
   */
  inputTokens: number;
  /**
   * The number of output tokens generated by the model.
   */
  outputTokens: number;
  /**
   * The input tokens detailed information for the image generation.
   */
  inputTokensDetails: CreateImageEditInputTokensDetails;
};

/**
 * Represents an image edit response from the API.
 */
export type CreateImageEditResponseBody = {
  /**
   * The Unix timestamp (in seconds) of when the image was created.
   */
  created: number;
  /**
   * The output format of the image generation
   */
  outputFormat?: string | undefined;
  /**
   * The size of the image generated
   */
  size?: string | undefined;
  /**
   * The quality of the image generated
   */
  quality?: string | undefined;
  /**
   * The list of generated images.
   */
  data: Array<CreateImageEditData>;
  /**
   * The token usage information for the image generation.
   */
  usage?: CreateImageEditUsage | undefined;
};

/** @internal */
export const CreateImageEditQuality$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageEditQuality
> = z.nativeEnum(CreateImageEditQuality);

/** @internal */
export const CreateImageEditResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageEditResponseFormat
> = z.nativeEnum(CreateImageEditResponseFormat);

/** @internal */
export type CreateImageEditRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateImageEditRetry$outboundSchema: z.ZodType<
  CreateImageEditRetry$Outbound,
  z.ZodTypeDef,
  CreateImageEditRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createImageEditRetryToJSON(
  createImageEditRetry: CreateImageEditRetry,
): string {
  return JSON.stringify(
    CreateImageEditRetry$outboundSchema.parse(createImageEditRetry),
  );
}

/** @internal */
export type CreateImageEditFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateImageEditFallbacks$outboundSchema: z.ZodType<
  CreateImageEditFallbacks$Outbound,
  z.ZodTypeDef,
  CreateImageEditFallbacks
> = z.object({
  model: z.string(),
});

export function createImageEditFallbacksToJSON(
  createImageEditFallbacks: CreateImageEditFallbacks,
): string {
  return JSON.stringify(
    CreateImageEditFallbacks$outboundSchema.parse(createImageEditFallbacks),
  );
}

/** @internal */
export const CreateImageEditVersion$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageEditVersion
> = z.nativeEnum(CreateImageEditVersion);

/** @internal */
export type CreateImageEditPrompt$Outbound = {
  id: string;
  version: string;
};

/** @internal */
export const CreateImageEditPrompt$outboundSchema: z.ZodType<
  CreateImageEditPrompt$Outbound,
  z.ZodTypeDef,
  CreateImageEditPrompt
> = z.object({
  id: z.string(),
  version: CreateImageEditVersion$outboundSchema,
});

export function createImageEditPromptToJSON(
  createImageEditPrompt: CreateImageEditPrompt,
): string {
  return JSON.stringify(
    CreateImageEditPrompt$outboundSchema.parse(createImageEditPrompt),
  );
}

/** @internal */
export type CreateImageEditContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateImageEditContact$outboundSchema: z.ZodType<
  CreateImageEditContact$Outbound,
  z.ZodTypeDef,
  CreateImageEditContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createImageEditContactToJSON(
  createImageEditContact: CreateImageEditContact,
): string {
  return JSON.stringify(
    CreateImageEditContact$outboundSchema.parse(createImageEditContact),
  );
}

/** @internal */
export const CreateImageEditType$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageEditType
> = z.nativeEnum(CreateImageEditType);

/** @internal */
export type CreateImageEditCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateImageEditCache$outboundSchema: z.ZodType<
  CreateImageEditCache$Outbound,
  z.ZodTypeDef,
  CreateImageEditCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateImageEditType$outboundSchema,
});

export function createImageEditCacheToJSON(
  createImageEditCache: CreateImageEditCache,
): string {
  return JSON.stringify(
    CreateImageEditCache$outboundSchema.parse(createImageEditCache),
  );
}

/** @internal */
export const CreateImageEditLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageEditLoadBalancerType
> = z.nativeEnum(CreateImageEditLoadBalancerType);

/** @internal */
export type CreateImageEditLoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const CreateImageEditLoadBalancer1$outboundSchema: z.ZodType<
  CreateImageEditLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateImageEditLoadBalancer1
> = z.object({
  type: CreateImageEditLoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createImageEditLoadBalancer1ToJSON(
  createImageEditLoadBalancer1: CreateImageEditLoadBalancer1,
): string {
  return JSON.stringify(
    CreateImageEditLoadBalancer1$outboundSchema.parse(
      createImageEditLoadBalancer1,
    ),
  );
}

/** @internal */
export type CreateImageEditLoadBalancer$Outbound =
  CreateImageEditLoadBalancer1$Outbound;

/** @internal */
export const CreateImageEditLoadBalancer$outboundSchema: z.ZodType<
  CreateImageEditLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateImageEditLoadBalancer
> = z.lazy(() => CreateImageEditLoadBalancer1$outboundSchema);

export function createImageEditLoadBalancerToJSON(
  createImageEditLoadBalancer: CreateImageEditLoadBalancer,
): string {
  return JSON.stringify(
    CreateImageEditLoadBalancer$outboundSchema.parse(
      createImageEditLoadBalancer,
    ),
  );
}

/** @internal */
export type CreateImageEditTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateImageEditTimeout$outboundSchema: z.ZodType<
  CreateImageEditTimeout$Outbound,
  z.ZodTypeDef,
  CreateImageEditTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createImageEditTimeoutToJSON(
  createImageEditTimeout: CreateImageEditTimeout,
): string {
  return JSON.stringify(
    CreateImageEditTimeout$outboundSchema.parse(createImageEditTimeout),
  );
}

/** @internal */
export type CreateImageEditOrq$Outbound = {
  name?: string | undefined;
  retry?: CreateImageEditRetry$Outbound | undefined;
  fallbacks?: Array<CreateImageEditFallbacks$Outbound> | undefined;
  prompt?: CreateImageEditPrompt$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateImageEditContact$Outbound | undefined;
  cache?: CreateImageEditCache$Outbound | undefined;
  load_balancer?: Array<CreateImageEditLoadBalancer1$Outbound> | undefined;
  timeout?: CreateImageEditTimeout$Outbound | undefined;
};

/** @internal */
export const CreateImageEditOrq$outboundSchema: z.ZodType<
  CreateImageEditOrq$Outbound,
  z.ZodTypeDef,
  CreateImageEditOrq
> = z.object({
  name: z.string().optional(),
  retry: z.lazy(() => CreateImageEditRetry$outboundSchema).optional(),
  fallbacks: z.array(z.lazy(() => CreateImageEditFallbacks$outboundSchema))
    .optional(),
  prompt: z.lazy(() => CreateImageEditPrompt$outboundSchema).optional(),
  identity: components.PublicContact$outboundSchema.optional(),
  contact: z.lazy(() => CreateImageEditContact$outboundSchema).optional(),
  cache: z.lazy(() => CreateImageEditCache$outboundSchema).optional(),
  loadBalancer: z.array(
    z.lazy(() => CreateImageEditLoadBalancer1$outboundSchema),
  ).optional(),
  timeout: z.lazy(() => CreateImageEditTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createImageEditOrqToJSON(
  createImageEditOrq: CreateImageEditOrq,
): string {
  return JSON.stringify(
    CreateImageEditOrq$outboundSchema.parse(createImageEditOrq),
  );
}

/** @internal */
export type CreateImageEditRequestBody$Outbound = {
  model: string;
  image?: any | undefined;
  prompt: string;
  n: number | null;
  size?: string | null | undefined;
  quality?: string | null | undefined;
  response_format?: string | undefined;
  user?: string | undefined;
  orq?: CreateImageEditOrq$Outbound | undefined;
};

/** @internal */
export const CreateImageEditRequestBody$outboundSchema: z.ZodType<
  CreateImageEditRequestBody$Outbound,
  z.ZodTypeDef,
  CreateImageEditRequestBody
> = z.object({
  model: z.string(),
  image: z.any().optional(),
  prompt: z.string(),
  n: z.nullable(z.number().int().default(1)),
  size: z.nullable(z.string()).optional(),
  quality: z.nullable(CreateImageEditQuality$outboundSchema).optional(),
  responseFormat: CreateImageEditResponseFormat$outboundSchema.optional(),
  user: z.string().optional(),
  orq: z.lazy(() => CreateImageEditOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    responseFormat: "response_format",
  });
});

export function createImageEditRequestBodyToJSON(
  createImageEditRequestBody: CreateImageEditRequestBody,
): string {
  return JSON.stringify(
    CreateImageEditRequestBody$outboundSchema.parse(createImageEditRequestBody),
  );
}

/** @internal */
export const CreateImageEditData$inboundSchema: z.ZodType<
  CreateImageEditData,
  z.ZodTypeDef,
  unknown
> = z.object({
  b64_json: z.string().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "b64_json": "b64Json",
  });
});

export function createImageEditDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageEditData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageEditData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageEditData' from JSON`,
  );
}

/** @internal */
export const CreateImageEditInputTokensDetails$inboundSchema: z.ZodType<
  CreateImageEditInputTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  text_tokens: z.number(),
  image_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "text_tokens": "textTokens",
    "image_tokens": "imageTokens",
  });
});

export function createImageEditInputTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageEditInputTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageEditInputTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageEditInputTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateImageEditUsage$inboundSchema: z.ZodType<
  CreateImageEditUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_tokens: z.number(),
  input_tokens: z.number(),
  output_tokens: z.number(),
  input_tokens_details: z.lazy(() =>
    CreateImageEditInputTokensDetails$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "total_tokens": "totalTokens",
    "input_tokens": "inputTokens",
    "output_tokens": "outputTokens",
    "input_tokens_details": "inputTokensDetails",
  });
});

export function createImageEditUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageEditUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageEditUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageEditUsage' from JSON`,
  );
}

/** @internal */
export const CreateImageEditResponseBody$inboundSchema: z.ZodType<
  CreateImageEditResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  created: z.number(),
  output_format: z.string().optional(),
  size: z.string().optional(),
  quality: z.string().optional(),
  data: z.array(z.lazy(() => CreateImageEditData$inboundSchema)),
  usage: z.lazy(() => CreateImageEditUsage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "output_format": "outputFormat",
  });
});

export function createImageEditResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageEditResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageEditResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageEditResponseBody' from JSON`,
  );
}
