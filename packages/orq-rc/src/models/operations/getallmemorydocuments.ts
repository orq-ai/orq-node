/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAllMemoryDocumentsRequest = {
  /**
   * The unique key identifier of the memory store
   */
  memoryStoreKey: string;
  /**
   * The unique identifier of the memory
   */
  memoryEntityId: string;
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
  /**
   * Filter documents updated after this ISO datetime
   */
  updatedAfter?: Date | undefined;
  /**
   * Filter documents updated before this ISO datetime
   */
  updatedBefore?: Date | undefined;
};

export const GetAllMemoryDocumentsObject = {
  List: "list",
} as const;
export type GetAllMemoryDocumentsObject = ClosedEnum<
  typeof GetAllMemoryDocumentsObject
>;

export type GetAllMemoryDocumentsData = {
  id: string;
  memoryId: string;
  storeId: string;
  /**
   * The content of the memory document (whitespace trimmed).
   */
  text: string;
  created: string;
  updated: string;
  createdById?: string | undefined;
  updatedById?: string | undefined;
  workspaceId: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization. Clients can add arbitrary string metadata to enable future filtering of memory documents based on their specific needs (e.g., document type, source, topic, relevance score, or any custom taxonomy).
   */
  metadata?: { [k: string]: string } | undefined;
};

/**
 * Successfully retrieved the list of memory documents.
 */
export type GetAllMemoryDocumentsResponseBody = {
  object: GetAllMemoryDocumentsObject;
  data: Array<GetAllMemoryDocumentsData>;
  hasMore: boolean;
};

/** @internal */
export type GetAllMemoryDocumentsRequest$Outbound = {
  memory_store_key: string;
  memory_entity_id: string;
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
  updated_after?: string | undefined;
  updated_before?: string | undefined;
};

/** @internal */
export const GetAllMemoryDocumentsRequest$outboundSchema: z.ZodType<
  GetAllMemoryDocumentsRequest$Outbound,
  z.ZodTypeDef,
  GetAllMemoryDocumentsRequest
> = z.object({
  memoryStoreKey: z.string(),
  memoryEntityId: z.string(),
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
  updatedAfter: z.date().transform(v => v.toISOString()).optional(),
  updatedBefore: z.date().transform(v => v.toISOString()).optional(),
}).transform((v) => {
  return remap$(v, {
    memoryStoreKey: "memory_store_key",
    memoryEntityId: "memory_entity_id",
    startingAfter: "starting_after",
    endingBefore: "ending_before",
    updatedAfter: "updated_after",
    updatedBefore: "updated_before",
  });
});

export function getAllMemoryDocumentsRequestToJSON(
  getAllMemoryDocumentsRequest: GetAllMemoryDocumentsRequest,
): string {
  return JSON.stringify(
    GetAllMemoryDocumentsRequest$outboundSchema.parse(
      getAllMemoryDocumentsRequest,
    ),
  );
}

/** @internal */
export const GetAllMemoryDocumentsObject$inboundSchema: z.ZodNativeEnum<
  typeof GetAllMemoryDocumentsObject
> = z.nativeEnum(GetAllMemoryDocumentsObject);

/** @internal */
export const GetAllMemoryDocumentsData$inboundSchema: z.ZodType<
  GetAllMemoryDocumentsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  memory_id: z.string(),
  store_id: z.string(),
  text: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  workspace_id: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "memory_id": "memoryId",
    "store_id": "storeId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "workspace_id": "workspaceId",
  });
});

export function getAllMemoryDocumentsDataFromJSON(
  jsonString: string,
): SafeParseResult<GetAllMemoryDocumentsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllMemoryDocumentsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllMemoryDocumentsData' from JSON`,
  );
}

/** @internal */
export const GetAllMemoryDocumentsResponseBody$inboundSchema: z.ZodType<
  GetAllMemoryDocumentsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: GetAllMemoryDocumentsObject$inboundSchema,
  data: z.array(z.lazy(() => GetAllMemoryDocumentsData$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function getAllMemoryDocumentsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAllMemoryDocumentsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAllMemoryDocumentsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAllMemoryDocumentsResponseBody' from JSON`,
  );
}
