/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentModelConfigurationFormat;
};

export type StreamRunAgentResponseFormatAgentsJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: StreamRunAgentResponseFormatAgentsJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatText
  | StreamRunAgentResponseFormatJSONObject
  | StreamRunAgentResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const StreamRunAgentModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type StreamRunAgentModelConfigurationReasoningEffort = ClosedEnum<
  typeof StreamRunAgentModelConfigurationReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type StreamRunAgentModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceType = ClosedEnum<
  typeof StreamRunAgentToolChoiceType
>;

export type StreamRunAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type StreamRunAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceType | undefined;
  function: StreamRunAgentToolChoiceFunction;
};

export const StreamRunAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoice1 = ClosedEnum<
  typeof StreamRunAgentToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentModelConfigurationToolChoice =
  | StreamRunAgentToolChoice2
  | StreamRunAgentToolChoice1;

export const StreamRunAgentModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const StreamRunAgentId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type StreamRunAgentId1 = ClosedEnum<typeof StreamRunAgentId1>;

export type StreamRunAgentModelConfigurationId = StreamRunAgentId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const StreamRunAgentModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type StreamRunAgentModelConfigurationExecuteOn = ClosedEnum<
  typeof StreamRunAgentModelConfigurationExecuteOn
>;

export type StreamRunAgentModelConfigurationGuardrails = {
  id: StreamRunAgentId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: StreamRunAgentModelConfigurationExecuteOn;
};

/**
 * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
 */
export type StreamRunAgentModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatText
    | StreamRunAgentResponseFormatJSONObject
    | StreamRunAgentResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: StreamRunAgentModelConfigurationReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoice2
    | StreamRunAgentToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<StreamRunAgentModelConfigurationGuardrails> | undefined;
};

/**
 * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
 */
export type StreamRunAgentModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * @remarks
 *
 * Model configuration with parameters and retry settings.
 */
export type StreamRunAgentModelConfiguration2 = {
  /**
   * A model ID string (e.g., `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`). Only models that support tool calling can be used with agents.
   */
  id: string;
  /**
   * Model behavior parameters that control how the model generates responses. Common parameters: `temperature` (0-1, randomness), `max_completion_tokens` (max output length), `top_p` (sampling diversity). Advanced: `frequency_penalty`, `presence_penalty`, `response_format` (JSON/structured), `reasoning_effort`, `seed` (reproducibility). Support varies by model - consult AI Gateway documentation.
   */
  parameters?: StreamRunAgentModelConfigurationParameters | undefined;
  /**
   * Retry configuration for model requests. Retries are triggered for specific HTTP status codes (e.g., 500, 429, 502, 503, 504). Supports configurable retry count (1-5) and custom status codes.
   */
  retry?: StreamRunAgentModelConfigurationRetry | undefined;
};

/**
 * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
 */
export type StreamRunAgentModelConfiguration =
  | StreamRunAgentModelConfiguration2
  | string;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const StreamRunAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type StreamRunAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const StreamRunAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type StreamRunAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type StreamRunAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: StreamRunAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: StreamRunAgentFallbackModelConfigurationFormat;
};

export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema = {
  type: "json_schema";
  jsonSchema: StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type StreamRunAgentResponseFormatAgentsJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type StreamRunAgentResponseFormatAgentsText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type StreamRunAgentFallbackModelConfigurationResponseFormat =
  | StreamRunAgentResponseFormatAgentsText
  | StreamRunAgentResponseFormatAgentsJSONObject
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const StreamRunAgentFallbackModelConfigurationReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type StreamRunAgentFallbackModelConfigurationReasoningEffort =
  ClosedEnum<typeof StreamRunAgentFallbackModelConfigurationReasoningEffort>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type StreamRunAgentFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type StreamRunAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type StreamRunAgentFallbackModelConfigurationThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const StreamRunAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type StreamRunAgentToolChoiceAgentsType = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgentsType
>;

export type StreamRunAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type StreamRunAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: StreamRunAgentToolChoiceAgentsType | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction;
};

export const StreamRunAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type StreamRunAgentToolChoiceAgents1 = ClosedEnum<
  typeof StreamRunAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type StreamRunAgentFallbackModelConfigurationToolChoice =
  | StreamRunAgentToolChoiceAgents2
  | StreamRunAgentToolChoiceAgents1;

export const StreamRunAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type StreamRunAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationModalities
>;

/**
 * The key of the guardrail.
 */
export const StreamRunAgentIdAgents1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type StreamRunAgentIdAgents1 = ClosedEnum<
  typeof StreamRunAgentIdAgents1
>;

export type StreamRunAgentFallbackModelConfigurationId =
  | StreamRunAgentIdAgents1
  | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const StreamRunAgentFallbackModelConfigurationExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type StreamRunAgentFallbackModelConfigurationExecuteOn = ClosedEnum<
  typeof StreamRunAgentFallbackModelConfigurationExecuteOn
>;

export type StreamRunAgentFallbackModelConfigurationGuardrails = {
  id: StreamRunAgentIdAgents1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: StreamRunAgentFallbackModelConfigurationExecuteOn;
};

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type StreamRunAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: StreamRunAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | StreamRunAgentResponseFormatAgentsText
    | StreamRunAgentResponseFormatAgentsJSONObject
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?:
    | StreamRunAgentFallbackModelConfigurationReasoningEffort
    | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | StreamRunAgentToolChoiceAgents2
    | StreamRunAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<StreamRunAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?:
    | Array<StreamRunAgentFallbackModelConfigurationGuardrails>
    | undefined;
};

/**
 * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
 */
export type StreamRunAgentFallbackModelConfigurationRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * Fallback model configuration with optional parameters and retry settings.
 */
export type StreamRunAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: StreamRunAgentFallbackModelConfigurationParameters | undefined;
  /**
   * Retry configuration for this fallback model. Allows customizing retry count (1-5) and HTTP status codes that trigger retries.
   */
  retry?: StreamRunAgentFallbackModelConfigurationRetry | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type StreamRunAgentFallbackModelConfiguration =
  | StreamRunAgentFallbackModelConfiguration2
  | string;

/**
 * Message containing tool execution results
 */
export const StreamRunAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type StreamRunAgentRoleToolMessage = ClosedEnum<
  typeof StreamRunAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const StreamRunAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type StreamRunAgentRoleUserMessage = ClosedEnum<
  typeof StreamRunAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamRunAgentRole =
  | StreamRunAgentRoleUserMessage
  | StreamRunAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type StreamRunAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart
  | components.ErrorPart;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type StreamRunAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamRunAgentRoleUserMessage | StreamRunAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | components.TextPart
    | components.FilePart
    | components.ToolResultPart
    | components.ErrorPart
  >;
};

/**
 * Information about the identity making the request. If the identity does not exist, it will be created automatically.
 */
export type StreamRunAgentIdentity = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type StreamRunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamRunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamRunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type StreamRunAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

export type StreamRunAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type StreamRunAgentAgentToolInputRunAgentsHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  {
    Object: "object",
  } as const;
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  >;

export type StreamRunAgentAgentToolInputRunAgentsSchema = {
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type AgentToolInputRunTools = {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  schema: StreamRunAgentAgentToolInputRunAgentsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const AgentToolInputRunConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type AgentToolInputRunConnectionType = ClosedEnum<
  typeof AgentToolInputRunConnectionType
>;

export type AgentToolInputRunMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?:
    | { [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders }
    | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<AgentToolInputRunTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: AgentToolInputRunConnectionType;
};

/**
 * MCP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunMCPToolRun = {
  type: "mcp";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  mcp: AgentToolInputRunMcp;
  requiresApproval?: boolean | undefined;
};

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunSchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type StreamRunAgentAgentToolInputRunJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: StreamRunAgentAgentToolInputRunSchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

/**
 * JSON Schema tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunJSONSchemaToolRun = {
  type: "json_schema";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  jsonSchema: StreamRunAgentAgentToolInputRunJsonSchema;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunAgentsParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type StreamRunAgentAgentToolInputRunFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunAgentsParameters | undefined;
};

/**
 * Function tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunFunctionToolRun = {
  type: "function";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction;
  requiresApproval?: boolean | undefined;
};

/**
 * The type must be "object"
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  {
    Object: "object",
  } as const;
/**
 * The type must be "object"
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type StreamRunAgentAgentToolInputRunParameters = {
  /**
   * The type must be "object"
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const AgentToolInputRunLanguage = {
  Python: "python",
} as const;
export type AgentToolInputRunLanguage = ClosedEnum<
  typeof AgentToolInputRunLanguage
>;

export type AgentToolInputRunCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: StreamRunAgentAgentToolInputRunParameters | undefined;
  language: AgentToolInputRunLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

/**
 * Code execution tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunCodeToolRun = {
  type: "code";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  codeTool: AgentToolInputRunCodeTool;
  requiresApproval?: boolean | undefined;
};

/**
 * The HTTP method to use.
 */
export const AgentToolInputRunMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type AgentToolInputRunMethod = ClosedEnum<
  typeof AgentToolInputRunMethod
>;

export type StreamRunAgentHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type StreamRunAgentAgentToolInputRunHeaders =
  | StreamRunAgentHeaders2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type AgentToolInputRunBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: AgentToolInputRunMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: StreamRunAgentHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  {
    String: "string",
    Number: "number",
    Boolean: "boolean",
  } as const;
/**
 * The type of the argument.
 */
export type StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType =
  ClosedEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  >;

/**
 * The default value of the argument.
 */
export type AgentToolInputRunDefaultValue = string | number | boolean;

export type AgentToolInputRunArguments = {
  /**
   * The type of the argument.
   */
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type AgentToolInputRunHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: AgentToolInputRunBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: AgentToolInputRunArguments } | undefined;
};

/**
 * HTTP tool with inline definition for on-the-fly creation in run endpoint
 */
export type AgentToolInputRunHTTPToolRun = {
  type: "http";
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  id?: string | undefined;
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  http: AgentToolInputRunHttp;
  requiresApproval?: boolean | undefined;
};

/**
 * Returns the current date and time
 */
export type StreamRunAgentAgentToolInputRunCurrentDateTool = {
  type: "current_date";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries knowledge bases for information
 */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool = {
  type: "query_knowledge_base";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available knowledge bases
 */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool = {
  type: "retrieve_knowledge_bases";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Deletes documents from memory stores
 */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool = {
  type: "delete_memory_document";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Lists available memory stores
 */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool = {
  type: "retrieve_memory_stores";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Writes information to agent memory stores
 */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool = {
  type: "write_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Queries agent memory stores for context
 */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool = {
  type: "query_memory_store";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Retrieves available agents in the system
 */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool = {
  type: "retrieve_agents";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Delegates tasks to specialized sub-agents
 */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool = {
  type: "call_sub_agent";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Scrapes and extracts content from web pages
 */
export type StreamRunAgentAgentToolInputRunWebScraperTool = {
  type: "web_scraper";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Performs Google searches to retrieve web content
 */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool = {
  type: "google_search";
  /**
   * Whether this tool requires approval before execution
   */
  requiresApproval?: boolean | undefined;
};

/**
 * Tool configuration for agent run operations. Built-in tools only require a type and requires_approval, while custom tools (HTTP, Code, Function, JSON Schema, MCP) support full inline definitions for on-the-fly creation.
 */
export type StreamRunAgentAgentToolInputRun =
  | StreamRunAgentAgentToolInputRunGoogleSearchTool
  | StreamRunAgentAgentToolInputRunWebScraperTool
  | StreamRunAgentAgentToolInputRunCallSubAgentTool
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  | StreamRunAgentAgentToolInputRunCurrentDateTool
  | AgentToolInputRunHTTPToolRun
  | AgentToolInputRunCodeToolRun
  | AgentToolInputRunFunctionToolRun
  | AgentToolInputRunJSONSchemaToolRun
  | AgentToolInputRunMCPToolRun;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const StreamRunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type StreamRunAgentToolApprovalRequired = ClosedEnum<
  typeof StreamRunAgentToolApprovalRequired
>;

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentExecuteOn = ClosedEnum<
  typeof StreamRunAgentExecuteOn
>;

export type StreamRunAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const StreamRunAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type StreamRunAgentAgentsExecuteOn = ClosedEnum<
  typeof StreamRunAgentAgentsExecuteOn
>;

export type StreamRunAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: StreamRunAgentAgentsExecuteOn;
};

export type StreamRunAgentSettings = {
  /**
   * Tools available to the agent
   */
  tools?:
    | Array<
      | StreamRunAgentAgentToolInputRunGoogleSearchTool
      | StreamRunAgentAgentToolInputRunWebScraperTool
      | StreamRunAgentAgentToolInputRunCallSubAgentTool
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
      | StreamRunAgentAgentToolInputRunCurrentDateTool
      | AgentToolInputRunHTTPToolRun
      | AgentToolInputRunCodeToolRun
      | AgentToolInputRunFunctionToolRun
      | AgentToolInputRunJSONSchemaToolRun
      | AgentToolInputRunMCPToolRun
    >
    | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: StreamRunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<StreamRunAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<StreamRunAgentGuardrails> | undefined;
};

export type StreamRunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * Model configuration for this execution. Can override the agent manifest defaults if the agent already exists.
   */
  model: StreamRunAgentModelConfiguration2 | string;
  /**
   * Optional array of fallback models used when the primary model fails. Fallbacks are attempted in order. All models must support tool calling.
   */
  fallbackModels?:
    | Array<StreamRunAgentFallbackModelConfiguration2 | string>
    | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: StreamRunAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: StreamRunAgentIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: StreamRunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamRunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamRunAgentMemory | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  /**
   * Array of memory store identifiers that are accessible to the agent. Accepts both memory store IDs and keys.
   */
  memoryStores?: Array<string> | undefined;
  /**
   * Knowledge base configurations for the agent to access
   */
  knowledgeBases?: Array<StreamRunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<StreamRunAgentTeamOfAgents> | undefined;
  settings: StreamRunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

export type StreamRunAgentData =
  | components.AgentExecutionStartedStreamingEvent
  | components.AgentStartedStreamingEvent
  | components.AgentThoughtStreamingEvent
  | components.AgentInactiveStreamingEvent
  | components.AgentErroredStreamingEvent
  | components.ActionReviewRequestedStreamingEvent
  | components.ActionReviewedStreamingEvent
  | components.ExecutionReviewRequiredStreamingEvent
  | components.ExecutionReviewedStreamingEvent
  | components.ExecutionNamedStreamingEvent
  | components.AgentHandedOffStreamingEvent
  | components.AgentMessageCreatedStreamingEvent
  | components.ToolExecutionStartedStreamingEvent
  | components.ToolExecutionFinishedStreamingEvent
  | components.ToolExecutionFailedStreamingEvent
  | components.TimeoutStreamingEvent
  | components.ErrorStreamingEvent;

/**
 * Server-Sent Event stream successfully established. Delivers real-time agent execution events including message fragments, tool invocations, intermediate results, and completion status. Stream terminates with [DONE] sentinel upon completion.
 */
export type StreamRunAgentResponseBody = {
  data:
    | components.AgentExecutionStartedStreamingEvent
    | components.AgentStartedStreamingEvent
    | components.AgentThoughtStreamingEvent
    | components.AgentInactiveStreamingEvent
    | components.AgentErroredStreamingEvent
    | components.ActionReviewRequestedStreamingEvent
    | components.ActionReviewedStreamingEvent
    | components.ExecutionReviewRequiredStreamingEvent
    | components.ExecutionReviewedStreamingEvent
    | components.ExecutionNamedStreamingEvent
    | components.AgentHandedOffStreamingEvent
    | components.AgentMessageCreatedStreamingEvent
    | components.ToolExecutionStartedStreamingEvent
    | components.ToolExecutionFinishedStreamingEvent
    | components.ToolExecutionFailedStreamingEvent
    | components.TimeoutStreamingEvent
    | components.ErrorStreamingEvent;
};

/** @internal */
export const StreamRunAgentModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationVoice> = z.nativeEnum(
    StreamRunAgentModelConfigurationVoice,
  );
/** @internal */
export const StreamRunAgentModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationVoice> =
    StreamRunAgentModelConfigurationVoice$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationFormat> = z.nativeEnum(
    StreamRunAgentModelConfigurationFormat,
  );
/** @internal */
export const StreamRunAgentModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationFormat> =
    StreamRunAgentModelConfigurationFormat$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationAudio$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: StreamRunAgentModelConfigurationVoice$inboundSchema,
  format: StreamRunAgentModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type StreamRunAgentModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationAudio$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationAudio
> = z.object({
  voice: StreamRunAgentModelConfigurationVoice$outboundSchema,
  format: StreamRunAgentModelConfigurationFormat$outboundSchema,
});

export function streamRunAgentModelConfigurationAudioToJSON(
  streamRunAgentModelConfigurationAudio: StreamRunAgentModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentModelConfigurationAudio,
    ),
  );
}
export function streamRunAgentModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsJsonSchema:
    StreamRunAgentResponseFormatAgentsJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJsonSchema,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatJSONSchema$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  json_schema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type StreamRunAgentResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: StreamRunAgentResponseFormatAgentsJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatJSONSchema$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONSchema
> = z.object({
  type: z.literal("json_schema"),
  jsonSchema: z.lazy(() =>
    StreamRunAgentResponseFormatAgentsJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function streamRunAgentResponseFormatJSONSchemaToJSON(
  streamRunAgentResponseFormatJSONSchema:
    StreamRunAgentResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatJSONSchema,
    ),
  );
}
export function streamRunAgentResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_object"),
});
/** @internal */
export type StreamRunAgentResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const StreamRunAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatJSONObject
> = z.object({
  type: z.literal("json_object"),
});

export function streamRunAgentResponseFormatJSONObjectToJSON(
  streamRunAgentResponseFormatJSONObject:
    StreamRunAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatJSONObject,
    ),
  );
}
export function streamRunAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatText$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type StreamRunAgentResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const StreamRunAgentResponseFormatText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function streamRunAgentResponseFormatTextToJSON(
  streamRunAgentResponseFormatText: StreamRunAgentResponseFormatText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatText$outboundSchema.parse(
      streamRunAgentResponseFormatText,
    ),
  );
}
export function streamRunAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatText$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONObject$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONSchema$inboundSchema),
  ]);
/** @internal */
export type StreamRunAgentModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatText$Outbound
  | StreamRunAgentResponseFormatJSONObject$Outbound
  | StreamRunAgentResponseFormatJSONSchema$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
  ]);

export function streamRunAgentModelConfigurationResponseFormatToJSON(
  streamRunAgentModelConfigurationResponseFormat:
    StreamRunAgentModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentModelConfigurationResponseFormat,
    ),
  );
}
export function streamRunAgentModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationReasoningEffort$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationReasoningEffort> = z
    .nativeEnum(StreamRunAgentModelConfigurationReasoningEffort);
/** @internal */
export const StreamRunAgentModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationReasoningEffort> =
    StreamRunAgentModelConfigurationReasoningEffort$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationStop$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentModelConfigurationStop$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentModelConfigurationStopToJSON(
  streamRunAgentModelConfigurationStop: StreamRunAgentModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStop$outboundSchema.parse(
      streamRunAgentModelConfigurationStop,
    ),
  );
}
export function streamRunAgentModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type StreamRunAgentModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentModelConfigurationStreamOptionsToJSON(
  streamRunAgentModelConfigurationStreamOptions:
    StreamRunAgentModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentModelConfigurationStreamOptions,
    ),
  );
}
export function streamRunAgentModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationThinking$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);
/** @internal */
export type StreamRunAgentModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const StreamRunAgentModelConfigurationThinking$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationThinking$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function streamRunAgentModelConfigurationThinkingToJSON(
  streamRunAgentModelConfigurationThinking:
    StreamRunAgentModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentModelConfigurationThinking,
    ),
  );
}
export function streamRunAgentModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = z.nativeEnum(StreamRunAgentToolChoiceType);
/** @internal */
export const StreamRunAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceType
> = StreamRunAgentToolChoiceType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type StreamRunAgentToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const StreamRunAgentToolChoiceFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function streamRunAgentToolChoiceFunctionToJSON(
  streamRunAgentToolChoiceFunction: StreamRunAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceFunction$outboundSchema.parse(
      streamRunAgentToolChoiceFunction,
    ),
  );
}
export function streamRunAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoice2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoice2
> = z.object({
  type: StreamRunAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceFunction$outboundSchema),
});

export function streamRunAgentToolChoice2ToJSON(
  streamRunAgentToolChoice2: StreamRunAgentToolChoice2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoice2$outboundSchema.parse(streamRunAgentToolChoice2),
  );
}
export function streamRunAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = z.nativeEnum(StreamRunAgentToolChoice1);
/** @internal */
export const StreamRunAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoice1
> = StreamRunAgentToolChoice1$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationToolChoice$inboundSchema:
  z.ZodType<StreamRunAgentModelConfigurationToolChoice, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
      StreamRunAgentToolChoice1$inboundSchema,
    ]);
/** @internal */
export type StreamRunAgentModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoice2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
    StreamRunAgentToolChoice1$outboundSchema,
  ]);

export function streamRunAgentModelConfigurationToolChoiceToJSON(
  streamRunAgentModelConfigurationToolChoice:
    StreamRunAgentModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentModelConfigurationToolChoice,
    ),
  );
}
export function streamRunAgentModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentModelConfigurationModalities);
/** @internal */
export const StreamRunAgentModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationModalities> =
    StreamRunAgentModelConfigurationModalities$inboundSchema;

/** @internal */
export const StreamRunAgentId1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentId1
> = z.nativeEnum(StreamRunAgentId1);
/** @internal */
export const StreamRunAgentId1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentId1
> = StreamRunAgentId1$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationId$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationId,
  z.ZodTypeDef,
  unknown
> = z.union([StreamRunAgentId1$inboundSchema, z.string()]);
/** @internal */
export type StreamRunAgentModelConfigurationId$Outbound = string | string;

/** @internal */
export const StreamRunAgentModelConfigurationId$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationId$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationId
> = z.union([StreamRunAgentId1$outboundSchema, z.string()]);

export function streamRunAgentModelConfigurationIdToJSON(
  streamRunAgentModelConfigurationId: StreamRunAgentModelConfigurationId,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationId$outboundSchema.parse(
      streamRunAgentModelConfigurationId,
    ),
  );
}
export function streamRunAgentModelConfigurationIdFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationId' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationExecuteOn> = z
    .nativeEnum(StreamRunAgentModelConfigurationExecuteOn);
/** @internal */
export const StreamRunAgentModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentModelConfigurationExecuteOn> =
    StreamRunAgentModelConfigurationExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentModelConfigurationGuardrails$inboundSchema:
  z.ZodType<StreamRunAgentModelConfigurationGuardrails, z.ZodTypeDef, unknown> =
    z.object({
      id: z.union([StreamRunAgentId1$inboundSchema, z.string()]),
      execute_on: StreamRunAgentModelConfigurationExecuteOn$inboundSchema,
    }).transform((v) => {
      return remap$(v, {
        "execute_on": "executeOn",
      });
    });
/** @internal */
export type StreamRunAgentModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationGuardrails
  > = z.object({
    id: z.union([StreamRunAgentId1$outboundSchema, z.string()]),
    executeOn: StreamRunAgentModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function streamRunAgentModelConfigurationGuardrailsToJSON(
  streamRunAgentModelConfigurationGuardrails:
    StreamRunAgentModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationGuardrails$outboundSchema.parse(
      streamRunAgentModelConfigurationGuardrails,
    ),
  );
}
export function streamRunAgentModelConfigurationGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationGuardrails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationGuardrails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationParameters$inboundSchema:
  z.ZodType<StreamRunAgentModelConfigurationParameters, z.ZodTypeDef, unknown> =
    z.object({
      audio: z.nullable(
        z.lazy(() => StreamRunAgentModelConfigurationAudio$inboundSchema),
      ).optional(),
      frequency_penalty: z.nullable(z.number()).optional(),
      max_tokens: z.nullable(z.number().int()).optional(),
      max_completion_tokens: z.nullable(z.number().int()).optional(),
      logprobs: z.nullable(z.boolean()).optional(),
      top_logprobs: z.nullable(z.number().int()).optional(),
      n: z.nullable(z.number().int()).optional(),
      presence_penalty: z.nullable(z.number()).optional(),
      response_format: z.union([
        z.lazy(() => StreamRunAgentResponseFormatText$inboundSchema),
        z.lazy(() => StreamRunAgentResponseFormatJSONObject$inboundSchema),
        z.lazy(() => StreamRunAgentResponseFormatJSONSchema$inboundSchema),
      ]).optional(),
      reasoning_effort:
        StreamRunAgentModelConfigurationReasoningEffort$inboundSchema
          .optional(),
      verbosity: z.string().optional(),
      seed: z.nullable(z.number()).optional(),
      stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
      stream_options: z.nullable(
        z.lazy(() =>
          StreamRunAgentModelConfigurationStreamOptions$inboundSchema
        ),
      ).optional(),
      thinking: z.union([
        components.ThinkingConfigDisabledSchema$inboundSchema,
        components.ThinkingConfigEnabledSchema$inboundSchema,
      ]).optional(),
      temperature: z.nullable(z.number()).optional(),
      top_p: z.nullable(z.number()).optional(),
      top_k: z.nullable(z.number()).optional(),
      tool_choice: z.union([
        z.lazy(() => StreamRunAgentToolChoice2$inboundSchema),
        StreamRunAgentToolChoice1$inboundSchema,
      ]).optional(),
      parallel_tool_calls: z.boolean().optional(),
      modalities: z.nullable(
        z.array(StreamRunAgentModelConfigurationModalities$inboundSchema),
      ).optional(),
      guardrails: z.array(
        z.lazy(() => StreamRunAgentModelConfigurationGuardrails$inboundSchema),
      ).optional(),
    }).transform((v) => {
      return remap$(v, {
        "frequency_penalty": "frequencyPenalty",
        "max_tokens": "maxTokens",
        "max_completion_tokens": "maxCompletionTokens",
        "top_logprobs": "topLogprobs",
        "presence_penalty": "presencePenalty",
        "response_format": "responseFormat",
        "reasoning_effort": "reasoningEffort",
        "stream_options": "streamOptions",
        "top_p": "topP",
        "top_k": "topK",
        "tool_choice": "toolChoice",
        "parallel_tool_calls": "parallelToolCalls",
      });
    });
/** @internal */
export type StreamRunAgentModelConfigurationParameters$Outbound = {
  audio?: StreamRunAgentModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatText$Outbound
    | StreamRunAgentResponseFormatJSONObject$Outbound
    | StreamRunAgentResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<StreamRunAgentModelConfigurationGuardrails$Outbound>
    | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => StreamRunAgentModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => StreamRunAgentResponseFormatText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatJSONObject$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatJSONSchema$outboundSchema),
    ]).optional(),
    reasoningEffort:
      StreamRunAgentModelConfigurationReasoningEffort$outboundSchema.optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoice2$outboundSchema),
      StreamRunAgentToolChoice1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(StreamRunAgentModelConfigurationModalities$outboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() => StreamRunAgentModelConfigurationGuardrails$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function streamRunAgentModelConfigurationParametersToJSON(
  streamRunAgentModelConfigurationParameters:
    StreamRunAgentModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentModelConfigurationParameters,
    ),
  );
}
export function streamRunAgentModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfigurationRetry$inboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type StreamRunAgentModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentModelConfigurationRetry$outboundSchema: z.ZodType<
  StreamRunAgentModelConfigurationRetry$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfigurationRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function streamRunAgentModelConfigurationRetryToJSON(
  streamRunAgentModelConfigurationRetry: StreamRunAgentModelConfigurationRetry,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfigurationRetry$outboundSchema.parse(
      streamRunAgentModelConfigurationRetry,
    ),
  );
}
export function streamRunAgentModelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfigurationRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentModelConfigurationRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfiguration2$inboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentModelConfigurationParameters$inboundSchema
  ).optional(),
  retry: z.lazy(() => StreamRunAgentModelConfigurationRetry$inboundSchema)
    .optional(),
});
/** @internal */
export type StreamRunAgentModelConfiguration2$Outbound = {
  id: string;
  parameters?: StreamRunAgentModelConfigurationParameters$Outbound | undefined;
  retry?: StreamRunAgentModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentModelConfiguration2$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentModelConfigurationParameters$outboundSchema
  ).optional(),
  retry: z.lazy(() => StreamRunAgentModelConfigurationRetry$outboundSchema)
    .optional(),
});

export function streamRunAgentModelConfiguration2ToJSON(
  streamRunAgentModelConfiguration2: StreamRunAgentModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration2$outboundSchema.parse(
      streamRunAgentModelConfiguration2,
    ),
  );
}
export function streamRunAgentModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentModelConfiguration$inboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type StreamRunAgentModelConfiguration$Outbound =
  | StreamRunAgentModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentModelConfigurationToJSON(
  streamRunAgentModelConfiguration: StreamRunAgentModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentModelConfiguration$outboundSchema.parse(
      streamRunAgentModelConfiguration,
    ),
  );
}
export function streamRunAgentModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentModelConfiguration' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationVoice);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationVoice> =
    StreamRunAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationFormat);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationFormat> =
    StreamRunAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: StreamRunAgentFallbackModelConfigurationVoice$inboundSchema,
    format: StreamRunAgentFallbackModelConfigurationFormat$inboundSchema,
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: StreamRunAgentFallbackModelConfigurationVoice$outboundSchema,
    format: StreamRunAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function streamRunAgentFallbackModelConfigurationAudioToJSON(
  streamRunAgentFallbackModelConfigurationAudio:
    StreamRunAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound =
  {
    description?: string | undefined;
    name: string;
    schema?: any | undefined;
    strict: boolean;
  };

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
      .parse(streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema),
  );
}
export function streamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound = {
  type: "json_schema";
  json_schema:
    StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$Outbound;
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsRequestJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestRequestBodyJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function streamRunAgentResponseFormatAgentsRequestJSONSchemaToJSON(
  streamRunAgentResponseFormatAgentsRequestJSONSchema:
    StreamRunAgentResponseFormatAgentsRequestJSONSchema,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsRequestJSONSchema,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsRequestJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsRequestJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsRequestJSONSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type StreamRunAgentResponseFormatAgentsJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    StreamRunAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    StreamRunAgentResponseFormatAgentsJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function streamRunAgentResponseFormatAgentsJSONObjectToJSON(
  streamRunAgentResponseFormatAgentsJSONObject:
    StreamRunAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type StreamRunAgentResponseFormatAgentsText$Outbound = {
  type: "text";
};

/** @internal */
export const StreamRunAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  StreamRunAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseFormatAgentsText
> = z.object({
  type: z.literal("text"),
});

export function streamRunAgentResponseFormatAgentsTextToJSON(
  streamRunAgentResponseFormatAgentsText:
    StreamRunAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    StreamRunAgentResponseFormatAgentsText$outboundSchema.parse(
      streamRunAgentResponseFormatAgentsText,
    ),
  );
}
export function streamRunAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema),
    z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
    ),
  ]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound =
  | StreamRunAgentResponseFormatAgentsText$Outbound
  | StreamRunAgentResponseFormatAgentsJSONObject$Outbound
  | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
    z.lazy(() =>
      StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
    ),
  ]);

export function streamRunAgentFallbackModelConfigurationResponseFormatToJSON(
  streamRunAgentFallbackModelConfigurationResponseFormat:
    StreamRunAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationReasoningEffort$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentFallbackModelConfigurationReasoningEffort
  > = z.nativeEnum(StreamRunAgentFallbackModelConfigurationReasoningEffort);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationReasoningEffort$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentFallbackModelConfigurationReasoningEffort
  > = StreamRunAgentFallbackModelConfigurationReasoningEffort$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function streamRunAgentFallbackModelConfigurationStopToJSON(
  streamRunAgentFallbackModelConfigurationStop:
    StreamRunAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStop$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStop,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function streamRunAgentFallbackModelConfigurationStreamOptionsToJSON(
  streamRunAgentFallbackModelConfigurationStreamOptions:
    StreamRunAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationThinking
  > = z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]);

export function streamRunAgentFallbackModelConfigurationThinkingToJSON(
  streamRunAgentFallbackModelConfigurationThinking:
    StreamRunAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = z.nativeEnum(StreamRunAgentToolChoiceAgentsType);
/** @internal */
export const StreamRunAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgentsType
> = StreamRunAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type StreamRunAgentToolChoiceAgentsFunction$Outbound = {
  name: string;
};

/** @internal */
export const StreamRunAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string(),
});

export function streamRunAgentToolChoiceAgentsFunctionToJSON(
  streamRunAgentToolChoiceAgentsFunction:
    StreamRunAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgentsFunction$outboundSchema.parse(
      streamRunAgentToolChoiceAgentsFunction,
    ),
  );
}
export function streamRunAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type StreamRunAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: StreamRunAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const StreamRunAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  StreamRunAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentToolChoiceAgents2
> = z.object({
  type: StreamRunAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => StreamRunAgentToolChoiceAgentsFunction$outboundSchema),
});

export function streamRunAgentToolChoiceAgents2ToJSON(
  streamRunAgentToolChoiceAgents2: StreamRunAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    StreamRunAgentToolChoiceAgents2$outboundSchema.parse(
      streamRunAgentToolChoiceAgents2,
    ),
  );
}
export function streamRunAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = z.nativeEnum(StreamRunAgentToolChoiceAgents1);
/** @internal */
export const StreamRunAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolChoiceAgents1
> = StreamRunAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
    StreamRunAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationToolChoice$Outbound =
  | StreamRunAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
    StreamRunAgentToolChoiceAgents1$outboundSchema,
  ]);

export function streamRunAgentFallbackModelConfigurationToolChoiceToJSON(
  streamRunAgentFallbackModelConfigurationToolChoice:
    StreamRunAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationModalities);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationModalities> =
    StreamRunAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const StreamRunAgentIdAgents1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentIdAgents1
> = z.nativeEnum(StreamRunAgentIdAgents1);
/** @internal */
export const StreamRunAgentIdAgents1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentIdAgents1
> = StreamRunAgentIdAgents1$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationId$inboundSchema:
  z.ZodType<StreamRunAgentFallbackModelConfigurationId, z.ZodTypeDef, unknown> =
    z.union([StreamRunAgentIdAgents1$inboundSchema, z.string()]);
/** @internal */
export type StreamRunAgentFallbackModelConfigurationId$Outbound =
  | string
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationId$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationId$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationId
  > = z.union([StreamRunAgentIdAgents1$outboundSchema, z.string()]);

export function streamRunAgentFallbackModelConfigurationIdToJSON(
  streamRunAgentFallbackModelConfigurationId:
    StreamRunAgentFallbackModelConfigurationId,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationId$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationId,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationIdFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationId,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationId$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationId' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationExecuteOn$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationExecuteOn> = z
    .nativeEnum(StreamRunAgentFallbackModelConfigurationExecuteOn);
/** @internal */
export const StreamRunAgentFallbackModelConfigurationExecuteOn$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentFallbackModelConfigurationExecuteOn> =
    StreamRunAgentFallbackModelConfigurationExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentFallbackModelConfigurationGuardrails$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationGuardrails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    id: z.union([StreamRunAgentIdAgents1$inboundSchema, z.string()]),
    execute_on: StreamRunAgentFallbackModelConfigurationExecuteOn$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "execute_on": "executeOn",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationGuardrails$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationGuardrails
  > = z.object({
    id: z.union([StreamRunAgentIdAgents1$outboundSchema, z.string()]),
    executeOn: StreamRunAgentFallbackModelConfigurationExecuteOn$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      executeOn: "execute_on",
    });
  });

export function streamRunAgentFallbackModelConfigurationGuardrailsToJSON(
  streamRunAgentFallbackModelConfigurationGuardrails:
    StreamRunAgentFallbackModelConfigurationGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationGuardrails,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationGuardrails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationGuardrails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationGuardrails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => StreamRunAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() => StreamRunAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$inboundSchema),
      z.lazy(() =>
        StreamRunAgentResponseFormatAgentsRequestJSONSchema$inboundSchema
      ),
    ]).optional(),
    reasoning_effort:
      StreamRunAgentFallbackModelConfigurationReasoningEffort$inboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$inboundSchema,
      components.ThinkingConfigEnabledSchema$inboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => StreamRunAgentToolChoiceAgents2$inboundSchema),
      StreamRunAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(StreamRunAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationGuardrails$inboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | StreamRunAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | StreamRunAgentResponseFormatAgentsText$Outbound
    | StreamRunAgentResponseFormatAgentsJSONObject$Outbound
    | StreamRunAgentResponseFormatAgentsRequestJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | StreamRunAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: StreamRunAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?:
    | Array<StreamRunAgentFallbackModelConfigurationGuardrails$Outbound>
    | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() => StreamRunAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => StreamRunAgentResponseFormatAgentsJSONObject$outboundSchema),
      z.lazy(() =>
        StreamRunAgentResponseFormatAgentsRequestJSONSchema$outboundSchema
      ),
    ]).optional(),
    reasoningEffort:
      StreamRunAgentFallbackModelConfigurationReasoningEffort$outboundSchema
        .optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.union([
      components.ThinkingConfigDisabledSchema$outboundSchema,
      components.ThinkingConfigEnabledSchema$outboundSchema,
    ]).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => StreamRunAgentToolChoiceAgents2$outboundSchema),
      StreamRunAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        StreamRunAgentFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
    guardrails: z.array(
      z.lazy(() =>
        StreamRunAgentFallbackModelConfigurationGuardrails$outboundSchema
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function streamRunAgentFallbackModelConfigurationParametersToJSON(
  streamRunAgentFallbackModelConfigurationParameters:
    StreamRunAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfigurationRetry$inboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationRetry,
    z.ZodTypeDef,
    unknown
  > = z.object({
    count: z.number().default(3),
    on_codes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "on_codes": "onCodes",
    });
  });
/** @internal */
export type StreamRunAgentFallbackModelConfigurationRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfigurationRetry$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfigurationRetry$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfigurationRetry
  > = z.object({
    count: z.number().default(3),
    onCodes: z.array(z.number()).optional(),
  }).transform((v) => {
    return remap$(v, {
      onCodes: "on_codes",
    });
  });

export function streamRunAgentFallbackModelConfigurationRetryToJSON(
  streamRunAgentFallbackModelConfigurationRetry:
    StreamRunAgentFallbackModelConfigurationRetry,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfigurationRetry$outboundSchema.parse(
      streamRunAgentFallbackModelConfigurationRetry,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationRetryFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfigurationRetry,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfigurationRetry$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfigurationRetry' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    StreamRunAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
  retry: z.lazy(() =>
    StreamRunAgentFallbackModelConfigurationRetry$inboundSchema
  ).optional(),
});
/** @internal */
export type StreamRunAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | StreamRunAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
  retry?: StreamRunAgentFallbackModelConfigurationRetry$Outbound | undefined;
};

/** @internal */
export const StreamRunAgentFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    StreamRunAgentFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    StreamRunAgentFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
    retry: z.lazy(() =>
      StreamRunAgentFallbackModelConfigurationRetry$outboundSchema
    ).optional(),
  });

export function streamRunAgentFallbackModelConfiguration2ToJSON(
  streamRunAgentFallbackModelConfiguration2:
    StreamRunAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration2$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration2,
    ),
  );
}
export function streamRunAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type StreamRunAgentFallbackModelConfiguration$Outbound =
  | StreamRunAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const StreamRunAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function streamRunAgentFallbackModelConfigurationToJSON(
  streamRunAgentFallbackModelConfiguration:
    StreamRunAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentFallbackModelConfiguration$outboundSchema.parse(
      streamRunAgentFallbackModelConfiguration,
    ),
  );
}
export function streamRunAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = z.nativeEnum(StreamRunAgentRoleToolMessage);
/** @internal */
export const StreamRunAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleToolMessage
> = StreamRunAgentRoleToolMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = z.nativeEnum(StreamRunAgentRoleUserMessage);
/** @internal */
export const StreamRunAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRoleUserMessage
> = StreamRunAgentRoleUserMessage$inboundSchema;

/** @internal */
export const StreamRunAgentRole$inboundSchema: z.ZodType<
  StreamRunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  StreamRunAgentRoleUserMessage$inboundSchema,
  StreamRunAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type StreamRunAgentRole$Outbound = string | string;

/** @internal */
export const StreamRunAgentRole$outboundSchema: z.ZodType<
  StreamRunAgentRole$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRole
> = z.union([
  StreamRunAgentRoleUserMessage$outboundSchema,
  StreamRunAgentRoleToolMessage$outboundSchema,
]);

export function streamRunAgentRoleToJSON(
  streamRunAgentRole: StreamRunAgentRole,
): string {
  return JSON.stringify(
    StreamRunAgentRole$outboundSchema.parse(streamRunAgentRole),
  );
}
export function streamRunAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRole' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPublicMessagePart$inboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolResultPart$inboundSchema,
  components.ErrorPart$inboundSchema,
]);
/** @internal */
export type StreamRunAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound
  | components.ErrorPart$Outbound;

/** @internal */
export const StreamRunAgentPublicMessagePart$outboundSchema: z.ZodType<
  StreamRunAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
  components.ErrorPart$outboundSchema,
]);

export function streamRunAgentPublicMessagePartToJSON(
  streamRunAgentPublicMessagePart: StreamRunAgentPublicMessagePart,
): string {
  return JSON.stringify(
    StreamRunAgentPublicMessagePart$outboundSchema.parse(
      streamRunAgentPublicMessagePart,
    ),
  );
}
export function streamRunAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentA2AMessage$inboundSchema: z.ZodType<
  StreamRunAgentA2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$inboundSchema,
    StreamRunAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolResultPart$inboundSchema,
      components.ErrorPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type StreamRunAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
    | components.ErrorPart$Outbound
  >;
};

/** @internal */
export const StreamRunAgentA2AMessage$outboundSchema: z.ZodType<
  StreamRunAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRoleUserMessage$outboundSchema,
    StreamRunAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
      components.ErrorPart$outboundSchema,
    ]),
  ),
});

export function streamRunAgentA2AMessageToJSON(
  streamRunAgentA2AMessage: StreamRunAgentA2AMessage,
): string {
  return JSON.stringify(
    StreamRunAgentA2AMessage$outboundSchema.parse(streamRunAgentA2AMessage),
  );
}
export function streamRunAgentA2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentA2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentA2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentA2AMessage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentIdentity$inboundSchema: z.ZodType<
  StreamRunAgentIdentity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type StreamRunAgentIdentity$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentIdentity$outboundSchema: z.ZodType<
  StreamRunAgentIdentity$Outbound,
  z.ZodTypeDef,
  StreamRunAgentIdentity
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentIdentityToJSON(
  streamRunAgentIdentity: StreamRunAgentIdentity,
): string {
  return JSON.stringify(
    StreamRunAgentIdentity$outboundSchema.parse(streamRunAgentIdentity),
  );
}
export function streamRunAgentIdentityFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentIdentity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentIdentity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentIdentity' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentContact$inboundSchema: z.ZodType<
  StreamRunAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type StreamRunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentContact$outboundSchema: z.ZodType<
  StreamRunAgentContact$Outbound,
  z.ZodTypeDef,
  StreamRunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function streamRunAgentContactToJSON(
  streamRunAgentContact: StreamRunAgentContact,
): string {
  return JSON.stringify(
    StreamRunAgentContact$outboundSchema.parse(streamRunAgentContact),
  );
}
export function streamRunAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentContact' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentThread$inboundSchema: z.ZodType<
  StreamRunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type StreamRunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentThread$outboundSchema: z.ZodType<
  StreamRunAgentThread$Outbound,
  z.ZodTypeDef,
  StreamRunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function streamRunAgentThreadToJSON(
  streamRunAgentThread: StreamRunAgentThread,
): string {
  return JSON.stringify(
    StreamRunAgentThread$outboundSchema.parse(streamRunAgentThread),
  );
}
export function streamRunAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentThread' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMemory$inboundSchema: z.ZodType<
  StreamRunAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type StreamRunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentMemory$outboundSchema: z.ZodType<
  StreamRunAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function streamRunAgentMemoryToJSON(
  streamRunAgentMemory: StreamRunAgentMemory,
): string {
  return JSON.stringify(
    StreamRunAgentMemory$outboundSchema.parse(streamRunAgentMemory),
  );
}
export function streamRunAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMemory' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentKnowledgeBases$inboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type StreamRunAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const StreamRunAgentKnowledgeBases$outboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  StreamRunAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function streamRunAgentKnowledgeBasesToJSON(
  streamRunAgentKnowledgeBases: StreamRunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    StreamRunAgentKnowledgeBases$outboundSchema.parse(
      streamRunAgentKnowledgeBases,
    ),
  );
}
export function streamRunAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentTeamOfAgents$inboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type StreamRunAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const StreamRunAgentTeamOfAgents$outboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function streamRunAgentTeamOfAgentsToJSON(
  streamRunAgentTeamOfAgents: StreamRunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    StreamRunAgentTeamOfAgents$outboundSchema.parse(streamRunAgentTeamOfAgents),
  );
}
export function streamRunAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsHeaders,
    z.ZodTypeDef,
    unknown
  > = z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsHeaders
  > = z.object({
    value: z.string(),
    encrypted: z.boolean().default(false),
  });

export function streamRunAgentAgentToolInputRunAgentsHeadersToJSON(
  streamRunAgentAgentToolInputRunAgentsHeaders:
    StreamRunAgentAgentToolInputRunAgentsHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsHeaders,
    ),
  );
}
export function streamRunAgentAgentToolInputRunAgentsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunAgentsHeaders,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunAgentsHeaders' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsSchema$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$inboundSchema,
    properties: z.record(z.any()).optional(),
    required: z.array(z.string()).optional(),
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsSchema
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools16McpType$outboundSchema,
    properties: z.record(z.any()).optional(),
    required: z.array(z.string()).optional(),
  });

export function streamRunAgentAgentToolInputRunAgentsSchemaToJSON(
  streamRunAgentAgentToolInputRunAgentsSchema:
    StreamRunAgentAgentToolInputRunAgentsSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsSchema,
    ),
  );
}
export function streamRunAgentAgentToolInputRunAgentsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunAgentsSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunAgentsSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunAgentsSchema' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunTools$inboundSchema: z.ZodType<
  AgentToolInputRunTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().default("01KFB68TA7MMDA405BPMMWP86K"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsSchema$inboundSchema
  ),
});
/** @internal */
export type AgentToolInputRunTools$Outbound = {
  id: string;
  name: string;
  description?: string | undefined;
  schema: StreamRunAgentAgentToolInputRunAgentsSchema$Outbound;
};

/** @internal */
export const AgentToolInputRunTools$outboundSchema: z.ZodType<
  AgentToolInputRunTools$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunTools
> = z.object({
  id: z.string().default("01KFB68TA7MMDA405BPMMWP86K"),
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsSchema$outboundSchema
  ),
});

export function agentToolInputRunToolsToJSON(
  agentToolInputRunTools: AgentToolInputRunTools,
): string {
  return JSON.stringify(
    AgentToolInputRunTools$outboundSchema.parse(agentToolInputRunTools),
  );
}
export function agentToolInputRunToolsFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunTools' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunConnectionType$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunConnectionType
> = z.nativeEnum(AgentToolInputRunConnectionType);
/** @internal */
export const AgentToolInputRunConnectionType$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunConnectionType
> = AgentToolInputRunConnectionType$inboundSchema;

/** @internal */
export const AgentToolInputRunMcp$inboundSchema: z.ZodType<
  AgentToolInputRunMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(
    z.lazy(() => StreamRunAgentAgentToolInputRunAgentsHeaders$inboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => AgentToolInputRunTools$inboundSchema)),
  connection_type: AgentToolInputRunConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type AgentToolInputRunMcp$Outbound = {
  server_url: string;
  headers?: {
    [k: string]: StreamRunAgentAgentToolInputRunAgentsHeaders$Outbound;
  } | undefined;
  tools: Array<AgentToolInputRunTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const AgentToolInputRunMcp$outboundSchema: z.ZodType<
  AgentToolInputRunMcp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(
    z.lazy(() => StreamRunAgentAgentToolInputRunAgentsHeaders$outboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => AgentToolInputRunTools$outboundSchema)),
  connectionType: AgentToolInputRunConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function agentToolInputRunMcpToJSON(
  agentToolInputRunMcp: AgentToolInputRunMcp,
): string {
  return JSON.stringify(
    AgentToolInputRunMcp$outboundSchema.parse(agentToolInputRunMcp),
  );
}
export function agentToolInputRunMcpFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunMcp' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunMCPToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunMCPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("mcp"),
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => AgentToolInputRunMcp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunMCPToolRun$Outbound = {
  type: "mcp";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  mcp: AgentToolInputRunMcp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunMCPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunMCPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunMCPToolRun
> = z.object({
  type: z.literal("mcp"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  mcp: z.lazy(() => AgentToolInputRunMcp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunMCPToolRunToJSON(
  agentToolInputRunMCPToolRun: AgentToolInputRunMCPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunMCPToolRun$outboundSchema.parse(
      agentToolInputRunMCPToolRun,
    ),
  );
}
export function agentToolInputRunMCPToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunMCPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunMCPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunMCPToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunSchema$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunSchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type StreamRunAgentAgentToolInputRunSchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunSchema$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunSchema$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunSchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function streamRunAgentAgentToolInputRunSchemaToJSON(
  streamRunAgentAgentToolInputRunSchema: StreamRunAgentAgentToolInputRunSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunSchema,
    ),
  );
}
export function streamRunAgentAgentToolInputRunSchemaFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRunSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunSchema' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunJsonSchema$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => StreamRunAgentAgentToolInputRunSchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type StreamRunAgentAgentToolInputRunJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: StreamRunAgentAgentToolInputRunSchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunJsonSchema$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunJsonSchema
  > = z.object({
    name: z.string(),
    description: z.string(),
    schema: z.lazy(() => StreamRunAgentAgentToolInputRunSchema$outboundSchema),
    strict: z.boolean().optional(),
  });

export function streamRunAgentAgentToolInputRunJsonSchemaToJSON(
  streamRunAgentAgentToolInputRunJsonSchema:
    StreamRunAgentAgentToolInputRunJsonSchema,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema.parse(
      streamRunAgentAgentToolInputRunJsonSchema,
    ),
  );
}
export function streamRunAgentAgentToolInputRunJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunJsonSchema' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunJSONSchemaToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunJSONSchemaToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("json_schema"),
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  json_schema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunJsonSchema$inboundSchema
  ),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "json_schema": "jsonSchema",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunJSONSchemaToolRun$Outbound = {
  type: "json_schema";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  json_schema: StreamRunAgentAgentToolInputRunJsonSchema$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunJSONSchemaToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunJSONSchemaToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunJSONSchemaToolRun
> = z.object({
  type: z.literal("json_schema"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  jsonSchema: z.lazy(() =>
    StreamRunAgentAgentToolInputRunJsonSchema$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    jsonSchema: "json_schema",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunJSONSchemaToolRunToJSON(
  agentToolInputRunJSONSchemaToolRun: AgentToolInputRunJSONSchemaToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunJSONSchemaToolRun$outboundSchema.parse(
      agentToolInputRunJSONSchemaToolRun,
    ),
  );
}
export function agentToolInputRunJSONSchemaToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunJSONSchemaToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      AgentToolInputRunJSONSchemaToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunJSONSchemaToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsParameters,
    z.ZodTypeDef,
    unknown
  > = collectExtraKeys$(
    z.object({
      type:
        StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$inboundSchema,
      properties: z.record(z.any()),
      required: z.array(z.string()),
    }).catchall(z.any()),
    "additionalProperties",
    true,
  );
/** @internal */
export type StreamRunAgentAgentToolInputRunAgentsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunAgentsParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunAgentsParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools14FunctionType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunAgentsParametersToJSON(
  streamRunAgentAgentToolInputRunAgentsParameters:
    StreamRunAgentAgentToolInputRunAgentsParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunAgentsParameters,
    ),
  );
}
export function streamRunAgentAgentToolInputRunAgentsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunAgentsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunAgentsParameters' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type StreamRunAgentAgentToolInputRunFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?:
    | StreamRunAgentAgentToolInputRunAgentsParameters$Outbound
    | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunFunction$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunFunction$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunAgentsParameters$outboundSchema
  ).optional(),
});

export function streamRunAgentAgentToolInputRunFunctionToJSON(
  streamRunAgentAgentToolInputRunFunction:
    StreamRunAgentAgentToolInputRunFunction,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunFunction$outboundSchema.parse(
      streamRunAgentAgentToolInputRunFunction,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunFunction' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunFunctionToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("function"),
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() => StreamRunAgentAgentToolInputRunFunction$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunFunctionToolRun$Outbound = {
  type: "function";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description?: string | undefined;
  function: StreamRunAgentAgentToolInputRunFunction$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunFunctionToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunFunctionToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunFunctionToolRun
> = z.object({
  type: z.literal("function"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  function: z.lazy(() =>
    StreamRunAgentAgentToolInputRunFunction$outboundSchema
  ),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunFunctionToolRunToJSON(
  agentToolInputRunFunctionToolRun: AgentToolInputRunFunctionToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunFunctionToolRun$outboundSchema.parse(
      agentToolInputRunFunctionToolRun,
    ),
  );
}
export function agentToolInputRunFunctionToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunFunctionToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunFunctionToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunFunctionToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema;

/** @internal */
export const StreamRunAgentAgentToolInputRunParameters$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type StreamRunAgentAgentToolInputRunParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunParameters$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunParameters$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunParameters
  > = z.object({
    type:
      StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools13CodeToolType$outboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
    additionalProperties: z.record(z.any()).optional(),
  }).transform((v) => {
    return {
      ...v.additionalProperties,
      ...remap$(v, {
        additionalProperties: null,
      }),
    };
  });

export function streamRunAgentAgentToolInputRunParametersToJSON(
  streamRunAgentAgentToolInputRunParameters:
    StreamRunAgentAgentToolInputRunParameters,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunParameters$outboundSchema.parse(
      streamRunAgentAgentToolInputRunParameters,
    ),
  );
}
export function streamRunAgentAgentToolInputRunParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunParameters' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunLanguage$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = z.nativeEnum(AgentToolInputRunLanguage);
/** @internal */
export const AgentToolInputRunLanguage$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunLanguage
> = AgentToolInputRunLanguage$inboundSchema;

/** @internal */
export const AgentToolInputRunCodeTool$inboundSchema: z.ZodType<
  AgentToolInputRunCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunParameters$inboundSchema
  ).optional(),
  language: AgentToolInputRunLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type AgentToolInputRunCodeTool$Outbound = {
  parameters?: StreamRunAgentAgentToolInputRunParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const AgentToolInputRunCodeTool$outboundSchema: z.ZodType<
  AgentToolInputRunCodeTool$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeTool
> = z.object({
  parameters: z.lazy(() =>
    StreamRunAgentAgentToolInputRunParameters$outboundSchema
  ).optional(),
  language: AgentToolInputRunLanguage$outboundSchema,
  code: z.string(),
});

export function agentToolInputRunCodeToolToJSON(
  agentToolInputRunCodeTool: AgentToolInputRunCodeTool,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeTool$outboundSchema.parse(agentToolInputRunCodeTool),
  );
}
export function agentToolInputRunCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeTool' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunCodeToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("code"),
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  code_tool: z.lazy(() => AgentToolInputRunCodeTool$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "code_tool": "codeTool",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunCodeToolRun$Outbound = {
  type: "code";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  code_tool: AgentToolInputRunCodeTool$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunCodeToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunCodeToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunCodeToolRun
> = z.object({
  type: z.literal("code"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  codeTool: z.lazy(() => AgentToolInputRunCodeTool$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    codeTool: "code_tool",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunCodeToolRunToJSON(
  agentToolInputRunCodeToolRun: AgentToolInputRunCodeToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunCodeToolRun$outboundSchema.parse(
      agentToolInputRunCodeToolRun,
    ),
  );
}
export function agentToolInputRunCodeToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunCodeToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunCodeToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunCodeToolRun' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunMethod$inboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = z.nativeEnum(AgentToolInputRunMethod);
/** @internal */
export const AgentToolInputRunMethod$outboundSchema: z.ZodNativeEnum<
  typeof AgentToolInputRunMethod
> = AgentToolInputRunMethod$inboundSchema;

/** @internal */
export const StreamRunAgentHeaders2$inboundSchema: z.ZodType<
  StreamRunAgentHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type StreamRunAgentHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const StreamRunAgentHeaders2$outboundSchema: z.ZodType<
  StreamRunAgentHeaders2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function streamRunAgentHeaders2ToJSON(
  streamRunAgentHeaders2: StreamRunAgentHeaders2,
): string {
  return JSON.stringify(
    StreamRunAgentHeaders2$outboundSchema.parse(streamRunAgentHeaders2),
  );
}
export function streamRunAgentHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentHeaders2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunHeaders$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => StreamRunAgentHeaders2$inboundSchema), z.string()]);
/** @internal */
export type StreamRunAgentAgentToolInputRunHeaders$Outbound =
  | StreamRunAgentHeaders2$Outbound
  | string;

/** @internal */
export const StreamRunAgentAgentToolInputRunHeaders$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRunHeaders$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRunHeaders
> = z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]);

export function streamRunAgentAgentToolInputRunHeadersToJSON(
  streamRunAgentAgentToolInputRunHeaders:
    StreamRunAgentAgentToolInputRunHeaders,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunHeaders$outboundSchema.parse(
      streamRunAgentAgentToolInputRunHeaders,
    ),
  );
}
export function streamRunAgentAgentToolInputRunHeadersFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRunHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunHeaders' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunBlueprint$inboundSchema: z.ZodType<
  AgentToolInputRunBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => StreamRunAgentHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type AgentToolInputRunBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: StreamRunAgentHeaders2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const AgentToolInputRunBlueprint$outboundSchema: z.ZodType<
  AgentToolInputRunBlueprint$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunBlueprint
> = z.object({
  url: z.string(),
  method: AgentToolInputRunMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => StreamRunAgentHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function agentToolInputRunBlueprintToJSON(
  agentToolInputRunBlueprint: AgentToolInputRunBlueprint,
): string {
  return JSON.stringify(
    AgentToolInputRunBlueprint$outboundSchema.parse(agentToolInputRunBlueprint),
  );
}
export function agentToolInputRunBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunBlueprint' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > = z.nativeEnum(
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType,
  );
/** @internal */
export const StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType
  > =
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema;

/** @internal */
export const AgentToolInputRunDefaultValue$inboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type AgentToolInputRunDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const AgentToolInputRunDefaultValue$outboundSchema: z.ZodType<
  AgentToolInputRunDefaultValue$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function agentToolInputRunDefaultValueToJSON(
  agentToolInputRunDefaultValue: AgentToolInputRunDefaultValue,
): string {
  return JSON.stringify(
    AgentToolInputRunDefaultValue$outboundSchema.parse(
      agentToolInputRunDefaultValue,
    ),
  );
}
export function agentToolInputRunDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunDefaultValue' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunArguments$inboundSchema: z.ZodType<
  AgentToolInputRunArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type AgentToolInputRunArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const AgentToolInputRunArguments$outboundSchema: z.ZodType<
  AgentToolInputRunArguments$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunArguments
> = z.object({
  type:
    StreamRunAgentAgentToolInputRunAgentsRequestRequestBodySettingsTools12HttpType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function agentToolInputRunArgumentsToJSON(
  agentToolInputRunArguments: AgentToolInputRunArguments,
): string {
  return JSON.stringify(
    AgentToolInputRunArguments$outboundSchema.parse(agentToolInputRunArguments),
  );
}
export function agentToolInputRunArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunArguments' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHttp$inboundSchema: z.ZodType<
  AgentToolInputRunHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$inboundSchema))
    .optional(),
});
/** @internal */
export type AgentToolInputRunHttp$Outbound = {
  blueprint: AgentToolInputRunBlueprint$Outbound;
  arguments?: { [k: string]: AgentToolInputRunArguments$Outbound } | undefined;
};

/** @internal */
export const AgentToolInputRunHttp$outboundSchema: z.ZodType<
  AgentToolInputRunHttp$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHttp
> = z.object({
  blueprint: z.lazy(() => AgentToolInputRunBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => AgentToolInputRunArguments$outboundSchema))
    .optional(),
});

export function agentToolInputRunHttpToJSON(
  agentToolInputRunHttp: AgentToolInputRunHttp,
): string {
  return JSON.stringify(
    AgentToolInputRunHttp$outboundSchema.parse(agentToolInputRunHttp),
  );
}
export function agentToolInputRunHttpFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHttp' from JSON`,
  );
}

/** @internal */
export const AgentToolInputRunHTTPToolRun$inboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("http"),
  key: z.string(),
  _id: z.string().optional(),
  display_name: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$inboundSchema),
  requires_approval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type AgentToolInputRunHTTPToolRun$Outbound = {
  type: "http";
  key: string;
  _id?: string | undefined;
  display_name?: string | undefined;
  description: string;
  http: AgentToolInputRunHttp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const AgentToolInputRunHTTPToolRun$outboundSchema: z.ZodType<
  AgentToolInputRunHTTPToolRun$Outbound,
  z.ZodTypeDef,
  AgentToolInputRunHTTPToolRun
> = z.object({
  type: z.literal("http"),
  key: z.string(),
  id: z.string().optional(),
  displayName: z.string().optional(),
  description: z.string(),
  http: z.lazy(() => AgentToolInputRunHttp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function agentToolInputRunHTTPToolRunToJSON(
  agentToolInputRunHTTPToolRun: AgentToolInputRunHTTPToolRun,
): string {
  return JSON.stringify(
    AgentToolInputRunHTTPToolRun$outboundSchema.parse(
      agentToolInputRunHTTPToolRun,
    ),
  );
}
export function agentToolInputRunHTTPToolRunFromJSON(
  jsonString: string,
): SafeParseResult<AgentToolInputRunHTTPToolRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgentToolInputRunHTTPToolRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgentToolInputRunHTTPToolRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("current_date"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound = {
  type: "current_date";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCurrentDateTool
  > = z.object({
    type: z.literal("current_date"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCurrentDateToolToJSON(
  streamRunAgentAgentToolInputRunCurrentDateTool:
    StreamRunAgentAgentToolInputRunCurrentDateTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCurrentDateTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCurrentDateToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCurrentDateTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCurrentDateTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("query_knowledge_base"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound = {
  type: "query_knowledge_base";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool
  > = z.object({
    type: z.literal("query_knowledge_base"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolToJSON(
  streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool:
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryKnowledgeBaseToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound =
  {
    type: "retrieve_knowledge_bases";
    requires_approval?: boolean | undefined;
  };

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool
  > = z.object({
    type: z.literal("retrieve_knowledge_bases"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool:
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveKnowledgeBasesToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("delete_memory_document"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound = {
  type: "delete_memory_document";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool
  > = z.object({
    type: z.literal("delete_memory_document"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolToJSON(
  streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool:
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunDeleteMemoryDocumentTool),
  );
}
export function streamRunAgentAgentToolInputRunDeleteMemoryDocumentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("retrieve_memory_stores"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound = {
  type: "retrieve_memory_stores";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool
  > = z.object({
    type: z.literal("retrieve_memory_stores"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool:
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      .parse(streamRunAgentAgentToolInputRunRetrieveMemoryStoresTool),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveMemoryStoresToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("write_memory_store"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound = {
  type: "write_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool
  > = z.object({
    type: z.literal("write_memory_store"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunWriteMemoryStoreTool:
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWriteMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWriteMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWriteMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWriteMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("query_memory_store"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound = {
  type: "query_memory_store";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool
  > = z.object({
    type: z.literal("query_memory_store"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolToJSON(
  streamRunAgentAgentToolInputRunQueryMemoryStoreTool:
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunQueryMemoryStoreTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunQueryMemoryStoreToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunQueryMemoryStoreTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunQueryMemoryStoreTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("retrieve_agents"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound = {
  type: "retrieve_agents";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool
  > = z.object({
    type: z.literal("retrieve_agents"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunRetrieveAgentsToolToJSON(
  streamRunAgentAgentToolInputRunRetrieveAgentsTool:
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunRetrieveAgentsTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunRetrieveAgentsToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunRetrieveAgentsTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunRetrieveAgentsTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("call_sub_agent"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound = {
  type: "call_sub_agent";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunCallSubAgentTool
  > = z.object({
    type: z.literal("call_sub_agent"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunCallSubAgentToolToJSON(
  streamRunAgentAgentToolInputRunCallSubAgentTool:
    StreamRunAgentAgentToolInputRunCallSubAgentTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunCallSubAgentTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunCallSubAgentToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunCallSubAgentTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunCallSubAgentTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("web_scraper"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunWebScraperTool$Outbound = {
  type: "web_scraper";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunWebScraperTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunWebScraperTool
  > = z.object({
    type: z.literal("web_scraper"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunWebScraperToolToJSON(
  streamRunAgentAgentToolInputRunWebScraperTool:
    StreamRunAgentAgentToolInputRunWebScraperTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunWebScraperTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunWebScraperToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunWebScraperTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunWebScraperTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("google_search"),
    requires_approval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "requires_approval": "requiresApproval",
    });
  });
/** @internal */
export type StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound = {
  type: "google_search";
  requires_approval?: boolean | undefined;
};

/** @internal */
export const StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema:
  z.ZodType<
    StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound,
    z.ZodTypeDef,
    StreamRunAgentAgentToolInputRunGoogleSearchTool
  > = z.object({
    type: z.literal("google_search"),
    requiresApproval: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      requiresApproval: "requires_approval",
    });
  });

export function streamRunAgentAgentToolInputRunGoogleSearchToolToJSON(
  streamRunAgentAgentToolInputRunGoogleSearchTool:
    StreamRunAgentAgentToolInputRunGoogleSearchTool,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema.parse(
      streamRunAgentAgentToolInputRunGoogleSearchTool,
    ),
  );
}
export function streamRunAgentAgentToolInputRunGoogleSearchToolFromJSON(
  jsonString: string,
): SafeParseResult<
  StreamRunAgentAgentToolInputRunGoogleSearchTool,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'StreamRunAgentAgentToolInputRunGoogleSearchTool' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentToolInputRun$inboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema),
  z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunJSONSchemaToolRun$inboundSchema),
  z.lazy(() => AgentToolInputRunMCPToolRun$inboundSchema),
]);
/** @internal */
export type StreamRunAgentAgentToolInputRun$Outbound =
  | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
  | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
  | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
  | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
  | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
  | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
  | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
  | AgentToolInputRunHTTPToolRun$Outbound
  | AgentToolInputRunCodeToolRun$Outbound
  | AgentToolInputRunFunctionToolRun$Outbound
  | AgentToolInputRunJSONSchemaToolRun$Outbound
  | AgentToolInputRunMCPToolRun$Outbound;

/** @internal */
export const StreamRunAgentAgentToolInputRun$outboundSchema: z.ZodType<
  StreamRunAgentAgentToolInputRun$Outbound,
  z.ZodTypeDef,
  StreamRunAgentAgentToolInputRun
> = z.union([
  z.lazy(() => StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema),
  z.lazy(() => StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
  ),
  z.lazy(() =>
    StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
  ),
  z.lazy(() => StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema),
  z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunJSONSchemaToolRun$outboundSchema),
  z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
]);

export function streamRunAgentAgentToolInputRunToJSON(
  streamRunAgentAgentToolInputRun: StreamRunAgentAgentToolInputRun,
): string {
  return JSON.stringify(
    StreamRunAgentAgentToolInputRun$outboundSchema.parse(
      streamRunAgentAgentToolInputRun,
    ),
  );
}
export function streamRunAgentAgentToolInputRunFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentAgentToolInputRun, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentAgentToolInputRun$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentAgentToolInputRun' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = z.nativeEnum(StreamRunAgentToolApprovalRequired);
/** @internal */
export const StreamRunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = StreamRunAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const StreamRunAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentExecuteOn
> = z.nativeEnum(StreamRunAgentExecuteOn);
/** @internal */
export const StreamRunAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentExecuteOn
> = StreamRunAgentExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentEvaluators$inboundSchema: z.ZodType<
  StreamRunAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: StreamRunAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type StreamRunAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentEvaluators$outboundSchema: z.ZodType<
  StreamRunAgentEvaluators$Outbound,
  z.ZodTypeDef,
  StreamRunAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentEvaluatorsToJSON(
  streamRunAgentEvaluators: StreamRunAgentEvaluators,
): string {
  return JSON.stringify(
    StreamRunAgentEvaluators$outboundSchema.parse(streamRunAgentEvaluators),
  );
}
export function streamRunAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentsExecuteOn
> = z.nativeEnum(StreamRunAgentAgentsExecuteOn);
/** @internal */
export const StreamRunAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentAgentsExecuteOn
> = StreamRunAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const StreamRunAgentGuardrails$inboundSchema: z.ZodType<
  StreamRunAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: StreamRunAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type StreamRunAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const StreamRunAgentGuardrails$outboundSchema: z.ZodType<
  StreamRunAgentGuardrails$Outbound,
  z.ZodTypeDef,
  StreamRunAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: StreamRunAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function streamRunAgentGuardrailsToJSON(
  streamRunAgentGuardrails: StreamRunAgentGuardrails,
): string {
  return JSON.stringify(
    StreamRunAgentGuardrails$outboundSchema.parse(streamRunAgentGuardrails),
  );
}
export function streamRunAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentSettings$inboundSchema: z.ZodType<
  StreamRunAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$inboundSchema
      ),
      z.lazy(() => StreamRunAgentAgentToolInputRunWebScraperTool$inboundSchema),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$inboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$inboundSchema
      ),
      z.lazy(() => AgentToolInputRunHTTPToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunJSONSchemaToolRun$inboundSchema),
      z.lazy(() => AgentToolInputRunMCPToolRun$inboundSchema),
    ]),
  ).optional(),
  tool_approval_required: StreamRunAgentToolApprovalRequired$inboundSchema
    .default("none"),
  max_iterations: z.number().int().default(100),
  max_execution_time: z.number().int().default(600),
  evaluators: z.array(z.lazy(() => StreamRunAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => StreamRunAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});
/** @internal */
export type StreamRunAgentSettings$Outbound = {
  tools?:
    | Array<
      | StreamRunAgentAgentToolInputRunGoogleSearchTool$Outbound
      | StreamRunAgentAgentToolInputRunWebScraperTool$Outbound
      | StreamRunAgentAgentToolInputRunCallSubAgentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveAgentsTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$Outbound
      | StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$Outbound
      | StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$Outbound
      | StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$Outbound
      | StreamRunAgentAgentToolInputRunCurrentDateTool$Outbound
      | AgentToolInputRunHTTPToolRun$Outbound
      | AgentToolInputRunCodeToolRun$Outbound
      | AgentToolInputRunFunctionToolRun$Outbound
      | AgentToolInputRunJSONSchemaToolRun$Outbound
      | AgentToolInputRunMCPToolRun$Outbound
    >
    | undefined;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
  evaluators?: Array<StreamRunAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<StreamRunAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const StreamRunAgentSettings$outboundSchema: z.ZodType<
  StreamRunAgentSettings$Outbound,
  z.ZodTypeDef,
  StreamRunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunGoogleSearchTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWebScraperTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCallSubAgentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveAgentsTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunWriteMemoryStoreTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveMemoryStoresTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunDeleteMemoryDocumentTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunRetrieveKnowledgeBasesTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunQueryKnowledgeBaseTool$outboundSchema
      ),
      z.lazy(() =>
        StreamRunAgentAgentToolInputRunCurrentDateTool$outboundSchema
      ),
      z.lazy(() => AgentToolInputRunHTTPToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunCodeToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunFunctionToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunJSONSchemaToolRun$outboundSchema),
      z.lazy(() => AgentToolInputRunMCPToolRun$outboundSchema),
    ]),
  ).optional(),
  toolApprovalRequired: StreamRunAgentToolApprovalRequired$outboundSchema
    .default("none"),
  maxIterations: z.number().int().default(100),
  maxExecutionTime: z.number().int().default(600),
  evaluators: z.array(z.lazy(() => StreamRunAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => StreamRunAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

export function streamRunAgentSettingsToJSON(
  streamRunAgentSettings: StreamRunAgentSettings,
): string {
  return JSON.stringify(
    StreamRunAgentSettings$outboundSchema.parse(streamRunAgentSettings),
  );
}
export function streamRunAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentSettings' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRequestBody$inboundSchema: z.ZodType<
  StreamRunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  task_id: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModelConfiguration2$inboundSchema),
    z.string(),
  ]),
  fallback_models: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentA2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => StreamRunAgentIdentity$inboundSchema).optional(),
  contact: z.lazy(() => StreamRunAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$inboundSchema),
  ).optional(),
  team_of_agents: z.array(
    z.lazy(() => StreamRunAgentTeamOfAgents$inboundSchema),
  ).optional(),
  settings: z.lazy(() => StreamRunAgentSettings$inboundSchema),
  metadata: z.record(z.any()).optional(),
  stream_timeout_seconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
    "stream_timeout_seconds": "streamTimeoutSeconds",
  });
});
/** @internal */
export type StreamRunAgentRequestBody$Outbound = {
  key: string;
  task_id?: string | undefined;
  model: StreamRunAgentModelConfiguration2$Outbound | string;
  fallback_models?:
    | Array<StreamRunAgentFallbackModelConfiguration2$Outbound | string>
    | undefined;
  role: string;
  instructions: string;
  message: StreamRunAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  identity?: StreamRunAgentIdentity$Outbound | undefined;
  contact?: StreamRunAgentContact$Outbound | undefined;
  thread?: StreamRunAgentThread$Outbound | undefined;
  memory?: StreamRunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<StreamRunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<StreamRunAgentTeamOfAgents$Outbound> | undefined;
  settings: StreamRunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamRunAgentRequestBody$outboundSchema: z.ZodType<
  StreamRunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.union([
    z.lazy(() => StreamRunAgentModelConfiguration2$outboundSchema),
    z.string(),
  ]),
  fallbackModels: z.array(
    z.union([
      z.lazy(() => StreamRunAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ]),
  ).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => StreamRunAgentIdentity$outboundSchema).optional(),
  contact: z.lazy(() => StreamRunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => StreamRunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => StreamRunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

export function streamRunAgentRequestBodyToJSON(
  streamRunAgentRequestBody: StreamRunAgentRequestBody,
): string {
  return JSON.stringify(
    StreamRunAgentRequestBody$outboundSchema.parse(streamRunAgentRequestBody),
  );
}
export function streamRunAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentData$inboundSchema: z.ZodType<
  StreamRunAgentData,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.AgentExecutionStartedStreamingEvent$inboundSchema,
  components.AgentStartedStreamingEvent$inboundSchema,
  components.AgentThoughtStreamingEvent$inboundSchema,
  components.AgentInactiveStreamingEvent$inboundSchema,
  components.AgentErroredStreamingEvent$inboundSchema,
  components.ActionReviewRequestedStreamingEvent$inboundSchema,
  components.ActionReviewedStreamingEvent$inboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
  components.ExecutionReviewedStreamingEvent$inboundSchema,
  components.ExecutionNamedStreamingEvent$inboundSchema,
  components.AgentHandedOffStreamingEvent$inboundSchema,
  components.AgentMessageCreatedStreamingEvent$inboundSchema,
  components.ToolExecutionStartedStreamingEvent$inboundSchema,
  components.ToolExecutionFinishedStreamingEvent$inboundSchema,
  components.ToolExecutionFailedStreamingEvent$inboundSchema,
  components.TimeoutStreamingEvent$inboundSchema,
  components.ErrorStreamingEvent$inboundSchema,
]);
/** @internal */
export type StreamRunAgentData$Outbound =
  | components.AgentExecutionStartedStreamingEvent$Outbound
  | components.AgentStartedStreamingEvent$Outbound
  | components.AgentThoughtStreamingEvent$Outbound
  | components.AgentInactiveStreamingEvent$Outbound
  | components.AgentErroredStreamingEvent$Outbound
  | components.ActionReviewRequestedStreamingEvent$Outbound
  | components.ActionReviewedStreamingEvent$Outbound
  | components.ExecutionReviewRequiredStreamingEvent$Outbound
  | components.ExecutionReviewedStreamingEvent$Outbound
  | components.ExecutionNamedStreamingEvent$Outbound
  | components.AgentHandedOffStreamingEvent$Outbound
  | components.AgentMessageCreatedStreamingEvent$Outbound
  | components.ToolExecutionStartedStreamingEvent$Outbound
  | components.ToolExecutionFinishedStreamingEvent$Outbound
  | components.ToolExecutionFailedStreamingEvent$Outbound
  | components.TimeoutStreamingEvent$Outbound
  | components.ErrorStreamingEvent$Outbound;

/** @internal */
export const StreamRunAgentData$outboundSchema: z.ZodType<
  StreamRunAgentData$Outbound,
  z.ZodTypeDef,
  StreamRunAgentData
> = z.union([
  components.AgentExecutionStartedStreamingEvent$outboundSchema,
  components.AgentStartedStreamingEvent$outboundSchema,
  components.AgentThoughtStreamingEvent$outboundSchema,
  components.AgentInactiveStreamingEvent$outboundSchema,
  components.AgentErroredStreamingEvent$outboundSchema,
  components.ActionReviewRequestedStreamingEvent$outboundSchema,
  components.ActionReviewedStreamingEvent$outboundSchema,
  components.ExecutionReviewRequiredStreamingEvent$outboundSchema,
  components.ExecutionReviewedStreamingEvent$outboundSchema,
  components.ExecutionNamedStreamingEvent$outboundSchema,
  components.AgentHandedOffStreamingEvent$outboundSchema,
  components.AgentMessageCreatedStreamingEvent$outboundSchema,
  components.ToolExecutionStartedStreamingEvent$outboundSchema,
  components.ToolExecutionFinishedStreamingEvent$outboundSchema,
  components.ToolExecutionFailedStreamingEvent$outboundSchema,
  components.TimeoutStreamingEvent$outboundSchema,
  components.ErrorStreamingEvent$outboundSchema,
]);

export function streamRunAgentDataToJSON(
  streamRunAgentData: StreamRunAgentData,
): string {
  return JSON.stringify(
    StreamRunAgentData$outboundSchema.parse(streamRunAgentData),
  );
}
export function streamRunAgentDataFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentData' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseBody$inboundSchema: z.ZodType<
  StreamRunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().transform((v, ctx) => {
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(
    z.union([
      components.AgentExecutionStartedStreamingEvent$inboundSchema,
      components.AgentStartedStreamingEvent$inboundSchema,
      components.AgentThoughtStreamingEvent$inboundSchema,
      components.AgentInactiveStreamingEvent$inboundSchema,
      components.AgentErroredStreamingEvent$inboundSchema,
      components.ActionReviewRequestedStreamingEvent$inboundSchema,
      components.ActionReviewedStreamingEvent$inboundSchema,
      components.ExecutionReviewRequiredStreamingEvent$inboundSchema,
      components.ExecutionReviewedStreamingEvent$inboundSchema,
      components.ExecutionNamedStreamingEvent$inboundSchema,
      components.AgentHandedOffStreamingEvent$inboundSchema,
      components.AgentMessageCreatedStreamingEvent$inboundSchema,
      components.ToolExecutionStartedStreamingEvent$inboundSchema,
      components.ToolExecutionFinishedStreamingEvent$inboundSchema,
      components.ToolExecutionFailedStreamingEvent$inboundSchema,
      components.TimeoutStreamingEvent$inboundSchema,
      components.ErrorStreamingEvent$inboundSchema,
    ]),
  ),
});
/** @internal */
export type StreamRunAgentResponseBody$Outbound = {
  data:
    | components.AgentExecutionStartedStreamingEvent$Outbound
    | components.AgentStartedStreamingEvent$Outbound
    | components.AgentThoughtStreamingEvent$Outbound
    | components.AgentInactiveStreamingEvent$Outbound
    | components.AgentErroredStreamingEvent$Outbound
    | components.ActionReviewRequestedStreamingEvent$Outbound
    | components.ActionReviewedStreamingEvent$Outbound
    | components.ExecutionReviewRequiredStreamingEvent$Outbound
    | components.ExecutionReviewedStreamingEvent$Outbound
    | components.ExecutionNamedStreamingEvent$Outbound
    | components.AgentHandedOffStreamingEvent$Outbound
    | components.AgentMessageCreatedStreamingEvent$Outbound
    | components.ToolExecutionStartedStreamingEvent$Outbound
    | components.ToolExecutionFinishedStreamingEvent$Outbound
    | components.ToolExecutionFailedStreamingEvent$Outbound
    | components.TimeoutStreamingEvent$Outbound
    | components.ErrorStreamingEvent$Outbound;
};

/** @internal */
export const StreamRunAgentResponseBody$outboundSchema: z.ZodType<
  StreamRunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseBody
> = z.object({
  data: z.union([
    components.AgentExecutionStartedStreamingEvent$outboundSchema,
    components.AgentStartedStreamingEvent$outboundSchema,
    components.AgentThoughtStreamingEvent$outboundSchema,
    components.AgentInactiveStreamingEvent$outboundSchema,
    components.AgentErroredStreamingEvent$outboundSchema,
    components.ActionReviewRequestedStreamingEvent$outboundSchema,
    components.ActionReviewedStreamingEvent$outboundSchema,
    components.ExecutionReviewRequiredStreamingEvent$outboundSchema,
    components.ExecutionReviewedStreamingEvent$outboundSchema,
    components.ExecutionNamedStreamingEvent$outboundSchema,
    components.AgentHandedOffStreamingEvent$outboundSchema,
    components.AgentMessageCreatedStreamingEvent$outboundSchema,
    components.ToolExecutionStartedStreamingEvent$outboundSchema,
    components.ToolExecutionFinishedStreamingEvent$outboundSchema,
    components.ToolExecutionFailedStreamingEvent$outboundSchema,
    components.TimeoutStreamingEvent$outboundSchema,
    components.ErrorStreamingEvent$outboundSchema,
  ]),
});

export function streamRunAgentResponseBodyToJSON(
  streamRunAgentResponseBody: StreamRunAgentResponseBody,
): string {
  return JSON.stringify(
    StreamRunAgentResponseBody$outboundSchema.parse(streamRunAgentResponseBody),
  );
}
export function streamRunAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseBody' from JSON`,
  );
}
