/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export const StreamRunAgentRole2 = {
  Tool: "tool",
} as const;
export type StreamRunAgentRole2 = ClosedEnum<typeof StreamRunAgentRole2>;

export const StreamRunAgentRole1 = {
  User: "user",
} as const;
export type StreamRunAgentRole1 = ClosedEnum<typeof StreamRunAgentRole1>;

/**
 * Message role (user or tool for continuing executions)
 */
export type StreamRunAgentRole = StreamRunAgentRole1 | StreamRunAgentRole2;

export const StreamRunAgentPartsAgentsRequestRequestBodyMessageKind = {
  ToolResult: "tool_result",
} as const;
export type StreamRunAgentPartsAgentsRequestRequestBodyMessageKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsRequestRequestBodyMessageKind
>;

export type Parts5 = {
  kind: StreamRunAgentPartsAgentsRequestRequestBodyMessageKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsRequestRequestBodyKind = {
  ToolCall: "tool_call",
} as const;
export type StreamRunAgentPartsAgentsRequestRequestBodyKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsRequestRequestBodyKind
>;

export type StreamRunAgentParts4 = {
  kind: StreamRunAgentPartsAgentsRequestRequestBodyKind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsRequestKind = {
  File: "file",
} as const;
export type StreamRunAgentPartsAgentsRequestKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsRequestKind
>;

export type StreamRunAgentFile2 = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentFile1 = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type StreamRunAgentPartsFile = StreamRunAgentFile1 | StreamRunAgentFile2;

export type StreamRunAgentParts3 = {
  kind: StreamRunAgentPartsAgentsRequestKind;
  file: StreamRunAgentFile1 | StreamRunAgentFile2;
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsAgentsKind = {
  Data: "data",
} as const;
export type StreamRunAgentPartsAgentsKind = ClosedEnum<
  typeof StreamRunAgentPartsAgentsKind
>;

export type StreamRunAgentParts2 = {
  kind: StreamRunAgentPartsAgentsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const StreamRunAgentPartsKind = {
  Text: "text",
} as const;
export type StreamRunAgentPartsKind = ClosedEnum<
  typeof StreamRunAgentPartsKind
>;

export type StreamRunAgentParts1 = {
  kind: StreamRunAgentPartsKind;
  text: string;
};

export type StreamRunAgentParts =
  | StreamRunAgentParts4
  | StreamRunAgentParts1
  | StreamRunAgentParts2
  | StreamRunAgentParts3
  | Parts5;

/**
 * The A2A format message containing the task for the agent to perform.
 */
export type StreamRunAgentMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: StreamRunAgentRole1 | StreamRunAgentRole2;
  /**
   * A2A message parts
   */
  parts: Array<
    | StreamRunAgentParts4
    | StreamRunAgentParts1
    | StreamRunAgentParts2
    | StreamRunAgentParts3
    | Parts5
  >;
  /**
   * Optional message metadata
   */
  metadata?: { [k: string]: any } | undefined;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type StreamRunAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type StreamRunAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type StreamRunAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export const StreamRunAgentConfigurationAgentsType = {
  Query: "query",
} as const;
export type StreamRunAgentConfigurationAgentsType = ClosedEnum<
  typeof StreamRunAgentConfigurationAgentsType
>;

export type StreamRunAgentConfiguration2 = {
  type: StreamRunAgentConfigurationAgentsType;
  query: string;
};

export const StreamRunAgentConfigurationType = {
  LastUserMessage: "last_user_message",
} as const;
export type StreamRunAgentConfigurationType = ClosedEnum<
  typeof StreamRunAgentConfigurationType
>;

export type StreamRunAgentConfiguration1 = {
  type: StreamRunAgentConfigurationType;
};

/**
 * Defines the configuration settings which can either be for a user message or a text entry.
 */
export type StreamRunAgentConfiguration =
  | StreamRunAgentConfiguration2
  | StreamRunAgentConfiguration1;

export type StreamRunAgentKnowledgeBases = {
  /**
   * Defines the configuration settings which can either be for a user message or a text entry.
   */
  configuration: StreamRunAgentConfiguration2 | StreamRunAgentConfiguration1;
};

export type StreamRunAgentTeamOfAgents = {
  id: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const ToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type ToolsStatus = ClosedEnum<typeof ToolsStatus>;

export const StreamRunAgentToolsType = {
  Http: "http",
} as const;
export type StreamRunAgentToolsType = ClosedEnum<
  typeof StreamRunAgentToolsType
>;

/**
 * The HTTP method to use.
 */
export const ToolsMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type ToolsMethod = ClosedEnum<typeof ToolsMethod>;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type ToolsBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: ToolsMethod;
  /**
   * The headers to send with the request.
   */
  headers?: { [k: string]: string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const StreamRunAgentToolsAgentsType = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type StreamRunAgentToolsAgentsType = ClosedEnum<
  typeof StreamRunAgentToolsAgentsType
>;

/**
 * The default value of the argument.
 */
export type ToolsDefaultValue = string | number | boolean;

export type ToolsArguments = {
  /**
   * The type of the argument.
   */
  type: StreamRunAgentToolsAgentsType;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type ToolsHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: ToolsBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: ToolsArguments } | undefined;
};

/**
 * Makes HTTP requests to external APIs
 */
export type Tools24 = {
  id?: string | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName: string;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: ToolsStatus | undefined;
  versionHash?: string | undefined;
  type: StreamRunAgentToolsType;
  http: ToolsHttp;
  requiresApproval?: boolean | undefined;
};

/**
 * Available tools for agent execution. Each tool provides specific capabilities to interact with external systems, retrieve information, or perform specialized tasks.
 */
export type StreamRunAgentTools =
  | (components.HttpTool & { type: "http" })
  | (components.CodeExecutionTool & { type: "code" })
  | (components.FunctionTool & { type: "function" })
  | (components.GoogleSearchTool & { type: "google_search" })
  | (components.WebScraperTool & { type: "web_scraper" })
  | (components.CallSubAgentTool & { type: "call_sub_agent" })
  | (components.RetrieveAgentsTool & { type: "retrieve_agents" })
  | (components.QueryMemoryStoreTool & { type: "query_memory_store" })
  | (components.WriteMemoryStoreTool & { type: "write_memory_store" })
  | (components.RetrieveMemoryStoresTool & { type: "retrieve_memory_stores" })
  | (components.RetrieveKnowledgeBasesTool & {
    type: "retrieve_knowledge_bases";
  })
  | (components.QueryKnowledgeBaseTool & { type: "query_knowledge_base" })
  | (components.CurrentDateTool & { type: "current_date" });

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const StreamRunAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type StreamRunAgentToolApprovalRequired = ClosedEnum<
  typeof StreamRunAgentToolApprovalRequired
>;

export type StreamRunAgentSettings = {
  tools: Array<
    | (components.HttpTool & { type: "http" })
    | (components.CodeExecutionTool & { type: "code" })
    | (components.FunctionTool & { type: "function" })
    | (components.GoogleSearchTool & { type: "google_search" })
    | (components.WebScraperTool & { type: "web_scraper" })
    | (components.CallSubAgentTool & { type: "call_sub_agent" })
    | (components.RetrieveAgentsTool & { type: "retrieve_agents" })
    | (components.QueryMemoryStoreTool & { type: "query_memory_store" })
    | (components.WriteMemoryStoreTool & { type: "write_memory_store" })
    | (components.RetrieveMemoryStoresTool & { type: "retrieve_memory_stores" })
    | (components.RetrieveKnowledgeBasesTool & {
      type: "retrieve_knowledge_bases";
    })
    | (components.QueryKnowledgeBaseTool & { type: "query_knowledge_base" })
    | (components.CurrentDateTool & { type: "current_date" })
  >;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: StreamRunAgentToolApprovalRequired | undefined;
  /**
   * Maximum iterations before the agent must provide its best answer.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for task execution.
   */
  maxExecutionTime?: number | undefined;
};

export type StreamRunAgentRequestBody = {
  /**
   * A unique identifier for the agent. This key must be unique within the same workspace and cannot be reused. When executing the agent, this key determines if the agent already exists. If the agent version differs, a new version is created at the end of the execution, except for the task. All agent parameters are evaluated to decide if a new version is needed.
   */
  key: string;
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The language model that powers the agent. The model must support tool calling capabilities.
   */
  model: string;
  /**
   * Optional array of fallback model IDs to use when the primary model fails. Models are tried in order. All models must support tool calling capabilities.
   */
  fallbackModels?: Array<string> | undefined;
  /**
   * Specifies the agent's function and area of expertise.
   */
  role: string;
  /**
   * Provides context and purpose for the agent. Combined with the system prompt template to generate the agent's instructions.
   */
  instructions: string;
  /**
   * The A2A format message containing the task for the agent to perform.
   */
  message: StreamRunAgentMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: StreamRunAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: StreamRunAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: StreamRunAgentMemory | undefined;
  /**
   * The path where the entity is stored in the project structure. The first element of the path always represents the project name. Any subsequent path element after the project will be created as a folder in the project if it does not exists.
   */
  path: string;
  /**
   * A brief summary of the agent's purpose.
   */
  description?: string | undefined;
  /**
   * A custom system prompt template for the agent. If omitted, the default template is used.
   */
  systemPrompt?: string | undefined;
  memoryStores?: Array<string> | undefined;
  knowledgeBases?: Array<StreamRunAgentKnowledgeBases> | undefined;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents?: Array<StreamRunAgentTeamOfAgents> | undefined;
  settings: StreamRunAgentSettings;
  /**
   * Optional metadata for the agent run as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Stream timeout in seconds (1-3600). Default: 1800 (30 minutes)
   */
  streamTimeoutSeconds?: number | undefined;
};

/**
 * SSE stream of agent events
 */
export type StreamRunAgentResponseBody = {
  /**
   * JSON-encoded event data
   */
  data: string;
};

/** @internal */
export const StreamRunAgentRole2$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRole2
> = z.nativeEnum(StreamRunAgentRole2);

/** @internal */
export const StreamRunAgentRole2$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRole2
> = StreamRunAgentRole2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentRole2$ {
  /** @deprecated use `StreamRunAgentRole2$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentRole2$inboundSchema;
  /** @deprecated use `StreamRunAgentRole2$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentRole2$outboundSchema;
}

/** @internal */
export const StreamRunAgentRole1$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRole1
> = z.nativeEnum(StreamRunAgentRole1);

/** @internal */
export const StreamRunAgentRole1$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentRole1
> = StreamRunAgentRole1$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentRole1$ {
  /** @deprecated use `StreamRunAgentRole1$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentRole1$inboundSchema;
  /** @deprecated use `StreamRunAgentRole1$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentRole1$outboundSchema;
}

/** @internal */
export const StreamRunAgentRole$inboundSchema: z.ZodType<
  StreamRunAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  StreamRunAgentRole1$inboundSchema,
  StreamRunAgentRole2$inboundSchema,
]);

/** @internal */
export type StreamRunAgentRole$Outbound = string | string;

/** @internal */
export const StreamRunAgentRole$outboundSchema: z.ZodType<
  StreamRunAgentRole$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRole
> = z.union([
  StreamRunAgentRole1$outboundSchema,
  StreamRunAgentRole2$outboundSchema,
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentRole$ {
  /** @deprecated use `StreamRunAgentRole$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentRole$inboundSchema;
  /** @deprecated use `StreamRunAgentRole$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentRole$outboundSchema;
  /** @deprecated use `StreamRunAgentRole$Outbound` instead. */
  export type Outbound = StreamRunAgentRole$Outbound;
}

export function streamRunAgentRoleToJSON(
  streamRunAgentRole: StreamRunAgentRole,
): string {
  return JSON.stringify(
    StreamRunAgentRole$outboundSchema.parse(streamRunAgentRole),
  );
}

export function streamRunAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRole' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$inboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsRequestRequestBodyMessageKind
  > = z.nativeEnum(StreamRunAgentPartsAgentsRequestRequestBodyMessageKind);

/** @internal */
export const StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$outboundSchema:
  z.ZodNativeEnum<
    typeof StreamRunAgentPartsAgentsRequestRequestBodyMessageKind
  > = StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$ {
  /** @deprecated use `StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$inboundSchema` instead. */
  export const inboundSchema =
    StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$outboundSchema` instead. */
  export const outboundSchema =
    StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$outboundSchema;
}

/** @internal */
export const Parts5$inboundSchema: z.ZodType<Parts5, z.ZodTypeDef, unknown> = z
  .object({
    kind: StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$inboundSchema,
    tool_call_id: z.string(),
    result: z.any().optional(),
    metadata: z.record(z.any()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_call_id": "toolCallId",
    });
  });

/** @internal */
export type Parts5$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Parts5$outboundSchema: z.ZodType<
  Parts5$Outbound,
  z.ZodTypeDef,
  Parts5
> = z.object({
  kind: StreamRunAgentPartsAgentsRequestRequestBodyMessageKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Parts5$ {
  /** @deprecated use `Parts5$inboundSchema` instead. */
  export const inboundSchema = Parts5$inboundSchema;
  /** @deprecated use `Parts5$outboundSchema` instead. */
  export const outboundSchema = Parts5$outboundSchema;
  /** @deprecated use `Parts5$Outbound` instead. */
  export type Outbound = Parts5$Outbound;
}

export function parts5ToJSON(parts5: Parts5): string {
  return JSON.stringify(Parts5$outboundSchema.parse(parts5));
}

export function parts5FromJSON(
  jsonString: string,
): SafeParseResult<Parts5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts5' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsRequestRequestBodyKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsRequestRequestBodyKind> = z
    .nativeEnum(StreamRunAgentPartsAgentsRequestRequestBodyKind);

/** @internal */
export const StreamRunAgentPartsAgentsRequestRequestBodyKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsRequestRequestBodyKind> =
    StreamRunAgentPartsAgentsRequestRequestBodyKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsAgentsRequestRequestBodyKind$ {
  /** @deprecated use `StreamRunAgentPartsAgentsRequestRequestBodyKind$inboundSchema` instead. */
  export const inboundSchema =
    StreamRunAgentPartsAgentsRequestRequestBodyKind$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsAgentsRequestRequestBodyKind$outboundSchema` instead. */
  export const outboundSchema =
    StreamRunAgentPartsAgentsRequestRequestBodyKind$outboundSchema;
}

/** @internal */
export const StreamRunAgentParts4$inboundSchema: z.ZodType<
  StreamRunAgentParts4,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsRequestRequestBodyKind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});

/** @internal */
export type StreamRunAgentParts4$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentParts4$outboundSchema: z.ZodType<
  StreamRunAgentParts4$Outbound,
  z.ZodTypeDef,
  StreamRunAgentParts4
> = z.object({
  kind: StreamRunAgentPartsAgentsRequestRequestBodyKind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentParts4$ {
  /** @deprecated use `StreamRunAgentParts4$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentParts4$inboundSchema;
  /** @deprecated use `StreamRunAgentParts4$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentParts4$outboundSchema;
  /** @deprecated use `StreamRunAgentParts4$Outbound` instead. */
  export type Outbound = StreamRunAgentParts4$Outbound;
}

export function streamRunAgentParts4ToJSON(
  streamRunAgentParts4: StreamRunAgentParts4,
): string {
  return JSON.stringify(
    StreamRunAgentParts4$outboundSchema.parse(streamRunAgentParts4),
  );
}

export function streamRunAgentParts4FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentParts4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentParts4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentParts4' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsRequestKind$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsRequestKind> = z.nativeEnum(
    StreamRunAgentPartsAgentsRequestKind,
  );

/** @internal */
export const StreamRunAgentPartsAgentsRequestKind$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentPartsAgentsRequestKind> =
    StreamRunAgentPartsAgentsRequestKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsAgentsRequestKind$ {
  /** @deprecated use `StreamRunAgentPartsAgentsRequestKind$inboundSchema` instead. */
  export const inboundSchema =
    StreamRunAgentPartsAgentsRequestKind$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsAgentsRequestKind$outboundSchema` instead. */
  export const outboundSchema =
    StreamRunAgentPartsAgentsRequestKind$outboundSchema;
}

/** @internal */
export const StreamRunAgentFile2$inboundSchema: z.ZodType<
  StreamRunAgentFile2,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/** @internal */
export type StreamRunAgentFile2$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFile2$outboundSchema: z.ZodType<
  StreamRunAgentFile2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFile2
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentFile2$ {
  /** @deprecated use `StreamRunAgentFile2$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentFile2$inboundSchema;
  /** @deprecated use `StreamRunAgentFile2$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentFile2$outboundSchema;
  /** @deprecated use `StreamRunAgentFile2$Outbound` instead. */
  export type Outbound = StreamRunAgentFile2$Outbound;
}

export function streamRunAgentFile2ToJSON(
  streamRunAgentFile2: StreamRunAgentFile2,
): string {
  return JSON.stringify(
    StreamRunAgentFile2$outboundSchema.parse(streamRunAgentFile2),
  );
}

export function streamRunAgentFile2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFile2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFile2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFile2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentFile1$inboundSchema: z.ZodType<
  StreamRunAgentFile1,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/** @internal */
export type StreamRunAgentFile1$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const StreamRunAgentFile1$outboundSchema: z.ZodType<
  StreamRunAgentFile1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentFile1
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentFile1$ {
  /** @deprecated use `StreamRunAgentFile1$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentFile1$inboundSchema;
  /** @deprecated use `StreamRunAgentFile1$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentFile1$outboundSchema;
  /** @deprecated use `StreamRunAgentFile1$Outbound` instead. */
  export type Outbound = StreamRunAgentFile1$Outbound;
}

export function streamRunAgentFile1ToJSON(
  streamRunAgentFile1: StreamRunAgentFile1,
): string {
  return JSON.stringify(
    StreamRunAgentFile1$outboundSchema.parse(streamRunAgentFile1),
  );
}

export function streamRunAgentFile1FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentFile1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentFile1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentFile1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsFile$inboundSchema: z.ZodType<
  StreamRunAgentPartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentFile1$inboundSchema),
  z.lazy(() => StreamRunAgentFile2$inboundSchema),
]);

/** @internal */
export type StreamRunAgentPartsFile$Outbound =
  | StreamRunAgentFile1$Outbound
  | StreamRunAgentFile2$Outbound;

/** @internal */
export const StreamRunAgentPartsFile$outboundSchema: z.ZodType<
  StreamRunAgentPartsFile$Outbound,
  z.ZodTypeDef,
  StreamRunAgentPartsFile
> = z.union([
  z.lazy(() => StreamRunAgentFile1$outboundSchema),
  z.lazy(() => StreamRunAgentFile2$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsFile$ {
  /** @deprecated use `StreamRunAgentPartsFile$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentPartsFile$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsFile$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentPartsFile$outboundSchema;
  /** @deprecated use `StreamRunAgentPartsFile$Outbound` instead. */
  export type Outbound = StreamRunAgentPartsFile$Outbound;
}

export function streamRunAgentPartsFileToJSON(
  streamRunAgentPartsFile: StreamRunAgentPartsFile,
): string {
  return JSON.stringify(
    StreamRunAgentPartsFile$outboundSchema.parse(streamRunAgentPartsFile),
  );
}

export function streamRunAgentPartsFileFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentPartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentPartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentPartsFile' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentParts3$inboundSchema: z.ZodType<
  StreamRunAgentParts3,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsRequestKind$inboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFile1$inboundSchema),
    z.lazy(() => StreamRunAgentFile2$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

/** @internal */
export type StreamRunAgentParts3$Outbound = {
  kind: string;
  file: StreamRunAgentFile1$Outbound | StreamRunAgentFile2$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentParts3$outboundSchema: z.ZodType<
  StreamRunAgentParts3$Outbound,
  z.ZodTypeDef,
  StreamRunAgentParts3
> = z.object({
  kind: StreamRunAgentPartsAgentsRequestKind$outboundSchema,
  file: z.union([
    z.lazy(() => StreamRunAgentFile1$outboundSchema),
    z.lazy(() => StreamRunAgentFile2$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentParts3$ {
  /** @deprecated use `StreamRunAgentParts3$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentParts3$inboundSchema;
  /** @deprecated use `StreamRunAgentParts3$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentParts3$outboundSchema;
  /** @deprecated use `StreamRunAgentParts3$Outbound` instead. */
  export type Outbound = StreamRunAgentParts3$Outbound;
}

export function streamRunAgentParts3ToJSON(
  streamRunAgentParts3: StreamRunAgentParts3,
): string {
  return JSON.stringify(
    StreamRunAgentParts3$outboundSchema.parse(streamRunAgentParts3),
  );
}

export function streamRunAgentParts3FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentParts3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentParts3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentParts3' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsAgentsKind
> = z.nativeEnum(StreamRunAgentPartsAgentsKind);

/** @internal */
export const StreamRunAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsAgentsKind
> = StreamRunAgentPartsAgentsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsAgentsKind$ {
  /** @deprecated use `StreamRunAgentPartsAgentsKind$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentPartsAgentsKind$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsAgentsKind$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentPartsAgentsKind$outboundSchema;
}

/** @internal */
export const StreamRunAgentParts2$inboundSchema: z.ZodType<
  StreamRunAgentParts2,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsAgentsKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

/** @internal */
export type StreamRunAgentParts2$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentParts2$outboundSchema: z.ZodType<
  StreamRunAgentParts2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentParts2
> = z.object({
  kind: StreamRunAgentPartsAgentsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentParts2$ {
  /** @deprecated use `StreamRunAgentParts2$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentParts2$inboundSchema;
  /** @deprecated use `StreamRunAgentParts2$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentParts2$outboundSchema;
  /** @deprecated use `StreamRunAgentParts2$Outbound` instead. */
  export type Outbound = StreamRunAgentParts2$Outbound;
}

export function streamRunAgentParts2ToJSON(
  streamRunAgentParts2: StreamRunAgentParts2,
): string {
  return JSON.stringify(
    StreamRunAgentParts2$outboundSchema.parse(streamRunAgentParts2),
  );
}

export function streamRunAgentParts2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentParts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentParts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentParts2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsKind
> = z.nativeEnum(StreamRunAgentPartsKind);

/** @internal */
export const StreamRunAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentPartsKind
> = StreamRunAgentPartsKind$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentPartsKind$ {
  /** @deprecated use `StreamRunAgentPartsKind$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentPartsKind$inboundSchema;
  /** @deprecated use `StreamRunAgentPartsKind$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentPartsKind$outboundSchema;
}

/** @internal */
export const StreamRunAgentParts1$inboundSchema: z.ZodType<
  StreamRunAgentParts1,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: StreamRunAgentPartsKind$inboundSchema,
  text: z.string(),
});

/** @internal */
export type StreamRunAgentParts1$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const StreamRunAgentParts1$outboundSchema: z.ZodType<
  StreamRunAgentParts1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentParts1
> = z.object({
  kind: StreamRunAgentPartsKind$outboundSchema,
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentParts1$ {
  /** @deprecated use `StreamRunAgentParts1$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentParts1$inboundSchema;
  /** @deprecated use `StreamRunAgentParts1$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentParts1$outboundSchema;
  /** @deprecated use `StreamRunAgentParts1$Outbound` instead. */
  export type Outbound = StreamRunAgentParts1$Outbound;
}

export function streamRunAgentParts1ToJSON(
  streamRunAgentParts1: StreamRunAgentParts1,
): string {
  return JSON.stringify(
    StreamRunAgentParts1$outboundSchema.parse(streamRunAgentParts1),
  );
}

export function streamRunAgentParts1FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentParts1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentParts1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentParts1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentParts$inboundSchema: z.ZodType<
  StreamRunAgentParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentParts4$inboundSchema),
  z.lazy(() => StreamRunAgentParts1$inboundSchema),
  z.lazy(() => StreamRunAgentParts2$inboundSchema),
  z.lazy(() => StreamRunAgentParts3$inboundSchema),
  z.lazy(() => Parts5$inboundSchema),
]);

/** @internal */
export type StreamRunAgentParts$Outbound =
  | StreamRunAgentParts4$Outbound
  | StreamRunAgentParts1$Outbound
  | StreamRunAgentParts2$Outbound
  | StreamRunAgentParts3$Outbound
  | Parts5$Outbound;

/** @internal */
export const StreamRunAgentParts$outboundSchema: z.ZodType<
  StreamRunAgentParts$Outbound,
  z.ZodTypeDef,
  StreamRunAgentParts
> = z.union([
  z.lazy(() => StreamRunAgentParts4$outboundSchema),
  z.lazy(() => StreamRunAgentParts1$outboundSchema),
  z.lazy(() => StreamRunAgentParts2$outboundSchema),
  z.lazy(() => StreamRunAgentParts3$outboundSchema),
  z.lazy(() => Parts5$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentParts$ {
  /** @deprecated use `StreamRunAgentParts$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentParts$inboundSchema;
  /** @deprecated use `StreamRunAgentParts$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentParts$outboundSchema;
  /** @deprecated use `StreamRunAgentParts$Outbound` instead. */
  export type Outbound = StreamRunAgentParts$Outbound;
}

export function streamRunAgentPartsToJSON(
  streamRunAgentParts: StreamRunAgentParts,
): string {
  return JSON.stringify(
    StreamRunAgentParts$outboundSchema.parse(streamRunAgentParts),
  );
}

export function streamRunAgentPartsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentParts' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMessage$inboundSchema: z.ZodType<
  StreamRunAgentMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRole1$inboundSchema,
    StreamRunAgentRole2$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentParts4$inboundSchema),
      z.lazy(() => StreamRunAgentParts1$inboundSchema),
      z.lazy(() => StreamRunAgentParts2$inboundSchema),
      z.lazy(() => StreamRunAgentParts3$inboundSchema),
      z.lazy(() => Parts5$inboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

/** @internal */
export type StreamRunAgentMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | StreamRunAgentParts4$Outbound
    | StreamRunAgentParts1$Outbound
    | StreamRunAgentParts2$Outbound
    | StreamRunAgentParts3$Outbound
    | Parts5$Outbound
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const StreamRunAgentMessage$outboundSchema: z.ZodType<
  StreamRunAgentMessage$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    StreamRunAgentRole1$outboundSchema,
    StreamRunAgentRole2$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => StreamRunAgentParts4$outboundSchema),
      z.lazy(() => StreamRunAgentParts1$outboundSchema),
      z.lazy(() => StreamRunAgentParts2$outboundSchema),
      z.lazy(() => StreamRunAgentParts3$outboundSchema),
      z.lazy(() => Parts5$outboundSchema),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentMessage$ {
  /** @deprecated use `StreamRunAgentMessage$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentMessage$inboundSchema;
  /** @deprecated use `StreamRunAgentMessage$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentMessage$outboundSchema;
  /** @deprecated use `StreamRunAgentMessage$Outbound` instead. */
  export type Outbound = StreamRunAgentMessage$Outbound;
}

export function streamRunAgentMessageToJSON(
  streamRunAgentMessage: StreamRunAgentMessage,
): string {
  return JSON.stringify(
    StreamRunAgentMessage$outboundSchema.parse(streamRunAgentMessage),
  );
}

export function streamRunAgentMessageFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMessage' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentContact$inboundSchema: z.ZodType<
  StreamRunAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});

/** @internal */
export type StreamRunAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentContact$outboundSchema: z.ZodType<
  StreamRunAgentContact$Outbound,
  z.ZodTypeDef,
  StreamRunAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentContact$ {
  /** @deprecated use `StreamRunAgentContact$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentContact$inboundSchema;
  /** @deprecated use `StreamRunAgentContact$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentContact$outboundSchema;
  /** @deprecated use `StreamRunAgentContact$Outbound` instead. */
  export type Outbound = StreamRunAgentContact$Outbound;
}

export function streamRunAgentContactToJSON(
  streamRunAgentContact: StreamRunAgentContact,
): string {
  return JSON.stringify(
    StreamRunAgentContact$outboundSchema.parse(streamRunAgentContact),
  );
}

export function streamRunAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentContact' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentThread$inboundSchema: z.ZodType<
  StreamRunAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

/** @internal */
export type StreamRunAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const StreamRunAgentThread$outboundSchema: z.ZodType<
  StreamRunAgentThread$Outbound,
  z.ZodTypeDef,
  StreamRunAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentThread$ {
  /** @deprecated use `StreamRunAgentThread$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentThread$inboundSchema;
  /** @deprecated use `StreamRunAgentThread$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentThread$outboundSchema;
  /** @deprecated use `StreamRunAgentThread$Outbound` instead. */
  export type Outbound = StreamRunAgentThread$Outbound;
}

export function streamRunAgentThreadToJSON(
  streamRunAgentThread: StreamRunAgentThread,
): string {
  return JSON.stringify(
    StreamRunAgentThread$outboundSchema.parse(streamRunAgentThread),
  );
}

export function streamRunAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentThread' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentMemory$inboundSchema: z.ZodType<
  StreamRunAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});

/** @internal */
export type StreamRunAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const StreamRunAgentMemory$outboundSchema: z.ZodType<
  StreamRunAgentMemory$Outbound,
  z.ZodTypeDef,
  StreamRunAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentMemory$ {
  /** @deprecated use `StreamRunAgentMemory$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentMemory$inboundSchema;
  /** @deprecated use `StreamRunAgentMemory$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentMemory$outboundSchema;
  /** @deprecated use `StreamRunAgentMemory$Outbound` instead. */
  export type Outbound = StreamRunAgentMemory$Outbound;
}

export function streamRunAgentMemoryToJSON(
  streamRunAgentMemory: StreamRunAgentMemory,
): string {
  return JSON.stringify(
    StreamRunAgentMemory$outboundSchema.parse(streamRunAgentMemory),
  );
}

export function streamRunAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentMemory' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentConfigurationAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentConfigurationAgentsType> = z.nativeEnum(
    StreamRunAgentConfigurationAgentsType,
  );

/** @internal */
export const StreamRunAgentConfigurationAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof StreamRunAgentConfigurationAgentsType> =
    StreamRunAgentConfigurationAgentsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentConfigurationAgentsType$ {
  /** @deprecated use `StreamRunAgentConfigurationAgentsType$inboundSchema` instead. */
  export const inboundSchema =
    StreamRunAgentConfigurationAgentsType$inboundSchema;
  /** @deprecated use `StreamRunAgentConfigurationAgentsType$outboundSchema` instead. */
  export const outboundSchema =
    StreamRunAgentConfigurationAgentsType$outboundSchema;
}

/** @internal */
export const StreamRunAgentConfiguration2$inboundSchema: z.ZodType<
  StreamRunAgentConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentConfigurationAgentsType$inboundSchema,
  query: z.string(),
});

/** @internal */
export type StreamRunAgentConfiguration2$Outbound = {
  type: string;
  query: string;
};

/** @internal */
export const StreamRunAgentConfiguration2$outboundSchema: z.ZodType<
  StreamRunAgentConfiguration2$Outbound,
  z.ZodTypeDef,
  StreamRunAgentConfiguration2
> = z.object({
  type: StreamRunAgentConfigurationAgentsType$outboundSchema,
  query: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentConfiguration2$ {
  /** @deprecated use `StreamRunAgentConfiguration2$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentConfiguration2$inboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration2$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentConfiguration2$outboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration2$Outbound` instead. */
  export type Outbound = StreamRunAgentConfiguration2$Outbound;
}

export function streamRunAgentConfiguration2ToJSON(
  streamRunAgentConfiguration2: StreamRunAgentConfiguration2,
): string {
  return JSON.stringify(
    StreamRunAgentConfiguration2$outboundSchema.parse(
      streamRunAgentConfiguration2,
    ),
  );
}

export function streamRunAgentConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentConfiguration2' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentConfigurationType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentConfigurationType
> = z.nativeEnum(StreamRunAgentConfigurationType);

/** @internal */
export const StreamRunAgentConfigurationType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentConfigurationType
> = StreamRunAgentConfigurationType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentConfigurationType$ {
  /** @deprecated use `StreamRunAgentConfigurationType$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentConfigurationType$inboundSchema;
  /** @deprecated use `StreamRunAgentConfigurationType$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentConfigurationType$outboundSchema;
}

/** @internal */
export const StreamRunAgentConfiguration1$inboundSchema: z.ZodType<
  StreamRunAgentConfiguration1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentConfigurationType$inboundSchema,
});

/** @internal */
export type StreamRunAgentConfiguration1$Outbound = {
  type: string;
};

/** @internal */
export const StreamRunAgentConfiguration1$outboundSchema: z.ZodType<
  StreamRunAgentConfiguration1$Outbound,
  z.ZodTypeDef,
  StreamRunAgentConfiguration1
> = z.object({
  type: StreamRunAgentConfigurationType$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentConfiguration1$ {
  /** @deprecated use `StreamRunAgentConfiguration1$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentConfiguration1$inboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration1$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentConfiguration1$outboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration1$Outbound` instead. */
  export type Outbound = StreamRunAgentConfiguration1$Outbound;
}

export function streamRunAgentConfiguration1ToJSON(
  streamRunAgentConfiguration1: StreamRunAgentConfiguration1,
): string {
  return JSON.stringify(
    StreamRunAgentConfiguration1$outboundSchema.parse(
      streamRunAgentConfiguration1,
    ),
  );
}

export function streamRunAgentConfiguration1FromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentConfiguration1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentConfiguration1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentConfiguration1' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentConfiguration$inboundSchema: z.ZodType<
  StreamRunAgentConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => StreamRunAgentConfiguration2$inboundSchema),
  z.lazy(() => StreamRunAgentConfiguration1$inboundSchema),
]);

/** @internal */
export type StreamRunAgentConfiguration$Outbound =
  | StreamRunAgentConfiguration2$Outbound
  | StreamRunAgentConfiguration1$Outbound;

/** @internal */
export const StreamRunAgentConfiguration$outboundSchema: z.ZodType<
  StreamRunAgentConfiguration$Outbound,
  z.ZodTypeDef,
  StreamRunAgentConfiguration
> = z.union([
  z.lazy(() => StreamRunAgentConfiguration2$outboundSchema),
  z.lazy(() => StreamRunAgentConfiguration1$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentConfiguration$ {
  /** @deprecated use `StreamRunAgentConfiguration$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentConfiguration$inboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentConfiguration$outboundSchema;
  /** @deprecated use `StreamRunAgentConfiguration$Outbound` instead. */
  export type Outbound = StreamRunAgentConfiguration$Outbound;
}

export function streamRunAgentConfigurationToJSON(
  streamRunAgentConfiguration: StreamRunAgentConfiguration,
): string {
  return JSON.stringify(
    StreamRunAgentConfiguration$outboundSchema.parse(
      streamRunAgentConfiguration,
    ),
  );
}

export function streamRunAgentConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentConfiguration' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentKnowledgeBases$inboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  configuration: z.union([
    z.lazy(() => StreamRunAgentConfiguration2$inboundSchema),
    z.lazy(() => StreamRunAgentConfiguration1$inboundSchema),
  ]),
});

/** @internal */
export type StreamRunAgentKnowledgeBases$Outbound = {
  configuration:
    | StreamRunAgentConfiguration2$Outbound
    | StreamRunAgentConfiguration1$Outbound;
};

/** @internal */
export const StreamRunAgentKnowledgeBases$outboundSchema: z.ZodType<
  StreamRunAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  StreamRunAgentKnowledgeBases
> = z.object({
  configuration: z.union([
    z.lazy(() => StreamRunAgentConfiguration2$outboundSchema),
    z.lazy(() => StreamRunAgentConfiguration1$outboundSchema),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentKnowledgeBases$ {
  /** @deprecated use `StreamRunAgentKnowledgeBases$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentKnowledgeBases$inboundSchema;
  /** @deprecated use `StreamRunAgentKnowledgeBases$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentKnowledgeBases$outboundSchema;
  /** @deprecated use `StreamRunAgentKnowledgeBases$Outbound` instead. */
  export type Outbound = StreamRunAgentKnowledgeBases$Outbound;
}

export function streamRunAgentKnowledgeBasesToJSON(
  streamRunAgentKnowledgeBases: StreamRunAgentKnowledgeBases,
): string {
  return JSON.stringify(
    StreamRunAgentKnowledgeBases$outboundSchema.parse(
      streamRunAgentKnowledgeBases,
    ),
  );
}

export function streamRunAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentTeamOfAgents$inboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  role: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});

/** @internal */
export type StreamRunAgentTeamOfAgents$Outbound = {
  _id: string;
  role?: string | undefined;
};

/** @internal */
export const StreamRunAgentTeamOfAgents$outboundSchema: z.ZodType<
  StreamRunAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTeamOfAgents
> = z.object({
  id: z.string(),
  role: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentTeamOfAgents$ {
  /** @deprecated use `StreamRunAgentTeamOfAgents$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentTeamOfAgents$inboundSchema;
  /** @deprecated use `StreamRunAgentTeamOfAgents$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentTeamOfAgents$outboundSchema;
  /** @deprecated use `StreamRunAgentTeamOfAgents$Outbound` instead. */
  export type Outbound = StreamRunAgentTeamOfAgents$Outbound;
}

export function streamRunAgentTeamOfAgentsToJSON(
  streamRunAgentTeamOfAgents: StreamRunAgentTeamOfAgents,
): string {
  return JSON.stringify(
    StreamRunAgentTeamOfAgents$outboundSchema.parse(streamRunAgentTeamOfAgents),
  );
}

export function streamRunAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const ToolsStatus$inboundSchema: z.ZodNativeEnum<typeof ToolsStatus> = z
  .nativeEnum(ToolsStatus);

/** @internal */
export const ToolsStatus$outboundSchema: z.ZodNativeEnum<typeof ToolsStatus> =
  ToolsStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsStatus$ {
  /** @deprecated use `ToolsStatus$inboundSchema` instead. */
  export const inboundSchema = ToolsStatus$inboundSchema;
  /** @deprecated use `ToolsStatus$outboundSchema` instead. */
  export const outboundSchema = ToolsStatus$outboundSchema;
}

/** @internal */
export const StreamRunAgentToolsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolsType
> = z.nativeEnum(StreamRunAgentToolsType);

/** @internal */
export const StreamRunAgentToolsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolsType
> = StreamRunAgentToolsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentToolsType$ {
  /** @deprecated use `StreamRunAgentToolsType$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentToolsType$inboundSchema;
  /** @deprecated use `StreamRunAgentToolsType$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentToolsType$outboundSchema;
}

/** @internal */
export const ToolsMethod$inboundSchema: z.ZodNativeEnum<typeof ToolsMethod> = z
  .nativeEnum(ToolsMethod);

/** @internal */
export const ToolsMethod$outboundSchema: z.ZodNativeEnum<typeof ToolsMethod> =
  ToolsMethod$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsMethod$ {
  /** @deprecated use `ToolsMethod$inboundSchema` instead. */
  export const inboundSchema = ToolsMethod$inboundSchema;
  /** @deprecated use `ToolsMethod$outboundSchema` instead. */
  export const outboundSchema = ToolsMethod$outboundSchema;
}

/** @internal */
export const ToolsBlueprint$inboundSchema: z.ZodType<
  ToolsBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: ToolsMethod$inboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/** @internal */
export type ToolsBlueprint$Outbound = {
  url: string;
  method: string;
  headers?: { [k: string]: string } | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const ToolsBlueprint$outboundSchema: z.ZodType<
  ToolsBlueprint$Outbound,
  z.ZodTypeDef,
  ToolsBlueprint
> = z.object({
  url: z.string(),
  method: ToolsMethod$outboundSchema,
  headers: z.record(z.string()).optional(),
  body: z.record(z.any()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsBlueprint$ {
  /** @deprecated use `ToolsBlueprint$inboundSchema` instead. */
  export const inboundSchema = ToolsBlueprint$inboundSchema;
  /** @deprecated use `ToolsBlueprint$outboundSchema` instead. */
  export const outboundSchema = ToolsBlueprint$outboundSchema;
  /** @deprecated use `ToolsBlueprint$Outbound` instead. */
  export type Outbound = ToolsBlueprint$Outbound;
}

export function toolsBlueprintToJSON(toolsBlueprint: ToolsBlueprint): string {
  return JSON.stringify(ToolsBlueprint$outboundSchema.parse(toolsBlueprint));
}

export function toolsBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<ToolsBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsBlueprint' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolsAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolsAgentsType
> = z.nativeEnum(StreamRunAgentToolsAgentsType);

/** @internal */
export const StreamRunAgentToolsAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolsAgentsType
> = StreamRunAgentToolsAgentsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentToolsAgentsType$ {
  /** @deprecated use `StreamRunAgentToolsAgentsType$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentToolsAgentsType$inboundSchema;
  /** @deprecated use `StreamRunAgentToolsAgentsType$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentToolsAgentsType$outboundSchema;
}

/** @internal */
export const ToolsDefaultValue$inboundSchema: z.ZodType<
  ToolsDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type ToolsDefaultValue$Outbound = string | number | boolean;

/** @internal */
export const ToolsDefaultValue$outboundSchema: z.ZodType<
  ToolsDefaultValue$Outbound,
  z.ZodTypeDef,
  ToolsDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsDefaultValue$ {
  /** @deprecated use `ToolsDefaultValue$inboundSchema` instead. */
  export const inboundSchema = ToolsDefaultValue$inboundSchema;
  /** @deprecated use `ToolsDefaultValue$outboundSchema` instead. */
  export const outboundSchema = ToolsDefaultValue$outboundSchema;
  /** @deprecated use `ToolsDefaultValue$Outbound` instead. */
  export type Outbound = ToolsDefaultValue$Outbound;
}

export function toolsDefaultValueToJSON(
  toolsDefaultValue: ToolsDefaultValue,
): string {
  return JSON.stringify(
    ToolsDefaultValue$outboundSchema.parse(toolsDefaultValue),
  );
}

export function toolsDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<ToolsDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsDefaultValue' from JSON`,
  );
}

/** @internal */
export const ToolsArguments$inboundSchema: z.ZodType<
  ToolsArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: StreamRunAgentToolsAgentsType$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});

/** @internal */
export type ToolsArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const ToolsArguments$outboundSchema: z.ZodType<
  ToolsArguments$Outbound,
  z.ZodTypeDef,
  ToolsArguments
> = z.object({
  type: StreamRunAgentToolsAgentsType$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsArguments$ {
  /** @deprecated use `ToolsArguments$inboundSchema` instead. */
  export const inboundSchema = ToolsArguments$inboundSchema;
  /** @deprecated use `ToolsArguments$outboundSchema` instead. */
  export const outboundSchema = ToolsArguments$outboundSchema;
  /** @deprecated use `ToolsArguments$Outbound` instead. */
  export type Outbound = ToolsArguments$Outbound;
}

export function toolsArgumentsToJSON(toolsArguments: ToolsArguments): string {
  return JSON.stringify(ToolsArguments$outboundSchema.parse(toolsArguments));
}

export function toolsArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<ToolsArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsArguments' from JSON`,
  );
}

/** @internal */
export const ToolsHttp$inboundSchema: z.ZodType<
  ToolsHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => ToolsBlueprint$inboundSchema),
  arguments: z.record(z.lazy(() => ToolsArguments$inboundSchema)).optional(),
});

/** @internal */
export type ToolsHttp$Outbound = {
  blueprint: ToolsBlueprint$Outbound;
  arguments?: { [k: string]: ToolsArguments$Outbound } | undefined;
};

/** @internal */
export const ToolsHttp$outboundSchema: z.ZodType<
  ToolsHttp$Outbound,
  z.ZodTypeDef,
  ToolsHttp
> = z.object({
  blueprint: z.lazy(() => ToolsBlueprint$outboundSchema),
  arguments: z.record(z.lazy(() => ToolsArguments$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolsHttp$ {
  /** @deprecated use `ToolsHttp$inboundSchema` instead. */
  export const inboundSchema = ToolsHttp$inboundSchema;
  /** @deprecated use `ToolsHttp$outboundSchema` instead. */
  export const outboundSchema = ToolsHttp$outboundSchema;
  /** @deprecated use `ToolsHttp$Outbound` instead. */
  export type Outbound = ToolsHttp$Outbound;
}

export function toolsHttpToJSON(toolsHttp: ToolsHttp): string {
  return JSON.stringify(ToolsHttp$outboundSchema.parse(toolsHttp));
}

export function toolsHttpFromJSON(
  jsonString: string,
): SafeParseResult<ToolsHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolsHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolsHttp' from JSON`,
  );
}

/** @internal */
export const Tools24$inboundSchema: z.ZodType<Tools24, z.ZodTypeDef, unknown> =
  z.object({
    _id: z.string().default("01K5ZT3CR3PWN9D2Z5RR1XF0A2"),
    path: z.string(),
    key: z.string(),
    display_name: z.string(),
    description: z.string(),
    status: ToolsStatus$inboundSchema.default("live"),
    version_hash: z.string().optional(),
    type: StreamRunAgentToolsType$inboundSchema,
    http: z.lazy(() => ToolsHttp$inboundSchema),
    requires_approval: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      "_id": "id",
      "display_name": "displayName",
      "version_hash": "versionHash",
      "requires_approval": "requiresApproval",
    });
  });

/** @internal */
export type Tools24$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name: string;
  description: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: ToolsHttp$Outbound;
  requires_approval: boolean;
};

/** @internal */
export const Tools24$outboundSchema: z.ZodType<
  Tools24$Outbound,
  z.ZodTypeDef,
  Tools24
> = z.object({
  id: z.string().default("01K5ZT3CR3PWN9D2Z5RR1XF0A2"),
  path: z.string(),
  key: z.string(),
  displayName: z.string(),
  description: z.string(),
  status: ToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: StreamRunAgentToolsType$outboundSchema,
  http: z.lazy(() => ToolsHttp$outboundSchema),
  requiresApproval: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    versionHash: "version_hash",
    requiresApproval: "requires_approval",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tools24$ {
  /** @deprecated use `Tools24$inboundSchema` instead. */
  export const inboundSchema = Tools24$inboundSchema;
  /** @deprecated use `Tools24$outboundSchema` instead. */
  export const outboundSchema = Tools24$outboundSchema;
  /** @deprecated use `Tools24$Outbound` instead. */
  export type Outbound = Tools24$Outbound;
}

export function tools24ToJSON(tools24: Tools24): string {
  return JSON.stringify(Tools24$outboundSchema.parse(tools24));
}

export function tools24FromJSON(
  jsonString: string,
): SafeParseResult<Tools24, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tools24$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tools24' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentTools$inboundSchema: z.ZodType<
  StreamRunAgentTools,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.HttpTool$inboundSchema.and(
    z.object({ type: z.literal("http") }).transform((v) => ({ type: v.type })),
  ),
  components.CodeExecutionTool$inboundSchema.and(
    z.object({ type: z.literal("code") }).transform((v) => ({ type: v.type })),
  ),
  components.FunctionTool$inboundSchema.and(
    z.object({ type: z.literal("function") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.GoogleSearchTool$inboundSchema.and(
    z.object({ type: z.literal("google_search") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WebScraperTool$inboundSchema.and(
    z.object({ type: z.literal("web_scraper") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CallSubAgentTool$inboundSchema.and(
    z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveAgentsTool$inboundSchema.and(
    z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.QueryMemoryStoreTool$inboundSchema.and(
    z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WriteMemoryStoreTool$inboundSchema.and(
    z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveMemoryStoresTool$inboundSchema.and(
    z.object({ type: z.literal("retrieve_memory_stores") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveKnowledgeBasesTool$inboundSchema.and(
    z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
      v,
    ) => ({ type: v.type })),
  ),
  components.QueryKnowledgeBaseTool$inboundSchema.and(
    z.object({ type: z.literal("query_knowledge_base") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CurrentDateTool$inboundSchema.and(
    z.object({ type: z.literal("current_date") }).transform((v) => ({
      type: v.type,
    })),
  ),
]);

/** @internal */
export type StreamRunAgentTools$Outbound =
  | (components.HttpTool$Outbound & { type: "http" })
  | (components.CodeExecutionTool$Outbound & { type: "code" })
  | (components.FunctionTool$Outbound & { type: "function" })
  | (components.GoogleSearchTool$Outbound & { type: "google_search" })
  | (components.WebScraperTool$Outbound & { type: "web_scraper" })
  | (components.CallSubAgentTool$Outbound & { type: "call_sub_agent" })
  | (components.RetrieveAgentsTool$Outbound & { type: "retrieve_agents" })
  | (components.QueryMemoryStoreTool$Outbound & { type: "query_memory_store" })
  | (components.WriteMemoryStoreTool$Outbound & { type: "write_memory_store" })
  | (components.RetrieveMemoryStoresTool$Outbound & {
    type: "retrieve_memory_stores";
  })
  | (components.RetrieveKnowledgeBasesTool$Outbound & {
    type: "retrieve_knowledge_bases";
  })
  | (components.QueryKnowledgeBaseTool$Outbound & {
    type: "query_knowledge_base";
  })
  | (components.CurrentDateTool$Outbound & { type: "current_date" });

/** @internal */
export const StreamRunAgentTools$outboundSchema: z.ZodType<
  StreamRunAgentTools$Outbound,
  z.ZodTypeDef,
  StreamRunAgentTools
> = z.union([
  components.HttpTool$outboundSchema.and(
    z.object({ type: z.literal("http") }).transform((v) => ({ type: v.type })),
  ),
  components.CodeExecutionTool$outboundSchema.and(
    z.object({ type: z.literal("code") }).transform((v) => ({ type: v.type })),
  ),
  components.FunctionTool$outboundSchema.and(
    z.object({ type: z.literal("function") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.GoogleSearchTool$outboundSchema.and(
    z.object({ type: z.literal("google_search") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WebScraperTool$outboundSchema.and(
    z.object({ type: z.literal("web_scraper") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CallSubAgentTool$outboundSchema.and(
    z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveAgentsTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.QueryMemoryStoreTool$outboundSchema.and(
    z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.WriteMemoryStoreTool$outboundSchema.and(
    z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveMemoryStoresTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_memory_stores") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.RetrieveKnowledgeBasesTool$outboundSchema.and(
    z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
      v,
    ) => ({ type: v.type })),
  ),
  components.QueryKnowledgeBaseTool$outboundSchema.and(
    z.object({ type: z.literal("query_knowledge_base") }).transform((v) => ({
      type: v.type,
    })),
  ),
  components.CurrentDateTool$outboundSchema.and(
    z.object({ type: z.literal("current_date") }).transform((v) => ({
      type: v.type,
    })),
  ),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentTools$ {
  /** @deprecated use `StreamRunAgentTools$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentTools$inboundSchema;
  /** @deprecated use `StreamRunAgentTools$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentTools$outboundSchema;
  /** @deprecated use `StreamRunAgentTools$Outbound` instead. */
  export type Outbound = StreamRunAgentTools$Outbound;
}

export function streamRunAgentToolsToJSON(
  streamRunAgentTools: StreamRunAgentTools,
): string {
  return JSON.stringify(
    StreamRunAgentTools$outboundSchema.parse(streamRunAgentTools),
  );
}

export function streamRunAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentTools' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = z.nativeEnum(StreamRunAgentToolApprovalRequired);

/** @internal */
export const StreamRunAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof StreamRunAgentToolApprovalRequired
> = StreamRunAgentToolApprovalRequired$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentToolApprovalRequired$ {
  /** @deprecated use `StreamRunAgentToolApprovalRequired$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentToolApprovalRequired$inboundSchema;
  /** @deprecated use `StreamRunAgentToolApprovalRequired$outboundSchema` instead. */
  export const outboundSchema =
    StreamRunAgentToolApprovalRequired$outboundSchema;
}

/** @internal */
export const StreamRunAgentSettings$inboundSchema: z.ZodType<
  StreamRunAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  tools: z.array(
    z.union([
      components.HttpTool$inboundSchema.and(
        z.object({ type: z.literal("http") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CodeExecutionTool$inboundSchema.and(
        z.object({ type: z.literal("code") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.FunctionTool$inboundSchema.and(
        z.object({ type: z.literal("function") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.GoogleSearchTool$inboundSchema.and(
        z.object({ type: z.literal("google_search") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WebScraperTool$inboundSchema.and(
        z.object({ type: z.literal("web_scraper") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CallSubAgentTool$inboundSchema.and(
        z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveAgentsTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.QueryMemoryStoreTool$inboundSchema.and(
        z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WriteMemoryStoreTool$inboundSchema.and(
        z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveMemoryStoresTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_memory_stores") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.RetrieveKnowledgeBasesTool$inboundSchema.and(
        z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.QueryKnowledgeBaseTool$inboundSchema.and(
        z.object({ type: z.literal("query_knowledge_base") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.CurrentDateTool$inboundSchema.and(
        z.object({ type: z.literal("current_date") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ),
  tool_approval_required: StreamRunAgentToolApprovalRequired$inboundSchema
    .default("none"),
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(120),
}).transform((v) => {
  return remap$(v, {
    "tool_approval_required": "toolApprovalRequired",
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
  });
});

/** @internal */
export type StreamRunAgentSettings$Outbound = {
  tools: Array<
    | (components.HttpTool$Outbound & { type: "http" })
    | (components.CodeExecutionTool$Outbound & { type: "code" })
    | (components.FunctionTool$Outbound & { type: "function" })
    | (components.GoogleSearchTool$Outbound & { type: "google_search" })
    | (components.WebScraperTool$Outbound & { type: "web_scraper" })
    | (components.CallSubAgentTool$Outbound & { type: "call_sub_agent" })
    | (components.RetrieveAgentsTool$Outbound & { type: "retrieve_agents" })
    | (components.QueryMemoryStoreTool$Outbound & {
      type: "query_memory_store";
    })
    | (components.WriteMemoryStoreTool$Outbound & {
      type: "write_memory_store";
    })
    | (components.RetrieveMemoryStoresTool$Outbound & {
      type: "retrieve_memory_stores";
    })
    | (components.RetrieveKnowledgeBasesTool$Outbound & {
      type: "retrieve_knowledge_bases";
    })
    | (components.QueryKnowledgeBaseTool$Outbound & {
      type: "query_knowledge_base";
    })
    | (components.CurrentDateTool$Outbound & { type: "current_date" })
  >;
  tool_approval_required: string;
  max_iterations: number;
  max_execution_time: number;
};

/** @internal */
export const StreamRunAgentSettings$outboundSchema: z.ZodType<
  StreamRunAgentSettings$Outbound,
  z.ZodTypeDef,
  StreamRunAgentSettings
> = z.object({
  tools: z.array(
    z.union([
      components.HttpTool$outboundSchema.and(
        z.object({ type: z.literal("http") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CodeExecutionTool$outboundSchema.and(
        z.object({ type: z.literal("code") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.FunctionTool$outboundSchema.and(
        z.object({ type: z.literal("function") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.GoogleSearchTool$outboundSchema.and(
        z.object({ type: z.literal("google_search") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WebScraperTool$outboundSchema.and(
        z.object({ type: z.literal("web_scraper") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.CallSubAgentTool$outboundSchema.and(
        z.object({ type: z.literal("call_sub_agent") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveAgentsTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_agents") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.QueryMemoryStoreTool$outboundSchema.and(
        z.object({ type: z.literal("query_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.WriteMemoryStoreTool$outboundSchema.and(
        z.object({ type: z.literal("write_memory_store") }).transform((v) => ({
          type: v.type,
        })),
      ),
      components.RetrieveMemoryStoresTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_memory_stores") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.RetrieveKnowledgeBasesTool$outboundSchema.and(
        z.object({ type: z.literal("retrieve_knowledge_bases") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.QueryKnowledgeBaseTool$outboundSchema.and(
        z.object({ type: z.literal("query_knowledge_base") }).transform((
          v,
        ) => ({ type: v.type })),
      ),
      components.CurrentDateTool$outboundSchema.and(
        z.object({ type: z.literal("current_date") }).transform((v) => ({
          type: v.type,
        })),
      ),
    ]),
  ),
  toolApprovalRequired: StreamRunAgentToolApprovalRequired$outboundSchema
    .default("none"),
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(120),
}).transform((v) => {
  return remap$(v, {
    toolApprovalRequired: "tool_approval_required",
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentSettings$ {
  /** @deprecated use `StreamRunAgentSettings$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentSettings$inboundSchema;
  /** @deprecated use `StreamRunAgentSettings$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentSettings$outboundSchema;
  /** @deprecated use `StreamRunAgentSettings$Outbound` instead. */
  export type Outbound = StreamRunAgentSettings$Outbound;
}

export function streamRunAgentSettingsToJSON(
  streamRunAgentSettings: StreamRunAgentSettings,
): string {
  return JSON.stringify(
    StreamRunAgentSettings$outboundSchema.parse(streamRunAgentSettings),
  );
}

export function streamRunAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentSettings' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentRequestBody$inboundSchema: z.ZodType<
  StreamRunAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.string(),
  fallback_models: z.array(z.string()).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$inboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  system_prompt: z.string().optional(),
  memory_stores: z.array(z.string()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$inboundSchema),
  ).optional(),
  team_of_agents: z.array(
    z.lazy(() => StreamRunAgentTeamOfAgents$inboundSchema),
  ).optional(),
  settings: z.lazy(() => StreamRunAgentSettings$inboundSchema),
  metadata: z.record(z.any()).optional(),
  stream_timeout_seconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "fallback_models": "fallbackModels",
    "system_prompt": "systemPrompt",
    "memory_stores": "memoryStores",
    "knowledge_bases": "knowledgeBases",
    "team_of_agents": "teamOfAgents",
    "stream_timeout_seconds": "streamTimeoutSeconds",
  });
});

/** @internal */
export type StreamRunAgentRequestBody$Outbound = {
  key: string;
  taskId?: string | undefined;
  model: string;
  fallback_models?: Array<string> | undefined;
  role: string;
  instructions: string;
  message: StreamRunAgentMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: StreamRunAgentContact$Outbound | undefined;
  thread?: StreamRunAgentThread$Outbound | undefined;
  memory?: StreamRunAgentMemory$Outbound | undefined;
  path: string;
  description?: string | undefined;
  system_prompt?: string | undefined;
  memory_stores?: Array<string> | undefined;
  knowledge_bases?: Array<StreamRunAgentKnowledgeBases$Outbound> | undefined;
  team_of_agents?: Array<StreamRunAgentTeamOfAgents$Outbound> | undefined;
  settings: StreamRunAgentSettings$Outbound;
  metadata?: { [k: string]: any } | undefined;
  stream_timeout_seconds?: number | undefined;
};

/** @internal */
export const StreamRunAgentRequestBody$outboundSchema: z.ZodType<
  StreamRunAgentRequestBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentRequestBody
> = z.object({
  key: z.string(),
  taskId: z.string().optional(),
  model: z.string(),
  fallbackModels: z.array(z.string()).optional(),
  role: z.string(),
  instructions: z.string(),
  message: z.lazy(() => StreamRunAgentMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => StreamRunAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => StreamRunAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => StreamRunAgentMemory$outboundSchema).optional(),
  path: z.string(),
  description: z.string().optional(),
  systemPrompt: z.string().optional(),
  memoryStores: z.array(z.string()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => StreamRunAgentKnowledgeBases$outboundSchema),
  ).optional(),
  teamOfAgents: z.array(z.lazy(() => StreamRunAgentTeamOfAgents$outboundSchema))
    .optional(),
  settings: z.lazy(() => StreamRunAgentSettings$outboundSchema),
  metadata: z.record(z.any()).optional(),
  streamTimeoutSeconds: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fallbackModels: "fallback_models",
    systemPrompt: "system_prompt",
    memoryStores: "memory_stores",
    knowledgeBases: "knowledge_bases",
    teamOfAgents: "team_of_agents",
    streamTimeoutSeconds: "stream_timeout_seconds",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentRequestBody$ {
  /** @deprecated use `StreamRunAgentRequestBody$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentRequestBody$inboundSchema;
  /** @deprecated use `StreamRunAgentRequestBody$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentRequestBody$outboundSchema;
  /** @deprecated use `StreamRunAgentRequestBody$Outbound` instead. */
  export type Outbound = StreamRunAgentRequestBody$Outbound;
}

export function streamRunAgentRequestBodyToJSON(
  streamRunAgentRequestBody: StreamRunAgentRequestBody,
): string {
  return JSON.stringify(
    StreamRunAgentRequestBody$outboundSchema.parse(streamRunAgentRequestBody),
  );
}

export function streamRunAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const StreamRunAgentResponseBody$inboundSchema: z.ZodType<
  StreamRunAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
});

/** @internal */
export type StreamRunAgentResponseBody$Outbound = {
  data: string;
};

/** @internal */
export const StreamRunAgentResponseBody$outboundSchema: z.ZodType<
  StreamRunAgentResponseBody$Outbound,
  z.ZodTypeDef,
  StreamRunAgentResponseBody
> = z.object({
  data: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace StreamRunAgentResponseBody$ {
  /** @deprecated use `StreamRunAgentResponseBody$inboundSchema` instead. */
  export const inboundSchema = StreamRunAgentResponseBody$inboundSchema;
  /** @deprecated use `StreamRunAgentResponseBody$outboundSchema` instead. */
  export const outboundSchema = StreamRunAgentResponseBody$outboundSchema;
  /** @deprecated use `StreamRunAgentResponseBody$Outbound` instead. */
  export type Outbound = StreamRunAgentResponseBody$Outbound;
}

export function streamRunAgentResponseBodyToJSON(
  streamRunAgentResponseBody: StreamRunAgentResponseBody,
): string {
  return JSON.stringify(
    StreamRunAgentResponseBody$outboundSchema.parse(streamRunAgentResponseBody),
  );
}

export function streamRunAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<StreamRunAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => StreamRunAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'StreamRunAgentResponseBody' from JSON`,
  );
}
