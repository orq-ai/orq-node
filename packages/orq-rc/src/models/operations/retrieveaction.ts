/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RetrieveActionRequest = {
  /**
   * The unique key of the agent
   */
  agentKey: string;
  /**
   * The unique id of the task
   */
  taskId: string;
  /**
   * The unique id of the action
   */
  actionId: string;
};

export type Tool = {
  /**
   * The tool' id in orq
   */
  id: string;
  displayName: string;
  requiresApproval?: boolean | undefined;
};

export const Review = {
  Approved: "approved",
  Rejected: "rejected",
} as const;
export type Review = ClosedEnum<typeof Review>;

/**
 * An action is a tool that an agent chooses to use. If executed is false, together with the output being there, it can indicate that a tool was mocked
 */
export type State = {
  review?: Review | null | undefined;
  /**
   * The source of the review, where it was approved or rejected
   */
  reviewSource?: string | undefined;
  /**
   * Only refers to an internal user of the platform, who approved or rejected the tool execution
   */
  reviewedById?: string | undefined;
  executed?: boolean | undefined;
  error?: string | undefined;
  input: { [k: string]: any };
  output: { [k: string]: any };
};

/**
 * The action object
 */
export type RetrieveActionResponseBody = {
  /**
   * Internal id for the action
   */
  id: string;
  /**
   * The tool call id what the agent chooses to use and generates
   */
  agentToolCallId: string;
  tool: Tool;
  created: string;
  updated: string;
  started?: string | undefined;
  finished?: string | undefined;
  agentId: string;
  actionType: string;
  agentExecutionId: string;
  workspaceId: string;
  /**
   * An action is a tool that an agent chooses to use. If executed is false, together with the output being there, it can indicate that a tool was mocked
   */
  state: State;
};

/** @internal */
export const RetrieveActionRequest$inboundSchema: z.ZodType<
  RetrieveActionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  task_id: z.string(),
  action_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "task_id": "taskId",
    "action_id": "actionId",
  });
});

/** @internal */
export type RetrieveActionRequest$Outbound = {
  agent_key: string;
  task_id: string;
  action_id: string;
};

/** @internal */
export const RetrieveActionRequest$outboundSchema: z.ZodType<
  RetrieveActionRequest$Outbound,
  z.ZodTypeDef,
  RetrieveActionRequest
> = z.object({
  agentKey: z.string(),
  taskId: z.string(),
  actionId: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    taskId: "task_id",
    actionId: "action_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetrieveActionRequest$ {
  /** @deprecated use `RetrieveActionRequest$inboundSchema` instead. */
  export const inboundSchema = RetrieveActionRequest$inboundSchema;
  /** @deprecated use `RetrieveActionRequest$outboundSchema` instead. */
  export const outboundSchema = RetrieveActionRequest$outboundSchema;
  /** @deprecated use `RetrieveActionRequest$Outbound` instead. */
  export type Outbound = RetrieveActionRequest$Outbound;
}

export function retrieveActionRequestToJSON(
  retrieveActionRequest: RetrieveActionRequest,
): string {
  return JSON.stringify(
    RetrieveActionRequest$outboundSchema.parse(retrieveActionRequest),
  );
}

export function retrieveActionRequestFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveActionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveActionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveActionRequest' from JSON`,
  );
}

/** @internal */
export const Tool$inboundSchema: z.ZodType<Tool, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    display_name: z.string(),
    requires_approval: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
      "requires_approval": "requiresApproval",
    });
  });

/** @internal */
export type Tool$Outbound = {
  id: string;
  display_name: string;
  requires_approval: boolean;
};

/** @internal */
export const Tool$outboundSchema: z.ZodType<Tool$Outbound, z.ZodTypeDef, Tool> =
  z.object({
    id: z.string(),
    displayName: z.string(),
    requiresApproval: z.boolean().default(false),
  }).transform((v) => {
    return remap$(v, {
      displayName: "display_name",
      requiresApproval: "requires_approval",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Tool$ {
  /** @deprecated use `Tool$inboundSchema` instead. */
  export const inboundSchema = Tool$inboundSchema;
  /** @deprecated use `Tool$outboundSchema` instead. */
  export const outboundSchema = Tool$outboundSchema;
  /** @deprecated use `Tool$Outbound` instead. */
  export type Outbound = Tool$Outbound;
}

export function toolToJSON(tool: Tool): string {
  return JSON.stringify(Tool$outboundSchema.parse(tool));
}

export function toolFromJSON(
  jsonString: string,
): SafeParseResult<Tool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Tool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Tool' from JSON`,
  );
}

/** @internal */
export const Review$inboundSchema: z.ZodNativeEnum<typeof Review> = z
  .nativeEnum(Review);

/** @internal */
export const Review$outboundSchema: z.ZodNativeEnum<typeof Review> =
  Review$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Review$ {
  /** @deprecated use `Review$inboundSchema` instead. */
  export const inboundSchema = Review$inboundSchema;
  /** @deprecated use `Review$outboundSchema` instead. */
  export const outboundSchema = Review$outboundSchema;
}

/** @internal */
export const State$inboundSchema: z.ZodType<State, z.ZodTypeDef, unknown> = z
  .object({
    review: z.nullable(Review$inboundSchema).optional(),
    review_source: z.string().optional(),
    reviewed_by_id: z.string().optional(),
    executed: z.boolean().default(false),
    error: z.string().optional(),
    input: z.record(z.any()),
    output: z.record(z.any()),
  }).transform((v) => {
    return remap$(v, {
      "review_source": "reviewSource",
      "reviewed_by_id": "reviewedById",
    });
  });

/** @internal */
export type State$Outbound = {
  review?: string | null | undefined;
  review_source?: string | undefined;
  reviewed_by_id?: string | undefined;
  executed: boolean;
  error?: string | undefined;
  input: { [k: string]: any };
  output: { [k: string]: any };
};

/** @internal */
export const State$outboundSchema: z.ZodType<
  State$Outbound,
  z.ZodTypeDef,
  State
> = z.object({
  review: z.nullable(Review$outboundSchema).optional(),
  reviewSource: z.string().optional(),
  reviewedById: z.string().optional(),
  executed: z.boolean().default(false),
  error: z.string().optional(),
  input: z.record(z.any()),
  output: z.record(z.any()),
}).transform((v) => {
  return remap$(v, {
    reviewSource: "review_source",
    reviewedById: "reviewed_by_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace State$ {
  /** @deprecated use `State$inboundSchema` instead. */
  export const inboundSchema = State$inboundSchema;
  /** @deprecated use `State$outboundSchema` instead. */
  export const outboundSchema = State$outboundSchema;
  /** @deprecated use `State$Outbound` instead. */
  export type Outbound = State$Outbound;
}

export function stateToJSON(state: State): string {
  return JSON.stringify(State$outboundSchema.parse(state));
}

export function stateFromJSON(
  jsonString: string,
): SafeParseResult<State, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => State$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'State' from JSON`,
  );
}

/** @internal */
export const RetrieveActionResponseBody$inboundSchema: z.ZodType<
  RetrieveActionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  agent_tool_call_id: z.string(),
  tool: z.lazy(() => Tool$inboundSchema),
  created: z.string(),
  updated: z.string(),
  started: z.string().optional(),
  finished: z.string().optional(),
  agent_id: z.string(),
  action_type: z.string(),
  agent_execution_id: z.string(),
  workspace_id: z.string(),
  state: z.lazy(() => State$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "agent_tool_call_id": "agentToolCallId",
    "agent_id": "agentId",
    "action_type": "actionType",
    "agent_execution_id": "agentExecutionId",
    "workspace_id": "workspaceId",
  });
});

/** @internal */
export type RetrieveActionResponseBody$Outbound = {
  _id: string;
  agent_tool_call_id: string;
  tool: Tool$Outbound;
  created: string;
  updated: string;
  started?: string | undefined;
  finished?: string | undefined;
  agent_id: string;
  action_type: string;
  agent_execution_id: string;
  workspace_id: string;
  state: State$Outbound;
};

/** @internal */
export const RetrieveActionResponseBody$outboundSchema: z.ZodType<
  RetrieveActionResponseBody$Outbound,
  z.ZodTypeDef,
  RetrieveActionResponseBody
> = z.object({
  id: z.string(),
  agentToolCallId: z.string(),
  tool: z.lazy(() => Tool$outboundSchema),
  created: z.string(),
  updated: z.string(),
  started: z.string().optional(),
  finished: z.string().optional(),
  agentId: z.string(),
  actionType: z.string(),
  agentExecutionId: z.string(),
  workspaceId: z.string(),
  state: z.lazy(() => State$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    agentToolCallId: "agent_tool_call_id",
    agentId: "agent_id",
    actionType: "action_type",
    agentExecutionId: "agent_execution_id",
    workspaceId: "workspace_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RetrieveActionResponseBody$ {
  /** @deprecated use `RetrieveActionResponseBody$inboundSchema` instead. */
  export const inboundSchema = RetrieveActionResponseBody$inboundSchema;
  /** @deprecated use `RetrieveActionResponseBody$outboundSchema` instead. */
  export const outboundSchema = RetrieveActionResponseBody$outboundSchema;
  /** @deprecated use `RetrieveActionResponseBody$Outbound` instead. */
  export type Outbound = RetrieveActionResponseBody$Outbound;
}

export function retrieveActionResponseBodyToJSON(
  retrieveActionResponseBody: RetrieveActionResponseBody,
): string {
  return JSON.stringify(
    RetrieveActionResponseBody$outboundSchema.parse(retrieveActionResponseBody),
  );
}

export function retrieveActionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveActionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveActionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveActionResponseBody' from JSON`,
  );
}
