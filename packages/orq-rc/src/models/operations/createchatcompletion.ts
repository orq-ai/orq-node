/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateChatCompletionContentRouterRequest2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type CreateChatCompletionMessagesRouterRequestRequestBody5Content =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreateChatCompletionMessagesRouterType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreateChatCompletionMessagesRouterType = ClosedEnum<
  typeof CreateChatCompletionMessagesRouterType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreateChatCompletionMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreateChatCompletionMessagesTtl = ClosedEnum<
  typeof CreateChatCompletionMessagesTtl
>;

export type CreateChatCompletionMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreateChatCompletionMessagesRouterType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreateChatCompletionMessagesTtl | undefined;
};

export type CreateChatCompletionMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: CreateChatCompletionMessagesCacheControl | undefined;
};

export type CreateChatCompletionContentRouter2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type CreateChatCompletionMessagesRouterRequestRequestBodyContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type CreateChatCompletionMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const CreateChatCompletionMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type CreateChatCompletionMessagesType = ClosedEnum<
  typeof CreateChatCompletionMessagesType
>;

export type CreateChatCompletionMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: CreateChatCompletionMessagesType;
  function: CreateChatCompletionMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type CreateChatCompletionMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: CreateChatCompletionMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<CreateChatCompletionMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const CreateChatCompletion2RouterType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type CreateChatCompletion2RouterType = ClosedEnum<
  typeof CreateChatCompletion2RouterType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const CreateChatCompletion2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type CreateChatCompletion2Ttl = ClosedEnum<
  typeof CreateChatCompletion2Ttl
>;

export type CreateChatCompletion2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: CreateChatCompletion2RouterType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: CreateChatCompletion2Ttl | undefined;
};

export type CreateChatCompletion24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: CreateChatCompletion2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type CreateChatCompletionContent2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | CreateChatCompletion24;

/**
 * The contents of the user message.
 */
export type CreateChatCompletionMessagesRouterRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | CreateChatCompletion24
  >;

export type CreateChatCompletionMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | CreateChatCompletion24
    >;
};

/**
 * The contents of the developer message.
 */
export type CreateChatCompletionMessagesRouterContent =
  | string
  | Array<components.TextContentPartSchema>;

export type CreateChatCompletionMessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type CreateChatCompletionMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type CreateChatCompletionMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type CreateChatCompletionMessages =
  | CreateChatCompletionMessagesSystemMessage
  | CreateChatCompletionMessagesDeveloperMessage
  | CreateChatCompletionMessagesUserMessage
  | CreateChatCompletionMessagesAssistantMessage
  | CreateChatCompletionMessagesToolMessage;

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const CreateChatCompletionVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type CreateChatCompletionVoice = ClosedEnum<
  typeof CreateChatCompletionVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const CreateChatCompletionFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type CreateChatCompletionFormat = ClosedEnum<
  typeof CreateChatCompletionFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type CreateChatCompletionAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: CreateChatCompletionVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: CreateChatCompletionFormat;
};

export type CreateChatCompletionResponseFormatRouterJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type CreateChatCompletionResponseFormatJSONSchema = {
  type: "json_schema";
  jsonSchema: CreateChatCompletionResponseFormatRouterJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type CreateChatCompletionResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type CreateChatCompletionResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type CreateChatCompletionResponseFormat =
  | CreateChatCompletionResponseFormatText
  | CreateChatCompletionResponseFormatJSONObject
  | CreateChatCompletionResponseFormatJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const CreateChatCompletionReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type CreateChatCompletionReasoningEffort = ClosedEnum<
  typeof CreateChatCompletionReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type CreateChatCompletionStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type CreateChatCompletionStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type CreateChatCompletionThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateChatCompletionType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateChatCompletionType = ClosedEnum<
  typeof CreateChatCompletionType
>;

export const CreateChatCompletionRouterType = {
  Object: "object",
} as const;
export type CreateChatCompletionRouterType = ClosedEnum<
  typeof CreateChatCompletionRouterType
>;

/**
 * The parameters the functions accepts, described as a JSON Schema object
 */
export type CreateChatCompletionParameters = {
  type: CreateChatCompletionRouterType;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

export type CreateChatCompletionFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object
   */
  parameters?: CreateChatCompletionParameters | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call.
   */
  strict?: boolean | undefined;
};

export type CreateChatCompletionTools = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateChatCompletionType | undefined;
  function: CreateChatCompletionFunction;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const CreateChatCompletionToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type CreateChatCompletionToolChoiceType = ClosedEnum<
  typeof CreateChatCompletionToolChoiceType
>;

export type CreateChatCompletionToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type CreateChatCompletionToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: CreateChatCompletionToolChoiceType | undefined;
  function: CreateChatCompletionToolChoiceFunction;
};

export const CreateChatCompletionToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type CreateChatCompletionToolChoice1 = ClosedEnum<
  typeof CreateChatCompletionToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type CreateChatCompletionToolChoice =
  | CreateChatCompletionToolChoice2
  | CreateChatCompletionToolChoice1;

export const CreateChatCompletionModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type CreateChatCompletionModalities = ClosedEnum<
  typeof CreateChatCompletionModalities
>;

/**
 * The key of the guardrail.
 */
export const CreateChatCompletionId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type CreateChatCompletionId1 = ClosedEnum<
  typeof CreateChatCompletionId1
>;

export type CreateChatCompletionId = CreateChatCompletionId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const CreateChatCompletionExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type CreateChatCompletionExecuteOn = ClosedEnum<
  typeof CreateChatCompletionExecuteOn
>;

export type CreateChatCompletionGuardrails = {
  id: CreateChatCompletionId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: CreateChatCompletionExecuteOn;
};

/**
 * Retry configuration for the request
 */
export type CreateChatCompletionRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type Fallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export const Version = {
  Latest: "latest",
} as const;
/**
 * Version of the prompt to use (currently only "latest" supported)
 */
export type Version = ClosedEnum<typeof Version>;

/**
 * Prompt configuration for the request
 */
export type Prompt = {
  /**
   * Unique identifier of the prompt to use
   */
  id: string;
  /**
   * Version of the prompt to use (currently only "latest" supported)
   */
  version: Version;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type CreateChatCompletionContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type CreateChatCompletionThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

export type Inputs2 = {
  key: string;
  value?: any | undefined;
  isPii?: boolean | undefined;
};

/**
 * Values to replace in the prompt messages using {{variableName}} syntax
 */
export type Inputs = { [k: string]: any } | Array<Inputs2>;

export const CreateChatCompletionRouterRequestType = {
  ExactMatch: "exact_match",
} as const;
export type CreateChatCompletionRouterRequestType = ClosedEnum<
  typeof CreateChatCompletionRouterRequestType
>;

/**
 * Cache configuration for the request.
 */
export type Cache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateChatCompletionRouterRequestType;
};

/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export const CreateChatCompletionSearchType = {
  VectorSearch: "vector_search",
  KeywordSearch: "keyword_search",
  HybridSearch: "hybrid_search",
} as const;
/**
 * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
 */
export type CreateChatCompletionSearchType = ClosedEnum<
  typeof CreateChatCompletionSearchType
>;

/**
 * Exists
 */
export type CreateChatCompletionOrExists = {
  exists: boolean;
};

export type CreateChatCompletionOrRouterNin = string | number | boolean;

/**
 * Not in
 */
export type CreateChatCompletionOrNin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletionOrRouterIn = string | number | boolean;

/**
 * In
 */
export type CreateChatCompletionOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletionOrLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletionOrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletionOrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletionOrGt = {
  gt: number;
};

export type CreateChatCompletionOrRouterNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletionOrNe = {
  ne: string | number | boolean;
};

export type CreateChatCompletionOrRouterEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateChatCompletionOrEq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterByRouterOr =
  | CreateChatCompletionOrEq
  | CreateChatCompletionOrNe
  | CreateChatCompletionOrGt
  | CreateChatCompletionOrGte
  | CreateChatCompletionOrLt
  | CreateChatCompletionOrLte
  | CreateChatCompletionOrIn
  | CreateChatCompletionOrNin
  | CreateChatCompletionOrExists;

/**
 * Or
 */
export type CreateChatCompletionFilterByOr = {
  or: Array<
    {
      [k: string]:
        | CreateChatCompletionOrEq
        | CreateChatCompletionOrNe
        | CreateChatCompletionOrGt
        | CreateChatCompletionOrGte
        | CreateChatCompletionOrLt
        | CreateChatCompletionOrLte
        | CreateChatCompletionOrIn
        | CreateChatCompletionOrNin
        | CreateChatCompletionOrExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateChatCompletionAndExists = {
  exists: boolean;
};

export type CreateChatCompletionAndRouterNin = string | number | boolean;

/**
 * Not in
 */
export type CreateChatCompletionAndNin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletionAndRouterIn = string | number | boolean;

/**
 * In
 */
export type CreateChatCompletionAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletionAndLte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletionAndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletionAndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletionAndGt = {
  gt: number;
};

export type CreateChatCompletionAndRouterNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletionAndNe = {
  ne: string | number | boolean;
};

export type CreateChatCompletionAndRouterEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateChatCompletionAndEq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterByRouterAnd =
  | CreateChatCompletionAndEq
  | CreateChatCompletionAndNe
  | CreateChatCompletionAndGt
  | CreateChatCompletionAndGte
  | CreateChatCompletionAndLt
  | CreateChatCompletionAndLte
  | CreateChatCompletionAndIn
  | CreateChatCompletionAndNin
  | CreateChatCompletionAndExists;

/**
 * And
 */
export type CreateChatCompletionFilterByAnd = {
  and: Array<
    {
      [k: string]:
        | CreateChatCompletionAndEq
        | CreateChatCompletionAndNe
        | CreateChatCompletionAndGt
        | CreateChatCompletionAndGte
        | CreateChatCompletionAndLt
        | CreateChatCompletionAndLte
        | CreateChatCompletionAndIn
        | CreateChatCompletionAndNin
        | CreateChatCompletionAndExists;
    }
  >;
};

/**
 * Exists
 */
export type CreateChatCompletion1Exists = {
  exists: boolean;
};

export type CreateChatCompletion1RouterNin = string | number | boolean;

/**
 * Not in
 */
export type CreateChatCompletion1Nin = {
  nin: Array<string | number | boolean>;
};

export type CreateChatCompletion1RouterIn = string | number | boolean;

/**
 * In
 */
export type CreateChatCompletion1In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type CreateChatCompletion1Lte = {
  lte: number;
};

/**
 * Less than
 */
export type CreateChatCompletion1Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type CreateChatCompletion1Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type CreateChatCompletion1Gt = {
  gt: number;
};

export type CreateChatCompletion1RouterNe = string | number | boolean;

/**
 * Not equal to
 */
export type CreateChatCompletion1Ne = {
  ne: string | number | boolean;
};

export type CreateChatCompletion1RouterEq = string | number | boolean;

/**
 * Equal to
 */
export type CreateChatCompletion1Eq = {
  eq: string | number | boolean;
};

export type CreateChatCompletionFilterBy1 =
  | CreateChatCompletion1Eq
  | CreateChatCompletion1Ne
  | CreateChatCompletion1Gt
  | CreateChatCompletion1Gte
  | CreateChatCompletion1Lt
  | CreateChatCompletion1Lte
  | CreateChatCompletion1In
  | CreateChatCompletion1Nin
  | CreateChatCompletion1Exists;

/**
 * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
 */
export type CreateChatCompletionFilterBy =
  | CreateChatCompletionFilterByAnd
  | CreateChatCompletionFilterByOr
  | {
    [k: string]:
      | CreateChatCompletion1Eq
      | CreateChatCompletion1Ne
      | CreateChatCompletion1Gt
      | CreateChatCompletion1Gte
      | CreateChatCompletion1Lt
      | CreateChatCompletion1Lte
      | CreateChatCompletion1In
      | CreateChatCompletion1Nin
      | CreateChatCompletion1Exists;
  };

/**
 * Additional search options
 */
export type CreateChatCompletionSearchOptions = {
  /**
   * Whether to include the vector in the chunk
   */
  includeVectors?: boolean | undefined;
  /**
   * Whether to include the metadata in the chunk
   */
  includeMetadata?: boolean | undefined;
  /**
   * Whether to include the scores in the chunk
   */
  includeScores?: boolean | undefined;
};

/**
 * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
 */
export type CreateChatCompletionRerankConfig = {
  /**
   * The name of the rerank model to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/rerank-models).
   */
  model: string;
  /**
   * The threshold value used to filter the rerank results, only documents with a relevance score greater than the threshold will be returned
   */
  threshold?: number | undefined;
  /**
   * The number of top results to return after reranking. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
};

/**
 * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
 */
export type CreateChatCompletionAgenticRagConfig = {
  /**
   * The name of the model for the Agent to use. Refer to the [model list](https://docs.orq.ai/docs/proxy#/chat-models).
   */
  model: string;
};

export type CreateChatCompletionKnowledgeBases = {
  /**
   * The number of results to return. If not provided, will default to the knowledge base configured `top_k`.
   */
  topK?: number | undefined;
  /**
   * The threshold to apply to the search. If not provided, will default to the knowledge base configured `threshold`
   */
  threshold?: number | undefined;
  /**
   * The type of search to perform. If not provided, will default to the knowledge base configured `retrieval_type`
   */
  searchType?: CreateChatCompletionSearchType | undefined;
  /**
   * The metadata filter to apply to the search. Check the [Searching a Knowledge Base](https://dash.readme.com/project/orqai/v2.0/docs/searching-a-knowledge-base) for more information.
   */
  filterBy?:
    | CreateChatCompletionFilterByAnd
    | CreateChatCompletionFilterByOr
    | {
      [k: string]:
        | CreateChatCompletion1Eq
        | CreateChatCompletion1Ne
        | CreateChatCompletion1Gt
        | CreateChatCompletion1Gte
        | CreateChatCompletion1Lt
        | CreateChatCompletion1Lte
        | CreateChatCompletion1In
        | CreateChatCompletion1Nin
        | CreateChatCompletion1Exists;
    }
    | undefined;
  /**
   * Additional search options
   */
  searchOptions?: CreateChatCompletionSearchOptions | undefined;
  /**
   * Override the rerank configuration for this search. If not provided, will use the knowledge base configured rerank settings.
   */
  rerankConfig?: CreateChatCompletionRerankConfig | undefined;
  /**
   * Override the agentic RAG configuration for this search. If not provided, will use the knowledge base configured agentic RAG settings.
   */
  agenticRagConfig?: CreateChatCompletionAgenticRagConfig | undefined;
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
  /**
   * The query to use to search the knowledge base. If not provided we will use the last user message from the messages of the requests
   */
  query?: string | undefined;
};

export const LoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type LoadBalancerType = ClosedEnum<typeof LoadBalancerType>;

export type LoadBalancer1 = {
  type: LoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type LoadBalancer = LoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type Timeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

/**
 * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
 */
export type Orq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateChatCompletionRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<Fallbacks> | undefined;
  /**
   * Prompt configuration for the request
   */
  prompt?: Prompt | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicContact | undefined;
  contact?: CreateChatCompletionContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateChatCompletionThread | undefined;
  /**
   * Values to replace in the prompt messages using {{variableName}} syntax
   */
  inputs?: { [k: string]: any } | Array<Inputs2> | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: Cache | undefined;
  knowledgeBases?: Array<CreateChatCompletionKnowledgeBases> | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<LoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: Timeout | undefined;
};

export type CreateChatCompletionRequestBody = {
  /**
   * A list of messages comprising the conversation so far.
   */
  messages: Array<
    | CreateChatCompletionMessagesSystemMessage
    | CreateChatCompletionMessagesDeveloperMessage
    | CreateChatCompletionMessagesUserMessage
    | CreateChatCompletionMessagesAssistantMessage
    | CreateChatCompletionMessagesToolMessage
  >;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-haiku-4-5-20251001`. The AI Gateway offers a wide range of models with different capabilities, performance characteristics, and price points. Refer to the (Supported models)[/docs/proxy/supported-models] to browse available models.
   */
  model: string;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can have a maximum length of 64 characters and values can have a maximum length of 512 characters.
   */
  metadata?: { [k: string]: string } | undefined;
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: CreateChatCompletionAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | CreateChatCompletionResponseFormatText
    | CreateChatCompletionResponseFormatJSONObject
    | CreateChatCompletionResponseFormatJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: CreateChatCompletionReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: CreateChatCompletionStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * A list of tools the model may call.
   */
  tools?: Array<CreateChatCompletionTools> | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | CreateChatCompletionToolChoice2
    | CreateChatCompletionToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<CreateChatCompletionModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<CreateChatCompletionGuardrails> | undefined;
  /**
   * Leverage Orq's intelligent routing capabilities to enhance your AI application with enterprise-grade reliability and observability. Orq provides automatic request management including retries on failures, model fallbacks for high availability, identity-level analytics tracking, conversation threading, and dynamic prompt templating with variable substitution.
   */
  orq?: Orq | undefined;
  stream?: boolean | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const CreateChatCompletionFinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type CreateChatCompletionFinishReason = ClosedEnum<
  typeof CreateChatCompletionFinishReason
>;

export type CreateChatCompletionRouterTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionRouterContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<CreateChatCompletionRouterTopLogprobs>;
};

export type CreateChatCompletionRouterResponseTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionRefusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<CreateChatCompletionRouterResponseTopLogprobs>;
};

/**
 * Log probability information for the choice.
 */
export type CreateChatCompletionLogprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<CreateChatCompletionRouterContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<CreateChatCompletionRefusal> | null;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const CreateChatCompletionRouterResponse200Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type CreateChatCompletionRouterResponse200Type = ClosedEnum<
  typeof CreateChatCompletionRouterResponse200Type
>;

export type CreateChatCompletionRouterResponseFunction = {
  /**
   * The name of the function.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionRouterToolCalls = {
  /**
   * The index of the tool call.
   */
  index?: number | undefined;
  /**
   * The ID of the tool call.
   */
  id?: string | undefined;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type?: CreateChatCompletionRouterResponse200Type | undefined;
  function?: CreateChatCompletionRouterResponseFunction | undefined;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models.
   */
  thoughtSignature?: string | undefined;
};

export const CreateChatCompletionRouterRole = {
  Assistant: "assistant",
} as const;
export type CreateChatCompletionRouterRole = ClosedEnum<
  typeof CreateChatCompletionRouterRole
>;

/**
 * Audio response data in streaming mode.
 */
export type CreateChatCompletionRouterResponseAudio = {
  id?: string | undefined;
  transcript?: string | undefined;
  data?: string | undefined;
  expiresAt?: number | undefined;
};

/**
 * A chat completion delta generated by streamed model responses.
 */
export type Delta = {
  /**
   * The contents of the chunk message.
   */
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?: Array<CreateChatCompletionRouterToolCalls> | undefined;
  role?: CreateChatCompletionRouterRole | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * Audio response data in streaming mode.
   */
  audio?: CreateChatCompletionRouterResponseAudio | null | undefined;
};

export type CreateChatCompletionRouterChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: CreateChatCompletionFinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index?: number | undefined;
  /**
   * Log probability information for the choice.
   */
  logprobs?: CreateChatCompletionLogprobs | null | undefined;
  /**
   * A chat completion delta generated by streamed model responses.
   */
  delta: Delta;
};

export type CreateChatCompletionRouterPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateChatCompletionRouterCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateChatCompletionRouterUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | CreateChatCompletionRouterPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | CreateChatCompletionRouterCompletionTokensDetails
    | null
    | undefined;
};

export const CreateChatCompletionRouterObject = {
  ChatCompletionChunk: "chat.completion.chunk",
} as const;
export type CreateChatCompletionRouterObject = ClosedEnum<
  typeof CreateChatCompletionRouterObject
>;

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionData = {
  /**
   * A unique identifier for the chat completion.
   */
  id: string;
  /**
   * A list of chat completion choices. Can contain more than one elements if n is greater than 1. Can also be empty for the last chunk if you set stream_options: {"include_usage": true}.
   */
  choices: Array<CreateChatCompletionRouterChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created: number;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateChatCompletionRouterUsage | null | undefined;
  object: CreateChatCompletionRouterObject;
};

/**
 * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionRouterResponseBody = {
  /**
   * Represents a streamed chunk of a chat completion response returned by model, based on the provided input.
   */
  data?: CreateChatCompletionData | undefined;
};

/**
 * The reason the model stopped generating tokens.
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
} as const;
/**
 * The reason the model stopped generating tokens.
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export const CreateChatCompletionRouterResponseType = {
  Function: "function",
} as const;
export type CreateChatCompletionRouterResponseType = ClosedEnum<
  typeof CreateChatCompletionRouterResponseType
>;

export type CreateChatCompletionRouterFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type CreateChatCompletionToolCalls = {
  index?: number | undefined;
  id?: string | undefined;
  type?: CreateChatCompletionRouterResponseType | undefined;
  function?: CreateChatCompletionRouterFunction | undefined;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export const CreateChatCompletionRole = {
  Assistant: "assistant",
} as const;
export type CreateChatCompletionRole = ClosedEnum<
  typeof CreateChatCompletionRole
>;

/**
 * If the audio output modality is requested, this object contains data about the audio response from the model.
 */
export type CreateChatCompletionRouterAudio = {
  id: string;
  expiresAt: number;
  data: string;
  transcript: string;
};

/**
 * A chat completion message generated by the model.
 */
export type CreateChatCompletionMessage = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  toolCalls?: Array<CreateChatCompletionToolCalls> | undefined;
  role?: CreateChatCompletionRole | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | null | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | null | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
  /**
   * If the audio output modality is requested, this object contains data about the audio response from the model.
   */
  audio?: CreateChatCompletionRouterAudio | null | undefined;
};

export type TopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type CreateChatCompletionContent = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<TopLogprobs>;
};

export type CreateChatCompletionTopLogprobs = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
};

export type Refusal = {
  /**
   * The token.
   */
  token: string;
  /**
   * The log probability of this token, if it is within the top 20 most likely tokens. Otherwise, the value -9999.0 is used to signify that the token is very unlikely.
   */
  logprob: number;
  /**
   * A list of integers representing the UTF-8 bytes representation of the token.
   */
  bytes: Array<number> | null;
  /**
   * List of the most likely tokens and their log probability, at this token position.
   */
  topLogprobs: Array<CreateChatCompletionTopLogprobs>;
};

/**
 * Log probability information for the choice.
 */
export type Logprobs = {
  /**
   * A list of message content tokens with log probability information.
   */
  content: Array<CreateChatCompletionContent> | null;
  /**
   * A list of message refusal tokens with log probability information.
   */
  refusal: Array<Refusal> | null;
};

export type CreateChatCompletionChoices = {
  /**
   * The reason the model stopped generating tokens.
   */
  finishReason: FinishReason | null;
  /**
   * The index of the choice in the list of choices.
   */
  index?: number | undefined;
  /**
   * A chat completion message generated by the model.
   */
  message: CreateChatCompletionMessage;
  /**
   * Log probability information for the choice.
   */
  logprobs?: Logprobs | null | undefined;
};

export type CreateChatCompletionPromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CreateChatCompletionCompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Usage statistics for the completion request.
 */
export type CreateChatCompletionUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?:
    | CreateChatCompletionPromptTokensDetails
    | null
    | undefined;
  completionTokensDetails?:
    | CreateChatCompletionCompletionTokensDetails
    | null
    | undefined;
};

export const CreateChatCompletionObject = {
  ChatCompletion: "chat.completion",
} as const;
export type CreateChatCompletionObject = ClosedEnum<
  typeof CreateChatCompletionObject
>;

/**
 * Represents a chat completion response returned by model, based on the provided input.
 */
export type CreateChatCompletionResponseBody = {
  /**
   * A unique identifier for the chat completion.
   */
  id: string;
  /**
   * A list of chat completion choices. Can be more than one if n is greater than 1.
   */
  choices: Array<CreateChatCompletionChoices>;
  /**
   * The Unix timestamp (in seconds) of when the chat completion was created.
   */
  created: number;
  /**
   * The model used for the chat completion.
   */
  model: string;
  /**
   * This fingerprint represents the backend configuration that the model runs with.
   */
  systemFingerprint?: string | null | undefined;
  /**
   * Usage statistics for the completion request.
   */
  usage?: CreateChatCompletionUsage | null | undefined;
  object: CreateChatCompletionObject;
};

export type CreateChatCompletionResponse =
  | CreateChatCompletionResponseBody
  | EventStream<CreateChatCompletionRouterResponseBody>;

/** @internal */
export const CreateChatCompletionContentRouterRequest2$inboundSchema: z.ZodType<
  CreateChatCompletionContentRouterRequest2,
  z.ZodTypeDef,
  unknown
> = components.TextContentPartSchema$inboundSchema;
/** @internal */
export type CreateChatCompletionContentRouterRequest2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const CreateChatCompletionContentRouterRequest2$outboundSchema:
  z.ZodType<
    CreateChatCompletionContentRouterRequest2$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionContentRouterRequest2
  > = components.TextContentPartSchema$outboundSchema;

export function createChatCompletionContentRouterRequest2ToJSON(
  createChatCompletionContentRouterRequest2:
    CreateChatCompletionContentRouterRequest2,
): string {
  return JSON.stringify(
    CreateChatCompletionContentRouterRequest2$outboundSchema.parse(
      createChatCompletionContentRouterRequest2,
    ),
  );
}
export function createChatCompletionContentRouterRequest2FromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionContentRouterRequest2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionContentRouterRequest2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionContentRouterRequest2' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterRequestRequestBody5Content$inboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestRequestBody5Content,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);
/** @internal */
export type CreateChatCompletionMessagesRouterRequestRequestBody5Content$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesRouterRequestRequestBody5Content$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestRequestBody5Content$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterRequestRequestBody5Content
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function createChatCompletionMessagesRouterRequestRequestBody5ContentToJSON(
  createChatCompletionMessagesRouterRequestRequestBody5Content:
    CreateChatCompletionMessagesRouterRequestRequestBody5Content,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterRequestRequestBody5Content$outboundSchema
      .parse(createChatCompletionMessagesRouterRequestRequestBody5Content),
  );
}
export function createChatCompletionMessagesRouterRequestRequestBody5ContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesRouterRequestRequestBody5Content,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesRouterRequestRequestBody5Content$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesRouterRequestRequestBody5Content' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterType$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionMessagesRouterType> = z.nativeEnum(
    CreateChatCompletionMessagesRouterType,
  );
/** @internal */
export const CreateChatCompletionMessagesRouterType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionMessagesRouterType> =
    CreateChatCompletionMessagesRouterType$inboundSchema;

/** @internal */
export const CreateChatCompletionMessagesTtl$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesTtl
> = z.nativeEnum(CreateChatCompletionMessagesTtl);
/** @internal */
export const CreateChatCompletionMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesTtl
> = CreateChatCompletionMessagesTtl$inboundSchema;

/** @internal */
export const CreateChatCompletionMessagesCacheControl$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateChatCompletionMessagesRouterType$inboundSchema,
  ttl: CreateChatCompletionMessagesTtl$inboundSchema.default("5m"),
});
/** @internal */
export type CreateChatCompletionMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreateChatCompletionMessagesCacheControl$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesCacheControl
> = z.object({
  type: CreateChatCompletionMessagesRouterType$outboundSchema,
  ttl: CreateChatCompletionMessagesTtl$outboundSchema.default("5m"),
});

export function createChatCompletionMessagesCacheControlToJSON(
  createChatCompletionMessagesCacheControl:
    CreateChatCompletionMessagesCacheControl,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesCacheControl$outboundSchema.parse(
      createChatCompletionMessagesCacheControl,
    ),
  );
}
export function createChatCompletionMessagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesCacheControl,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesCacheControl$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesToolMessage$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.nullable(z.string()),
  cache_control: z.lazy(() =>
    CreateChatCompletionMessagesCacheControl$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type CreateChatCompletionMessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: CreateChatCompletionMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesToolMessage$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolMessage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() =>
    CreateChatCompletionMessagesCacheControl$outboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function createChatCompletionMessagesToolMessageToJSON(
  createChatCompletionMessagesToolMessage:
    CreateChatCompletionMessagesToolMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesToolMessage$outboundSchema.parse(
      createChatCompletionMessagesToolMessage,
    ),
  );
}
export function createChatCompletionMessagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesToolMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesToolMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionContentRouter2$inboundSchema: z.ZodType<
  CreateChatCompletionContentRouter2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$inboundSchema,
  components.ReasoningPartSchema$inboundSchema,
  components.RedactedReasoningPartSchema$inboundSchema,
]);
/** @internal */
export type CreateChatCompletionContentRouter2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const CreateChatCompletionContentRouter2$outboundSchema: z.ZodType<
  CreateChatCompletionContentRouter2$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContentRouter2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$outboundSchema,
  components.ReasoningPartSchema$outboundSchema,
  components.RedactedReasoningPartSchema$outboundSchema,
]);

export function createChatCompletionContentRouter2ToJSON(
  createChatCompletionContentRouter2: CreateChatCompletionContentRouter2,
): string {
  return JSON.stringify(
    CreateChatCompletionContentRouter2$outboundSchema.parse(
      createChatCompletionContentRouter2,
    ),
  );
}
export function createChatCompletionContentRouter2FromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionContentRouter2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionContentRouter2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionContentRouter2' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterRequestRequestBodyContent$inboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestRequestBodyContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);
/** @internal */
export type CreateChatCompletionMessagesRouterRequestRequestBodyContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const CreateChatCompletionMessagesRouterRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function createChatCompletionMessagesRouterRequestRequestBodyContentToJSON(
  createChatCompletionMessagesRouterRequestRequestBodyContent:
    CreateChatCompletionMessagesRouterRequestRequestBodyContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterRequestRequestBodyContent$outboundSchema
      .parse(createChatCompletionMessagesRouterRequestRequestBodyContent),
  );
}
export function createChatCompletionMessagesRouterRequestRequestBodyContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesRouterRequestRequestBodyContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesRouterRequestRequestBodyContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesRouterRequestRequestBodyContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesAudio$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});
/** @internal */
export type CreateChatCompletionMessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const CreateChatCompletionMessagesAudio$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesAudio
> = z.object({
  id: z.string(),
});

export function createChatCompletionMessagesAudioToJSON(
  createChatCompletionMessagesAudio: CreateChatCompletionMessagesAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesAudio$outboundSchema.parse(
      createChatCompletionMessagesAudio,
    ),
  );
}
export function createChatCompletionMessagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionMessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesAudio' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesType
> = z.nativeEnum(CreateChatCompletionMessagesType);
/** @internal */
export const CreateChatCompletionMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionMessagesType
> = CreateChatCompletionMessagesType$inboundSchema;

/** @internal */
export const CreateChatCompletionMessagesFunction$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type CreateChatCompletionMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesFunction$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function createChatCompletionMessagesFunctionToJSON(
  createChatCompletionMessagesFunction: CreateChatCompletionMessagesFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesFunction$outboundSchema.parse(
      createChatCompletionMessagesFunction,
    ),
  );
}
export function createChatCompletionMessagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesToolCalls$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateChatCompletionMessagesType$inboundSchema,
  function: z.lazy(() => CreateChatCompletionMessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type CreateChatCompletionMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: CreateChatCompletionMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesToolCalls$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesToolCalls
> = z.object({
  id: z.string(),
  type: CreateChatCompletionMessagesType$outboundSchema,
  function: z.lazy(() => CreateChatCompletionMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function createChatCompletionMessagesToolCallsToJSON(
  createChatCompletionMessagesToolCalls: CreateChatCompletionMessagesToolCalls,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesToolCalls$outboundSchema.parse(
      createChatCompletionMessagesToolCalls,
    ),
  );
}
export function createChatCompletionMessagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesAssistantMessage$inboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesAssistantMessage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    content: z.nullable(
      z.union([
        z.string(),
        z.array(
          z.union([
            components.TextContentPartSchema$inboundSchema.and(
              z.object({ type: z.literal("text") }),
            ),
            components.RefusalPartSchema$inboundSchema,
            components.ReasoningPartSchema$inboundSchema,
            components.RedactedReasoningPartSchema$inboundSchema,
          ]),
        ),
      ]),
    ).optional(),
    refusal: z.nullable(z.string()).optional(),
    role: z.literal("assistant"),
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => CreateChatCompletionMessagesAudio$inboundSchema),
    ).optional(),
    tool_calls: z.array(
      z.lazy(() => CreateChatCompletionMessagesToolCalls$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_calls": "toolCalls",
    });
  });
/** @internal */
export type CreateChatCompletionMessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: CreateChatCompletionMessagesAudio$Outbound | null | undefined;
  tool_calls?:
    | Array<CreateChatCompletionMessagesToolCalls$Outbound>
    | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesAssistantMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesAssistantMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesAssistantMessage
  > = z.object({
    content: z.nullable(
      z.union([
        z.string(),
        z.array(
          z.union([
            components.TextContentPartSchema$outboundSchema.and(
              z.object({ type: z.literal("text") }),
            ),
            components.RefusalPartSchema$outboundSchema,
            components.ReasoningPartSchema$outboundSchema,
            components.RedactedReasoningPartSchema$outboundSchema,
          ]),
        ),
      ]),
    ).optional(),
    refusal: z.nullable(z.string()).optional(),
    role: z.literal("assistant"),
    name: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => CreateChatCompletionMessagesAudio$outboundSchema),
    ).optional(),
    toolCalls: z.array(
      z.lazy(() => CreateChatCompletionMessagesToolCalls$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      toolCalls: "tool_calls",
    });
  });

export function createChatCompletionMessagesAssistantMessageToJSON(
  createChatCompletionMessagesAssistantMessage:
    CreateChatCompletionMessagesAssistantMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesAssistantMessage$outboundSchema.parse(
      createChatCompletionMessagesAssistantMessage,
    ),
  );
}
export function createChatCompletionMessagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesAssistantMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesAssistantMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion2RouterType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletion2RouterType
> = z.nativeEnum(CreateChatCompletion2RouterType);
/** @internal */
export const CreateChatCompletion2RouterType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletion2RouterType
> = CreateChatCompletion2RouterType$inboundSchema;

/** @internal */
export const CreateChatCompletion2Ttl$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletion2Ttl
> = z.nativeEnum(CreateChatCompletion2Ttl);
/** @internal */
export const CreateChatCompletion2Ttl$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletion2Ttl
> = CreateChatCompletion2Ttl$inboundSchema;

/** @internal */
export const CreateChatCompletion2CacheControl$inboundSchema: z.ZodType<
  CreateChatCompletion2CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateChatCompletion2RouterType$inboundSchema,
  ttl: CreateChatCompletion2Ttl$inboundSchema.default("5m"),
});
/** @internal */
export type CreateChatCompletion2CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CreateChatCompletion2CacheControl$outboundSchema: z.ZodType<
  CreateChatCompletion2CacheControl$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion2CacheControl
> = z.object({
  type: CreateChatCompletion2RouterType$outboundSchema,
  ttl: CreateChatCompletion2Ttl$outboundSchema.default("5m"),
});

export function createChatCompletion2CacheControlToJSON(
  createChatCompletion2CacheControl: CreateChatCompletion2CacheControl,
): string {
  return JSON.stringify(
    CreateChatCompletion2CacheControl$outboundSchema.parse(
      createChatCompletion2CacheControl,
    ),
  );
}
export function createChatCompletion2CacheControlFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion2CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion2CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion2CacheControl' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion24$inboundSchema: z.ZodType<
  CreateChatCompletion24,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  cache_control: z.lazy(() => CreateChatCompletion2CacheControl$inboundSchema)
    .optional(),
  file: components.FileContentPartSchema$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type CreateChatCompletion24$Outbound = {
  type: "file";
  cache_control?: CreateChatCompletion2CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const CreateChatCompletion24$outboundSchema: z.ZodType<
  CreateChatCompletion24$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion24
> = z.object({
  type: z.literal("file"),
  cacheControl: z.lazy(() => CreateChatCompletion2CacheControl$outboundSchema)
    .optional(),
  file: components.FileContentPartSchema$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    cacheControl: "cache_control",
  });
});

export function createChatCompletion24ToJSON(
  createChatCompletion24: CreateChatCompletion24,
): string {
  return JSON.stringify(
    CreateChatCompletion24$outboundSchema.parse(createChatCompletion24),
  );
}
export function createChatCompletion24FromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion24, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion24$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion24' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionContent2$inboundSchema: z.ZodType<
  CreateChatCompletionContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => CreateChatCompletion24$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionContent2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | CreateChatCompletion24$Outbound;

/** @internal */
export const CreateChatCompletionContent2$outboundSchema: z.ZodType<
  CreateChatCompletionContent2$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContent2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => CreateChatCompletion24$outboundSchema),
]);

export function createChatCompletionContent2ToJSON(
  createChatCompletionContent2: CreateChatCompletionContent2,
): string {
  return JSON.stringify(
    CreateChatCompletionContent2$outboundSchema.parse(
      createChatCompletionContent2,
    ),
  );
}
export function createChatCompletionContent2FromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionContent2' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterRequestContent$inboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => CreateChatCompletion24$inboundSchema),
      ]),
    ),
  ]);
/** @internal */
export type CreateChatCompletionMessagesRouterRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | CreateChatCompletion24$Outbound
  >;

/** @internal */
export const CreateChatCompletionMessagesRouterRequestContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterRequestContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => CreateChatCompletion24$outboundSchema),
      ]),
    ),
  ]);

export function createChatCompletionMessagesRouterRequestContentToJSON(
  createChatCompletionMessagesRouterRequestContent:
    CreateChatCompletionMessagesRouterRequestContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterRequestContent$outboundSchema.parse(
      createChatCompletionMessagesRouterRequestContent,
    ),
  );
}
export function createChatCompletionMessagesRouterRequestContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesRouterRequestContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesRouterRequestContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesRouterRequestContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesUserMessage$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => CreateChatCompletion24$inboundSchema),
      ]),
    ),
  ]),
});
/** @internal */
export type CreateChatCompletionMessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | CreateChatCompletion24$Outbound
    >;
};

/** @internal */
export const CreateChatCompletionMessagesUserMessage$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesUserMessage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => CreateChatCompletion24$outboundSchema),
      ]),
    ),
  ]),
});

export function createChatCompletionMessagesUserMessageToJSON(
  createChatCompletionMessagesUserMessage:
    CreateChatCompletionMessagesUserMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesUserMessage$outboundSchema.parse(
      createChatCompletionMessagesUserMessage,
    ),
  );
}
export function createChatCompletionMessagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesUserMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesUserMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesRouterContent$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesRouterContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionMessagesRouterContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesRouterContent$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesRouterContent$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesRouterContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function createChatCompletionMessagesRouterContentToJSON(
  createChatCompletionMessagesRouterContent:
    CreateChatCompletionMessagesRouterContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesRouterContent$outboundSchema.parse(
      createChatCompletionMessagesRouterContent,
    ),
  );
}
export function createChatCompletionMessagesRouterContentFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesRouterContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesRouterContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesRouterContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesDeveloperMessage$inboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesDeveloperMessage,
    z.ZodTypeDef,
    unknown
  > = z.object({
    role: z.literal("developer"),
    content: z.union([
      z.string(),
      z.array(components.TextContentPartSchema$inboundSchema),
    ]),
    name: z.string().optional(),
  });
/** @internal */
export type CreateChatCompletionMessagesDeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesDeveloperMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesDeveloperMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesDeveloperMessage
  > = z.object({
    role: z.literal("developer"),
    content: z.union([
      z.string(),
      z.array(components.TextContentPartSchema$outboundSchema),
    ]),
    name: z.string().optional(),
  });

export function createChatCompletionMessagesDeveloperMessageToJSON(
  createChatCompletionMessagesDeveloperMessage:
    CreateChatCompletionMessagesDeveloperMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesDeveloperMessage$outboundSchema.parse(
      createChatCompletionMessagesDeveloperMessage,
    ),
  );
}
export function createChatCompletionMessagesDeveloperMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesDeveloperMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesDeveloperMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesDeveloperMessage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesContent$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const CreateChatCompletionMessagesContent$outboundSchema: z.ZodType<
  CreateChatCompletionMessagesContent$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function createChatCompletionMessagesContentToJSON(
  createChatCompletionMessagesContent: CreateChatCompletionMessagesContent,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesContent$outboundSchema.parse(
      createChatCompletionMessagesContent,
    ),
  );
}
export function createChatCompletionMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessagesContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessagesSystemMessage$inboundSchema: z.ZodType<
  CreateChatCompletionMessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type CreateChatCompletionMessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const CreateChatCompletionMessagesSystemMessage$outboundSchema:
  z.ZodType<
    CreateChatCompletionMessagesSystemMessage$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionMessagesSystemMessage
  > = z.object({
    role: z.literal("system"),
    content: z.union([
      z.string(),
      z.array(components.TextContentPartSchema$outboundSchema),
    ]),
    name: z.string().optional(),
  });

export function createChatCompletionMessagesSystemMessageToJSON(
  createChatCompletionMessagesSystemMessage:
    CreateChatCompletionMessagesSystemMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessagesSystemMessage$outboundSchema.parse(
      createChatCompletionMessagesSystemMessage,
    ),
  );
}
export function createChatCompletionMessagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionMessagesSystemMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionMessagesSystemMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionMessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessages$inboundSchema: z.ZodType<
  CreateChatCompletionMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionMessagesSystemMessage$inboundSchema),
  z.lazy(() => CreateChatCompletionMessagesDeveloperMessage$inboundSchema),
  z.lazy(() => CreateChatCompletionMessagesUserMessage$inboundSchema),
  z.lazy(() => CreateChatCompletionMessagesAssistantMessage$inboundSchema),
  z.lazy(() => CreateChatCompletionMessagesToolMessage$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionMessages$Outbound =
  | CreateChatCompletionMessagesSystemMessage$Outbound
  | CreateChatCompletionMessagesDeveloperMessage$Outbound
  | CreateChatCompletionMessagesUserMessage$Outbound
  | CreateChatCompletionMessagesAssistantMessage$Outbound
  | CreateChatCompletionMessagesToolMessage$Outbound;

/** @internal */
export const CreateChatCompletionMessages$outboundSchema: z.ZodType<
  CreateChatCompletionMessages$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessages
> = z.union([
  z.lazy(() => CreateChatCompletionMessagesSystemMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesDeveloperMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesUserMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesAssistantMessage$outboundSchema),
  z.lazy(() => CreateChatCompletionMessagesToolMessage$outboundSchema),
]);

export function createChatCompletionMessagesToJSON(
  createChatCompletionMessages: CreateChatCompletionMessages,
): string {
  return JSON.stringify(
    CreateChatCompletionMessages$outboundSchema.parse(
      createChatCompletionMessages,
    ),
  );
}
export function createChatCompletionMessagesFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessages' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionVoice$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionVoice
> = z.nativeEnum(CreateChatCompletionVoice);
/** @internal */
export const CreateChatCompletionVoice$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionVoice
> = CreateChatCompletionVoice$inboundSchema;

/** @internal */
export const CreateChatCompletionFormat$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFormat
> = z.nativeEnum(CreateChatCompletionFormat);
/** @internal */
export const CreateChatCompletionFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFormat
> = CreateChatCompletionFormat$inboundSchema;

/** @internal */
export const CreateChatCompletionAudio$inboundSchema: z.ZodType<
  CreateChatCompletionAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: CreateChatCompletionVoice$inboundSchema,
  format: CreateChatCompletionFormat$inboundSchema,
});
/** @internal */
export type CreateChatCompletionAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const CreateChatCompletionAudio$outboundSchema: z.ZodType<
  CreateChatCompletionAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAudio
> = z.object({
  voice: CreateChatCompletionVoice$outboundSchema,
  format: CreateChatCompletionFormat$outboundSchema,
});

export function createChatCompletionAudioToJSON(
  createChatCompletionAudio: CreateChatCompletionAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionAudio$outboundSchema.parse(createChatCompletionAudio),
  );
}
export function createChatCompletionAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAudio' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponseFormatRouterJsonSchema$inboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatRouterJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });
/** @internal */
export type CreateChatCompletionResponseFormatRouterJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict: boolean;
};

/** @internal */
export const CreateChatCompletionResponseFormatRouterJsonSchema$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatRouterJsonSchema$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatRouterJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().default(false),
  });

export function createChatCompletionResponseFormatRouterJsonSchemaToJSON(
  createChatCompletionResponseFormatRouterJsonSchema:
    CreateChatCompletionResponseFormatRouterJsonSchema,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatRouterJsonSchema$outboundSchema.parse(
      createChatCompletionResponseFormatRouterJsonSchema,
    ),
  );
}
export function createChatCompletionResponseFormatRouterJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionResponseFormatRouterJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionResponseFormatRouterJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionResponseFormatRouterJsonSchema' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponseFormatJSONSchema$inboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      CreateChatCompletionResponseFormatRouterJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type CreateChatCompletionResponseFormatJSONSchema$Outbound = {
  type: "json_schema";
  json_schema: CreateChatCompletionResponseFormatRouterJsonSchema$Outbound;
};

/** @internal */
export const CreateChatCompletionResponseFormatJSONSchema$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONSchema$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatJSONSchema
  > = z.object({
    type: z.literal("json_schema"),
    jsonSchema: z.lazy(() =>
      CreateChatCompletionResponseFormatRouterJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function createChatCompletionResponseFormatJSONSchemaToJSON(
  createChatCompletionResponseFormatJSONSchema:
    CreateChatCompletionResponseFormatJSONSchema,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatJSONSchema$outboundSchema.parse(
      createChatCompletionResponseFormatJSONSchema,
    ),
  );
}
export function createChatCompletionResponseFormatJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionResponseFormatJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionResponseFormatJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionResponseFormatJSONSchema' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponseFormatJSONObject$inboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_object"),
  });
/** @internal */
export type CreateChatCompletionResponseFormatJSONObject$Outbound = {
  type: "json_object";
};

/** @internal */
export const CreateChatCompletionResponseFormatJSONObject$outboundSchema:
  z.ZodType<
    CreateChatCompletionResponseFormatJSONObject$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionResponseFormatJSONObject
  > = z.object({
    type: z.literal("json_object"),
  });

export function createChatCompletionResponseFormatJSONObjectToJSON(
  createChatCompletionResponseFormatJSONObject:
    CreateChatCompletionResponseFormatJSONObject,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatJSONObject$outboundSchema.parse(
      createChatCompletionResponseFormatJSONObject,
    ),
  );
}
export function createChatCompletionResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionResponseFormatJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionResponseFormatJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponseFormatText$inboundSchema: z.ZodType<
  CreateChatCompletionResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});
/** @internal */
export type CreateChatCompletionResponseFormatText$Outbound = {
  type: "text";
};

/** @internal */
export const CreateChatCompletionResponseFormatText$outboundSchema: z.ZodType<
  CreateChatCompletionResponseFormatText$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponseFormatText
> = z.object({
  type: z.literal("text"),
});

export function createChatCompletionResponseFormatTextToJSON(
  createChatCompletionResponseFormatText:
    CreateChatCompletionResponseFormatText,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormatText$outboundSchema.parse(
      createChatCompletionResponseFormatText,
    ),
  );
}
export function createChatCompletionResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponseFormatText' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponseFormat$inboundSchema: z.ZodType<
  CreateChatCompletionResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionResponseFormatText$inboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONObject$inboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionResponseFormat$Outbound =
  | CreateChatCompletionResponseFormatText$Outbound
  | CreateChatCompletionResponseFormatJSONObject$Outbound
  | CreateChatCompletionResponseFormatJSONSchema$Outbound;

/** @internal */
export const CreateChatCompletionResponseFormat$outboundSchema: z.ZodType<
  CreateChatCompletionResponseFormat$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponseFormat
> = z.union([
  z.lazy(() => CreateChatCompletionResponseFormatText$outboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONObject$outboundSchema),
  z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$outboundSchema),
]);

export function createChatCompletionResponseFormatToJSON(
  createChatCompletionResponseFormat: CreateChatCompletionResponseFormat,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseFormat$outboundSchema.parse(
      createChatCompletionResponseFormat,
    ),
  );
}
export function createChatCompletionResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponseFormat' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionReasoningEffort
> = z.nativeEnum(CreateChatCompletionReasoningEffort);
/** @internal */
export const CreateChatCompletionReasoningEffort$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionReasoningEffort> =
    CreateChatCompletionReasoningEffort$inboundSchema;

/** @internal */
export const CreateChatCompletionStop$inboundSchema: z.ZodType<
  CreateChatCompletionStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type CreateChatCompletionStop$Outbound = string | Array<string>;

/** @internal */
export const CreateChatCompletionStop$outboundSchema: z.ZodType<
  CreateChatCompletionStop$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionStop
> = z.union([z.string(), z.array(z.string())]);

export function createChatCompletionStopToJSON(
  createChatCompletionStop: CreateChatCompletionStop,
): string {
  return JSON.stringify(
    CreateChatCompletionStop$outboundSchema.parse(createChatCompletionStop),
  );
}
export function createChatCompletionStopFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionStop' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionStreamOptions$inboundSchema: z.ZodType<
  CreateChatCompletionStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type CreateChatCompletionStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionStreamOptions$outboundSchema: z.ZodType<
  CreateChatCompletionStreamOptions$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function createChatCompletionStreamOptionsToJSON(
  createChatCompletionStreamOptions: CreateChatCompletionStreamOptions,
): string {
  return JSON.stringify(
    CreateChatCompletionStreamOptions$outboundSchema.parse(
      createChatCompletionStreamOptions,
    ),
  );
}
export function createChatCompletionStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionStreamOptions' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionThinking$inboundSchema: z.ZodType<
  CreateChatCompletionThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);
/** @internal */
export type CreateChatCompletionThinking$Outbound =
  | components.ThinkingConfigDisabledSchema$Outbound
  | components.ThinkingConfigEnabledSchema$Outbound;

/** @internal */
export const CreateChatCompletionThinking$outboundSchema: z.ZodType<
  CreateChatCompletionThinking$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionThinking
> = z.union([
  components.ThinkingConfigDisabledSchema$outboundSchema,
  components.ThinkingConfigEnabledSchema$outboundSchema,
]);

export function createChatCompletionThinkingToJSON(
  createChatCompletionThinking: CreateChatCompletionThinking,
): string {
  return JSON.stringify(
    CreateChatCompletionThinking$outboundSchema.parse(
      createChatCompletionThinking,
    ),
  );
}
export function createChatCompletionThinkingFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionThinking' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionType
> = z.nativeEnum(CreateChatCompletionType);
/** @internal */
export const CreateChatCompletionType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionType
> = CreateChatCompletionType$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterType
> = z.nativeEnum(CreateChatCompletionRouterType);
/** @internal */
export const CreateChatCompletionRouterType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterType
> = CreateChatCompletionRouterType$inboundSchema;

/** @internal */
export const CreateChatCompletionParameters$inboundSchema: z.ZodType<
  CreateChatCompletionParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateChatCompletionRouterType$inboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});
/** @internal */
export type CreateChatCompletionParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required?: Array<string> | undefined;
  additionalProperties?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionParameters$outboundSchema: z.ZodType<
  CreateChatCompletionParameters$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionParameters
> = z.object({
  type: CreateChatCompletionRouterType$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()).optional(),
  additionalProperties: z.boolean().optional(),
});

export function createChatCompletionParametersToJSON(
  createChatCompletionParameters: CreateChatCompletionParameters,
): string {
  return JSON.stringify(
    CreateChatCompletionParameters$outboundSchema.parse(
      createChatCompletionParameters,
    ),
  );
}
export function createChatCompletionParametersFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionParameters' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFunction$inboundSchema: z.ZodType<
  CreateChatCompletionFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.lazy(() => CreateChatCompletionParameters$inboundSchema)
    .optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type CreateChatCompletionFunction$Outbound = {
  name: string;
  description?: string | undefined;
  parameters?: CreateChatCompletionParameters$Outbound | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionFunction$outboundSchema: z.ZodType<
  CreateChatCompletionFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.lazy(() => CreateChatCompletionParameters$outboundSchema)
    .optional(),
  strict: z.boolean().optional(),
});

export function createChatCompletionFunctionToJSON(
  createChatCompletionFunction: CreateChatCompletionFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionFunction$outboundSchema.parse(
      createChatCompletionFunction,
    ),
  );
}
export function createChatCompletionFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionTools$inboundSchema: z.ZodType<
  CreateChatCompletionTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateChatCompletionType$inboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionFunction$inboundSchema),
});
/** @internal */
export type CreateChatCompletionTools$Outbound = {
  type?: string | undefined;
  function: CreateChatCompletionFunction$Outbound;
};

/** @internal */
export const CreateChatCompletionTools$outboundSchema: z.ZodType<
  CreateChatCompletionTools$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionTools
> = z.object({
  type: CreateChatCompletionType$outboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionFunction$outboundSchema),
});

export function createChatCompletionToolsToJSON(
  createChatCompletionTools: CreateChatCompletionTools,
): string {
  return JSON.stringify(
    CreateChatCompletionTools$outboundSchema.parse(createChatCompletionTools),
  );
}
export function createChatCompletionToolsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionTools' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoiceType
> = z.nativeEnum(CreateChatCompletionToolChoiceType);
/** @internal */
export const CreateChatCompletionToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoiceType
> = CreateChatCompletionToolChoiceType$inboundSchema;

/** @internal */
export const CreateChatCompletionToolChoiceFunction$inboundSchema: z.ZodType<
  CreateChatCompletionToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});
/** @internal */
export type CreateChatCompletionToolChoiceFunction$Outbound = {
  name: string;
};

/** @internal */
export const CreateChatCompletionToolChoiceFunction$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoiceFunction
> = z.object({
  name: z.string(),
});

export function createChatCompletionToolChoiceFunctionToJSON(
  createChatCompletionToolChoiceFunction:
    CreateChatCompletionToolChoiceFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoiceFunction$outboundSchema.parse(
      createChatCompletionToolChoiceFunction,
    ),
  );
}
export function createChatCompletionToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionToolChoice2$inboundSchema: z.ZodType<
  CreateChatCompletionToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: CreateChatCompletionToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionToolChoiceFunction$inboundSchema),
});
/** @internal */
export type CreateChatCompletionToolChoice2$Outbound = {
  type?: string | undefined;
  function: CreateChatCompletionToolChoiceFunction$Outbound;
};

/** @internal */
export const CreateChatCompletionToolChoice2$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoice2$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoice2
> = z.object({
  type: CreateChatCompletionToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionToolChoiceFunction$outboundSchema),
});

export function createChatCompletionToolChoice2ToJSON(
  createChatCompletionToolChoice2: CreateChatCompletionToolChoice2,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoice2$outboundSchema.parse(
      createChatCompletionToolChoice2,
    ),
  );
}
export function createChatCompletionToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionToolChoice2' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoice1
> = z.nativeEnum(CreateChatCompletionToolChoice1);
/** @internal */
export const CreateChatCompletionToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionToolChoice1
> = CreateChatCompletionToolChoice1$inboundSchema;

/** @internal */
export const CreateChatCompletionToolChoice$inboundSchema: z.ZodType<
  CreateChatCompletionToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionToolChoice2$inboundSchema),
  CreateChatCompletionToolChoice1$inboundSchema,
]);
/** @internal */
export type CreateChatCompletionToolChoice$Outbound =
  | CreateChatCompletionToolChoice2$Outbound
  | string;

/** @internal */
export const CreateChatCompletionToolChoice$outboundSchema: z.ZodType<
  CreateChatCompletionToolChoice$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolChoice
> = z.union([
  z.lazy(() => CreateChatCompletionToolChoice2$outboundSchema),
  CreateChatCompletionToolChoice1$outboundSchema,
]);

export function createChatCompletionToolChoiceToJSON(
  createChatCompletionToolChoice: CreateChatCompletionToolChoice,
): string {
  return JSON.stringify(
    CreateChatCompletionToolChoice$outboundSchema.parse(
      createChatCompletionToolChoice,
    ),
  );
}
export function createChatCompletionToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionToolChoice' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionModalities$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionModalities
> = z.nativeEnum(CreateChatCompletionModalities);
/** @internal */
export const CreateChatCompletionModalities$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionModalities
> = CreateChatCompletionModalities$inboundSchema;

/** @internal */
export const CreateChatCompletionId1$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionId1
> = z.nativeEnum(CreateChatCompletionId1);
/** @internal */
export const CreateChatCompletionId1$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionId1
> = CreateChatCompletionId1$inboundSchema;

/** @internal */
export const CreateChatCompletionId$inboundSchema: z.ZodType<
  CreateChatCompletionId,
  z.ZodTypeDef,
  unknown
> = z.union([CreateChatCompletionId1$inboundSchema, z.string()]);
/** @internal */
export type CreateChatCompletionId$Outbound = string | string;

/** @internal */
export const CreateChatCompletionId$outboundSchema: z.ZodType<
  CreateChatCompletionId$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionId
> = z.union([CreateChatCompletionId1$outboundSchema, z.string()]);

export function createChatCompletionIdToJSON(
  createChatCompletionId: CreateChatCompletionId,
): string {
  return JSON.stringify(
    CreateChatCompletionId$outboundSchema.parse(createChatCompletionId),
  );
}
export function createChatCompletionIdFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionId' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionExecuteOn
> = z.nativeEnum(CreateChatCompletionExecuteOn);
/** @internal */
export const CreateChatCompletionExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionExecuteOn
> = CreateChatCompletionExecuteOn$inboundSchema;

/** @internal */
export const CreateChatCompletionGuardrails$inboundSchema: z.ZodType<
  CreateChatCompletionGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([CreateChatCompletionId1$inboundSchema, z.string()]),
  execute_on: CreateChatCompletionExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});
/** @internal */
export type CreateChatCompletionGuardrails$Outbound = {
  id: string | string;
  execute_on: string;
};

/** @internal */
export const CreateChatCompletionGuardrails$outboundSchema: z.ZodType<
  CreateChatCompletionGuardrails$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionGuardrails
> = z.object({
  id: z.union([CreateChatCompletionId1$outboundSchema, z.string()]),
  executeOn: CreateChatCompletionExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    executeOn: "execute_on",
  });
});

export function createChatCompletionGuardrailsToJSON(
  createChatCompletionGuardrails: CreateChatCompletionGuardrails,
): string {
  return JSON.stringify(
    CreateChatCompletionGuardrails$outboundSchema.parse(
      createChatCompletionGuardrails,
    ),
  );
}
export function createChatCompletionGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionGuardrails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRetry$inboundSchema: z.ZodType<
  CreateChatCompletionRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type CreateChatCompletionRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateChatCompletionRetry$outboundSchema: z.ZodType<
  CreateChatCompletionRetry$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createChatCompletionRetryToJSON(
  createChatCompletionRetry: CreateChatCompletionRetry,
): string {
  return JSON.stringify(
    CreateChatCompletionRetry$outboundSchema.parse(createChatCompletionRetry),
  );
}
export function createChatCompletionRetryFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRetry' from JSON`,
  );
}

/** @internal */
export const Fallbacks$inboundSchema: z.ZodType<
  Fallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type Fallbacks$Outbound = {
  model: string;
};

/** @internal */
export const Fallbacks$outboundSchema: z.ZodType<
  Fallbacks$Outbound,
  z.ZodTypeDef,
  Fallbacks
> = z.object({
  model: z.string(),
});

export function fallbacksToJSON(fallbacks: Fallbacks): string {
  return JSON.stringify(Fallbacks$outboundSchema.parse(fallbacks));
}
export function fallbacksFromJSON(
  jsonString: string,
): SafeParseResult<Fallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Fallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Fallbacks' from JSON`,
  );
}

/** @internal */
export const Version$inboundSchema: z.ZodNativeEnum<typeof Version> = z
  .nativeEnum(Version);
/** @internal */
export const Version$outboundSchema: z.ZodNativeEnum<typeof Version> =
  Version$inboundSchema;

/** @internal */
export const Prompt$inboundSchema: z.ZodType<Prompt, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    version: Version$inboundSchema,
  });
/** @internal */
export type Prompt$Outbound = {
  id: string;
  version: string;
};

/** @internal */
export const Prompt$outboundSchema: z.ZodType<
  Prompt$Outbound,
  z.ZodTypeDef,
  Prompt
> = z.object({
  id: z.string(),
  version: Version$outboundSchema,
});

export function promptToJSON(prompt: Prompt): string {
  return JSON.stringify(Prompt$outboundSchema.parse(prompt));
}
export function promptFromJSON(
  jsonString: string,
): SafeParseResult<Prompt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Prompt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Prompt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionContact$inboundSchema: z.ZodType<
  CreateChatCompletionContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type CreateChatCompletionContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateChatCompletionContact$outboundSchema: z.ZodType<
  CreateChatCompletionContact$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function createChatCompletionContactToJSON(
  createChatCompletionContact: CreateChatCompletionContact,
): string {
  return JSON.stringify(
    CreateChatCompletionContact$outboundSchema.parse(
      createChatCompletionContact,
    ),
  );
}
export function createChatCompletionContactFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionContact' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionThread$inboundSchema: z.ZodType<
  CreateChatCompletionThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type CreateChatCompletionThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateChatCompletionThread$outboundSchema: z.ZodType<
  CreateChatCompletionThread$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createChatCompletionThreadToJSON(
  createChatCompletionThread: CreateChatCompletionThread,
): string {
  return JSON.stringify(
    CreateChatCompletionThread$outboundSchema.parse(createChatCompletionThread),
  );
}
export function createChatCompletionThreadFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionThread' from JSON`,
  );
}

/** @internal */
export const Inputs2$inboundSchema: z.ZodType<Inputs2, z.ZodTypeDef, unknown> =
  z.object({
    key: z.string(),
    value: z.any().optional(),
    is_pii: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "is_pii": "isPii",
    });
  });
/** @internal */
export type Inputs2$Outbound = {
  key: string;
  value?: any | undefined;
  is_pii?: boolean | undefined;
};

/** @internal */
export const Inputs2$outboundSchema: z.ZodType<
  Inputs2$Outbound,
  z.ZodTypeDef,
  Inputs2
> = z.object({
  key: z.string(),
  value: z.any().optional(),
  isPii: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    isPii: "is_pii",
  });
});

export function inputs2ToJSON(inputs2: Inputs2): string {
  return JSON.stringify(Inputs2$outboundSchema.parse(inputs2));
}
export function inputs2FromJSON(
  jsonString: string,
): SafeParseResult<Inputs2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Inputs2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Inputs2' from JSON`,
  );
}

/** @internal */
export const Inputs$inboundSchema: z.ZodType<Inputs, z.ZodTypeDef, unknown> = z
  .union([z.record(z.any()), z.array(z.lazy(() => Inputs2$inboundSchema))]);
/** @internal */
export type Inputs$Outbound = { [k: string]: any } | Array<Inputs2$Outbound>;

/** @internal */
export const Inputs$outboundSchema: z.ZodType<
  Inputs$Outbound,
  z.ZodTypeDef,
  Inputs
> = z.union([z.record(z.any()), z.array(z.lazy(() => Inputs2$outboundSchema))]);

export function inputsToJSON(inputs: Inputs): string {
  return JSON.stringify(Inputs$outboundSchema.parse(inputs));
}
export function inputsFromJSON(
  jsonString: string,
): SafeParseResult<Inputs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Inputs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Inputs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterRequestType$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterRequestType> = z.nativeEnum(
    CreateChatCompletionRouterRequestType,
  );
/** @internal */
export const CreateChatCompletionRouterRequestType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterRequestType> =
    CreateChatCompletionRouterRequestType$inboundSchema;

/** @internal */
export const Cache$inboundSchema: z.ZodType<Cache, z.ZodTypeDef, unknown> = z
  .object({
    ttl: z.number().default(1800),
    type: CreateChatCompletionRouterRequestType$inboundSchema,
  });
/** @internal */
export type Cache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const Cache$outboundSchema: z.ZodType<
  Cache$Outbound,
  z.ZodTypeDef,
  Cache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateChatCompletionRouterRequestType$outboundSchema,
});

export function cacheToJSON(cache: Cache): string {
  return JSON.stringify(Cache$outboundSchema.parse(cache));
}
export function cacheFromJSON(
  jsonString: string,
): SafeParseResult<Cache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Cache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Cache' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionSearchType$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionSearchType
> = z.nativeEnum(CreateChatCompletionSearchType);
/** @internal */
export const CreateChatCompletionSearchType$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionSearchType
> = CreateChatCompletionSearchType$inboundSchema;

/** @internal */
export const CreateChatCompletionOrExists$inboundSchema: z.ZodType<
  CreateChatCompletionOrExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type CreateChatCompletionOrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletionOrExists$outboundSchema: z.ZodType<
  CreateChatCompletionOrExists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrExists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletionOrExistsToJSON(
  createChatCompletionOrExists: CreateChatCompletionOrExists,
): string {
  return JSON.stringify(
    CreateChatCompletionOrExists$outboundSchema.parse(
      createChatCompletionOrExists,
    ),
  );
}
export function createChatCompletionOrExistsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrExists' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrRouterNin$inboundSchema: z.ZodType<
  CreateChatCompletionOrRouterNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionOrRouterNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionOrRouterNin$outboundSchema: z.ZodType<
  CreateChatCompletionOrRouterNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrRouterNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterNinToJSON(
  createChatCompletionOrRouterNin: CreateChatCompletionOrRouterNin,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterNin$outboundSchema.parse(
      createChatCompletionOrRouterNin,
    ),
  );
}
export function createChatCompletionOrRouterNinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrRouterNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrRouterNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrRouterNin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrNin$inboundSchema: z.ZodType<
  CreateChatCompletionOrNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletionOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionOrNin$outboundSchema: z.ZodType<
  CreateChatCompletionOrNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionOrNinToJSON(
  createChatCompletionOrNin: CreateChatCompletionOrNin,
): string {
  return JSON.stringify(
    CreateChatCompletionOrNin$outboundSchema.parse(createChatCompletionOrNin),
  );
}
export function createChatCompletionOrNinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrNin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrRouterIn$inboundSchema: z.ZodType<
  CreateChatCompletionOrRouterIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionOrRouterIn$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletionOrRouterIn$outboundSchema: z.ZodType<
  CreateChatCompletionOrRouterIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrRouterIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterInToJSON(
  createChatCompletionOrRouterIn: CreateChatCompletionOrRouterIn,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterIn$outboundSchema.parse(
      createChatCompletionOrRouterIn,
    ),
  );
}
export function createChatCompletionOrRouterInFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrRouterIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrRouterIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrRouterIn' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrIn$inboundSchema: z.ZodType<
  CreateChatCompletionOrIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletionOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionOrIn$outboundSchema: z.ZodType<
  CreateChatCompletionOrIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionOrInToJSON(
  createChatCompletionOrIn: CreateChatCompletionOrIn,
): string {
  return JSON.stringify(
    CreateChatCompletionOrIn$outboundSchema.parse(createChatCompletionOrIn),
  );
}
export function createChatCompletionOrInFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrIn' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrLte$inboundSchema: z.ZodType<
  CreateChatCompletionOrLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});
/** @internal */
export type CreateChatCompletionOrLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletionOrLte$outboundSchema: z.ZodType<
  CreateChatCompletionOrLte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrLte
> = z.object({
  lte: z.number(),
});

export function createChatCompletionOrLteToJSON(
  createChatCompletionOrLte: CreateChatCompletionOrLte,
): string {
  return JSON.stringify(
    CreateChatCompletionOrLte$outboundSchema.parse(createChatCompletionOrLte),
  );
}
export function createChatCompletionOrLteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrLte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrLt$inboundSchema: z.ZodType<
  CreateChatCompletionOrLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});
/** @internal */
export type CreateChatCompletionOrLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletionOrLt$outboundSchema: z.ZodType<
  CreateChatCompletionOrLt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrLt
> = z.object({
  lt: z.number(),
});

export function createChatCompletionOrLtToJSON(
  createChatCompletionOrLt: CreateChatCompletionOrLt,
): string {
  return JSON.stringify(
    CreateChatCompletionOrLt$outboundSchema.parse(createChatCompletionOrLt),
  );
}
export function createChatCompletionOrLtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrLt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrGte$inboundSchema: z.ZodType<
  CreateChatCompletionOrGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});
/** @internal */
export type CreateChatCompletionOrGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletionOrGte$outboundSchema: z.ZodType<
  CreateChatCompletionOrGte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrGte
> = z.object({
  gte: z.number(),
});

export function createChatCompletionOrGteToJSON(
  createChatCompletionOrGte: CreateChatCompletionOrGte,
): string {
  return JSON.stringify(
    CreateChatCompletionOrGte$outboundSchema.parse(createChatCompletionOrGte),
  );
}
export function createChatCompletionOrGteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrGte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrGt$inboundSchema: z.ZodType<
  CreateChatCompletionOrGt,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});
/** @internal */
export type CreateChatCompletionOrGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletionOrGt$outboundSchema: z.ZodType<
  CreateChatCompletionOrGt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrGt
> = z.object({
  gt: z.number(),
});

export function createChatCompletionOrGtToJSON(
  createChatCompletionOrGt: CreateChatCompletionOrGt,
): string {
  return JSON.stringify(
    CreateChatCompletionOrGt$outboundSchema.parse(createChatCompletionOrGt),
  );
}
export function createChatCompletionOrGtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrGt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrRouterNe$inboundSchema: z.ZodType<
  CreateChatCompletionOrRouterNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionOrRouterNe$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletionOrRouterNe$outboundSchema: z.ZodType<
  CreateChatCompletionOrRouterNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrRouterNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterNeToJSON(
  createChatCompletionOrRouterNe: CreateChatCompletionOrRouterNe,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterNe$outboundSchema.parse(
      createChatCompletionOrRouterNe,
    ),
  );
}
export function createChatCompletionOrRouterNeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrRouterNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrRouterNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrRouterNe' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrNe$inboundSchema: z.ZodType<
  CreateChatCompletionOrNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletionOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionOrNe$outboundSchema: z.ZodType<
  CreateChatCompletionOrNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionOrNeToJSON(
  createChatCompletionOrNe: CreateChatCompletionOrNe,
): string {
  return JSON.stringify(
    CreateChatCompletionOrNe$outboundSchema.parse(createChatCompletionOrNe),
  );
}
export function createChatCompletionOrNeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrNe' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrRouterEq$inboundSchema: z.ZodType<
  CreateChatCompletionOrRouterEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionOrRouterEq$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletionOrRouterEq$outboundSchema: z.ZodType<
  CreateChatCompletionOrRouterEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrRouterEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionOrRouterEqToJSON(
  createChatCompletionOrRouterEq: CreateChatCompletionOrRouterEq,
): string {
  return JSON.stringify(
    CreateChatCompletionOrRouterEq$outboundSchema.parse(
      createChatCompletionOrRouterEq,
    ),
  );
}
export function createChatCompletionOrRouterEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrRouterEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrRouterEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrRouterEq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionOrEq$inboundSchema: z.ZodType<
  CreateChatCompletionOrEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletionOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionOrEq$outboundSchema: z.ZodType<
  CreateChatCompletionOrEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionOrEqToJSON(
  createChatCompletionOrEq: CreateChatCompletionOrEq,
): string {
  return JSON.stringify(
    CreateChatCompletionOrEq$outboundSchema.parse(createChatCompletionOrEq),
  );
}
export function createChatCompletionOrEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionOrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionOrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionOrEq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterByRouterOr$inboundSchema: z.ZodType<
  CreateChatCompletionFilterByRouterOr,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionOrEq$inboundSchema),
  z.lazy(() => CreateChatCompletionOrNe$inboundSchema),
  z.lazy(() => CreateChatCompletionOrGt$inboundSchema),
  z.lazy(() => CreateChatCompletionOrGte$inboundSchema),
  z.lazy(() => CreateChatCompletionOrLt$inboundSchema),
  z.lazy(() => CreateChatCompletionOrLte$inboundSchema),
  z.lazy(() => CreateChatCompletionOrIn$inboundSchema),
  z.lazy(() => CreateChatCompletionOrNin$inboundSchema),
  z.lazy(() => CreateChatCompletionOrExists$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionFilterByRouterOr$Outbound =
  | CreateChatCompletionOrEq$Outbound
  | CreateChatCompletionOrNe$Outbound
  | CreateChatCompletionOrGt$Outbound
  | CreateChatCompletionOrGte$Outbound
  | CreateChatCompletionOrLt$Outbound
  | CreateChatCompletionOrLte$Outbound
  | CreateChatCompletionOrIn$Outbound
  | CreateChatCompletionOrNin$Outbound
  | CreateChatCompletionOrExists$Outbound;

/** @internal */
export const CreateChatCompletionFilterByRouterOr$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByRouterOr$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByRouterOr
> = z.union([
  z.lazy(() => CreateChatCompletionOrEq$outboundSchema),
  z.lazy(() => CreateChatCompletionOrNe$outboundSchema),
  z.lazy(() => CreateChatCompletionOrGt$outboundSchema),
  z.lazy(() => CreateChatCompletionOrGte$outboundSchema),
  z.lazy(() => CreateChatCompletionOrLt$outboundSchema),
  z.lazy(() => CreateChatCompletionOrLte$outboundSchema),
  z.lazy(() => CreateChatCompletionOrIn$outboundSchema),
  z.lazy(() => CreateChatCompletionOrNin$outboundSchema),
  z.lazy(() => CreateChatCompletionOrExists$outboundSchema),
]);

export function createChatCompletionFilterByRouterOrToJSON(
  createChatCompletionFilterByRouterOr: CreateChatCompletionFilterByRouterOr,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByRouterOr$outboundSchema.parse(
      createChatCompletionFilterByRouterOr,
    ),
  );
}
export function createChatCompletionFilterByRouterOrFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterByRouterOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionFilterByRouterOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterByRouterOr' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterByOr$inboundSchema: z.ZodType<
  CreateChatCompletionFilterByOr,
  z.ZodTypeDef,
  unknown
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionOrEq$inboundSchema),
      z.lazy(() =>
        CreateChatCompletionOrNe$inboundSchema
      ),
      z.lazy(() => CreateChatCompletionOrGt$inboundSchema),
      z.lazy(() => CreateChatCompletionOrGte$inboundSchema),
      z.lazy(() => CreateChatCompletionOrLt$inboundSchema),
      z.lazy(() => CreateChatCompletionOrLte$inboundSchema),
      z.lazy(() => CreateChatCompletionOrIn$inboundSchema),
      z.lazy(() => CreateChatCompletionOrNin$inboundSchema),
      z.lazy(() => CreateChatCompletionOrExists$inboundSchema),
    ])),
  ),
});
/** @internal */
export type CreateChatCompletionFilterByOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | CreateChatCompletionOrEq$Outbound
        | CreateChatCompletionOrNe$Outbound
        | CreateChatCompletionOrGt$Outbound
        | CreateChatCompletionOrGte$Outbound
        | CreateChatCompletionOrLt$Outbound
        | CreateChatCompletionOrLte$Outbound
        | CreateChatCompletionOrIn$Outbound
        | CreateChatCompletionOrNin$Outbound
        | CreateChatCompletionOrExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateChatCompletionFilterByOr$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByOr$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionOrEq$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionOrNe$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionOrGt$outboundSchema),
      z.lazy(() => CreateChatCompletionOrGte$outboundSchema),
      z.lazy(() => CreateChatCompletionOrLt$outboundSchema),
      z.lazy(() => CreateChatCompletionOrLte$outboundSchema),
      z.lazy(() => CreateChatCompletionOrIn$outboundSchema),
      z.lazy(() => CreateChatCompletionOrNin$outboundSchema),
      z.lazy(() => CreateChatCompletionOrExists$outboundSchema),
    ])),
  ),
});

export function createChatCompletionFilterByOrToJSON(
  createChatCompletionFilterByOr: CreateChatCompletionFilterByOr,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByOr$outboundSchema.parse(
      createChatCompletionFilterByOr,
    ),
  );
}
export function createChatCompletionFilterByOrFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterByOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionFilterByOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterByOr' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndExists$inboundSchema: z.ZodType<
  CreateChatCompletionAndExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type CreateChatCompletionAndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletionAndExists$outboundSchema: z.ZodType<
  CreateChatCompletionAndExists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndExists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletionAndExistsToJSON(
  createChatCompletionAndExists: CreateChatCompletionAndExists,
): string {
  return JSON.stringify(
    CreateChatCompletionAndExists$outboundSchema.parse(
      createChatCompletionAndExists,
    ),
  );
}
export function createChatCompletionAndExistsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndExists' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndRouterNin$inboundSchema: z.ZodType<
  CreateChatCompletionAndRouterNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionAndRouterNin$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterNin$outboundSchema: z.ZodType<
  CreateChatCompletionAndRouterNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndRouterNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterNinToJSON(
  createChatCompletionAndRouterNin: CreateChatCompletionAndRouterNin,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterNin$outboundSchema.parse(
      createChatCompletionAndRouterNin,
    ),
  );
}
export function createChatCompletionAndRouterNinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndRouterNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndRouterNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndRouterNin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndNin$inboundSchema: z.ZodType<
  CreateChatCompletionAndNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletionAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionAndNin$outboundSchema: z.ZodType<
  CreateChatCompletionAndNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionAndNinToJSON(
  createChatCompletionAndNin: CreateChatCompletionAndNin,
): string {
  return JSON.stringify(
    CreateChatCompletionAndNin$outboundSchema.parse(createChatCompletionAndNin),
  );
}
export function createChatCompletionAndNinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndNin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndRouterIn$inboundSchema: z.ZodType<
  CreateChatCompletionAndRouterIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionAndRouterIn$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterIn$outboundSchema: z.ZodType<
  CreateChatCompletionAndRouterIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndRouterIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterInToJSON(
  createChatCompletionAndRouterIn: CreateChatCompletionAndRouterIn,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterIn$outboundSchema.parse(
      createChatCompletionAndRouterIn,
    ),
  );
}
export function createChatCompletionAndRouterInFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndRouterIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndRouterIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndRouterIn' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndIn$inboundSchema: z.ZodType<
  CreateChatCompletionAndIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletionAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletionAndIn$outboundSchema: z.ZodType<
  CreateChatCompletionAndIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletionAndInToJSON(
  createChatCompletionAndIn: CreateChatCompletionAndIn,
): string {
  return JSON.stringify(
    CreateChatCompletionAndIn$outboundSchema.parse(createChatCompletionAndIn),
  );
}
export function createChatCompletionAndInFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndIn' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndLte$inboundSchema: z.ZodType<
  CreateChatCompletionAndLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});
/** @internal */
export type CreateChatCompletionAndLte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletionAndLte$outboundSchema: z.ZodType<
  CreateChatCompletionAndLte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndLte
> = z.object({
  lte: z.number(),
});

export function createChatCompletionAndLteToJSON(
  createChatCompletionAndLte: CreateChatCompletionAndLte,
): string {
  return JSON.stringify(
    CreateChatCompletionAndLte$outboundSchema.parse(createChatCompletionAndLte),
  );
}
export function createChatCompletionAndLteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndLte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndLt$inboundSchema: z.ZodType<
  CreateChatCompletionAndLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});
/** @internal */
export type CreateChatCompletionAndLt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletionAndLt$outboundSchema: z.ZodType<
  CreateChatCompletionAndLt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndLt
> = z.object({
  lt: z.number(),
});

export function createChatCompletionAndLtToJSON(
  createChatCompletionAndLt: CreateChatCompletionAndLt,
): string {
  return JSON.stringify(
    CreateChatCompletionAndLt$outboundSchema.parse(createChatCompletionAndLt),
  );
}
export function createChatCompletionAndLtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndLt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndGte$inboundSchema: z.ZodType<
  CreateChatCompletionAndGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});
/** @internal */
export type CreateChatCompletionAndGte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletionAndGte$outboundSchema: z.ZodType<
  CreateChatCompletionAndGte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndGte
> = z.object({
  gte: z.number(),
});

export function createChatCompletionAndGteToJSON(
  createChatCompletionAndGte: CreateChatCompletionAndGte,
): string {
  return JSON.stringify(
    CreateChatCompletionAndGte$outboundSchema.parse(createChatCompletionAndGte),
  );
}
export function createChatCompletionAndGteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndGte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndGt$inboundSchema: z.ZodType<
  CreateChatCompletionAndGt,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});
/** @internal */
export type CreateChatCompletionAndGt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletionAndGt$outboundSchema: z.ZodType<
  CreateChatCompletionAndGt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndGt
> = z.object({
  gt: z.number(),
});

export function createChatCompletionAndGtToJSON(
  createChatCompletionAndGt: CreateChatCompletionAndGt,
): string {
  return JSON.stringify(
    CreateChatCompletionAndGt$outboundSchema.parse(createChatCompletionAndGt),
  );
}
export function createChatCompletionAndGtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndGt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndRouterNe$inboundSchema: z.ZodType<
  CreateChatCompletionAndRouterNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionAndRouterNe$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterNe$outboundSchema: z.ZodType<
  CreateChatCompletionAndRouterNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndRouterNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterNeToJSON(
  createChatCompletionAndRouterNe: CreateChatCompletionAndRouterNe,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterNe$outboundSchema.parse(
      createChatCompletionAndRouterNe,
    ),
  );
}
export function createChatCompletionAndRouterNeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndRouterNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndRouterNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndRouterNe' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndNe$inboundSchema: z.ZodType<
  CreateChatCompletionAndNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletionAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionAndNe$outboundSchema: z.ZodType<
  CreateChatCompletionAndNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionAndNeToJSON(
  createChatCompletionAndNe: CreateChatCompletionAndNe,
): string {
  return JSON.stringify(
    CreateChatCompletionAndNe$outboundSchema.parse(createChatCompletionAndNe),
  );
}
export function createChatCompletionAndNeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndNe' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndRouterEq$inboundSchema: z.ZodType<
  CreateChatCompletionAndRouterEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletionAndRouterEq$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const CreateChatCompletionAndRouterEq$outboundSchema: z.ZodType<
  CreateChatCompletionAndRouterEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndRouterEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletionAndRouterEqToJSON(
  createChatCompletionAndRouterEq: CreateChatCompletionAndRouterEq,
): string {
  return JSON.stringify(
    CreateChatCompletionAndRouterEq$outboundSchema.parse(
      createChatCompletionAndRouterEq,
    ),
  );
}
export function createChatCompletionAndRouterEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndRouterEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndRouterEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndRouterEq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAndEq$inboundSchema: z.ZodType<
  CreateChatCompletionAndEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletionAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletionAndEq$outboundSchema: z.ZodType<
  CreateChatCompletionAndEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletionAndEqToJSON(
  createChatCompletionAndEq: CreateChatCompletionAndEq,
): string {
  return JSON.stringify(
    CreateChatCompletionAndEq$outboundSchema.parse(createChatCompletionAndEq),
  );
}
export function createChatCompletionAndEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionAndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAndEq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterByRouterAnd$inboundSchema: z.ZodType<
  CreateChatCompletionFilterByRouterAnd,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionAndEq$inboundSchema),
  z.lazy(() => CreateChatCompletionAndNe$inboundSchema),
  z.lazy(() => CreateChatCompletionAndGt$inboundSchema),
  z.lazy(() => CreateChatCompletionAndGte$inboundSchema),
  z.lazy(() => CreateChatCompletionAndLt$inboundSchema),
  z.lazy(() => CreateChatCompletionAndLte$inboundSchema),
  z.lazy(() => CreateChatCompletionAndIn$inboundSchema),
  z.lazy(() => CreateChatCompletionAndNin$inboundSchema),
  z.lazy(() => CreateChatCompletionAndExists$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionFilterByRouterAnd$Outbound =
  | CreateChatCompletionAndEq$Outbound
  | CreateChatCompletionAndNe$Outbound
  | CreateChatCompletionAndGt$Outbound
  | CreateChatCompletionAndGte$Outbound
  | CreateChatCompletionAndLt$Outbound
  | CreateChatCompletionAndLte$Outbound
  | CreateChatCompletionAndIn$Outbound
  | CreateChatCompletionAndNin$Outbound
  | CreateChatCompletionAndExists$Outbound;

/** @internal */
export const CreateChatCompletionFilterByRouterAnd$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByRouterAnd$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByRouterAnd
> = z.union([
  z.lazy(() => CreateChatCompletionAndEq$outboundSchema),
  z.lazy(() => CreateChatCompletionAndNe$outboundSchema),
  z.lazy(() => CreateChatCompletionAndGt$outboundSchema),
  z.lazy(() => CreateChatCompletionAndGte$outboundSchema),
  z.lazy(() => CreateChatCompletionAndLt$outboundSchema),
  z.lazy(() => CreateChatCompletionAndLte$outboundSchema),
  z.lazy(() => CreateChatCompletionAndIn$outboundSchema),
  z.lazy(() => CreateChatCompletionAndNin$outboundSchema),
  z.lazy(() => CreateChatCompletionAndExists$outboundSchema),
]);

export function createChatCompletionFilterByRouterAndToJSON(
  createChatCompletionFilterByRouterAnd: CreateChatCompletionFilterByRouterAnd,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByRouterAnd$outboundSchema.parse(
      createChatCompletionFilterByRouterAnd,
    ),
  );
}
export function createChatCompletionFilterByRouterAndFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterByRouterAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionFilterByRouterAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterByRouterAnd' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterByAnd$inboundSchema: z.ZodType<
  CreateChatCompletionFilterByAnd,
  z.ZodTypeDef,
  unknown
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionAndEq$inboundSchema),
      z.lazy(() =>
        CreateChatCompletionAndNe$inboundSchema
      ),
      z.lazy(() => CreateChatCompletionAndGt$inboundSchema),
      z.lazy(() => CreateChatCompletionAndGte$inboundSchema),
      z.lazy(() => CreateChatCompletionAndLt$inboundSchema),
      z.lazy(() => CreateChatCompletionAndLte$inboundSchema),
      z.lazy(() => CreateChatCompletionAndIn$inboundSchema),
      z.lazy(() => CreateChatCompletionAndNin$inboundSchema),
      z.lazy(() => CreateChatCompletionAndExists$inboundSchema),
    ])),
  ),
});
/** @internal */
export type CreateChatCompletionFilterByAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | CreateChatCompletionAndEq$Outbound
        | CreateChatCompletionAndNe$Outbound
        | CreateChatCompletionAndGt$Outbound
        | CreateChatCompletionAndGte$Outbound
        | CreateChatCompletionAndLt$Outbound
        | CreateChatCompletionAndLte$Outbound
        | CreateChatCompletionAndIn$Outbound
        | CreateChatCompletionAndNin$Outbound
        | CreateChatCompletionAndExists$Outbound;
    }
  >;
};

/** @internal */
export const CreateChatCompletionFilterByAnd$outboundSchema: z.ZodType<
  CreateChatCompletionFilterByAnd$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterByAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => CreateChatCompletionAndEq$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionAndNe$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionAndGt$outboundSchema),
      z.lazy(() => CreateChatCompletionAndGte$outboundSchema),
      z.lazy(() => CreateChatCompletionAndLt$outboundSchema),
      z.lazy(() => CreateChatCompletionAndLte$outboundSchema),
      z.lazy(() => CreateChatCompletionAndIn$outboundSchema),
      z.lazy(() => CreateChatCompletionAndNin$outboundSchema),
      z.lazy(() => CreateChatCompletionAndExists$outboundSchema),
    ])),
  ),
});

export function createChatCompletionFilterByAndToJSON(
  createChatCompletionFilterByAnd: CreateChatCompletionFilterByAnd,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterByAnd$outboundSchema.parse(
      createChatCompletionFilterByAnd,
    ),
  );
}
export function createChatCompletionFilterByAndFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterByAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionFilterByAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterByAnd' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Exists$inboundSchema: z.ZodType<
  CreateChatCompletion1Exists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type CreateChatCompletion1Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const CreateChatCompletion1Exists$outboundSchema: z.ZodType<
  CreateChatCompletion1Exists$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Exists
> = z.object({
  exists: z.boolean(),
});

export function createChatCompletion1ExistsToJSON(
  createChatCompletion1Exists: CreateChatCompletion1Exists,
): string {
  return JSON.stringify(
    CreateChatCompletion1Exists$outboundSchema.parse(
      createChatCompletion1Exists,
    ),
  );
}
export function createChatCompletion1ExistsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Exists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Exists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Exists' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1RouterNin$inboundSchema: z.ZodType<
  CreateChatCompletion1RouterNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletion1RouterNin$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletion1RouterNin$outboundSchema: z.ZodType<
  CreateChatCompletion1RouterNin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1RouterNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterNinToJSON(
  createChatCompletion1RouterNin: CreateChatCompletion1RouterNin,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterNin$outboundSchema.parse(
      createChatCompletion1RouterNin,
    ),
  );
}
export function createChatCompletion1RouterNinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1RouterNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1RouterNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1RouterNin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Nin$inboundSchema: z.ZodType<
  CreateChatCompletion1Nin,
  z.ZodTypeDef,
  unknown
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletion1Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletion1Nin$outboundSchema: z.ZodType<
  CreateChatCompletion1Nin$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Nin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletion1NinToJSON(
  createChatCompletion1Nin: CreateChatCompletion1Nin,
): string {
  return JSON.stringify(
    CreateChatCompletion1Nin$outboundSchema.parse(createChatCompletion1Nin),
  );
}
export function createChatCompletion1NinFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Nin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Nin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Nin' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1RouterIn$inboundSchema: z.ZodType<
  CreateChatCompletion1RouterIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletion1RouterIn$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletion1RouterIn$outboundSchema: z.ZodType<
  CreateChatCompletion1RouterIn$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1RouterIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterInToJSON(
  createChatCompletion1RouterIn: CreateChatCompletion1RouterIn,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterIn$outboundSchema.parse(
      createChatCompletion1RouterIn,
    ),
  );
}
export function createChatCompletion1RouterInFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1RouterIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1RouterIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1RouterIn' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1In$inboundSchema: z.ZodType<
  CreateChatCompletion1In,
  z.ZodTypeDef,
  unknown
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type CreateChatCompletion1In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const CreateChatCompletion1In$outboundSchema: z.ZodType<
  CreateChatCompletion1In$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1In
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function createChatCompletion1InToJSON(
  createChatCompletion1In: CreateChatCompletion1In,
): string {
  return JSON.stringify(
    CreateChatCompletion1In$outboundSchema.parse(createChatCompletion1In),
  );
}
export function createChatCompletion1InFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1In, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1In$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1In' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Lte$inboundSchema: z.ZodType<
  CreateChatCompletion1Lte,
  z.ZodTypeDef,
  unknown
> = z.object({
  lte: z.number(),
});
/** @internal */
export type CreateChatCompletion1Lte$Outbound = {
  lte: number;
};

/** @internal */
export const CreateChatCompletion1Lte$outboundSchema: z.ZodType<
  CreateChatCompletion1Lte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Lte
> = z.object({
  lte: z.number(),
});

export function createChatCompletion1LteToJSON(
  createChatCompletion1Lte: CreateChatCompletion1Lte,
): string {
  return JSON.stringify(
    CreateChatCompletion1Lte$outboundSchema.parse(createChatCompletion1Lte),
  );
}
export function createChatCompletion1LteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Lte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Lte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Lte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Lt$inboundSchema: z.ZodType<
  CreateChatCompletion1Lt,
  z.ZodTypeDef,
  unknown
> = z.object({
  lt: z.number(),
});
/** @internal */
export type CreateChatCompletion1Lt$Outbound = {
  lt: number;
};

/** @internal */
export const CreateChatCompletion1Lt$outboundSchema: z.ZodType<
  CreateChatCompletion1Lt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Lt
> = z.object({
  lt: z.number(),
});

export function createChatCompletion1LtToJSON(
  createChatCompletion1Lt: CreateChatCompletion1Lt,
): string {
  return JSON.stringify(
    CreateChatCompletion1Lt$outboundSchema.parse(createChatCompletion1Lt),
  );
}
export function createChatCompletion1LtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Lt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Lt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Lt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Gte$inboundSchema: z.ZodType<
  CreateChatCompletion1Gte,
  z.ZodTypeDef,
  unknown
> = z.object({
  gte: z.number(),
});
/** @internal */
export type CreateChatCompletion1Gte$Outbound = {
  gte: number;
};

/** @internal */
export const CreateChatCompletion1Gte$outboundSchema: z.ZodType<
  CreateChatCompletion1Gte$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Gte
> = z.object({
  gte: z.number(),
});

export function createChatCompletion1GteToJSON(
  createChatCompletion1Gte: CreateChatCompletion1Gte,
): string {
  return JSON.stringify(
    CreateChatCompletion1Gte$outboundSchema.parse(createChatCompletion1Gte),
  );
}
export function createChatCompletion1GteFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Gte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Gte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Gte' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Gt$inboundSchema: z.ZodType<
  CreateChatCompletion1Gt,
  z.ZodTypeDef,
  unknown
> = z.object({
  gt: z.number(),
});
/** @internal */
export type CreateChatCompletion1Gt$Outbound = {
  gt: number;
};

/** @internal */
export const CreateChatCompletion1Gt$outboundSchema: z.ZodType<
  CreateChatCompletion1Gt$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Gt
> = z.object({
  gt: z.number(),
});

export function createChatCompletion1GtToJSON(
  createChatCompletion1Gt: CreateChatCompletion1Gt,
): string {
  return JSON.stringify(
    CreateChatCompletion1Gt$outboundSchema.parse(createChatCompletion1Gt),
  );
}
export function createChatCompletion1GtFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Gt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Gt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Gt' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1RouterNe$inboundSchema: z.ZodType<
  CreateChatCompletion1RouterNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletion1RouterNe$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletion1RouterNe$outboundSchema: z.ZodType<
  CreateChatCompletion1RouterNe$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1RouterNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterNeToJSON(
  createChatCompletion1RouterNe: CreateChatCompletion1RouterNe,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterNe$outboundSchema.parse(
      createChatCompletion1RouterNe,
    ),
  );
}
export function createChatCompletion1RouterNeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1RouterNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1RouterNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1RouterNe' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Ne$inboundSchema: z.ZodType<
  CreateChatCompletion1Ne,
  z.ZodTypeDef,
  unknown
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletion1Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const CreateChatCompletion1Ne$outboundSchema: z.ZodType<
  CreateChatCompletion1Ne$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Ne
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletion1NeToJSON(
  createChatCompletion1Ne: CreateChatCompletion1Ne,
): string {
  return JSON.stringify(
    CreateChatCompletion1Ne$outboundSchema.parse(createChatCompletion1Ne),
  );
}
export function createChatCompletion1NeFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Ne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Ne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Ne' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1RouterEq$inboundSchema: z.ZodType<
  CreateChatCompletion1RouterEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type CreateChatCompletion1RouterEq$Outbound = string | number | boolean;

/** @internal */
export const CreateChatCompletion1RouterEq$outboundSchema: z.ZodType<
  CreateChatCompletion1RouterEq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1RouterEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function createChatCompletion1RouterEqToJSON(
  createChatCompletion1RouterEq: CreateChatCompletion1RouterEq,
): string {
  return JSON.stringify(
    CreateChatCompletion1RouterEq$outboundSchema.parse(
      createChatCompletion1RouterEq,
    ),
  );
}
export function createChatCompletion1RouterEqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1RouterEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1RouterEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1RouterEq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletion1Eq$inboundSchema: z.ZodType<
  CreateChatCompletion1Eq,
  z.ZodTypeDef,
  unknown
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type CreateChatCompletion1Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const CreateChatCompletion1Eq$outboundSchema: z.ZodType<
  CreateChatCompletion1Eq$Outbound,
  z.ZodTypeDef,
  CreateChatCompletion1Eq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function createChatCompletion1EqToJSON(
  createChatCompletion1Eq: CreateChatCompletion1Eq,
): string {
  return JSON.stringify(
    CreateChatCompletion1Eq$outboundSchema.parse(createChatCompletion1Eq),
  );
}
export function createChatCompletion1EqFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletion1Eq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletion1Eq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletion1Eq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterBy1$inboundSchema: z.ZodType<
  CreateChatCompletionFilterBy1,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletion1Eq$inboundSchema),
  z.lazy(() => CreateChatCompletion1Ne$inboundSchema),
  z.lazy(() => CreateChatCompletion1Gt$inboundSchema),
  z.lazy(() => CreateChatCompletion1Gte$inboundSchema),
  z.lazy(() => CreateChatCompletion1Lt$inboundSchema),
  z.lazy(() => CreateChatCompletion1Lte$inboundSchema),
  z.lazy(() => CreateChatCompletion1In$inboundSchema),
  z.lazy(() => CreateChatCompletion1Nin$inboundSchema),
  z.lazy(() => CreateChatCompletion1Exists$inboundSchema),
]);
/** @internal */
export type CreateChatCompletionFilterBy1$Outbound =
  | CreateChatCompletion1Eq$Outbound
  | CreateChatCompletion1Ne$Outbound
  | CreateChatCompletion1Gt$Outbound
  | CreateChatCompletion1Gte$Outbound
  | CreateChatCompletion1Lt$Outbound
  | CreateChatCompletion1Lte$Outbound
  | CreateChatCompletion1In$Outbound
  | CreateChatCompletion1Nin$Outbound
  | CreateChatCompletion1Exists$Outbound;

/** @internal */
export const CreateChatCompletionFilterBy1$outboundSchema: z.ZodType<
  CreateChatCompletionFilterBy1$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterBy1
> = z.union([
  z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
  z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
  z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
  z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
  z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
  z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
  z.lazy(() => CreateChatCompletion1In$outboundSchema),
  z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
  z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
]);

export function createChatCompletionFilterBy1ToJSON(
  createChatCompletionFilterBy1: CreateChatCompletionFilterBy1,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterBy1$outboundSchema.parse(
      createChatCompletionFilterBy1,
    ),
  );
}
export function createChatCompletionFilterBy1FromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterBy1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionFilterBy1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterBy1' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFilterBy$inboundSchema: z.ZodType<
  CreateChatCompletionFilterBy,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionFilterByAnd$inboundSchema),
  z.lazy(() => CreateChatCompletionFilterByOr$inboundSchema),
  z.record(z.union([
    z.lazy(() => CreateChatCompletion1Eq$inboundSchema),
    z.lazy(() => CreateChatCompletion1Ne$inboundSchema),
    z.lazy(() => CreateChatCompletion1Gt$inboundSchema),
    z.lazy(() => CreateChatCompletion1Gte$inboundSchema),
    z.lazy(() => CreateChatCompletion1Lt$inboundSchema),
    z.lazy(() => CreateChatCompletion1Lte$inboundSchema),
    z.lazy(() => CreateChatCompletion1In$inboundSchema),
    z.lazy(() => CreateChatCompletion1Nin$inboundSchema),
    z.lazy(() => CreateChatCompletion1Exists$inboundSchema),
  ])),
]);
/** @internal */
export type CreateChatCompletionFilterBy$Outbound =
  | CreateChatCompletionFilterByAnd$Outbound
  | CreateChatCompletionFilterByOr$Outbound
  | {
    [k: string]:
      | CreateChatCompletion1Eq$Outbound
      | CreateChatCompletion1Ne$Outbound
      | CreateChatCompletion1Gt$Outbound
      | CreateChatCompletion1Gte$Outbound
      | CreateChatCompletion1Lt$Outbound
      | CreateChatCompletion1Lte$Outbound
      | CreateChatCompletion1In$Outbound
      | CreateChatCompletion1Nin$Outbound
      | CreateChatCompletion1Exists$Outbound;
  };

/** @internal */
export const CreateChatCompletionFilterBy$outboundSchema: z.ZodType<
  CreateChatCompletionFilterBy$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionFilterBy
> = z.union([
  z.lazy(() => CreateChatCompletionFilterByAnd$outboundSchema),
  z.lazy(() => CreateChatCompletionFilterByOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
    z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
    z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
    z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
    z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
    z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
    z.lazy(() => CreateChatCompletion1In$outboundSchema),
    z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
    z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
  ])),
]);

export function createChatCompletionFilterByToJSON(
  createChatCompletionFilterBy: CreateChatCompletionFilterBy,
): string {
  return JSON.stringify(
    CreateChatCompletionFilterBy$outboundSchema.parse(
      createChatCompletionFilterBy,
    ),
  );
}
export function createChatCompletionFilterByFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionFilterBy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionFilterBy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionFilterBy' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionSearchOptions$inboundSchema: z.ZodType<
  CreateChatCompletionSearchOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_vectors: z.boolean().optional(),
  include_metadata: z.boolean().optional(),
  include_scores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_vectors": "includeVectors",
    "include_metadata": "includeMetadata",
    "include_scores": "includeScores",
  });
});
/** @internal */
export type CreateChatCompletionSearchOptions$Outbound = {
  include_vectors?: boolean | undefined;
  include_metadata?: boolean | undefined;
  include_scores?: boolean | undefined;
};

/** @internal */
export const CreateChatCompletionSearchOptions$outboundSchema: z.ZodType<
  CreateChatCompletionSearchOptions$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionSearchOptions
> = z.object({
  includeVectors: z.boolean().optional(),
  includeMetadata: z.boolean().optional(),
  includeScores: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeVectors: "include_vectors",
    includeMetadata: "include_metadata",
    includeScores: "include_scores",
  });
});

export function createChatCompletionSearchOptionsToJSON(
  createChatCompletionSearchOptions: CreateChatCompletionSearchOptions,
): string {
  return JSON.stringify(
    CreateChatCompletionSearchOptions$outboundSchema.parse(
      createChatCompletionSearchOptions,
    ),
  );
}
export function createChatCompletionSearchOptionsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionSearchOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionSearchOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionSearchOptions' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRerankConfig$inboundSchema: z.ZodType<
  CreateChatCompletionRerankConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
  threshold: z.number().default(0),
  top_k: z.number().int().default(10),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
  });
});
/** @internal */
export type CreateChatCompletionRerankConfig$Outbound = {
  model: string;
  threshold: number;
  top_k: number;
};

/** @internal */
export const CreateChatCompletionRerankConfig$outboundSchema: z.ZodType<
  CreateChatCompletionRerankConfig$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRerankConfig
> = z.object({
  model: z.string(),
  threshold: z.number().default(0),
  topK: z.number().int().default(10),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
  });
});

export function createChatCompletionRerankConfigToJSON(
  createChatCompletionRerankConfig: CreateChatCompletionRerankConfig,
): string {
  return JSON.stringify(
    CreateChatCompletionRerankConfig$outboundSchema.parse(
      createChatCompletionRerankConfig,
    ),
  );
}
export function createChatCompletionRerankConfigFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRerankConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRerankConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRerankConfig' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionAgenticRagConfig$inboundSchema: z.ZodType<
  CreateChatCompletionAgenticRagConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});
/** @internal */
export type CreateChatCompletionAgenticRagConfig$Outbound = {
  model: string;
};

/** @internal */
export const CreateChatCompletionAgenticRagConfig$outboundSchema: z.ZodType<
  CreateChatCompletionAgenticRagConfig$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionAgenticRagConfig
> = z.object({
  model: z.string(),
});

export function createChatCompletionAgenticRagConfigToJSON(
  createChatCompletionAgenticRagConfig: CreateChatCompletionAgenticRagConfig,
): string {
  return JSON.stringify(
    CreateChatCompletionAgenticRagConfig$outboundSchema.parse(
      createChatCompletionAgenticRagConfig,
    ),
  );
}
export function createChatCompletionAgenticRagConfigFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionAgenticRagConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionAgenticRagConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionAgenticRagConfig' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionKnowledgeBases$inboundSchema: z.ZodType<
  CreateChatCompletionKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  top_k: z.number().int().optional(),
  threshold: z.number().optional(),
  search_type: CreateChatCompletionSearchType$inboundSchema.default(
    "hybrid_search",
  ),
  filter_by: z.union([
    z.lazy(() => CreateChatCompletionFilterByAnd$inboundSchema),
    z.lazy(() => CreateChatCompletionFilterByOr$inboundSchema),
    z.record(
      z.union([
        z.lazy(() => CreateChatCompletion1Eq$inboundSchema),
        z.lazy(() => CreateChatCompletion1Ne$inboundSchema),
        z.lazy(() => CreateChatCompletion1Gt$inboundSchema),
        z.lazy(() => CreateChatCompletion1Gte$inboundSchema),
        z.lazy(() => CreateChatCompletion1Lt$inboundSchema),
        z.lazy(() => CreateChatCompletion1Lte$inboundSchema),
        z.lazy(() => CreateChatCompletion1In$inboundSchema),
        z.lazy(() => CreateChatCompletion1Nin$inboundSchema),
        z.lazy(() => CreateChatCompletion1Exists$inboundSchema),
      ]),
    ),
  ]).optional(),
  search_options: z.lazy(() => CreateChatCompletionSearchOptions$inboundSchema)
    .optional(),
  rerank_config: z.lazy(() => CreateChatCompletionRerankConfig$inboundSchema)
    .optional(),
  agentic_rag_config: z.lazy(() =>
    CreateChatCompletionAgenticRagConfig$inboundSchema
  ).optional(),
  knowledge_id: z.string(),
  query: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "top_k": "topK",
    "search_type": "searchType",
    "filter_by": "filterBy",
    "search_options": "searchOptions",
    "rerank_config": "rerankConfig",
    "agentic_rag_config": "agenticRagConfig",
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type CreateChatCompletionKnowledgeBases$Outbound = {
  top_k?: number | undefined;
  threshold?: number | undefined;
  search_type: string;
  filter_by?:
    | CreateChatCompletionFilterByAnd$Outbound
    | CreateChatCompletionFilterByOr$Outbound
    | {
      [k: string]:
        | CreateChatCompletion1Eq$Outbound
        | CreateChatCompletion1Ne$Outbound
        | CreateChatCompletion1Gt$Outbound
        | CreateChatCompletion1Gte$Outbound
        | CreateChatCompletion1Lt$Outbound
        | CreateChatCompletion1Lte$Outbound
        | CreateChatCompletion1In$Outbound
        | CreateChatCompletion1Nin$Outbound
        | CreateChatCompletion1Exists$Outbound;
    }
    | undefined;
  search_options?: CreateChatCompletionSearchOptions$Outbound | undefined;
  rerank_config?: CreateChatCompletionRerankConfig$Outbound | undefined;
  agentic_rag_config?:
    | CreateChatCompletionAgenticRagConfig$Outbound
    | undefined;
  knowledge_id: string;
  query?: string | undefined;
};

/** @internal */
export const CreateChatCompletionKnowledgeBases$outboundSchema: z.ZodType<
  CreateChatCompletionKnowledgeBases$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionKnowledgeBases
> = z.object({
  topK: z.number().int().optional(),
  threshold: z.number().optional(),
  searchType: CreateChatCompletionSearchType$outboundSchema.default(
    "hybrid_search",
  ),
  filterBy: z.union([
    z.lazy(() => CreateChatCompletionFilterByAnd$outboundSchema),
    z.lazy(() => CreateChatCompletionFilterByOr$outboundSchema),
    z.record(
      z.union([
        z.lazy(() => CreateChatCompletion1Eq$outboundSchema),
        z.lazy(() => CreateChatCompletion1Ne$outboundSchema),
        z.lazy(() => CreateChatCompletion1Gt$outboundSchema),
        z.lazy(() => CreateChatCompletion1Gte$outboundSchema),
        z.lazy(() => CreateChatCompletion1Lt$outboundSchema),
        z.lazy(() => CreateChatCompletion1Lte$outboundSchema),
        z.lazy(() => CreateChatCompletion1In$outboundSchema),
        z.lazy(() => CreateChatCompletion1Nin$outboundSchema),
        z.lazy(() => CreateChatCompletion1Exists$outboundSchema),
      ]),
    ),
  ]).optional(),
  searchOptions: z.lazy(() => CreateChatCompletionSearchOptions$outboundSchema)
    .optional(),
  rerankConfig: z.lazy(() => CreateChatCompletionRerankConfig$outboundSchema)
    .optional(),
  agenticRagConfig: z.lazy(() =>
    CreateChatCompletionAgenticRagConfig$outboundSchema
  ).optional(),
  knowledgeId: z.string(),
  query: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    topK: "top_k",
    searchType: "search_type",
    filterBy: "filter_by",
    searchOptions: "search_options",
    rerankConfig: "rerank_config",
    agenticRagConfig: "agentic_rag_config",
    knowledgeId: "knowledge_id",
  });
});

export function createChatCompletionKnowledgeBasesToJSON(
  createChatCompletionKnowledgeBases: CreateChatCompletionKnowledgeBases,
): string {
  return JSON.stringify(
    CreateChatCompletionKnowledgeBases$outboundSchema.parse(
      createChatCompletionKnowledgeBases,
    ),
  );
}
export function createChatCompletionKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const LoadBalancerType$inboundSchema: z.ZodNativeEnum<
  typeof LoadBalancerType
> = z.nativeEnum(LoadBalancerType);
/** @internal */
export const LoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof LoadBalancerType
> = LoadBalancerType$inboundSchema;

/** @internal */
export const LoadBalancer1$inboundSchema: z.ZodType<
  LoadBalancer1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: LoadBalancerType$inboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});
/** @internal */
export type LoadBalancer1$Outbound = {
  type: string;
  model: string;
  weight: number;
};

/** @internal */
export const LoadBalancer1$outboundSchema: z.ZodType<
  LoadBalancer1$Outbound,
  z.ZodTypeDef,
  LoadBalancer1
> = z.object({
  type: LoadBalancerType$outboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function loadBalancer1ToJSON(loadBalancer1: LoadBalancer1): string {
  return JSON.stringify(LoadBalancer1$outboundSchema.parse(loadBalancer1));
}
export function loadBalancer1FromJSON(
  jsonString: string,
): SafeParseResult<LoadBalancer1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LoadBalancer1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LoadBalancer1' from JSON`,
  );
}

/** @internal */
export const LoadBalancer$inboundSchema: z.ZodType<
  LoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => LoadBalancer1$inboundSchema);
/** @internal */
export type LoadBalancer$Outbound = LoadBalancer1$Outbound;

/** @internal */
export const LoadBalancer$outboundSchema: z.ZodType<
  LoadBalancer$Outbound,
  z.ZodTypeDef,
  LoadBalancer
> = z.lazy(() => LoadBalancer1$outboundSchema);

export function loadBalancerToJSON(loadBalancer: LoadBalancer): string {
  return JSON.stringify(LoadBalancer$outboundSchema.parse(loadBalancer));
}
export function loadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<LoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => LoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'LoadBalancer' from JSON`,
  );
}

/** @internal */
export const Timeout$inboundSchema: z.ZodType<Timeout, z.ZodTypeDef, unknown> =
  z.object({
    call_timeout: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "call_timeout": "callTimeout",
    });
  });
/** @internal */
export type Timeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const Timeout$outboundSchema: z.ZodType<
  Timeout$Outbound,
  z.ZodTypeDef,
  Timeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function timeoutToJSON(timeout: Timeout): string {
  return JSON.stringify(Timeout$outboundSchema.parse(timeout));
}
export function timeoutFromJSON(
  jsonString: string,
): SafeParseResult<Timeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Timeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Timeout' from JSON`,
  );
}

/** @internal */
export const Orq$inboundSchema: z.ZodType<Orq, z.ZodTypeDef, unknown> = z
  .object({
    name: z.string().optional(),
    retry: z.lazy(() => CreateChatCompletionRetry$inboundSchema).optional(),
    fallbacks: z.array(z.lazy(() => Fallbacks$inboundSchema)).optional(),
    prompt: z.lazy(() => Prompt$inboundSchema).optional(),
    identity: components.PublicContact$inboundSchema.optional(),
    contact: z.lazy(() => CreateChatCompletionContact$inboundSchema).optional(),
    thread: z.lazy(() => CreateChatCompletionThread$inboundSchema).optional(),
    inputs: z.union([
      z.record(z.any()),
      z.array(z.lazy(() => Inputs2$inboundSchema)),
    ]).optional(),
    cache: z.lazy(() => Cache$inboundSchema).optional(),
    knowledge_bases: z.array(
      z.lazy(() => CreateChatCompletionKnowledgeBases$inboundSchema),
    ).optional(),
    load_balancer: z.array(z.lazy(() => LoadBalancer1$inboundSchema))
      .optional(),
    timeout: z.lazy(() => Timeout$inboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      "knowledge_bases": "knowledgeBases",
      "load_balancer": "loadBalancer",
    });
  });
/** @internal */
export type Orq$Outbound = {
  name?: string | undefined;
  retry?: CreateChatCompletionRetry$Outbound | undefined;
  fallbacks?: Array<Fallbacks$Outbound> | undefined;
  prompt?: Prompt$Outbound | undefined;
  identity?: components.PublicContact$Outbound | undefined;
  contact?: CreateChatCompletionContact$Outbound | undefined;
  thread?: CreateChatCompletionThread$Outbound | undefined;
  inputs?: { [k: string]: any } | Array<Inputs2$Outbound> | undefined;
  cache?: Cache$Outbound | undefined;
  knowledge_bases?:
    | Array<CreateChatCompletionKnowledgeBases$Outbound>
    | undefined;
  load_balancer?: Array<LoadBalancer1$Outbound> | undefined;
  timeout?: Timeout$Outbound | undefined;
};

/** @internal */
export const Orq$outboundSchema: z.ZodType<Orq$Outbound, z.ZodTypeDef, Orq> = z
  .object({
    name: z.string().optional(),
    retry: z.lazy(() => CreateChatCompletionRetry$outboundSchema).optional(),
    fallbacks: z.array(z.lazy(() => Fallbacks$outboundSchema)).optional(),
    prompt: z.lazy(() => Prompt$outboundSchema).optional(),
    identity: components.PublicContact$outboundSchema.optional(),
    contact: z.lazy(() => CreateChatCompletionContact$outboundSchema)
      .optional(),
    thread: z.lazy(() => CreateChatCompletionThread$outboundSchema).optional(),
    inputs: z.union([
      z.record(z.any()),
      z.array(z.lazy(() => Inputs2$outboundSchema)),
    ]).optional(),
    cache: z.lazy(() => Cache$outboundSchema).optional(),
    knowledgeBases: z.array(
      z.lazy(() => CreateChatCompletionKnowledgeBases$outboundSchema),
    ).optional(),
    loadBalancer: z.array(z.lazy(() => LoadBalancer1$outboundSchema))
      .optional(),
    timeout: z.lazy(() => Timeout$outboundSchema).optional(),
  }).transform((v) => {
    return remap$(v, {
      knowledgeBases: "knowledge_bases",
      loadBalancer: "load_balancer",
    });
  });

export function orqToJSON(orq: Orq): string {
  return JSON.stringify(Orq$outboundSchema.parse(orq));
}
export function orqFromJSON(
  jsonString: string,
): SafeParseResult<Orq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Orq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Orq' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRequestBody$inboundSchema: z.ZodType<
  CreateChatCompletionRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => CreateChatCompletionMessagesSystemMessage$inboundSchema),
      z.lazy(() => CreateChatCompletionMessagesDeveloperMessage$inboundSchema),
      z.lazy(() => CreateChatCompletionMessagesUserMessage$inboundSchema),
      z.lazy(() => CreateChatCompletionMessagesAssistantMessage$inboundSchema),
      z.lazy(() => CreateChatCompletionMessagesToolMessage$inboundSchema),
    ]),
  ),
  model: z.string(),
  metadata: z.record(z.string()).optional(),
  audio: z.nullable(z.lazy(() => CreateChatCompletionAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => CreateChatCompletionResponseFormatText$inboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONObject$inboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$inboundSchema),
  ]).optional(),
  reasoning_effort: CreateChatCompletionReasoningEffort$inboundSchema
    .optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => CreateChatCompletionStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tools: z.array(z.lazy(() => CreateChatCompletionTools$inboundSchema))
    .optional(),
  tool_choice: z.union([
    z.lazy(() => CreateChatCompletionToolChoice2$inboundSchema),
    CreateChatCompletionToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateChatCompletionModalities$inboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => CreateChatCompletionGuardrails$inboundSchema),
  ).optional(),
  orq: z.lazy(() => Orq$inboundSchema).optional(),
  stream: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type CreateChatCompletionRequestBody$Outbound = {
  messages: Array<
    | CreateChatCompletionMessagesSystemMessage$Outbound
    | CreateChatCompletionMessagesDeveloperMessage$Outbound
    | CreateChatCompletionMessagesUserMessage$Outbound
    | CreateChatCompletionMessagesAssistantMessage$Outbound
    | CreateChatCompletionMessagesToolMessage$Outbound
  >;
  model: string;
  metadata?: { [k: string]: string } | undefined;
  audio?: CreateChatCompletionAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | CreateChatCompletionResponseFormatText$Outbound
    | CreateChatCompletionResponseFormatJSONObject$Outbound
    | CreateChatCompletionResponseFormatJSONSchema$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | CreateChatCompletionStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema$Outbound
    | components.ThinkingConfigEnabledSchema$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tools?: Array<CreateChatCompletionTools$Outbound> | undefined;
  tool_choice?: CreateChatCompletionToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
  guardrails?: Array<CreateChatCompletionGuardrails$Outbound> | undefined;
  orq?: Orq$Outbound | undefined;
  stream: boolean;
};

/** @internal */
export const CreateChatCompletionRequestBody$outboundSchema: z.ZodType<
  CreateChatCompletionRequestBody$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRequestBody
> = z.object({
  messages: z.array(
    z.union([
      z.lazy(() => CreateChatCompletionMessagesSystemMessage$outboundSchema),
      z.lazy(() =>
        CreateChatCompletionMessagesDeveloperMessage$outboundSchema
      ),
      z.lazy(() => CreateChatCompletionMessagesUserMessage$outboundSchema),
      z.lazy(() => CreateChatCompletionMessagesAssistantMessage$outboundSchema),
      z.lazy(() => CreateChatCompletionMessagesToolMessage$outboundSchema),
    ]),
  ),
  model: z.string(),
  metadata: z.record(z.string()).optional(),
  audio: z.nullable(z.lazy(() => CreateChatCompletionAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => CreateChatCompletionResponseFormatText$outboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONObject$outboundSchema),
    z.lazy(() => CreateChatCompletionResponseFormatJSONSchema$outboundSchema),
  ]).optional(),
  reasoningEffort: CreateChatCompletionReasoningEffort$outboundSchema
    .optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => CreateChatCompletionStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$outboundSchema,
    components.ThinkingConfigEnabledSchema$outboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  tools: z.array(z.lazy(() => CreateChatCompletionTools$outboundSchema))
    .optional(),
  toolChoice: z.union([
    z.lazy(() => CreateChatCompletionToolChoice2$outboundSchema),
    CreateChatCompletionToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(CreateChatCompletionModalities$outboundSchema))
    .optional(),
  guardrails: z.array(
    z.lazy(() => CreateChatCompletionGuardrails$outboundSchema),
  ).optional(),
  orq: z.lazy(() => Orq$outboundSchema).optional(),
  stream: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function createChatCompletionRequestBodyToJSON(
  createChatCompletionRequestBody: CreateChatCompletionRequestBody,
): string {
  return JSON.stringify(
    CreateChatCompletionRequestBody$outboundSchema.parse(
      createChatCompletionRequestBody,
    ),
  );
}
export function createChatCompletionRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionFinishReason$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFinishReason
> = z.nativeEnum(CreateChatCompletionFinishReason);
/** @internal */
export const CreateChatCompletionFinishReason$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionFinishReason
> = CreateChatCompletionFinishReason$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterTopLogprobs$inboundSchema: z.ZodType<
  CreateChatCompletionRouterTopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type CreateChatCompletionRouterTopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const CreateChatCompletionRouterTopLogprobs$outboundSchema: z.ZodType<
  CreateChatCompletionRouterTopLogprobs$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterTopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function createChatCompletionRouterTopLogprobsToJSON(
  createChatCompletionRouterTopLogprobs: CreateChatCompletionRouterTopLogprobs,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterTopLogprobs$outboundSchema.parse(
      createChatCompletionRouterTopLogprobs,
    ),
  );
}
export function createChatCompletionRouterTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterTopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterTopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterTopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterContent$inboundSchema: z.ZodType<
  CreateChatCompletionRouterContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(
    z.lazy(() => CreateChatCompletionRouterTopLogprobs$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});
/** @internal */
export type CreateChatCompletionRouterContent$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<CreateChatCompletionRouterTopLogprobs$Outbound>;
};

/** @internal */
export const CreateChatCompletionRouterContent$outboundSchema: z.ZodType<
  CreateChatCompletionRouterContent$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterContent
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(
    z.lazy(() => CreateChatCompletionRouterTopLogprobs$outboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function createChatCompletionRouterContentToJSON(
  createChatCompletionRouterContent: CreateChatCompletionRouterContent,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterContent$outboundSchema.parse(
      createChatCompletionRouterContent,
    ),
  );
}
export function createChatCompletionRouterContentFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRouterContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterResponseTopLogprobs$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterResponseTopLogprobs,
    z.ZodTypeDef,
    unknown
  > = z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
  });
/** @internal */
export type CreateChatCompletionRouterResponseTopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const CreateChatCompletionRouterResponseTopLogprobs$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterResponseTopLogprobs$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterResponseTopLogprobs
  > = z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
  });

export function createChatCompletionRouterResponseTopLogprobsToJSON(
  createChatCompletionRouterResponseTopLogprobs:
    CreateChatCompletionRouterResponseTopLogprobs,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterResponseTopLogprobs$outboundSchema.parse(
      createChatCompletionRouterResponseTopLogprobs,
    ),
  );
}
export function createChatCompletionRouterResponseTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterResponseTopLogprobs,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterResponseTopLogprobs$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterResponseTopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRefusal$inboundSchema: z.ZodType<
  CreateChatCompletionRefusal,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(
    z.lazy(() => CreateChatCompletionRouterResponseTopLogprobs$inboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});
/** @internal */
export type CreateChatCompletionRefusal$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<CreateChatCompletionRouterResponseTopLogprobs$Outbound>;
};

/** @internal */
export const CreateChatCompletionRefusal$outboundSchema: z.ZodType<
  CreateChatCompletionRefusal$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRefusal
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(
    z.lazy(() => CreateChatCompletionRouterResponseTopLogprobs$outboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function createChatCompletionRefusalToJSON(
  createChatCompletionRefusal: CreateChatCompletionRefusal,
): string {
  return JSON.stringify(
    CreateChatCompletionRefusal$outboundSchema.parse(
      createChatCompletionRefusal,
    ),
  );
}
export function createChatCompletionRefusalFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRefusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRefusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRefusal' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionLogprobs$inboundSchema: z.ZodType<
  CreateChatCompletionLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionRouterContent$inboundSchema)),
  ),
  refusal: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionRefusal$inboundSchema)),
  ),
});
/** @internal */
export type CreateChatCompletionLogprobs$Outbound = {
  content: Array<CreateChatCompletionRouterContent$Outbound> | null;
  refusal: Array<CreateChatCompletionRefusal$Outbound> | null;
};

/** @internal */
export const CreateChatCompletionLogprobs$outboundSchema: z.ZodType<
  CreateChatCompletionLogprobs$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionLogprobs
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionRouterContent$outboundSchema)),
  ),
  refusal: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionRefusal$outboundSchema)),
  ),
});

export function createChatCompletionLogprobsToJSON(
  createChatCompletionLogprobs: CreateChatCompletionLogprobs,
): string {
  return JSON.stringify(
    CreateChatCompletionLogprobs$outboundSchema.parse(
      createChatCompletionLogprobs,
    ),
  );
}
export function createChatCompletionLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterResponse200Type> = z
    .nativeEnum(CreateChatCompletionRouterResponse200Type);
/** @internal */
export const CreateChatCompletionRouterResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterResponse200Type> =
    CreateChatCompletionRouterResponse200Type$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterResponseFunction$inboundSchema:
  z.ZodType<CreateChatCompletionRouterResponseFunction, z.ZodTypeDef, unknown> =
    z.object({
      name: z.string().optional(),
      arguments: z.string().optional(),
    });
/** @internal */
export type CreateChatCompletionRouterResponseFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const CreateChatCompletionRouterResponseFunction$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterResponseFunction$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterResponseFunction
  > = z.object({
    name: z.string().optional(),
    arguments: z.string().optional(),
  });

export function createChatCompletionRouterResponseFunctionToJSON(
  createChatCompletionRouterResponseFunction:
    CreateChatCompletionRouterResponseFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterResponseFunction$outboundSchema.parse(
      createChatCompletionRouterResponseFunction,
    ),
  );
}
export function createChatCompletionRouterResponseFunctionFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterResponseFunction,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterResponseFunction$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterResponseFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterToolCalls$inboundSchema: z.ZodType<
  CreateChatCompletionRouterToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number().optional(),
  id: z.string().optional(),
  type: CreateChatCompletionRouterResponse200Type$inboundSchema.optional(),
  function: z.lazy(() =>
    CreateChatCompletionRouterResponseFunction$inboundSchema
  ).optional(),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type CreateChatCompletionRouterToolCalls$Outbound = {
  index?: number | undefined;
  id?: string | undefined;
  type?: string | undefined;
  function?: CreateChatCompletionRouterResponseFunction$Outbound | undefined;
  thought_signature?: string | undefined;
};

/** @internal */
export const CreateChatCompletionRouterToolCalls$outboundSchema: z.ZodType<
  CreateChatCompletionRouterToolCalls$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterToolCalls
> = z.object({
  index: z.number().optional(),
  id: z.string().optional(),
  type: CreateChatCompletionRouterResponse200Type$outboundSchema.optional(),
  function: z.lazy(() =>
    CreateChatCompletionRouterResponseFunction$outboundSchema
  ).optional(),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function createChatCompletionRouterToolCallsToJSON(
  createChatCompletionRouterToolCalls: CreateChatCompletionRouterToolCalls,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterToolCalls$outboundSchema.parse(
      createChatCompletionRouterToolCalls,
    ),
  );
}
export function createChatCompletionRouterToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterRole$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterRole
> = z.nativeEnum(CreateChatCompletionRouterRole);
/** @internal */
export const CreateChatCompletionRouterRole$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterRole
> = CreateChatCompletionRouterRole$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterResponseAudio$inboundSchema: z.ZodType<
  CreateChatCompletionRouterResponseAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  transcript: z.string().optional(),
  data: z.string().optional(),
  expires_at: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    "expires_at": "expiresAt",
  });
});
/** @internal */
export type CreateChatCompletionRouterResponseAudio$Outbound = {
  id?: string | undefined;
  transcript?: string | undefined;
  data?: string | undefined;
  expires_at?: number | undefined;
};

/** @internal */
export const CreateChatCompletionRouterResponseAudio$outboundSchema: z.ZodType<
  CreateChatCompletionRouterResponseAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterResponseAudio
> = z.object({
  id: z.string().optional(),
  transcript: z.string().optional(),
  data: z.string().optional(),
  expiresAt: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    expiresAt: "expires_at",
  });
});

export function createChatCompletionRouterResponseAudioToJSON(
  createChatCompletionRouterResponseAudio:
    CreateChatCompletionRouterResponseAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterResponseAudio$outboundSchema.parse(
      createChatCompletionRouterResponseAudio,
    ),
  );
}
export function createChatCompletionRouterResponseAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterResponseAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterResponseAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterResponseAudio' from JSON`,
  );
}

/** @internal */
export const Delta$inboundSchema: z.ZodType<Delta, z.ZodTypeDef, unknown> = z
  .object({
    content: z.nullable(z.string()).optional(),
    refusal: z.nullable(z.string()).optional(),
    tool_calls: z.array(
      z.lazy(() => CreateChatCompletionRouterToolCalls$inboundSchema),
    ).optional(),
    role: CreateChatCompletionRouterRole$inboundSchema.optional(),
    reasoning: z.string().optional(),
    reasoning_signature: z.string().optional(),
    redacted_reasoning: z.string().optional(),
    audio: z.nullable(
      z.lazy(() => CreateChatCompletionRouterResponseAudio$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "tool_calls": "toolCalls",
      "reasoning_signature": "reasoningSignature",
      "redacted_reasoning": "redactedReasoning",
    });
  });
/** @internal */
export type Delta$Outbound = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  tool_calls?: Array<CreateChatCompletionRouterToolCalls$Outbound> | undefined;
  role?: string | undefined;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
  audio?: CreateChatCompletionRouterResponseAudio$Outbound | null | undefined;
};

/** @internal */
export const Delta$outboundSchema: z.ZodType<
  Delta$Outbound,
  z.ZodTypeDef,
  Delta
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  toolCalls: z.array(
    z.lazy(() => CreateChatCompletionRouterToolCalls$outboundSchema),
  ).optional(),
  role: CreateChatCompletionRouterRole$outboundSchema.optional(),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
  audio: z.nullable(
    z.lazy(() => CreateChatCompletionRouterResponseAudio$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function deltaToJSON(delta: Delta): string {
  return JSON.stringify(Delta$outboundSchema.parse(delta));
}
export function deltaFromJSON(
  jsonString: string,
): SafeParseResult<Delta, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Delta$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Delta' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterChoices$inboundSchema: z.ZodType<
  CreateChatCompletionRouterChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: z.nullable(CreateChatCompletionFinishReason$inboundSchema),
  index: z.number().default(0),
  logprobs: z.nullable(z.lazy(() => CreateChatCompletionLogprobs$inboundSchema))
    .optional(),
  delta: z.lazy(() => Delta$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});
/** @internal */
export type CreateChatCompletionRouterChoices$Outbound = {
  finish_reason: string | null;
  index: number;
  logprobs?: CreateChatCompletionLogprobs$Outbound | null | undefined;
  delta: Delta$Outbound;
};

/** @internal */
export const CreateChatCompletionRouterChoices$outboundSchema: z.ZodType<
  CreateChatCompletionRouterChoices$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterChoices
> = z.object({
  finishReason: z.nullable(CreateChatCompletionFinishReason$outboundSchema),
  index: z.number().default(0),
  logprobs: z.nullable(
    z.lazy(() => CreateChatCompletionLogprobs$outboundSchema),
  ).optional(),
  delta: z.lazy(() => Delta$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

export function createChatCompletionRouterChoicesToJSON(
  createChatCompletionRouterChoices: CreateChatCompletionRouterChoices,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterChoices$outboundSchema.parse(
      createChatCompletionRouterChoices,
    ),
  );
}
export function createChatCompletionRouterChoicesFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRouterChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterChoices' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterPromptTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterPromptTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    cached_tokens: z.nullable(z.number().int()).optional(),
    cache_creation_tokens: z.nullable(z.number().int()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "cached_tokens": "cachedTokens",
      "cache_creation_tokens": "cacheCreationTokens",
      "audio_tokens": "audioTokens",
    });
  });
/** @internal */
export type CreateChatCompletionRouterPromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  cache_creation_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CreateChatCompletionRouterPromptTokensDetails$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterPromptTokensDetails$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterPromptTokensDetails
  > = z.object({
    cachedTokens: z.nullable(z.number().int()).optional(),
    cacheCreationTokens: z.nullable(z.number().int()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      cachedTokens: "cached_tokens",
      cacheCreationTokens: "cache_creation_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function createChatCompletionRouterPromptTokensDetailsToJSON(
  createChatCompletionRouterPromptTokensDetails:
    CreateChatCompletionRouterPromptTokensDetails,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterPromptTokensDetails$outboundSchema.parse(
      createChatCompletionRouterPromptTokensDetails,
    ),
  );
}
export function createChatCompletionRouterPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterCompletionTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionRouterCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });
/** @internal */
export type CreateChatCompletionRouterCompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CreateChatCompletionRouterCompletionTokensDetails$outboundSchema:
  z.ZodType<
    CreateChatCompletionRouterCompletionTokensDetails$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionRouterCompletionTokensDetails
  > = z.object({
    reasoningTokens: z.nullable(z.number()).optional(),
    acceptedPredictionTokens: z.nullable(z.number()).optional(),
    rejectedPredictionTokens: z.nullable(z.number()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      reasoningTokens: "reasoning_tokens",
      acceptedPredictionTokens: "accepted_prediction_tokens",
      rejectedPredictionTokens: "rejected_prediction_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function createChatCompletionRouterCompletionTokensDetailsToJSON(
  createChatCompletionRouterCompletionTokensDetails:
    CreateChatCompletionRouterCompletionTokensDetails,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterCompletionTokensDetails$outboundSchema.parse(
      createChatCompletionRouterCompletionTokensDetails,
    ),
  );
}
export function createChatCompletionRouterCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionRouterCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionRouterCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterUsage$inboundSchema: z.ZodType<
  CreateChatCompletionRouterUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => CreateChatCompletionRouterPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() =>
      CreateChatCompletionRouterCompletionTokensDetails$inboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type CreateChatCompletionRouterUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?:
    | CreateChatCompletionRouterPromptTokensDetails$Outbound
    | null
    | undefined;
  completion_tokens_details?:
    | CreateChatCompletionRouterCompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const CreateChatCompletionRouterUsage$outboundSchema: z.ZodType<
  CreateChatCompletionRouterUsage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => CreateChatCompletionRouterPromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() =>
      CreateChatCompletionRouterCompletionTokensDetails$outboundSchema
    ),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function createChatCompletionRouterUsageToJSON(
  createChatCompletionRouterUsage: CreateChatCompletionRouterUsage,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterUsage$outboundSchema.parse(
      createChatCompletionRouterUsage,
    ),
  );
}
export function createChatCompletionRouterUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRouterUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterUsage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterObject
> = z.nativeEnum(CreateChatCompletionRouterObject);
/** @internal */
export const CreateChatCompletionRouterObject$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRouterObject
> = CreateChatCompletionRouterObject$inboundSchema;

/** @internal */
export const CreateChatCompletionData$inboundSchema: z.ZodType<
  CreateChatCompletionData,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(
    z.lazy(() => CreateChatCompletionRouterChoices$inboundSchema),
  ),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(z.lazy(() => CreateChatCompletionRouterUsage$inboundSchema))
    .optional(),
  object: CreateChatCompletionRouterObject$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});
/** @internal */
export type CreateChatCompletionData$Outbound = {
  id: string;
  choices: Array<CreateChatCompletionRouterChoices$Outbound>;
  created: number;
  model: string;
  system_fingerprint?: string | null | undefined;
  usage?: CreateChatCompletionRouterUsage$Outbound | null | undefined;
  object: string;
};

/** @internal */
export const CreateChatCompletionData$outboundSchema: z.ZodType<
  CreateChatCompletionData$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionData
> = z.object({
  id: z.string(),
  choices: z.array(
    z.lazy(() => CreateChatCompletionRouterChoices$outboundSchema),
  ),
  created: z.number(),
  model: z.string(),
  systemFingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(
    z.lazy(() => CreateChatCompletionRouterUsage$outboundSchema),
  ).optional(),
  object: CreateChatCompletionRouterObject$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    systemFingerprint: "system_fingerprint",
  });
});

export function createChatCompletionDataToJSON(
  createChatCompletionData: CreateChatCompletionData,
): string {
  return JSON.stringify(
    CreateChatCompletionData$outboundSchema.parse(createChatCompletionData),
  );
}
export function createChatCompletionDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionData' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRouterResponseBody$inboundSchema: z.ZodType<
  CreateChatCompletionRouterResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().optional().transform((v, ctx) => {
    if (v === undefined) return undefined;
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(z.lazy(() => CreateChatCompletionData$inboundSchema).optional()),
});
/** @internal */
export type CreateChatCompletionRouterResponseBody$Outbound = {
  data?: CreateChatCompletionData$Outbound | undefined;
};

/** @internal */
export const CreateChatCompletionRouterResponseBody$outboundSchema: z.ZodType<
  CreateChatCompletionRouterResponseBody$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterResponseBody
> = z.object({
  data: z.lazy(() => CreateChatCompletionData$outboundSchema).optional(),
});

export function createChatCompletionRouterResponseBodyToJSON(
  createChatCompletionRouterResponseBody:
    CreateChatCompletionRouterResponseBody,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterResponseBody$outboundSchema.parse(
      createChatCompletionRouterResponseBody,
    ),
  );
}
export function createChatCompletionRouterResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterResponseBody' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);
/** @internal */
export const FinishReason$outboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  FinishReason$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterResponseType$inboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterResponseType> = z.nativeEnum(
    CreateChatCompletionRouterResponseType,
  );
/** @internal */
export const CreateChatCompletionRouterResponseType$outboundSchema:
  z.ZodNativeEnum<typeof CreateChatCompletionRouterResponseType> =
    CreateChatCompletionRouterResponseType$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterFunction$inboundSchema: z.ZodType<
  CreateChatCompletionRouterFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type CreateChatCompletionRouterFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const CreateChatCompletionRouterFunction$outboundSchema: z.ZodType<
  CreateChatCompletionRouterFunction$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function createChatCompletionRouterFunctionToJSON(
  createChatCompletionRouterFunction: CreateChatCompletionRouterFunction,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterFunction$outboundSchema.parse(
      createChatCompletionRouterFunction,
    ),
  );
}
export function createChatCompletionRouterFunctionFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionRouterFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterFunction' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionToolCalls$inboundSchema: z.ZodType<
  CreateChatCompletionToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  index: z.number().optional(),
  id: z.string().optional(),
  type: CreateChatCompletionRouterResponseType$inboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionRouterFunction$inboundSchema)
    .optional(),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type CreateChatCompletionToolCalls$Outbound = {
  index?: number | undefined;
  id?: string | undefined;
  type?: string | undefined;
  function?: CreateChatCompletionRouterFunction$Outbound | undefined;
  thought_signature?: string | undefined;
};

/** @internal */
export const CreateChatCompletionToolCalls$outboundSchema: z.ZodType<
  CreateChatCompletionToolCalls$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionToolCalls
> = z.object({
  index: z.number().optional(),
  id: z.string().optional(),
  type: CreateChatCompletionRouterResponseType$outboundSchema.optional(),
  function: z.lazy(() => CreateChatCompletionRouterFunction$outboundSchema)
    .optional(),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function createChatCompletionToolCallsToJSON(
  createChatCompletionToolCalls: CreateChatCompletionToolCalls,
): string {
  return JSON.stringify(
    CreateChatCompletionToolCalls$outboundSchema.parse(
      createChatCompletionToolCalls,
    ),
  );
}
export function createChatCompletionToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionRole$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRole
> = z.nativeEnum(CreateChatCompletionRole);
/** @internal */
export const CreateChatCompletionRole$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionRole
> = CreateChatCompletionRole$inboundSchema;

/** @internal */
export const CreateChatCompletionRouterAudio$inboundSchema: z.ZodType<
  CreateChatCompletionRouterAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  expires_at: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    "expires_at": "expiresAt",
  });
});
/** @internal */
export type CreateChatCompletionRouterAudio$Outbound = {
  id: string;
  expires_at: number;
  data: string;
  transcript: string;
};

/** @internal */
export const CreateChatCompletionRouterAudio$outboundSchema: z.ZodType<
  CreateChatCompletionRouterAudio$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionRouterAudio
> = z.object({
  id: z.string(),
  expiresAt: z.number().int(),
  data: z.string(),
  transcript: z.string(),
}).transform((v) => {
  return remap$(v, {
    expiresAt: "expires_at",
  });
});

export function createChatCompletionRouterAudioToJSON(
  createChatCompletionRouterAudio: CreateChatCompletionRouterAudio,
): string {
  return JSON.stringify(
    CreateChatCompletionRouterAudio$outboundSchema.parse(
      createChatCompletionRouterAudio,
    ),
  );
}
export function createChatCompletionRouterAudioFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionRouterAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionRouterAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionRouterAudio' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionMessage$inboundSchema: z.ZodType<
  CreateChatCompletionMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  tool_calls: z.array(z.lazy(() => CreateChatCompletionToolCalls$inboundSchema))
    .optional(),
  role: CreateChatCompletionRole$inboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoning_signature: z.nullable(z.string()).optional(),
  redacted_reasoning: z.string().optional(),
  audio: z.nullable(z.lazy(() => CreateChatCompletionRouterAudio$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});
/** @internal */
export type CreateChatCompletionMessage$Outbound = {
  content?: string | null | undefined;
  refusal?: string | null | undefined;
  tool_calls?: Array<CreateChatCompletionToolCalls$Outbound> | undefined;
  role?: string | undefined;
  reasoning?: string | null | undefined;
  reasoning_signature?: string | null | undefined;
  redacted_reasoning?: string | undefined;
  audio?: CreateChatCompletionRouterAudio$Outbound | null | undefined;
};

/** @internal */
export const CreateChatCompletionMessage$outboundSchema: z.ZodType<
  CreateChatCompletionMessage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionMessage
> = z.object({
  content: z.nullable(z.string()).optional(),
  refusal: z.nullable(z.string()).optional(),
  toolCalls: z.array(z.lazy(() => CreateChatCompletionToolCalls$outboundSchema))
    .optional(),
  role: CreateChatCompletionRole$outboundSchema.optional(),
  reasoning: z.nullable(z.string()).optional(),
  reasoningSignature: z.nullable(z.string()).optional(),
  redactedReasoning: z.string().optional(),
  audio: z.nullable(
    z.lazy(() => CreateChatCompletionRouterAudio$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

export function createChatCompletionMessageToJSON(
  createChatCompletionMessage: CreateChatCompletionMessage,
): string {
  return JSON.stringify(
    CreateChatCompletionMessage$outboundSchema.parse(
      createChatCompletionMessage,
    ),
  );
}
export function createChatCompletionMessageFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionMessage' from JSON`,
  );
}

/** @internal */
export const TopLogprobs$inboundSchema: z.ZodType<
  TopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type TopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const TopLogprobs$outboundSchema: z.ZodType<
  TopLogprobs$Outbound,
  z.ZodTypeDef,
  TopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function topLogprobsToJSON(topLogprobs: TopLogprobs): string {
  return JSON.stringify(TopLogprobs$outboundSchema.parse(topLogprobs));
}
export function topLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<TopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TopLogprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionContent$inboundSchema: z.ZodType<
  CreateChatCompletionContent,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  top_logprobs: z.array(z.lazy(() => TopLogprobs$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "top_logprobs": "topLogprobs",
  });
});
/** @internal */
export type CreateChatCompletionContent$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<TopLogprobs$Outbound>;
};

/** @internal */
export const CreateChatCompletionContent$outboundSchema: z.ZodType<
  CreateChatCompletionContent$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionContent
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(z.lazy(() => TopLogprobs$outboundSchema)),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function createChatCompletionContentToJSON(
  createChatCompletionContent: CreateChatCompletionContent,
): string {
  return JSON.stringify(
    CreateChatCompletionContent$outboundSchema.parse(
      createChatCompletionContent,
    ),
  );
}
export function createChatCompletionContentFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionContent' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionTopLogprobs$inboundSchema: z.ZodType<
  CreateChatCompletionTopLogprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});
/** @internal */
export type CreateChatCompletionTopLogprobs$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
};

/** @internal */
export const CreateChatCompletionTopLogprobs$outboundSchema: z.ZodType<
  CreateChatCompletionTopLogprobs$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionTopLogprobs
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
});

export function createChatCompletionTopLogprobsToJSON(
  createChatCompletionTopLogprobs: CreateChatCompletionTopLogprobs,
): string {
  return JSON.stringify(
    CreateChatCompletionTopLogprobs$outboundSchema.parse(
      createChatCompletionTopLogprobs,
    ),
  );
}
export function createChatCompletionTopLogprobsFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionTopLogprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionTopLogprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionTopLogprobs' from JSON`,
  );
}

/** @internal */
export const Refusal$inboundSchema: z.ZodType<Refusal, z.ZodTypeDef, unknown> =
  z.object({
    token: z.string(),
    logprob: z.number(),
    bytes: z.nullable(z.array(z.number())),
    top_logprobs: z.array(
      z.lazy(() => CreateChatCompletionTopLogprobs$inboundSchema),
    ),
  }).transform((v) => {
    return remap$(v, {
      "top_logprobs": "topLogprobs",
    });
  });
/** @internal */
export type Refusal$Outbound = {
  token: string;
  logprob: number;
  bytes: Array<number> | null;
  top_logprobs: Array<CreateChatCompletionTopLogprobs$Outbound>;
};

/** @internal */
export const Refusal$outboundSchema: z.ZodType<
  Refusal$Outbound,
  z.ZodTypeDef,
  Refusal
> = z.object({
  token: z.string(),
  logprob: z.number(),
  bytes: z.nullable(z.array(z.number())),
  topLogprobs: z.array(
    z.lazy(() => CreateChatCompletionTopLogprobs$outboundSchema),
  ),
}).transform((v) => {
  return remap$(v, {
    topLogprobs: "top_logprobs",
  });
});

export function refusalToJSON(refusal: Refusal): string {
  return JSON.stringify(Refusal$outboundSchema.parse(refusal));
}
export function refusalFromJSON(
  jsonString: string,
): SafeParseResult<Refusal, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Refusal$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Refusal' from JSON`,
  );
}

/** @internal */
export const Logprobs$inboundSchema: z.ZodType<
  Logprobs,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionContent$inboundSchema)),
  ),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$inboundSchema))),
});
/** @internal */
export type Logprobs$Outbound = {
  content: Array<CreateChatCompletionContent$Outbound> | null;
  refusal: Array<Refusal$Outbound> | null;
};

/** @internal */
export const Logprobs$outboundSchema: z.ZodType<
  Logprobs$Outbound,
  z.ZodTypeDef,
  Logprobs
> = z.object({
  content: z.nullable(
    z.array(z.lazy(() => CreateChatCompletionContent$outboundSchema)),
  ),
  refusal: z.nullable(z.array(z.lazy(() => Refusal$outboundSchema))),
});

export function logprobsToJSON(logprobs: Logprobs): string {
  return JSON.stringify(Logprobs$outboundSchema.parse(logprobs));
}
export function logprobsFromJSON(
  jsonString: string,
): SafeParseResult<Logprobs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Logprobs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Logprobs' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionChoices$inboundSchema: z.ZodType<
  CreateChatCompletionChoices,
  z.ZodTypeDef,
  unknown
> = z.object({
  finish_reason: z.nullable(FinishReason$inboundSchema),
  index: z.number().default(0),
  message: z.lazy(() => CreateChatCompletionMessage$inboundSchema),
  logprobs: z.nullable(z.lazy(() => Logprobs$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "finish_reason": "finishReason",
  });
});
/** @internal */
export type CreateChatCompletionChoices$Outbound = {
  finish_reason: string | null;
  index: number;
  message: CreateChatCompletionMessage$Outbound;
  logprobs?: Logprobs$Outbound | null | undefined;
};

/** @internal */
export const CreateChatCompletionChoices$outboundSchema: z.ZodType<
  CreateChatCompletionChoices$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionChoices
> = z.object({
  finishReason: z.nullable(FinishReason$outboundSchema),
  index: z.number().default(0),
  message: z.lazy(() => CreateChatCompletionMessage$outboundSchema),
  logprobs: z.nullable(z.lazy(() => Logprobs$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    finishReason: "finish_reason",
  });
});

export function createChatCompletionChoicesToJSON(
  createChatCompletionChoices: CreateChatCompletionChoices,
): string {
  return JSON.stringify(
    CreateChatCompletionChoices$outboundSchema.parse(
      createChatCompletionChoices,
    ),
  );
}
export function createChatCompletionChoicesFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionChoices, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionChoices$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionChoices' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionPromptTokensDetails$inboundSchema: z.ZodType<
  CreateChatCompletionPromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  cache_creation_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "cache_creation_tokens": "cacheCreationTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type CreateChatCompletionPromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  cache_creation_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CreateChatCompletionPromptTokensDetails$outboundSchema: z.ZodType<
  CreateChatCompletionPromptTokensDetails$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionPromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  cacheCreationTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    cacheCreationTokens: "cache_creation_tokens",
    audioTokens: "audio_tokens",
  });
});

export function createChatCompletionPromptTokensDetailsToJSON(
  createChatCompletionPromptTokensDetails:
    CreateChatCompletionPromptTokensDetails,
): string {
  return JSON.stringify(
    CreateChatCompletionPromptTokensDetails$outboundSchema.parse(
      createChatCompletionPromptTokensDetails,
    ),
  );
}
export function createChatCompletionPromptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionPromptTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionPromptTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionPromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionCompletionTokensDetails$inboundSchema:
  z.ZodType<
    CreateChatCompletionCompletionTokensDetails,
    z.ZodTypeDef,
    unknown
  > = z.object({
    reasoning_tokens: z.nullable(z.number()).optional(),
    accepted_prediction_tokens: z.nullable(z.number()).optional(),
    rejected_prediction_tokens: z.nullable(z.number()).optional(),
    audio_tokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "reasoning_tokens": "reasoningTokens",
      "accepted_prediction_tokens": "acceptedPredictionTokens",
      "rejected_prediction_tokens": "rejectedPredictionTokens",
      "audio_tokens": "audioTokens",
    });
  });
/** @internal */
export type CreateChatCompletionCompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CreateChatCompletionCompletionTokensDetails$outboundSchema:
  z.ZodType<
    CreateChatCompletionCompletionTokensDetails$Outbound,
    z.ZodTypeDef,
    CreateChatCompletionCompletionTokensDetails
  > = z.object({
    reasoningTokens: z.nullable(z.number()).optional(),
    acceptedPredictionTokens: z.nullable(z.number()).optional(),
    rejectedPredictionTokens: z.nullable(z.number()).optional(),
    audioTokens: z.nullable(z.number().int()).optional(),
  }).transform((v) => {
    return remap$(v, {
      reasoningTokens: "reasoning_tokens",
      acceptedPredictionTokens: "accepted_prediction_tokens",
      rejectedPredictionTokens: "rejected_prediction_tokens",
      audioTokens: "audio_tokens",
    });
  });

export function createChatCompletionCompletionTokensDetailsToJSON(
  createChatCompletionCompletionTokensDetails:
    CreateChatCompletionCompletionTokensDetails,
): string {
  return JSON.stringify(
    CreateChatCompletionCompletionTokensDetails$outboundSchema.parse(
      createChatCompletionCompletionTokensDetails,
    ),
  );
}
export function createChatCompletionCompletionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<
  CreateChatCompletionCompletionTokensDetails,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      CreateChatCompletionCompletionTokensDetails$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'CreateChatCompletionCompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionUsage$inboundSchema: z.ZodType<
  CreateChatCompletionUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => CreateChatCompletionPromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CreateChatCompletionCompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type CreateChatCompletionUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?:
    | CreateChatCompletionPromptTokensDetails$Outbound
    | null
    | undefined;
  completion_tokens_details?:
    | CreateChatCompletionCompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const CreateChatCompletionUsage$outboundSchema: z.ZodType<
  CreateChatCompletionUsage$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => CreateChatCompletionPromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => CreateChatCompletionCompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function createChatCompletionUsageToJSON(
  createChatCompletionUsage: CreateChatCompletionUsage,
): string {
  return JSON.stringify(
    CreateChatCompletionUsage$outboundSchema.parse(createChatCompletionUsage),
  );
}
export function createChatCompletionUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionUsage' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionObject$inboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionObject
> = z.nativeEnum(CreateChatCompletionObject);
/** @internal */
export const CreateChatCompletionObject$outboundSchema: z.ZodNativeEnum<
  typeof CreateChatCompletionObject
> = CreateChatCompletionObject$inboundSchema;

/** @internal */
export const CreateChatCompletionResponseBody$inboundSchema: z.ZodType<
  CreateChatCompletionResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => CreateChatCompletionChoices$inboundSchema)),
  created: z.number(),
  model: z.string(),
  system_fingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(z.lazy(() => CreateChatCompletionUsage$inboundSchema))
    .optional(),
  object: CreateChatCompletionObject$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "system_fingerprint": "systemFingerprint",
  });
});
/** @internal */
export type CreateChatCompletionResponseBody$Outbound = {
  id: string;
  choices: Array<CreateChatCompletionChoices$Outbound>;
  created: number;
  model: string;
  system_fingerprint?: string | null | undefined;
  usage?: CreateChatCompletionUsage$Outbound | null | undefined;
  object: string;
};

/** @internal */
export const CreateChatCompletionResponseBody$outboundSchema: z.ZodType<
  CreateChatCompletionResponseBody$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponseBody
> = z.object({
  id: z.string(),
  choices: z.array(z.lazy(() => CreateChatCompletionChoices$outboundSchema)),
  created: z.number(),
  model: z.string(),
  systemFingerprint: z.nullable(z.string()).optional(),
  usage: z.nullable(z.lazy(() => CreateChatCompletionUsage$outboundSchema))
    .optional(),
  object: CreateChatCompletionObject$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    systemFingerprint: "system_fingerprint",
  });
});

export function createChatCompletionResponseBodyToJSON(
  createChatCompletionResponseBody: CreateChatCompletionResponseBody,
): string {
  return JSON.stringify(
    CreateChatCompletionResponseBody$outboundSchema.parse(
      createChatCompletionResponseBody,
    ),
  );
}
export function createChatCompletionResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateChatCompletionResponse$inboundSchema: z.ZodType<
  CreateChatCompletionResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => CreateChatCompletionResponseBody$inboundSchema),
  z.instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() =>
            CreateChatCompletionRouterResponseBody$inboundSchema
          ).parse(rawEvent),
        };
      });
    }),
]);
/** @internal */
export type CreateChatCompletionResponse$Outbound =
  | CreateChatCompletionResponseBody$Outbound
  | never;

/** @internal */
export const CreateChatCompletionResponse$outboundSchema: z.ZodType<
  CreateChatCompletionResponse$Outbound,
  z.ZodTypeDef,
  CreateChatCompletionResponse
> = z.union([
  z.lazy(() => CreateChatCompletionResponseBody$outboundSchema),
  z.never(),
]);

export function createChatCompletionResponseToJSON(
  createChatCompletionResponse: CreateChatCompletionResponse,
): string {
  return JSON.stringify(
    CreateChatCompletionResponse$outboundSchema.parse(
      createChatCompletionResponse,
    ),
  );
}
export function createChatCompletionResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateChatCompletionResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChatCompletionResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChatCompletionResponse' from JSON`,
  );
}
