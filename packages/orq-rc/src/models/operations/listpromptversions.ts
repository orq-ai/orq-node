/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type ListPromptVersionsRequest = {
  promptId: string;
  /**
   * A limit on the number of objects to be returned. Limit can range between 1 and 50, and the default is 10
   */
  limit?: number | undefined;
  /**
   * A cursor for use in pagination. `starting_after` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, ending with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `after=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the next page of the list.
   */
  startingAfter?: string | undefined;
  /**
   * A cursor for use in pagination. `ending_before` is an object ID that defines your place in the list. For instance, if you make a list request and receive 20 objects, starting with `01JJ1HDHN79XAS7A01WB3HYSDB`, your subsequent call can include `before=01JJ1HDHN79XAS7A01WB3HYSDB` in order to fetch the previous page of the list.
   */
  endingBefore?: string | undefined;
};

export const ListPromptVersionsObject = {
  List: "list",
} as const;
export type ListPromptVersionsObject = ClosedEnum<
  typeof ListPromptVersionsObject
>;

/**
 * The modality of the model
 */
export const ListPromptVersionsModelType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Ocr: "ocr",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The modality of the model
 */
export type ListPromptVersionsModelType = ClosedEnum<
  typeof ListPromptVersionsModelType
>;

/**
 * Only supported on `image` models.
 */
export const ListPromptVersionsFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type ListPromptVersionsFormat = ClosedEnum<
  typeof ListPromptVersionsFormat
>;

export const ListPromptVersionsResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type ListPromptVersionsResponseFormat6 = ClosedEnum<
  typeof ListPromptVersionsResponseFormat6
>;

export const ListPromptVersionsResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type ListPromptVersionsResponseFormat5 = ClosedEnum<
  typeof ListPromptVersionsResponseFormat5
>;

export const ListPromptVersionsResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type ListPromptVersionsResponseFormat4 = ClosedEnum<
  typeof ListPromptVersionsResponseFormat4
>;

export const ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  {
    Text: "text",
  } as const;
export type ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  >;

export type ListPromptVersionsResponseFormat3 = {
  type:
    ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType;
};

export const ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType =
  {
    JsonObject: "json_object",
  } as const;
export type ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType
  >;

export type ListPromptVersionsResponseFormat2 = {
  type: ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType;
};

export const ListPromptVersionsResponseFormatPromptsResponse200Type = {
  JsonSchema: "json_schema",
} as const;
export type ListPromptVersionsResponseFormatPromptsResponse200Type = ClosedEnum<
  typeof ListPromptVersionsResponseFormatPromptsResponse200Type
>;

export type ListPromptVersionsResponseFormatPromptsResponseJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type ListPromptVersionsResponseFormat1 = {
  type: ListPromptVersionsResponseFormatPromptsResponse200Type;
  displayName?: string | undefined;
  jsonSchema: ListPromptVersionsResponseFormatPromptsResponseJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type ListPromptVersionsPromptsResponseFormat =
  | ListPromptVersionsResponseFormat1
  | ListPromptVersionsResponseFormat2
  | ListPromptVersionsResponseFormat3
  | ListPromptVersionsResponseFormat4
  | ListPromptVersionsResponseFormat5
  | ListPromptVersionsResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const ListPromptVersionsPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type ListPromptVersionsPhotoRealVersion = ClosedEnum<
  typeof ListPromptVersionsPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const ListPromptVersionsEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type ListPromptVersionsEncodingFormat = ClosedEnum<
  typeof ListPromptVersionsEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const ListPromptVersionsPromptsReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type ListPromptVersionsPromptsReasoningEffort = ClosedEnum<
  typeof ListPromptVersionsPromptsReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const ListPromptVersionsVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type ListPromptVersionsVerbosity = ClosedEnum<
  typeof ListPromptVersionsVerbosity
>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const ListPromptVersionsThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type ListPromptVersionsThinkingLevel = ClosedEnum<
  typeof ListPromptVersionsThinkingLevel
>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type ListPromptVersionsModelParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: ListPromptVersionsFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | ListPromptVersionsResponseFormat1
    | ListPromptVersionsResponseFormat2
    | ListPromptVersionsResponseFormat3
    | ListPromptVersionsResponseFormat4
    | ListPromptVersionsResponseFormat5
    | ListPromptVersionsResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: ListPromptVersionsPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: ListPromptVersionsEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: ListPromptVersionsPromptsReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: ListPromptVersionsVerbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: ListPromptVersionsThinkingLevel | undefined;
};

export const ListPromptVersionsProvider = {
  Openai: "openai",
  Groq: "groq",
  Cohere: "cohere",
  Azure: "azure",
  Aws: "aws",
  Google: "google",
  GoogleAi: "google-ai",
  Huggingface: "huggingface",
  Togetherai: "togetherai",
  Perplexity: "perplexity",
  Anthropic: "anthropic",
  Leonardoai: "leonardoai",
  Fal: "fal",
  Nvidia: "nvidia",
  Jina: "jina",
  Elevenlabs: "elevenlabs",
  Litellm: "litellm",
  Cerebras: "cerebras",
  Openailike: "openailike",
  Bytedance: "bytedance",
  Mistral: "mistral",
  Deepseek: "deepseek",
  Contextualai: "contextualai",
  Moonshotai: "moonshotai",
  Zai: "zai",
  Slack: "slack",
} as const;
export type ListPromptVersionsProvider = ClosedEnum<
  typeof ListPromptVersionsProvider
>;

/**
 * The role of the prompt message
 */
export const ListPromptVersionsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type ListPromptVersionsRole = ClosedEnum<typeof ListPromptVersionsRole>;

export type ListPromptVersions2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type ListPromptVersions23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: ListPromptVersions2File;
};

export type ListPromptVersions2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type ListPromptVersions22 = {
  type: "image_url";
  imageUrl: ListPromptVersions2ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type ListPromptVersions21 = {
  type: "text";
  text: string;
};

export type ListPromptVersionsContent2 =
  | ListPromptVersions21
  | ListPromptVersions22
  | ListPromptVersions23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type ListPromptVersionsContent =
  | string
  | Array<ListPromptVersions21 | ListPromptVersions22 | ListPromptVersions23>;

export const ListPromptVersionsPromptsType = {
  Function: "function",
} as const;
export type ListPromptVersionsPromptsType = ClosedEnum<
  typeof ListPromptVersionsPromptsType
>;

export type ListPromptVersionsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type ListPromptVersionsToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: ListPromptVersionsPromptsType;
  function: ListPromptVersionsFunction;
};

export type ListPromptVersionsMessages = {
  /**
   * The role of the prompt message
   */
  role: ListPromptVersionsRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<ListPromptVersions21 | ListPromptVersions22 | ListPromptVersions23>
    | null;
  toolCalls?: Array<ListPromptVersionsToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type ListPromptVersionsPromptConfig = {
  stream?: boolean | undefined;
  model?: string | null | undefined;
  /**
   * The id of the resource
   */
  modelDbId?: string | null | undefined;
  /**
   * The modality of the model
   */
  modelType?: ListPromptVersionsModelType | null | undefined;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  modelParameters?: ListPromptVersionsModelParameters | undefined;
  provider?: ListPromptVersionsProvider | null | undefined;
  /**
   * The ID of the integration to use
   */
  integrationId?: string | null | undefined;
  version?: string | undefined;
  messages: Array<ListPromptVersionsMessages>;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const ListPromptVersionsVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type ListPromptVersionsVoice = ClosedEnum<
  typeof ListPromptVersionsVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const ListPromptVersionsPromptsFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type ListPromptVersionsPromptsFormat = ClosedEnum<
  typeof ListPromptVersionsPromptsFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type ListPromptVersionsAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: ListPromptVersionsVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: ListPromptVersionsPromptsFormat;
};

export type ListPromptVersionsResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict: boolean;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type ListPromptVersionsResponseFormatPromptsJSONSchema = {
  type: "json_schema";
  jsonSchema: ListPromptVersionsResponseFormatJsonSchema;
};

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type ListPromptVersionsResponseFormatJSONObject = {
  type: "json_object";
};

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type ListPromptVersionsResponseFormatText = {
  type: "text";
};

/**
 * An object specifying the format that the model must output
 */
export type ListPromptVersionsResponseFormat =
  | ListPromptVersionsResponseFormatText
  | ListPromptVersionsResponseFormatJSONObject
  | ListPromptVersionsResponseFormatPromptsJSONSchema;

/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export const ListPromptVersionsReasoningEffort = {
  None: "none",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
  Xhigh: "xhigh",
} as const;
/**
 * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 *
 * @remarks
 *
 * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
 * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
 * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
 * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
 *
 * Any of "none", "minimal", "low", "medium", "high", "xhigh".
 */
export type ListPromptVersionsReasoningEffort = ClosedEnum<
  typeof ListPromptVersionsReasoningEffort
>;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type ListPromptVersionsStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type ListPromptVersionsStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

export type ListPromptVersionsThinking =
  | components.ThinkingConfigDisabledSchema
  | components.ThinkingConfigEnabledSchema;

/**
 * The type of the tool. Currently, only function is supported.
 */
export const ListPromptVersionsToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type ListPromptVersionsToolChoiceType = ClosedEnum<
  typeof ListPromptVersionsToolChoiceType
>;

export type ListPromptVersionsToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name: string;
};

export type ListPromptVersionsToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: ListPromptVersionsToolChoiceType | undefined;
  function: ListPromptVersionsToolChoiceFunction;
};

export const ListPromptVersionsToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type ListPromptVersionsToolChoice1 = ClosedEnum<
  typeof ListPromptVersionsToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type ListPromptVersionsToolChoice =
  | ListPromptVersionsToolChoice2
  | ListPromptVersionsToolChoice1;

export const ListPromptVersionsModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type ListPromptVersionsModalities = ClosedEnum<
  typeof ListPromptVersionsModalities
>;

/**
 * The key of the guardrail.
 */
export const ListPromptVersionsId1 = {
  OrqPiiDetection: "orq_pii_detection",
  OrqSexualModeration: "orq_sexual_moderation",
  OrqHarmfulModeration: "orq_harmful_moderation",
} as const;
/**
 * The key of the guardrail.
 */
export type ListPromptVersionsId1 = ClosedEnum<typeof ListPromptVersionsId1>;

export type ListPromptVersionsId = ListPromptVersionsId1 | string;

/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export const ListPromptVersionsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the guardrail runs on the input (user message) or output (model response).
 */
export type ListPromptVersionsExecuteOn = ClosedEnum<
  typeof ListPromptVersionsExecuteOn
>;

export type ListPromptVersionsGuardrails = {
  id: ListPromptVersionsId1 | string;
  /**
   * Determines whether the guardrail runs on the input (user message) or output (model response).
   */
  executeOn: ListPromptVersionsExecuteOn;
};

export type ListPromptVersionsFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

/**
 * Retry configuration for the request
 */
export type ListPromptVersionsRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count: number;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export const ListPromptVersionsType = {
  ExactMatch: "exact_match",
} as const;
export type ListPromptVersionsType = ClosedEnum<typeof ListPromptVersionsType>;

/**
 * Cache configuration for the request.
 */
export type ListPromptVersionsCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl: number;
  type: ListPromptVersionsType;
};

export const ListPromptVersionsLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type ListPromptVersionsLoadBalancerType = ClosedEnum<
  typeof ListPromptVersionsLoadBalancerType
>;

export type ListPromptVersionsLoadBalancer1 = {
  type: ListPromptVersionsLoadBalancerType;
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight: number;
};

export type ListPromptVersionsLoadBalancer = ListPromptVersionsLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type ListPromptVersionsTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type ListPromptVersionsContentPromptsResponse2002 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type ListPromptVersionsMessagesPromptsResponse200Content =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const ListPromptVersionsMessagesPromptsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type ListPromptVersionsMessagesPromptsType = ClosedEnum<
  typeof ListPromptVersionsMessagesPromptsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const ListPromptVersionsMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type ListPromptVersionsMessagesTtl = ClosedEnum<
  typeof ListPromptVersionsMessagesTtl
>;

export type ListPromptVersionsMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: ListPromptVersionsMessagesPromptsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: ListPromptVersionsMessagesTtl;
};

export type ListPromptVersionsMessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: ListPromptVersionsMessagesCacheControl | undefined;
};

export type ListPromptVersionsContentPromptsResponse2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type ListPromptVersionsMessagesPromptsResponseContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type ListPromptVersionsMessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const ListPromptVersionsMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type ListPromptVersionsMessagesType = ClosedEnum<
  typeof ListPromptVersionsMessagesType
>;

export type ListPromptVersionsMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type ListPromptVersionsMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: ListPromptVersionsMessagesType;
  function: ListPromptVersionsMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type ListPromptVersionsMessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: ListPromptVersionsMessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<ListPromptVersionsMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const ListPromptVersions2PromptsResponse200ApplicationJSONType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type ListPromptVersions2PromptsResponse200ApplicationJSONType =
  ClosedEnum<typeof ListPromptVersions2PromptsResponse200ApplicationJSONType>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const ListPromptVersions2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type ListPromptVersions2Ttl = ClosedEnum<typeof ListPromptVersions2Ttl>;

export type ListPromptVersions2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: ListPromptVersions2PromptsResponse200ApplicationJSONType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl: ListPromptVersions2Ttl;
};

export type ListPromptVersions24 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: ListPromptVersions2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type ListPromptVersionsContentPrompts2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | ListPromptVersions24;

/**
 * The contents of the user message.
 */
export type ListPromptVersionsMessagesPromptsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | ListPromptVersions24
  >;

export type ListPromptVersionsMessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | ListPromptVersions24
    >;
};

/**
 * The contents of the system message.
 */
export type ListPromptVersionsMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type ListPromptVersionsMessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type ListPromptVersionsPromptsMessages =
  | ListPromptVersionsMessagesSystemMessage
  | ListPromptVersionsMessagesUserMessage
  | ListPromptVersionsMessagesAssistantMessage
  | ListPromptVersionsMessagesToolMessage;

/**
 * Prompt configuration with model and messages. Use this instead of prompt_config.
 */
export type ListPromptVersionsPromptField = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: ListPromptVersionsAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | ListPromptVersionsResponseFormatText
    | ListPromptVersionsResponseFormatJSONObject
    | ListPromptVersionsResponseFormatPromptsJSONSchema
    | undefined;
  /**
   * Constrains effort on reasoning for [reasoning models](https://platform.openai.com/docs/guides/reasoning). Currently supported values are `none`, `minimal`, `low`, `medium`, `high`, and `xhigh`. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   *
   * @remarks
   *
   * - `gpt-5.1` defaults to `none`, which does not perform reasoning. The supported reasoning values for `gpt-5.1` are `none`, `low`, `medium`, and `high`. Tool calls are supported for all reasoning values in gpt-5.1.
   * - All models before `gpt-5.1` default to `medium` reasoning effort, and do not support `none`.
   * - The `gpt-5-pro` model defaults to (and only supports) `high` reasoning effort.
   * - `xhigh` is currently only supported for `gpt-5.1-codex-max`.
   *
   * Any of "none", "minimal", "low", "medium", "high", "xhigh".
   */
  reasoningEffort?: ListPromptVersionsReasoningEffort | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: ListPromptVersionsStreamOptions | null | undefined;
  thinking?:
    | components.ThinkingConfigDisabledSchema
    | components.ThinkingConfigEnabledSchema
    | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | ListPromptVersionsToolChoice2
    | ListPromptVersionsToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<ListPromptVersionsModalities> | null | undefined;
  /**
   * A list of guardrails to apply to the request.
   */
  guardrails?: Array<ListPromptVersionsGuardrails> | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<ListPromptVersionsFallbacks> | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: ListPromptVersionsRetry | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: ListPromptVersionsCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: Array<ListPromptVersionsLoadBalancer1> | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: ListPromptVersionsTimeout | undefined;
  /**
   * Array of messages that make up the conversation. Each message has a role (system, user, assistant, or tool) and content.
   */
  messages?:
    | Array<
      | ListPromptVersionsMessagesSystemMessage
      | ListPromptVersionsMessagesUserMessage
      | ListPromptVersionsMessagesAssistantMessage
      | ListPromptVersionsMessagesToolMessage
    >
    | undefined;
  /**
   * Model ID used to generate the response, like `openai/gpt-4o` or `anthropic/claude-3-5-sonnet-20241022`. For private models, use format: `{workspaceKey}@{provider}/{model}`.
   */
  model?: string | null | undefined;
  version?: string | undefined;
};

export const ListPromptVersionsUseCases = {
  AgentsSimulations: "Agents simulations",
  Agents: "Agents",
  APIInteraction: "API interaction",
  AutonomousAgents: "Autonomous Agents",
  Chatbots: "Chatbots",
  Classification: "Classification",
  CodeUnderstanding: "Code understanding",
  CodeWriting: "Code writing",
  Conversation: "Conversation",
  DocumentsQA: "Documents QA",
  Evaluation: "Evaluation",
  Extraction: "Extraction",
  MultiModal: "Multi-modal",
  SelfChecking: "Self-checking",
  SentimentAnalysis: "Sentiment analysis",
  Sql: "SQL",
  Summarization: "Summarization",
  Tagging: "Tagging",
  TranslationDocument: "Translation (document)",
  TranslationSentences: "Translation (sentences)",
} as const;
export type ListPromptVersionsUseCases = ClosedEnum<
  typeof ListPromptVersionsUseCases
>;

/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export const ListPromptVersionsLanguage = {
  Chinese: "Chinese",
  Dutch: "Dutch",
  English: "English",
  French: "French",
  German: "German",
  Russian: "Russian",
  Spanish: "Spanish",
} as const;
/**
 * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
 */
export type ListPromptVersionsLanguage = ClosedEnum<
  typeof ListPromptVersionsLanguage
>;

export type ListPromptVersionsMetadata = {
  /**
   * A list of use cases that the prompt is meant to be used for. Use this field to categorize the prompt for your own purpose
   */
  useCases?: Array<ListPromptVersionsUseCases> | undefined;
  /**
   * The language that the prompt is written in. Use this field to categorize the prompt for your own purpose
   */
  language?: ListPromptVersionsLanguage | null | undefined;
};

export type ListPromptVersionsData = {
  id: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  /**
   * The promptâ€™s description, meant to be displayable in the UI. Use this field to optionally store a long form explanation of the prompt for your own purpose
   */
  description?: string | null | undefined;
  /**
   * [DEPRECATED] Use the `prompt` property instead. A list of messages compatible with the openAI schema.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  promptConfig?: ListPromptVersionsPromptConfig | undefined;
  /**
   * Prompt configuration with model and messages. Use this instead of prompt_config.
   */
  prompt: ListPromptVersionsPromptField;
  metadata?: ListPromptVersionsMetadata | undefined;
  timestamp: string;
};

/**
 * Prompt versions retrieved.
 */
export type ListPromptVersionsResponseBody = {
  object: ListPromptVersionsObject;
  data: Array<ListPromptVersionsData>;
  hasMore: boolean;
};

/** @internal */
export type ListPromptVersionsRequest$Outbound = {
  prompt_id: string;
  limit: number;
  starting_after?: string | undefined;
  ending_before?: string | undefined;
};

/** @internal */
export const ListPromptVersionsRequest$outboundSchema: z.ZodType<
  ListPromptVersionsRequest$Outbound,
  z.ZodTypeDef,
  ListPromptVersionsRequest
> = z.object({
  promptId: z.string(),
  limit: z.number().default(10),
  startingAfter: z.string().optional(),
  endingBefore: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    promptId: "prompt_id",
    startingAfter: "starting_after",
    endingBefore: "ending_before",
  });
});

export function listPromptVersionsRequestToJSON(
  listPromptVersionsRequest: ListPromptVersionsRequest,
): string {
  return JSON.stringify(
    ListPromptVersionsRequest$outboundSchema.parse(listPromptVersionsRequest),
  );
}

/** @internal */
export const ListPromptVersionsObject$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsObject
> = z.nativeEnum(ListPromptVersionsObject);

/** @internal */
export const ListPromptVersionsModelType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsModelType
> = z.nativeEnum(ListPromptVersionsModelType);

/** @internal */
export const ListPromptVersionsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsFormat
> = z.nativeEnum(ListPromptVersionsFormat);

/** @internal */
export const ListPromptVersionsResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsResponseFormat6
> = z.nativeEnum(ListPromptVersionsResponseFormat6);

/** @internal */
export const ListPromptVersionsResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsResponseFormat5
> = z.nativeEnum(ListPromptVersionsResponseFormat5);

/** @internal */
export const ListPromptVersionsResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsResponseFormat4
> = z.nativeEnum(ListPromptVersionsResponseFormat4);

/** @internal */
export const ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType,
  );

/** @internal */
export const ListPromptVersionsResponseFormat3$inboundSchema: z.ZodType<
  ListPromptVersionsResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONResponseBodyType$inboundSchema,
});

export function listPromptVersionsResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormat3' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType
  > = z.nativeEnum(
    ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType,
  );

/** @internal */
export const ListPromptVersionsResponseFormat2$inboundSchema: z.ZodType<
  ListPromptVersionsResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    ListPromptVersionsResponseFormatPromptsResponse200ApplicationJSONType$inboundSchema,
});

export function listPromptVersionsResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormat2' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatPromptsResponse200Type$inboundSchema:
  z.ZodNativeEnum<
    typeof ListPromptVersionsResponseFormatPromptsResponse200Type
  > = z.nativeEnum(ListPromptVersionsResponseFormatPromptsResponse200Type);

/** @internal */
export const ListPromptVersionsResponseFormatPromptsResponseJsonSchema$inboundSchema:
  z.ZodType<
    ListPromptVersionsResponseFormatPromptsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function listPromptVersionsResponseFormatPromptsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsResponseFormatPromptsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsResponseFormatPromptsResponseJsonSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormatPromptsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormat1$inboundSchema: z.ZodType<
  ListPromptVersionsResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPromptVersionsResponseFormatPromptsResponse200Type$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    ListPromptVersionsResponseFormatPromptsResponseJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});

export function listPromptVersionsResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormat1' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPromptsResponseFormat$inboundSchema: z.ZodType<
  ListPromptVersionsPromptsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListPromptVersionsResponseFormat1$inboundSchema),
  z.lazy(() => ListPromptVersionsResponseFormat2$inboundSchema),
  z.lazy(() => ListPromptVersionsResponseFormat3$inboundSchema),
  ListPromptVersionsResponseFormat4$inboundSchema,
  ListPromptVersionsResponseFormat5$inboundSchema,
  ListPromptVersionsResponseFormat6$inboundSchema,
]);

export function listPromptVersionsPromptsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsPromptsResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsPromptsResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsPromptsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsPhotoRealVersion
> = z.nativeEnum(ListPromptVersionsPhotoRealVersion);

/** @internal */
export const ListPromptVersionsEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsEncodingFormat
> = z.nativeEnum(ListPromptVersionsEncodingFormat);

/** @internal */
export const ListPromptVersionsPromptsReasoningEffort$inboundSchema:
  z.ZodNativeEnum<typeof ListPromptVersionsPromptsReasoningEffort> = z
    .nativeEnum(ListPromptVersionsPromptsReasoningEffort);

/** @internal */
export const ListPromptVersionsVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsVerbosity
> = z.nativeEnum(ListPromptVersionsVerbosity);

/** @internal */
export const ListPromptVersionsThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsThinkingLevel
> = z.nativeEnum(ListPromptVersionsThinkingLevel);

/** @internal */
export const ListPromptVersionsModelParameters$inboundSchema: z.ZodType<
  ListPromptVersionsModelParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: ListPromptVersionsFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => ListPromptVersionsResponseFormat1$inboundSchema),
      z.lazy(() => ListPromptVersionsResponseFormat2$inboundSchema),
      z.lazy(() => ListPromptVersionsResponseFormat3$inboundSchema),
      ListPromptVersionsResponseFormat4$inboundSchema,
      ListPromptVersionsResponseFormat5$inboundSchema,
      ListPromptVersionsResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: ListPromptVersionsPhotoRealVersion$inboundSchema.optional(),
  encoding_format: ListPromptVersionsEncodingFormat$inboundSchema.optional(),
  reasoningEffort: ListPromptVersionsPromptsReasoningEffort$inboundSchema
    .optional(),
  budgetTokens: z.number().optional(),
  verbosity: ListPromptVersionsVerbosity$inboundSchema.optional(),
  thinkingLevel: ListPromptVersionsThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});

export function listPromptVersionsModelParametersFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsModelParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsModelParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsModelParameters' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsProvider$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsProvider
> = z.nativeEnum(ListPromptVersionsProvider);

/** @internal */
export const ListPromptVersionsRole$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsRole
> = z.nativeEnum(ListPromptVersionsRole);

/** @internal */
export const ListPromptVersions2File$inboundSchema: z.ZodType<
  ListPromptVersions2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});

export function listPromptVersions2FileFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions2File' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions23$inboundSchema: z.ZodType<
  ListPromptVersions23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => ListPromptVersions2File$inboundSchema),
});

export function listPromptVersions23FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions23' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions2ImageUrl$inboundSchema: z.ZodType<
  ListPromptVersions2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function listPromptVersions2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions2ImageUrl' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions22$inboundSchema: z.ZodType<
  ListPromptVersions22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => ListPromptVersions2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

export function listPromptVersions22FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions22' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions21$inboundSchema: z.ZodType<
  ListPromptVersions21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function listPromptVersions21FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions21' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsContent2$inboundSchema: z.ZodType<
  ListPromptVersionsContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListPromptVersions21$inboundSchema),
  z.lazy(() => ListPromptVersions22$inboundSchema),
  z.lazy(() => ListPromptVersions23$inboundSchema),
]);

export function listPromptVersionsContent2FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsContent2' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsContent$inboundSchema: z.ZodType<
  ListPromptVersionsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => ListPromptVersions21$inboundSchema),
    z.lazy(() => ListPromptVersions22$inboundSchema),
    z.lazy(() => ListPromptVersions23$inboundSchema),
  ])),
]);

export function listPromptVersionsContentFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsContent' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPromptsType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsPromptsType
> = z.nativeEnum(ListPromptVersionsPromptsType);

/** @internal */
export const ListPromptVersionsFunction$inboundSchema: z.ZodType<
  ListPromptVersionsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function listPromptVersionsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsFunction' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsToolCalls$inboundSchema: z.ZodType<
  ListPromptVersionsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: ListPromptVersionsPromptsType$inboundSchema,
  function: z.lazy(() => ListPromptVersionsFunction$inboundSchema),
});

export function listPromptVersionsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsToolCalls' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessages$inboundSchema: z.ZodType<
  ListPromptVersionsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: ListPromptVersionsRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => ListPromptVersions21$inboundSchema),
          z.lazy(() => ListPromptVersions22$inboundSchema),
          z.lazy(() => ListPromptVersions23$inboundSchema),
        ]),
      ),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => ListPromptVersionsToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});

export function listPromptVersionsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessages' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPromptConfig$inboundSchema: z.ZodType<
  ListPromptVersionsPromptConfig,
  z.ZodTypeDef,
  unknown
> = z.object({
  stream: z.boolean().optional(),
  model: z.nullable(z.string()).optional(),
  model_db_id: z.nullable(z.string()).optional(),
  model_type: z.nullable(ListPromptVersionsModelType$inboundSchema).optional(),
  model_parameters: z.lazy(() =>
    ListPromptVersionsModelParameters$inboundSchema
  ).optional(),
  provider: z.nullable(ListPromptVersionsProvider$inboundSchema).optional(),
  integration_id: z.nullable(z.string()).optional(),
  version: z.string().optional(),
  messages: z.array(z.lazy(() => ListPromptVersionsMessages$inboundSchema)),
}).transform((v) => {
  return remap$(v, {
    "model_db_id": "modelDbId",
    "model_type": "modelType",
    "model_parameters": "modelParameters",
    "integration_id": "integrationId",
  });
});

export function listPromptVersionsPromptConfigFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsPromptConfig, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsPromptConfig$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsPromptConfig' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsVoice$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsVoice
> = z.nativeEnum(ListPromptVersionsVoice);

/** @internal */
export const ListPromptVersionsPromptsFormat$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsPromptsFormat
> = z.nativeEnum(ListPromptVersionsPromptsFormat);

/** @internal */
export const ListPromptVersionsAudio$inboundSchema: z.ZodType<
  ListPromptVersionsAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: ListPromptVersionsVoice$inboundSchema,
  format: ListPromptVersionsPromptsFormat$inboundSchema,
});

export function listPromptVersionsAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsAudio' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatJsonSchema$inboundSchema:
  z.ZodType<ListPromptVersionsResponseFormatJsonSchema, z.ZodTypeDef, unknown> =
    z.object({
      description: z.string().optional(),
      name: z.string(),
      schema: z.any().optional(),
      strict: z.boolean().default(false),
    });

export function listPromptVersionsResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsResponseFormatJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsResponseFormatJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatPromptsJSONSchema$inboundSchema:
  z.ZodType<
    ListPromptVersionsResponseFormatPromptsJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: z.literal("json_schema"),
    json_schema: z.lazy(() =>
      ListPromptVersionsResponseFormatJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });

export function listPromptVersionsResponseFormatPromptsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsResponseFormatPromptsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsResponseFormatPromptsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsResponseFormatPromptsJSONSchema' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatJSONObject$inboundSchema:
  z.ZodType<ListPromptVersionsResponseFormatJSONObject, z.ZodTypeDef, unknown> =
    z.object({
      type: z.literal("json_object"),
    });

export function listPromptVersionsResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsResponseFormatJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsResponseFormatJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormatText$inboundSchema: z.ZodType<
  ListPromptVersionsResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
});

export function listPromptVersionsResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormatText' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseFormat$inboundSchema: z.ZodType<
  ListPromptVersionsResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListPromptVersionsResponseFormatText$inboundSchema),
  z.lazy(() => ListPromptVersionsResponseFormatJSONObject$inboundSchema),
  z.lazy(() => ListPromptVersionsResponseFormatPromptsJSONSchema$inboundSchema),
]);

export function listPromptVersionsResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseFormat' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsReasoningEffort
> = z.nativeEnum(ListPromptVersionsReasoningEffort);

/** @internal */
export const ListPromptVersionsStop$inboundSchema: z.ZodType<
  ListPromptVersionsStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

export function listPromptVersionsStopFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsStop' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsStreamOptions$inboundSchema: z.ZodType<
  ListPromptVersionsStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});

export function listPromptVersionsStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsStreamOptions' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsThinking$inboundSchema: z.ZodType<
  ListPromptVersionsThinking,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.ThinkingConfigDisabledSchema$inboundSchema,
  components.ThinkingConfigEnabledSchema$inboundSchema,
]);

export function listPromptVersionsThinkingFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsThinking' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsToolChoiceType
> = z.nativeEnum(ListPromptVersionsToolChoiceType);

/** @internal */
export const ListPromptVersionsToolChoiceFunction$inboundSchema: z.ZodType<
  ListPromptVersionsToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
});

export function listPromptVersionsToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsToolChoice2$inboundSchema: z.ZodType<
  ListPromptVersionsToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPromptVersionsToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => ListPromptVersionsToolChoiceFunction$inboundSchema),
});

export function listPromptVersionsToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsToolChoice2' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsToolChoice1
> = z.nativeEnum(ListPromptVersionsToolChoice1);

/** @internal */
export const ListPromptVersionsToolChoice$inboundSchema: z.ZodType<
  ListPromptVersionsToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListPromptVersionsToolChoice2$inboundSchema),
  ListPromptVersionsToolChoice1$inboundSchema,
]);

export function listPromptVersionsToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsToolChoice' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsModalities$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsModalities
> = z.nativeEnum(ListPromptVersionsModalities);

/** @internal */
export const ListPromptVersionsId1$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsId1
> = z.nativeEnum(ListPromptVersionsId1);

/** @internal */
export const ListPromptVersionsId$inboundSchema: z.ZodType<
  ListPromptVersionsId,
  z.ZodTypeDef,
  unknown
> = z.union([ListPromptVersionsId1$inboundSchema, z.string()]);

export function listPromptVersionsIdFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsId, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsId$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsId' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsExecuteOn
> = z.nativeEnum(ListPromptVersionsExecuteOn);

/** @internal */
export const ListPromptVersionsGuardrails$inboundSchema: z.ZodType<
  ListPromptVersionsGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.union([ListPromptVersionsId1$inboundSchema, z.string()]),
  execute_on: ListPromptVersionsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "execute_on": "executeOn",
  });
});

export function listPromptVersionsGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsGuardrails' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsFallbacks$inboundSchema: z.ZodType<
  ListPromptVersionsFallbacks,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string(),
});

export function listPromptVersionsFallbacksFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsFallbacks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsFallbacks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsFallbacks' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsRetry$inboundSchema: z.ZodType<
  ListPromptVersionsRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});

export function listPromptVersionsRetryFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsRetry' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsType
> = z.nativeEnum(ListPromptVersionsType);

/** @internal */
export const ListPromptVersionsCache$inboundSchema: z.ZodType<
  ListPromptVersionsCache,
  z.ZodTypeDef,
  unknown
> = z.object({
  ttl: z.number().default(1800),
  type: ListPromptVersionsType$inboundSchema,
});

export function listPromptVersionsCacheFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsCache, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsCache$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsCache' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsLoadBalancerType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsLoadBalancerType
> = z.nativeEnum(ListPromptVersionsLoadBalancerType);

/** @internal */
export const ListPromptVersionsLoadBalancer1$inboundSchema: z.ZodType<
  ListPromptVersionsLoadBalancer1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPromptVersionsLoadBalancerType$inboundSchema,
  model: z.string(),
  weight: z.number().default(0.5),
});

export function listPromptVersionsLoadBalancer1FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsLoadBalancer1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsLoadBalancer1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsLoadBalancer1' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsLoadBalancer$inboundSchema: z.ZodType<
  ListPromptVersionsLoadBalancer,
  z.ZodTypeDef,
  unknown
> = z.lazy(() => ListPromptVersionsLoadBalancer1$inboundSchema);

export function listPromptVersionsLoadBalancerFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsLoadBalancer, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsLoadBalancer$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsLoadBalancer' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsTimeout$inboundSchema: z.ZodType<
  ListPromptVersionsTimeout,
  z.ZodTypeDef,
  unknown
> = z.object({
  call_timeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    "call_timeout": "callTimeout",
  });
});

export function listPromptVersionsTimeoutFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsTimeout, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsTimeout$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsTimeout' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsContentPromptsResponse2002$inboundSchema:
  z.ZodType<
    ListPromptVersionsContentPromptsResponse2002,
    z.ZodTypeDef,
    unknown
  > = components.TextContentPartSchema$inboundSchema;

export function listPromptVersionsContentPromptsResponse2002FromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsContentPromptsResponse2002,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsContentPromptsResponse2002$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsContentPromptsResponse2002' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesPromptsResponse200Content$inboundSchema:
  z.ZodType<
    ListPromptVersionsMessagesPromptsResponse200Content,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);

export function listPromptVersionsMessagesPromptsResponse200ContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsMessagesPromptsResponse200Content,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesPromptsResponse200Content$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsMessagesPromptsResponse200Content' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesPromptsType$inboundSchema:
  z.ZodNativeEnum<typeof ListPromptVersionsMessagesPromptsType> = z.nativeEnum(
    ListPromptVersionsMessagesPromptsType,
  );

/** @internal */
export const ListPromptVersionsMessagesTtl$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsMessagesTtl
> = z.nativeEnum(ListPromptVersionsMessagesTtl);

/** @internal */
export const ListPromptVersionsMessagesCacheControl$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPromptVersionsMessagesPromptsType$inboundSchema,
  ttl: ListPromptVersionsMessagesTtl$inboundSchema.default("5m"),
});

export function listPromptVersionsMessagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesToolMessage$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.nullable(z.string()),
  cache_control: z.lazy(() =>
    ListPromptVersionsMessagesCacheControl$inboundSchema
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});

export function listPromptVersionsMessagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsContentPromptsResponse2$inboundSchema: z.ZodType<
  ListPromptVersionsContentPromptsResponse2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$inboundSchema,
  components.ReasoningPartSchema$inboundSchema,
  components.RedactedReasoningPartSchema$inboundSchema,
]);

export function listPromptVersionsContentPromptsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsContentPromptsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsContentPromptsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsContentPromptsResponse2' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesPromptsResponseContent$inboundSchema:
  z.ZodType<
    ListPromptVersionsMessagesPromptsResponseContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);

export function listPromptVersionsMessagesPromptsResponseContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsMessagesPromptsResponseContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesPromptsResponseContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsMessagesPromptsResponseContent' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesAudio$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

export function listPromptVersionsMessagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsMessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesAudio' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsMessagesType
> = z.nativeEnum(ListPromptVersionsMessagesType);

/** @internal */
export const ListPromptVersionsMessagesFunction$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function listPromptVersionsMessagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesFunction' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesToolCalls$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: ListPromptVersionsMessagesType$inboundSchema,
  function: z.lazy(() => ListPromptVersionsMessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});

export function listPromptVersionsMessagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesAssistantMessage$inboundSchema:
  z.ZodType<ListPromptVersionsMessagesAssistantMessage, z.ZodTypeDef, unknown> =
    z.object({
      content: z.nullable(
        z.union([
          z.string(),
          z.array(
            z.union([
              components.TextContentPartSchema$inboundSchema.and(
                z.object({ type: z.literal("text") }),
              ),
              components.RefusalPartSchema$inboundSchema,
              components.ReasoningPartSchema$inboundSchema,
              components.RedactedReasoningPartSchema$inboundSchema,
            ]),
          ),
        ]),
      ).optional(),
      refusal: z.nullable(z.string()).optional(),
      role: z.literal("assistant"),
      name: z.string().optional(),
      audio: z.nullable(
        z.lazy(() => ListPromptVersionsMessagesAudio$inboundSchema),
      ).optional(),
      tool_calls: z.array(
        z.lazy(() => ListPromptVersionsMessagesToolCalls$inboundSchema),
      ).optional(),
    }).transform((v) => {
      return remap$(v, {
        "tool_calls": "toolCalls",
      });
    });

export function listPromptVersionsMessagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsMessagesAssistantMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesAssistantMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsMessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions2PromptsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof ListPromptVersions2PromptsResponse200ApplicationJSONType
  > = z.nativeEnum(ListPromptVersions2PromptsResponse200ApplicationJSONType);

/** @internal */
export const ListPromptVersions2Ttl$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersions2Ttl
> = z.nativeEnum(ListPromptVersions2Ttl);

/** @internal */
export const ListPromptVersions2CacheControl$inboundSchema: z.ZodType<
  ListPromptVersions2CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: ListPromptVersions2PromptsResponse200ApplicationJSONType$inboundSchema,
  ttl: ListPromptVersions2Ttl$inboundSchema.default("5m"),
});

export function listPromptVersions2CacheControlFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions2CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions2CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions2CacheControl' from JSON`,
  );
}

/** @internal */
export const ListPromptVersions24$inboundSchema: z.ZodType<
  ListPromptVersions24,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  cache_control: z.lazy(() => ListPromptVersions2CacheControl$inboundSchema)
    .optional(),
  file: components.FileContentPartSchema$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});

export function listPromptVersions24FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersions24, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersions24$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersions24' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsContentPrompts2$inboundSchema: z.ZodType<
  ListPromptVersionsContentPrompts2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => ListPromptVersions24$inboundSchema),
]);

export function listPromptVersionsContentPrompts2FromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsContentPrompts2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsContentPrompts2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsContentPrompts2' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesPromptsContent$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesPromptsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(
    z.union([
      components.TextContentPartSchema$inboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      components.ImageContentPartSchema$inboundSchema,
      components.AudioContentPartSchema$inboundSchema,
      z.lazy(() => ListPromptVersions24$inboundSchema),
    ]),
  ),
]);

export function listPromptVersionsMessagesPromptsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsMessagesPromptsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesPromptsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsMessagesPromptsContent' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesUserMessage$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => ListPromptVersions24$inboundSchema),
      ]),
    ),
  ]),
});

export function listPromptVersionsMessagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesContent$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);

export function listPromptVersionsMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMessagesContent' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsMessagesSystemMessage$inboundSchema: z.ZodType<
  ListPromptVersionsMessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});

export function listPromptVersionsMessagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<
  ListPromptVersionsMessagesSystemMessage,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      ListPromptVersionsMessagesSystemMessage$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'ListPromptVersionsMessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPromptsMessages$inboundSchema: z.ZodType<
  ListPromptVersionsPromptsMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => ListPromptVersionsMessagesSystemMessage$inboundSchema),
  z.lazy(() => ListPromptVersionsMessagesUserMessage$inboundSchema),
  z.lazy(() => ListPromptVersionsMessagesAssistantMessage$inboundSchema),
  z.lazy(() => ListPromptVersionsMessagesToolMessage$inboundSchema),
]);

export function listPromptVersionsPromptsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsPromptsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsPromptsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsPromptsMessages' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsPromptField$inboundSchema: z.ZodType<
  ListPromptVersionsPromptField,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => ListPromptVersionsAudio$inboundSchema))
    .optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => ListPromptVersionsResponseFormatText$inboundSchema),
    z.lazy(() => ListPromptVersionsResponseFormatJSONObject$inboundSchema),
    z.lazy(() =>
      ListPromptVersionsResponseFormatPromptsJSONSchema$inboundSchema
    ),
  ]).optional(),
  reasoning_effort: ListPromptVersionsReasoningEffort$inboundSchema.optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => ListPromptVersionsStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.union([
    components.ThinkingConfigDisabledSchema$inboundSchema,
    components.ThinkingConfigEnabledSchema$inboundSchema,
  ]).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => ListPromptVersionsToolChoice2$inboundSchema),
    ListPromptVersionsToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(ListPromptVersionsModalities$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => ListPromptVersionsGuardrails$inboundSchema))
    .optional(),
  fallbacks: z.array(z.lazy(() => ListPromptVersionsFallbacks$inboundSchema))
    .optional(),
  retry: z.lazy(() => ListPromptVersionsRetry$inboundSchema).optional(),
  cache: z.lazy(() => ListPromptVersionsCache$inboundSchema).optional(),
  load_balancer: z.array(
    z.lazy(() => ListPromptVersionsLoadBalancer1$inboundSchema),
  ).optional(),
  timeout: z.lazy(() => ListPromptVersionsTimeout$inboundSchema).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => ListPromptVersionsMessagesSystemMessage$inboundSchema),
      z.lazy(() => ListPromptVersionsMessagesUserMessage$inboundSchema),
      z.lazy(() => ListPromptVersionsMessagesAssistantMessage$inboundSchema),
      z.lazy(() => ListPromptVersionsMessagesToolMessage$inboundSchema),
    ]),
  ).optional(),
  model: z.nullable(z.string()).optional(),
  version: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
    "load_balancer": "loadBalancer",
  });
});

export function listPromptVersionsPromptFieldFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsPromptField, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsPromptField$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsPromptField' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsUseCases$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsUseCases
> = z.nativeEnum(ListPromptVersionsUseCases);

/** @internal */
export const ListPromptVersionsLanguage$inboundSchema: z.ZodNativeEnum<
  typeof ListPromptVersionsLanguage
> = z.nativeEnum(ListPromptVersionsLanguage);

/** @internal */
export const ListPromptVersionsMetadata$inboundSchema: z.ZodType<
  ListPromptVersionsMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  use_cases: z.array(ListPromptVersionsUseCases$inboundSchema).optional(),
  language: z.nullable(ListPromptVersionsLanguage$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "use_cases": "useCases",
  });
});

export function listPromptVersionsMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsMetadata' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsData$inboundSchema: z.ZodType<
  ListPromptVersionsData,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  description: z.nullable(z.string()).optional(),
  prompt_config: z.lazy(() => ListPromptVersionsPromptConfig$inboundSchema)
    .optional(),
  prompt: z.lazy(() => ListPromptVersionsPromptField$inboundSchema),
  metadata: z.lazy(() => ListPromptVersionsMetadata$inboundSchema).optional(),
  timestamp: z.string(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "prompt_config": "promptConfig",
  });
});

export function listPromptVersionsDataFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsData' from JSON`,
  );
}

/** @internal */
export const ListPromptVersionsResponseBody$inboundSchema: z.ZodType<
  ListPromptVersionsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  object: ListPromptVersionsObject$inboundSchema,
  data: z.array(z.lazy(() => ListPromptVersionsData$inboundSchema)),
  has_more: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "has_more": "hasMore",
  });
});

export function listPromptVersionsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ListPromptVersionsResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ListPromptVersionsResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ListPromptVersionsResponseBody' from JSON`,
  );
}
