/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export const PostV2ProxyAudioTranscriptionsResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export type PostV2ProxyAudioTranscriptionsResponseFormat = ClosedEnum<
  typeof PostV2ProxyAudioTranscriptionsResponseFormat
>;

/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export const TimestampsGranularity = {
  None: "none",
  Word: "word",
  Character: "character",
} as const;
/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export type TimestampsGranularity = ClosedEnum<typeof TimestampsGranularity>;

export const TimestampGranularities = {
  Word: "word",
  Segment: "segment",
} as const;
export type TimestampGranularities = ClosedEnum<typeof TimestampGranularities>;

export type PostV2ProxyAudioTranscriptionsFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Transcribes audio into the input language.
 */
export type PostV2ProxyAudioTranscriptionsRequestBody = {
  /**
   * ID of the model to use
   */
  model?: string | undefined;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
   */
  prompt?: string | undefined;
  /**
   * When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
   */
  enableLogging?: boolean | undefined;
  /**
   * Whether to annotate which speaker is currently talking in the uploaded file.
   */
  diarize?: boolean | undefined;
  /**
   * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
   */
  responseFormat?: PostV2ProxyAudioTranscriptionsResponseFormat | undefined;
  /**
   * Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
   */
  tagAudioEvents?: boolean | undefined;
  /**
   * The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
   */
  numSpeakers?: number | undefined;
  /**
   * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
   */
  timestampsGranularity?: TimestampsGranularity | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number | undefined;
  /**
   * The language of the input audio. Supplying the input language in ISO-639-1 format will improve accuracy and latency.
   */
  language?: string | undefined;
  /**
   * The timestamp granularities to populate for this transcription. response_format must be set to verbose_json to use timestamp granularities. Either or both of these options are supported: "word" or "segment". Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.
   */
  timestampGranularities?: Array<TimestampGranularities> | undefined;
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file: PostV2ProxyAudioTranscriptionsFile | Blob;
};

export type Words = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

export type Segments = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avgLogprob: number;
  compressionRatio: number;
  noSpeechProb: number;
};

export type ResponseBody2 = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<Words> | undefined;
  segments?: Array<Segments> | undefined;
};

export type ResponseBody1 = {
  text: string;
};

/**
 * Returns the transcription or verbose transcription
 */
export type PostV2ProxyAudioTranscriptionsResponseBody =
  | ResponseBody1
  | ResponseBody2
  | string;

/** @internal */
export const PostV2ProxyAudioTranscriptionsResponseFormat$inboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranscriptionsResponseFormat> = z
    .nativeEnum(PostV2ProxyAudioTranscriptionsResponseFormat);

/** @internal */
export const PostV2ProxyAudioTranscriptionsResponseFormat$outboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranscriptionsResponseFormat> =
    PostV2ProxyAudioTranscriptionsResponseFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranscriptionsResponseFormat$ {
  /** @deprecated use `PostV2ProxyAudioTranscriptionsResponseFormat$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranscriptionsResponseFormat$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsResponseFormat$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranscriptionsResponseFormat$outboundSchema;
}

/** @internal */
export const TimestampsGranularity$inboundSchema: z.ZodNativeEnum<
  typeof TimestampsGranularity
> = z.nativeEnum(TimestampsGranularity);

/** @internal */
export const TimestampsGranularity$outboundSchema: z.ZodNativeEnum<
  typeof TimestampsGranularity
> = TimestampsGranularity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampsGranularity$ {
  /** @deprecated use `TimestampsGranularity$inboundSchema` instead. */
  export const inboundSchema = TimestampsGranularity$inboundSchema;
  /** @deprecated use `TimestampsGranularity$outboundSchema` instead. */
  export const outboundSchema = TimestampsGranularity$outboundSchema;
}

/** @internal */
export const TimestampGranularities$inboundSchema: z.ZodNativeEnum<
  typeof TimestampGranularities
> = z.nativeEnum(TimestampGranularities);

/** @internal */
export const TimestampGranularities$outboundSchema: z.ZodNativeEnum<
  typeof TimestampGranularities
> = TimestampGranularities$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampGranularities$ {
  /** @deprecated use `TimestampGranularities$inboundSchema` instead. */
  export const inboundSchema = TimestampGranularities$inboundSchema;
  /** @deprecated use `TimestampGranularities$outboundSchema` instead. */
  export const outboundSchema = TimestampGranularities$outboundSchema;
}

/** @internal */
export const PostV2ProxyAudioTranscriptionsFile$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranscriptionsFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/** @internal */
export type PostV2ProxyAudioTranscriptionsFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const PostV2ProxyAudioTranscriptionsFile$outboundSchema: z.ZodType<
  PostV2ProxyAudioTranscriptionsFile$Outbound,
  z.ZodTypeDef,
  PostV2ProxyAudioTranscriptionsFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranscriptionsFile$ {
  /** @deprecated use `PostV2ProxyAudioTranscriptionsFile$inboundSchema` instead. */
  export const inboundSchema = PostV2ProxyAudioTranscriptionsFile$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsFile$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranscriptionsFile$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsFile$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranscriptionsFile$Outbound;
}

export function postV2ProxyAudioTranscriptionsFileToJSON(
  postV2ProxyAudioTranscriptionsFile: PostV2ProxyAudioTranscriptionsFile,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranscriptionsFile$outboundSchema.parse(
      postV2ProxyAudioTranscriptionsFile,
    ),
  );
}

export function postV2ProxyAudioTranscriptionsFileFromJSON(
  jsonString: string,
): SafeParseResult<PostV2ProxyAudioTranscriptionsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranscriptionsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2ProxyAudioTranscriptionsFile' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranscriptionsRequestBody$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranscriptionsRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string().default("openai/whisper-1"),
  prompt: z.string().optional(),
  enable_logging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  response_format: PostV2ProxyAudioTranscriptionsResponseFormat$inboundSchema
    .optional(),
  tag_audio_events: z.boolean().default(true),
  num_speakers: z.number().optional(),
  timestamps_granularity: TimestampsGranularity$inboundSchema.default("word"),
  temperature: z.number().optional(),
  language: z.string().optional(),
  timestamp_granularities: z.array(TimestampGranularities$inboundSchema)
    .optional(),
  file: z.lazy(() => PostV2ProxyAudioTranscriptionsFile$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "enable_logging": "enableLogging",
    "response_format": "responseFormat",
    "tag_audio_events": "tagAudioEvents",
    "num_speakers": "numSpeakers",
    "timestamps_granularity": "timestampsGranularity",
    "timestamp_granularities": "timestampGranularities",
  });
});

/** @internal */
export type PostV2ProxyAudioTranscriptionsRequestBody$Outbound = {
  model: string;
  prompt?: string | undefined;
  enable_logging: boolean;
  diarize: boolean;
  response_format?: string | undefined;
  tag_audio_events: boolean;
  num_speakers?: number | undefined;
  timestamps_granularity: string;
  temperature?: number | undefined;
  language?: string | undefined;
  timestamp_granularities?: Array<string> | undefined;
  file: PostV2ProxyAudioTranscriptionsFile$Outbound | Blob;
};

/** @internal */
export const PostV2ProxyAudioTranscriptionsRequestBody$outboundSchema:
  z.ZodType<
    PostV2ProxyAudioTranscriptionsRequestBody$Outbound,
    z.ZodTypeDef,
    PostV2ProxyAudioTranscriptionsRequestBody
  > = z.object({
    model: z.string().default("openai/whisper-1"),
    prompt: z.string().optional(),
    enableLogging: z.boolean().default(true),
    diarize: z.boolean().default(false),
    responseFormat: PostV2ProxyAudioTranscriptionsResponseFormat$outboundSchema
      .optional(),
    tagAudioEvents: z.boolean().default(true),
    numSpeakers: z.number().optional(),
    timestampsGranularity: TimestampsGranularity$outboundSchema.default("word"),
    temperature: z.number().optional(),
    language: z.string().optional(),
    timestampGranularities: z.array(TimestampGranularities$outboundSchema)
      .optional(),
    file: z.lazy(() => PostV2ProxyAudioTranscriptionsFile$outboundSchema).or(
      blobLikeSchema,
    ),
  }).transform((v) => {
    return remap$(v, {
      enableLogging: "enable_logging",
      responseFormat: "response_format",
      tagAudioEvents: "tag_audio_events",
      numSpeakers: "num_speakers",
      timestampsGranularity: "timestamps_granularity",
      timestampGranularities: "timestamp_granularities",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranscriptionsRequestBody$ {
  /** @deprecated use `PostV2ProxyAudioTranscriptionsRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranscriptionsRequestBody$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranscriptionsRequestBody$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsRequestBody$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranscriptionsRequestBody$Outbound;
}

export function postV2ProxyAudioTranscriptionsRequestBodyToJSON(
  postV2ProxyAudioTranscriptionsRequestBody:
    PostV2ProxyAudioTranscriptionsRequestBody,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranscriptionsRequestBody$outboundSchema.parse(
      postV2ProxyAudioTranscriptionsRequestBody,
    ),
  );
}

export function postV2ProxyAudioTranscriptionsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranscriptionsRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranscriptionsRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranscriptionsRequestBody' from JSON`,
  );
}

/** @internal */
export const Words$inboundSchema: z.ZodType<Words, z.ZodTypeDef, unknown> = z
  .object({
    word: z.string().optional(),
    start: z.number().optional(),
    end: z.number().optional(),
  });

/** @internal */
export type Words$Outbound = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

/** @internal */
export const Words$outboundSchema: z.ZodType<
  Words$Outbound,
  z.ZodTypeDef,
  Words
> = z.object({
  word: z.string().optional(),
  start: z.number().optional(),
  end: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Words$ {
  /** @deprecated use `Words$inboundSchema` instead. */
  export const inboundSchema = Words$inboundSchema;
  /** @deprecated use `Words$outboundSchema` instead. */
  export const outboundSchema = Words$outboundSchema;
  /** @deprecated use `Words$Outbound` instead. */
  export type Outbound = Words$Outbound;
}

export function wordsToJSON(words: Words): string {
  return JSON.stringify(Words$outboundSchema.parse(words));
}

export function wordsFromJSON(
  jsonString: string,
): SafeParseResult<Words, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Words$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Words' from JSON`,
  );
}

/** @internal */
export const Segments$inboundSchema: z.ZodType<
  Segments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avg_logprob: z.number(),
  compression_ratio: z.number(),
  no_speech_prob: z.number(),
}).transform((v) => {
  return remap$(v, {
    "avg_logprob": "avgLogprob",
    "compression_ratio": "compressionRatio",
    "no_speech_prob": "noSpeechProb",
  });
});

/** @internal */
export type Segments$Outbound = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avg_logprob: number;
  compression_ratio: number;
  no_speech_prob: number;
};

/** @internal */
export const Segments$outboundSchema: z.ZodType<
  Segments$Outbound,
  z.ZodTypeDef,
  Segments
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avgLogprob: z.number(),
  compressionRatio: z.number(),
  noSpeechProb: z.number(),
}).transform((v) => {
  return remap$(v, {
    avgLogprob: "avg_logprob",
    compressionRatio: "compression_ratio",
    noSpeechProb: "no_speech_prob",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Segments$ {
  /** @deprecated use `Segments$inboundSchema` instead. */
  export const inboundSchema = Segments$inboundSchema;
  /** @deprecated use `Segments$outboundSchema` instead. */
  export const outboundSchema = Segments$outboundSchema;
  /** @deprecated use `Segments$Outbound` instead. */
  export type Outbound = Segments$Outbound;
}

export function segmentsToJSON(segments: Segments): string {
  return JSON.stringify(Segments$outboundSchema.parse(segments));
}

export function segmentsFromJSON(
  jsonString: string,
): SafeParseResult<Segments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Segments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Segments' from JSON`,
  );
}

/** @internal */
export const ResponseBody2$inboundSchema: z.ZodType<
  ResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => Words$inboundSchema)).optional(),
  segments: z.array(z.lazy(() => Segments$inboundSchema)).optional(),
});

/** @internal */
export type ResponseBody2$Outbound = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<Words$Outbound> | undefined;
  segments?: Array<Segments$Outbound> | undefined;
};

/** @internal */
export const ResponseBody2$outboundSchema: z.ZodType<
  ResponseBody2$Outbound,
  z.ZodTypeDef,
  ResponseBody2
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => Words$outboundSchema)).optional(),
  segments: z.array(z.lazy(() => Segments$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody2$ {
  /** @deprecated use `ResponseBody2$inboundSchema` instead. */
  export const inboundSchema = ResponseBody2$inboundSchema;
  /** @deprecated use `ResponseBody2$outboundSchema` instead. */
  export const outboundSchema = ResponseBody2$outboundSchema;
  /** @deprecated use `ResponseBody2$Outbound` instead. */
  export type Outbound = ResponseBody2$Outbound;
}

export function responseBody2ToJSON(responseBody2: ResponseBody2): string {
  return JSON.stringify(ResponseBody2$outboundSchema.parse(responseBody2));
}

export function responseBody2FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody2' from JSON`,
  );
}

/** @internal */
export const ResponseBody1$inboundSchema: z.ZodType<
  ResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
});

/** @internal */
export type ResponseBody1$Outbound = {
  text: string;
};

/** @internal */
export const ResponseBody1$outboundSchema: z.ZodType<
  ResponseBody1$Outbound,
  z.ZodTypeDef,
  ResponseBody1
> = z.object({
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody1$ {
  /** @deprecated use `ResponseBody1$inboundSchema` instead. */
  export const inboundSchema = ResponseBody1$inboundSchema;
  /** @deprecated use `ResponseBody1$outboundSchema` instead. */
  export const outboundSchema = ResponseBody1$outboundSchema;
  /** @deprecated use `ResponseBody1$Outbound` instead. */
  export type Outbound = ResponseBody1$Outbound;
}

export function responseBody1ToJSON(responseBody1: ResponseBody1): string {
  return JSON.stringify(ResponseBody1$outboundSchema.parse(responseBody1));
}

export function responseBody1FromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody1' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranscriptionsResponseBody$inboundSchema:
  z.ZodType<PostV2ProxyAudioTranscriptionsResponseBody, z.ZodTypeDef, unknown> =
    z.union([
      z.lazy(() => ResponseBody1$inboundSchema),
      z.lazy(() => ResponseBody2$inboundSchema),
      z.string(),
    ]);

/** @internal */
export type PostV2ProxyAudioTranscriptionsResponseBody$Outbound =
  | ResponseBody1$Outbound
  | ResponseBody2$Outbound
  | string;

/** @internal */
export const PostV2ProxyAudioTranscriptionsResponseBody$outboundSchema:
  z.ZodType<
    PostV2ProxyAudioTranscriptionsResponseBody$Outbound,
    z.ZodTypeDef,
    PostV2ProxyAudioTranscriptionsResponseBody
  > = z.union([
    z.lazy(() => ResponseBody1$outboundSchema),
    z.lazy(() => ResponseBody2$outboundSchema),
    z.string(),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranscriptionsResponseBody$ {
  /** @deprecated use `PostV2ProxyAudioTranscriptionsResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranscriptionsResponseBody$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranscriptionsResponseBody$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranscriptionsResponseBody$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranscriptionsResponseBody$Outbound;
}

export function postV2ProxyAudioTranscriptionsResponseBodyToJSON(
  postV2ProxyAudioTranscriptionsResponseBody:
    PostV2ProxyAudioTranscriptionsResponseBody,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranscriptionsResponseBody$outboundSchema.parse(
      postV2ProxyAudioTranscriptionsResponseBody,
    ),
  );
}

export function postV2ProxyAudioTranscriptionsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranscriptionsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranscriptionsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranscriptionsResponseBody' from JSON`,
  );
}
