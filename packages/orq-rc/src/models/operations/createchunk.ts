/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type CreateChunkMetadata = string | number | boolean;

export type RequestBody = {
  /**
   * The text content of the chunk
   */
  text: string;
  /**
   * The embedding vector of the chunk. If not provided the chunk will be embedded with the knowledge base embeddings model.
   */
  embedding?: Array<number> | undefined;
  /**
   * Metadata of the chunk
   */
  metadata?: { [k: string]: string | number | boolean } | undefined;
};

export type CreateChunkRequest = {
  /**
   * Unique identifier of the knowledge
   */
  knowledgeId: string;
  /**
   * Unique identifier of the datasource
   */
  datasourceId: string;
  requestBody?: Array<RequestBody> | undefined;
};

export type CreateChunkKnowledgeMetadata = string | number | boolean;

/**
 * The status of the chunk
 */
export const CreateChunkStatus = {
  Pending: "pending",
  Processing: "processing",
  Completed: "completed",
  Failed: "failed",
  Queued: "queued",
} as const;
/**
 * The status of the chunk
 */
export type CreateChunkStatus = ClosedEnum<typeof CreateChunkStatus>;

export type ResponseBody = {
  /**
   * The unique identifier of the chunk
   */
  id: string;
  /**
   * The text content of the chunk
   */
  text: string;
  /**
   * Metadata of the chunk. Can include `page_number` or any other key-value pairs
   */
  metadata?: { [k: string]: string | number | boolean } | undefined;
  /**
   * Whether the chunk is enabled
   */
  enabled: boolean;
  /**
   * The status of the chunk
   */
  status: CreateChunkStatus;
  /**
   * The date and time the chunk was created
   */
  created: string;
  /**
   * The date and time the chunk was updated
   */
  updated: string;
  /**
   * The unique identifier of the user who created the chunk
   */
  createdById?: string | null | undefined;
  /**
   * The unique identifier of the user who updated the chunk
   */
  updateById?: string | null | undefined;
};

/** @internal */
export const CreateChunkMetadata$inboundSchema: z.ZodType<
  CreateChunkMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type CreateChunkMetadata$Outbound = string | number | boolean;

/** @internal */
export const CreateChunkMetadata$outboundSchema: z.ZodType<
  CreateChunkMetadata$Outbound,
  z.ZodTypeDef,
  CreateChunkMetadata
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateChunkMetadata$ {
  /** @deprecated use `CreateChunkMetadata$inboundSchema` instead. */
  export const inboundSchema = CreateChunkMetadata$inboundSchema;
  /** @deprecated use `CreateChunkMetadata$outboundSchema` instead. */
  export const outboundSchema = CreateChunkMetadata$outboundSchema;
  /** @deprecated use `CreateChunkMetadata$Outbound` instead. */
  export type Outbound = CreateChunkMetadata$Outbound;
}

export function createChunkMetadataToJSON(
  createChunkMetadata: CreateChunkMetadata,
): string {
  return JSON.stringify(
    CreateChunkMetadata$outboundSchema.parse(createChunkMetadata),
  );
}

export function createChunkMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CreateChunkMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChunkMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChunkMetadata' from JSON`,
  );
}

/** @internal */
export const RequestBody$inboundSchema: z.ZodType<
  RequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  embedding: z.array(z.number()).optional(),
  metadata: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
});

/** @internal */
export type RequestBody$Outbound = {
  text: string;
  embedding?: Array<number> | undefined;
  metadata?: { [k: string]: string | number | boolean } | undefined;
};

/** @internal */
export const RequestBody$outboundSchema: z.ZodType<
  RequestBody$Outbound,
  z.ZodTypeDef,
  RequestBody
> = z.object({
  text: z.string(),
  embedding: z.array(z.number()).optional(),
  metadata: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestBody$ {
  /** @deprecated use `RequestBody$inboundSchema` instead. */
  export const inboundSchema = RequestBody$inboundSchema;
  /** @deprecated use `RequestBody$outboundSchema` instead. */
  export const outboundSchema = RequestBody$outboundSchema;
  /** @deprecated use `RequestBody$Outbound` instead. */
  export type Outbound = RequestBody$Outbound;
}

export function requestBodyToJSON(requestBody: RequestBody): string {
  return JSON.stringify(RequestBody$outboundSchema.parse(requestBody));
}

export function requestBodyFromJSON(
  jsonString: string,
): SafeParseResult<RequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestBody' from JSON`,
  );
}

/** @internal */
export const CreateChunkRequest$inboundSchema: z.ZodType<
  CreateChunkRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
  datasource_id: z.string(),
  RequestBody: z.array(z.lazy(() => RequestBody$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
    "datasource_id": "datasourceId",
    "RequestBody": "requestBody",
  });
});

/** @internal */
export type CreateChunkRequest$Outbound = {
  knowledge_id: string;
  datasource_id: string;
  RequestBody?: Array<RequestBody$Outbound> | undefined;
};

/** @internal */
export const CreateChunkRequest$outboundSchema: z.ZodType<
  CreateChunkRequest$Outbound,
  z.ZodTypeDef,
  CreateChunkRequest
> = z.object({
  knowledgeId: z.string(),
  datasourceId: z.string(),
  requestBody: z.array(z.lazy(() => RequestBody$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
    datasourceId: "datasource_id",
    requestBody: "RequestBody",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateChunkRequest$ {
  /** @deprecated use `CreateChunkRequest$inboundSchema` instead. */
  export const inboundSchema = CreateChunkRequest$inboundSchema;
  /** @deprecated use `CreateChunkRequest$outboundSchema` instead. */
  export const outboundSchema = CreateChunkRequest$outboundSchema;
  /** @deprecated use `CreateChunkRequest$Outbound` instead. */
  export type Outbound = CreateChunkRequest$Outbound;
}

export function createChunkRequestToJSON(
  createChunkRequest: CreateChunkRequest,
): string {
  return JSON.stringify(
    CreateChunkRequest$outboundSchema.parse(createChunkRequest),
  );
}

export function createChunkRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateChunkRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChunkRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChunkRequest' from JSON`,
  );
}

/** @internal */
export const CreateChunkKnowledgeMetadata$inboundSchema: z.ZodType<
  CreateChunkKnowledgeMetadata,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type CreateChunkKnowledgeMetadata$Outbound = string | number | boolean;

/** @internal */
export const CreateChunkKnowledgeMetadata$outboundSchema: z.ZodType<
  CreateChunkKnowledgeMetadata$Outbound,
  z.ZodTypeDef,
  CreateChunkKnowledgeMetadata
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateChunkKnowledgeMetadata$ {
  /** @deprecated use `CreateChunkKnowledgeMetadata$inboundSchema` instead. */
  export const inboundSchema = CreateChunkKnowledgeMetadata$inboundSchema;
  /** @deprecated use `CreateChunkKnowledgeMetadata$outboundSchema` instead. */
  export const outboundSchema = CreateChunkKnowledgeMetadata$outboundSchema;
  /** @deprecated use `CreateChunkKnowledgeMetadata$Outbound` instead. */
  export type Outbound = CreateChunkKnowledgeMetadata$Outbound;
}

export function createChunkKnowledgeMetadataToJSON(
  createChunkKnowledgeMetadata: CreateChunkKnowledgeMetadata,
): string {
  return JSON.stringify(
    CreateChunkKnowledgeMetadata$outboundSchema.parse(
      createChunkKnowledgeMetadata,
    ),
  );
}

export function createChunkKnowledgeMetadataFromJSON(
  jsonString: string,
): SafeParseResult<CreateChunkKnowledgeMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateChunkKnowledgeMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateChunkKnowledgeMetadata' from JSON`,
  );
}

/** @internal */
export const CreateChunkStatus$inboundSchema: z.ZodNativeEnum<
  typeof CreateChunkStatus
> = z.nativeEnum(CreateChunkStatus);

/** @internal */
export const CreateChunkStatus$outboundSchema: z.ZodNativeEnum<
  typeof CreateChunkStatus
> = CreateChunkStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateChunkStatus$ {
  /** @deprecated use `CreateChunkStatus$inboundSchema` instead. */
  export const inboundSchema = CreateChunkStatus$inboundSchema;
  /** @deprecated use `CreateChunkStatus$outboundSchema` instead. */
  export const outboundSchema = CreateChunkStatus$outboundSchema;
}

/** @internal */
export const ResponseBody$inboundSchema: z.ZodType<
  ResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  text: z.string(),
  metadata: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  enabled: z.boolean(),
  status: CreateChunkStatus$inboundSchema,
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  update_by_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "created_by_id": "createdById",
    "update_by_id": "updateById",
  });
});

/** @internal */
export type ResponseBody$Outbound = {
  _id: string;
  text: string;
  metadata?: { [k: string]: string | number | boolean } | undefined;
  enabled: boolean;
  status: string;
  created: string;
  updated: string;
  created_by_id?: string | null | undefined;
  update_by_id?: string | null | undefined;
};

/** @internal */
export const ResponseBody$outboundSchema: z.ZodType<
  ResponseBody$Outbound,
  z.ZodTypeDef,
  ResponseBody
> = z.object({
  id: z.string(),
  text: z.string(),
  metadata: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  enabled: z.boolean(),
  status: CreateChunkStatus$outboundSchema,
  created: z.string(),
  updated: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updateById: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    createdById: "created_by_id",
    updateById: "update_by_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBody$ {
  /** @deprecated use `ResponseBody$inboundSchema` instead. */
  export const inboundSchema = ResponseBody$inboundSchema;
  /** @deprecated use `ResponseBody$outboundSchema` instead. */
  export const outboundSchema = ResponseBody$outboundSchema;
  /** @deprecated use `ResponseBody$Outbound` instead. */
  export type Outbound = ResponseBody$Outbound;
}

export function responseBodyToJSON(responseBody: ResponseBody): string {
  return JSON.stringify(ResponseBody$outboundSchema.parse(responseBody));
}

export function responseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBody' from JSON`,
  );
}
