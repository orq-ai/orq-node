/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export const PostV2ProxyAudioTranslationsResponseFormat = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
/**
 * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
 */
export type PostV2ProxyAudioTranslationsResponseFormat = ClosedEnum<
  typeof PostV2ProxyAudioTranslationsResponseFormat
>;

/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export const PostV2ProxyAudioTranslationsTimestampsGranularity = {
  None: "none",
  Word: "word",
  Character: "character",
} as const;
/**
 * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
 */
export type PostV2ProxyAudioTranslationsTimestampsGranularity = ClosedEnum<
  typeof PostV2ProxyAudioTranslationsTimestampsGranularity
>;

export type PostV2ProxyAudioTranslationsFile = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/**
 * Translates audio into English.
 */
export type PostV2ProxyAudioTranslationsRequestBody = {
  /**
   * ID of the model to use
   */
  model?: string | undefined;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The prompt should match the audio language.
   */
  prompt?: string | undefined;
  /**
   * When enable_logging is set to false, zero retention mode is used. This disables history features like request stitching and is only available to enterprise customers.
   */
  enableLogging?: boolean | undefined;
  /**
   * Whether to annotate which speaker is currently talking in the uploaded file.
   */
  diarize?: boolean | undefined;
  /**
   * The format of the transcript output, in one of these options: json, text, srt, verbose_json, or vtt.
   */
  responseFormat?: PostV2ProxyAudioTranslationsResponseFormat | undefined;
  /**
   * Whether to tag audio events like (laughter), (footsteps), etc. in the transcription.
   */
  tagAudioEvents?: boolean | undefined;
  /**
   * The maximum amount of speakers talking in the uploaded file. Helps with predicting who speaks when, the maximum is 32.
   */
  numSpeakers?: number | undefined;
  /**
   * The granularity of the timestamps in the transcription. Word provides word-level timestamps and character provides character-level timestamps per word.
   */
  timestampsGranularity?:
    | PostV2ProxyAudioTranslationsTimestampsGranularity
    | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use log probability to automatically increase the temperature until certain thresholds are hit.
   */
  temperature?: number | undefined;
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   */
  file: PostV2ProxyAudioTranslationsFile | Blob;
};

export type ResponseBodyWords = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

export type ResponseBodySegments = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avgLogprob: number;
  compressionRatio: number;
  noSpeechProb: number;
};

export type PostV2ProxyAudioTranslationsResponseBody2 = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<ResponseBodyWords> | undefined;
  segments?: Array<ResponseBodySegments> | undefined;
};

export type PostV2ProxyAudioTranslationsResponseBody1 = {
  text: string;
};

/**
 * Returns the translated text
 */
export type PostV2ProxyAudioTranslationsResponseBody =
  | PostV2ProxyAudioTranslationsResponseBody1
  | PostV2ProxyAudioTranslationsResponseBody2
  | string;

/** @internal */
export const PostV2ProxyAudioTranslationsResponseFormat$inboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranslationsResponseFormat> = z
    .nativeEnum(PostV2ProxyAudioTranslationsResponseFormat);

/** @internal */
export const PostV2ProxyAudioTranslationsResponseFormat$outboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranslationsResponseFormat> =
    PostV2ProxyAudioTranslationsResponseFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsResponseFormat$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseFormat$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsResponseFormat$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseFormat$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsResponseFormat$outboundSchema;
}

/** @internal */
export const PostV2ProxyAudioTranslationsTimestampsGranularity$inboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranslationsTimestampsGranularity> = z
    .nativeEnum(PostV2ProxyAudioTranslationsTimestampsGranularity);

/** @internal */
export const PostV2ProxyAudioTranslationsTimestampsGranularity$outboundSchema:
  z.ZodNativeEnum<typeof PostV2ProxyAudioTranslationsTimestampsGranularity> =
    PostV2ProxyAudioTranslationsTimestampsGranularity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsTimestampsGranularity$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsTimestampsGranularity$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsTimestampsGranularity$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsTimestampsGranularity$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsTimestampsGranularity$outboundSchema;
}

/** @internal */
export const PostV2ProxyAudioTranslationsFile$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsFile,
  z.ZodTypeDef,
  unknown
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/** @internal */
export type PostV2ProxyAudioTranslationsFile$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const PostV2ProxyAudioTranslationsFile$outboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsFile$Outbound,
  z.ZodTypeDef,
  PostV2ProxyAudioTranslationsFile
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsFile$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsFile$inboundSchema` instead. */
  export const inboundSchema = PostV2ProxyAudioTranslationsFile$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsFile$outboundSchema` instead. */
  export const outboundSchema = PostV2ProxyAudioTranslationsFile$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsFile$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranslationsFile$Outbound;
}

export function postV2ProxyAudioTranslationsFileToJSON(
  postV2ProxyAudioTranslationsFile: PostV2ProxyAudioTranslationsFile,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranslationsFile$outboundSchema.parse(
      postV2ProxyAudioTranslationsFile,
    ),
  );
}

export function postV2ProxyAudioTranslationsFileFromJSON(
  jsonString: string,
): SafeParseResult<PostV2ProxyAudioTranslationsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PostV2ProxyAudioTranslationsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PostV2ProxyAudioTranslationsFile' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranslationsRequestBody$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  model: z.string().default("openai/whisper-1"),
  prompt: z.string().optional(),
  enable_logging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  response_format: PostV2ProxyAudioTranslationsResponseFormat$inboundSchema
    .optional(),
  tag_audio_events: z.boolean().default(true),
  num_speakers: z.number().optional(),
  timestamps_granularity:
    PostV2ProxyAudioTranslationsTimestampsGranularity$inboundSchema.default(
      "word",
    ),
  temperature: z.number().optional(),
  file: z.lazy(() => PostV2ProxyAudioTranslationsFile$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "enable_logging": "enableLogging",
    "response_format": "responseFormat",
    "tag_audio_events": "tagAudioEvents",
    "num_speakers": "numSpeakers",
    "timestamps_granularity": "timestampsGranularity",
  });
});

/** @internal */
export type PostV2ProxyAudioTranslationsRequestBody$Outbound = {
  model: string;
  prompt?: string | undefined;
  enable_logging: boolean;
  diarize: boolean;
  response_format?: string | undefined;
  tag_audio_events: boolean;
  num_speakers?: number | undefined;
  timestamps_granularity: string;
  temperature?: number | undefined;
  file: PostV2ProxyAudioTranslationsFile$Outbound | Blob;
};

/** @internal */
export const PostV2ProxyAudioTranslationsRequestBody$outboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsRequestBody$Outbound,
  z.ZodTypeDef,
  PostV2ProxyAudioTranslationsRequestBody
> = z.object({
  model: z.string().default("openai/whisper-1"),
  prompt: z.string().optional(),
  enableLogging: z.boolean().default(true),
  diarize: z.boolean().default(false),
  responseFormat: PostV2ProxyAudioTranslationsResponseFormat$outboundSchema
    .optional(),
  tagAudioEvents: z.boolean().default(true),
  numSpeakers: z.number().optional(),
  timestampsGranularity:
    PostV2ProxyAudioTranslationsTimestampsGranularity$outboundSchema.default(
      "word",
    ),
  temperature: z.number().optional(),
  file: z.lazy(() => PostV2ProxyAudioTranslationsFile$outboundSchema).or(
    blobLikeSchema,
  ),
}).transform((v) => {
  return remap$(v, {
    enableLogging: "enable_logging",
    responseFormat: "response_format",
    tagAudioEvents: "tag_audio_events",
    numSpeakers: "num_speakers",
    timestampsGranularity: "timestamps_granularity",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsRequestBody$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsRequestBody$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsRequestBody$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsRequestBody$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsRequestBody$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsRequestBody$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranslationsRequestBody$Outbound;
}

export function postV2ProxyAudioTranslationsRequestBodyToJSON(
  postV2ProxyAudioTranslationsRequestBody:
    PostV2ProxyAudioTranslationsRequestBody,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranslationsRequestBody$outboundSchema.parse(
      postV2ProxyAudioTranslationsRequestBody,
    ),
  );
}

export function postV2ProxyAudioTranslationsRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranslationsRequestBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranslationsRequestBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranslationsRequestBody' from JSON`,
  );
}

/** @internal */
export const ResponseBodyWords$inboundSchema: z.ZodType<
  ResponseBodyWords,
  z.ZodTypeDef,
  unknown
> = z.object({
  word: z.string().optional(),
  start: z.number().optional(),
  end: z.number().optional(),
});

/** @internal */
export type ResponseBodyWords$Outbound = {
  word?: string | undefined;
  start?: number | undefined;
  end?: number | undefined;
};

/** @internal */
export const ResponseBodyWords$outboundSchema: z.ZodType<
  ResponseBodyWords$Outbound,
  z.ZodTypeDef,
  ResponseBodyWords
> = z.object({
  word: z.string().optional(),
  start: z.number().optional(),
  end: z.number().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodyWords$ {
  /** @deprecated use `ResponseBodyWords$inboundSchema` instead. */
  export const inboundSchema = ResponseBodyWords$inboundSchema;
  /** @deprecated use `ResponseBodyWords$outboundSchema` instead. */
  export const outboundSchema = ResponseBodyWords$outboundSchema;
  /** @deprecated use `ResponseBodyWords$Outbound` instead. */
  export type Outbound = ResponseBodyWords$Outbound;
}

export function responseBodyWordsToJSON(
  responseBodyWords: ResponseBodyWords,
): string {
  return JSON.stringify(
    ResponseBodyWords$outboundSchema.parse(responseBodyWords),
  );
}

export function responseBodyWordsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodyWords, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodyWords$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodyWords' from JSON`,
  );
}

/** @internal */
export const ResponseBodySegments$inboundSchema: z.ZodType<
  ResponseBodySegments,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avg_logprob: z.number(),
  compression_ratio: z.number(),
  no_speech_prob: z.number(),
}).transform((v) => {
  return remap$(v, {
    "avg_logprob": "avgLogprob",
    "compression_ratio": "compressionRatio",
    "no_speech_prob": "noSpeechProb",
  });
});

/** @internal */
export type ResponseBodySegments$Outbound = {
  id: number;
  seek: number;
  start: number;
  end: number;
  text: string;
  tokens: Array<number>;
  temperature: number;
  avg_logprob: number;
  compression_ratio: number;
  no_speech_prob: number;
};

/** @internal */
export const ResponseBodySegments$outboundSchema: z.ZodType<
  ResponseBodySegments$Outbound,
  z.ZodTypeDef,
  ResponseBodySegments
> = z.object({
  id: z.number(),
  seek: z.number(),
  start: z.number(),
  end: z.number(),
  text: z.string(),
  tokens: z.array(z.number()),
  temperature: z.number(),
  avgLogprob: z.number(),
  compressionRatio: z.number(),
  noSpeechProb: z.number(),
}).transform((v) => {
  return remap$(v, {
    avgLogprob: "avg_logprob",
    compressionRatio: "compression_ratio",
    noSpeechProb: "no_speech_prob",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ResponseBodySegments$ {
  /** @deprecated use `ResponseBodySegments$inboundSchema` instead. */
  export const inboundSchema = ResponseBodySegments$inboundSchema;
  /** @deprecated use `ResponseBodySegments$outboundSchema` instead. */
  export const outboundSchema = ResponseBodySegments$outboundSchema;
  /** @deprecated use `ResponseBodySegments$Outbound` instead. */
  export type Outbound = ResponseBodySegments$Outbound;
}

export function responseBodySegmentsToJSON(
  responseBodySegments: ResponseBodySegments,
): string {
  return JSON.stringify(
    ResponseBodySegments$outboundSchema.parse(responseBodySegments),
  );
}

export function responseBodySegmentsFromJSON(
  jsonString: string,
): SafeParseResult<ResponseBodySegments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ResponseBodySegments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ResponseBodySegments' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody2$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  task: z.string().optional(),
  language: z.string().optional(),
  duration: z.number().optional(),
  text: z.string(),
  words: z.array(z.lazy(() => ResponseBodyWords$inboundSchema)).optional(),
  segments: z.array(z.lazy(() => ResponseBodySegments$inboundSchema))
    .optional(),
});

/** @internal */
export type PostV2ProxyAudioTranslationsResponseBody2$Outbound = {
  task?: string | undefined;
  language?: string | undefined;
  duration?: number | undefined;
  text: string;
  words?: Array<ResponseBodyWords$Outbound> | undefined;
  segments?: Array<ResponseBodySegments$Outbound> | undefined;
};

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody2$outboundSchema:
  z.ZodType<
    PostV2ProxyAudioTranslationsResponseBody2$Outbound,
    z.ZodTypeDef,
    PostV2ProxyAudioTranslationsResponseBody2
  > = z.object({
    task: z.string().optional(),
    language: z.string().optional(),
    duration: z.number().optional(),
    text: z.string(),
    words: z.array(z.lazy(() => ResponseBodyWords$outboundSchema)).optional(),
    segments: z.array(z.lazy(() => ResponseBodySegments$outboundSchema))
      .optional(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsResponseBody2$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody2$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsResponseBody2$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody2$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsResponseBody2$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody2$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranslationsResponseBody2$Outbound;
}

export function postV2ProxyAudioTranslationsResponseBody2ToJSON(
  postV2ProxyAudioTranslationsResponseBody2:
    PostV2ProxyAudioTranslationsResponseBody2,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranslationsResponseBody2$outboundSchema.parse(
      postV2ProxyAudioTranslationsResponseBody2,
    ),
  );
}

export function postV2ProxyAudioTranslationsResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranslationsResponseBody2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranslationsResponseBody2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranslationsResponseBody2' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody1$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
});

/** @internal */
export type PostV2ProxyAudioTranslationsResponseBody1$Outbound = {
  text: string;
};

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody1$outboundSchema:
  z.ZodType<
    PostV2ProxyAudioTranslationsResponseBody1$Outbound,
    z.ZodTypeDef,
    PostV2ProxyAudioTranslationsResponseBody1
  > = z.object({
    text: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsResponseBody1$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody1$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsResponseBody1$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody1$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsResponseBody1$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody1$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranslationsResponseBody1$Outbound;
}

export function postV2ProxyAudioTranslationsResponseBody1ToJSON(
  postV2ProxyAudioTranslationsResponseBody1:
    PostV2ProxyAudioTranslationsResponseBody1,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranslationsResponseBody1$outboundSchema.parse(
      postV2ProxyAudioTranslationsResponseBody1,
    ),
  );
}

export function postV2ProxyAudioTranslationsResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranslationsResponseBody1,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranslationsResponseBody1$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranslationsResponseBody1' from JSON`,
  );
}

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody$inboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => PostV2ProxyAudioTranslationsResponseBody1$inboundSchema),
  z.lazy(() => PostV2ProxyAudioTranslationsResponseBody2$inboundSchema),
  z.string(),
]);

/** @internal */
export type PostV2ProxyAudioTranslationsResponseBody$Outbound =
  | PostV2ProxyAudioTranslationsResponseBody1$Outbound
  | PostV2ProxyAudioTranslationsResponseBody2$Outbound
  | string;

/** @internal */
export const PostV2ProxyAudioTranslationsResponseBody$outboundSchema: z.ZodType<
  PostV2ProxyAudioTranslationsResponseBody$Outbound,
  z.ZodTypeDef,
  PostV2ProxyAudioTranslationsResponseBody
> = z.union([
  z.lazy(() => PostV2ProxyAudioTranslationsResponseBody1$outboundSchema),
  z.lazy(() => PostV2ProxyAudioTranslationsResponseBody2$outboundSchema),
  z.string(),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PostV2ProxyAudioTranslationsResponseBody$ {
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody$inboundSchema` instead. */
  export const inboundSchema =
    PostV2ProxyAudioTranslationsResponseBody$inboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody$outboundSchema` instead. */
  export const outboundSchema =
    PostV2ProxyAudioTranslationsResponseBody$outboundSchema;
  /** @deprecated use `PostV2ProxyAudioTranslationsResponseBody$Outbound` instead. */
  export type Outbound = PostV2ProxyAudioTranslationsResponseBody$Outbound;
}

export function postV2ProxyAudioTranslationsResponseBodyToJSON(
  postV2ProxyAudioTranslationsResponseBody:
    PostV2ProxyAudioTranslationsResponseBody,
): string {
  return JSON.stringify(
    PostV2ProxyAudioTranslationsResponseBody$outboundSchema.parse(
      postV2ProxyAudioTranslationsResponseBody,
    ),
  );
}

export function postV2ProxyAudioTranslationsResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<
  PostV2ProxyAudioTranslationsResponseBody,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      PostV2ProxyAudioTranslationsResponseBody$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'PostV2ProxyAudioTranslationsResponseBody' from JSON`,
  );
}
