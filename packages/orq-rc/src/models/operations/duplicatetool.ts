/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import {
  collectExtraKeys as collectExtraKeys$,
  safeParse,
} from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DuplicateToolRequestBody = {
  /**
   * Custom display name for the duplicated tool
   */
  displayName?: string | undefined;
};

export type DuplicateToolRequest = {
  /**
   * The id of the tool to duplicate
   */
  toolId: string;
  requestBody?: DuplicateToolRequestBody | undefined;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  >;

export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType = {
  Code: "code",
} as const;
export type DuplicateToolResponseBodyToolsResponse200ApplicationJSONType =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  >;

/**
 * The type must be "object"
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DuplicateToolResponseBodyToolsParameters = {
  /**
   * The type must be "object"
   */
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export const DuplicateToolResponseBodyLanguage = {
  Python: "python",
} as const;
export type DuplicateToolResponseBodyLanguage = ClosedEnum<
  typeof DuplicateToolResponseBodyLanguage
>;

export type DuplicateToolResponseBodyCodeTool = {
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: DuplicateToolResponseBodyToolsParameters | undefined;
  language: DuplicateToolResponseBodyLanguage;
  /**
   * The code to execute.
   */
  code: string;
};

export type DuplicateToolResponseBody5 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?:
    | DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
    | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJSONType;
  codeTool: DuplicateToolResponseBodyCodeTool;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponse200Status = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponse200Status = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponse200Status
>;

export const DuplicateToolResponseBodyToolsResponse200Type = {
  Mcp: "mcp",
} as const;
export type DuplicateToolResponseBodyToolsResponse200Type = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponse200Type
>;

export type DuplicateToolResponseBodyHeaders = {
  value: string;
  encrypted?: boolean | undefined;
};

export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type = {
  Object: "object",
} as const;
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  >;

export type DuplicateToolResponseBodyToolsSchema = {
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

export type DuplicateToolResponseBodyTools = {
  name: string;
  description?: string | undefined;
  schema: DuplicateToolResponseBodyToolsSchema;
};

/**
 * The connection type used by the MCP server
 */
export const DuplicateToolResponseBodyConnectionType = {
  Http: "http",
  Sse: "sse",
} as const;
/**
 * The connection type used by the MCP server
 */
export type DuplicateToolResponseBodyConnectionType = ClosedEnum<
  typeof DuplicateToolResponseBodyConnectionType
>;

export type DuplicateToolResponseBodyMcp = {
  /**
   * The MCP server URL (cached for execution)
   */
  serverUrl: string;
  /**
   * HTTP headers for MCP server requests with encryption support
   */
  headers?: { [k: string]: DuplicateToolResponseBodyHeaders } | undefined;
  /**
   * Array of tools available from the MCP server
   */
  tools: Array<DuplicateToolResponseBodyTools>;
  /**
   * The connection type used by the MCP server
   */
  connectionType: DuplicateToolResponseBodyConnectionType;
};

export type DuplicateToolResponseBody4 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsResponse200Status | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponse200Type;
  mcp: DuplicateToolResponseBodyMcp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsResponseStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsResponseStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponseStatus
>;

export const DuplicateToolResponseBodyToolsResponseType = {
  Http: "http",
} as const;
export type DuplicateToolResponseBodyToolsResponseType = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsResponseType
>;

/**
 * The HTTP method to use.
 */
export const DuplicateToolResponseBodyMethod = {
  Get: "GET",
  Post: "POST",
  Put: "PUT",
  Delete: "DELETE",
} as const;
/**
 * The HTTP method to use.
 */
export type DuplicateToolResponseBodyMethod = ClosedEnum<
  typeof DuplicateToolResponseBodyMethod
>;

export type DuplicateToolHeaders2 = {
  value: string;
  encrypted?: boolean | undefined;
};

export type DuplicateToolResponseBodyToolsHeaders =
  | DuplicateToolHeaders2
  | string;

/**
 * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
 */
export type DuplicateToolResponseBodyBlueprint = {
  /**
   * The URL to send the request to.
   */
  url: string;
  /**
   * The HTTP method to use.
   */
  method: DuplicateToolResponseBodyMethod;
  /**
   * The headers to send with the request. Can be a string value or an object with value and encrypted properties.
   */
  headers?: { [k: string]: DuplicateToolHeaders2 | string } | undefined;
  /**
   * The body to send with the request.
   */
  body?: { [k: string]: any } | undefined;
};

/**
 * The type of the argument.
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type = {
  String: "string",
  Number: "number",
  Boolean: "boolean",
} as const;
/**
 * The type of the argument.
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  >;

/**
 * The default value of the argument.
 */
export type DuplicateToolResponseBodyDefaultValue = string | number | boolean;

export type DuplicateToolResponseBodyArguments = {
  /**
   * The type of the argument.
   */
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type;
  /**
   * A description of the argument.
   */
  description: string;
  /**
   * Whether to send the argument to the model. If set to false, the argument will not be sent to the model and needs to be provided by the user or it will be left blank.
   */
  sendToModel?: boolean | undefined;
  /**
   * The default value of the argument.
   */
  defaultValue?: string | number | boolean | undefined;
};

export type DuplicateToolResponseBodyHttp = {
  /**
   * The blueprint for the HTTP request. The `arguments` field will be used to replace the placeholders in the `url`, `headers`, `body`, and `arguments` fields.
   */
  blueprint: DuplicateToolResponseBodyBlueprint;
  /**
   * The arguments to send with the request. The keys will be used to replace the placeholders in the `blueprint` field.
   */
  arguments?: { [k: string]: DuplicateToolResponseBodyArguments } | undefined;
};

export type DuplicateToolResponseBody3 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsResponseStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsResponseType;
  http: DuplicateToolResponseBodyHttp;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyToolsStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyToolsStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsStatus
>;

export const DuplicateToolResponseBodyToolsType = {
  JsonSchema: "json_schema",
} as const;
export type DuplicateToolResponseBodyToolsType = ClosedEnum<
  typeof DuplicateToolResponseBodyToolsType
>;

/**
 * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DuplicateToolResponseBodySchema = {
  /**
   * The JSON Schema type
   */
  type: string;
  /**
   * The properties of the JSON Schema object
   */
  properties: { [k: string]: any };
  /**
   * Array of required property names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DuplicateToolResponseBodyJsonSchema = {
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the response format is for. This will be shown to the user.
   */
  description: string;
  /**
   * The schema for the response format, described as a JSON Schema object. See the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  schema: DuplicateToolResponseBodySchema;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the `schema` field. Only a subset of JSON Schema is supported when `strict` is `true`. Only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
};

export type DuplicateToolResponseBody2 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyToolsStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyToolsType;
  jsonSchema: DuplicateToolResponseBodyJsonSchema;
};

/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateToolResponseBodyStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateToolResponseBodyStatus = ClosedEnum<
  typeof DuplicateToolResponseBodyStatus
>;

export const DuplicateToolResponseBodyType = {
  Function: "function",
} as const;
export type DuplicateToolResponseBodyType = ClosedEnum<
  typeof DuplicateToolResponseBodyType
>;

/**
 * The type must be "object"
 */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type = {
  Object: "object",
} as const;
/**
 * The type must be "object"
 */
export type DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type =
  ClosedEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type
  >;

/**
 * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
 */
export type DuplicateToolResponseBodyParameters = {
  /**
   * The type must be "object"
   */
  type: DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type;
  /**
   * The properties of the function parameters
   */
  properties: { [k: string]: any };
  /**
   * Array of required parameter names
   */
  required: Array<string>;
  additionalProperties?: { [k: string]: any } | undefined;
};

export type DuplicateToolResponseBodyFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * Whether to enable strict schema adherence when generating the function call. If set to true, the model will follow the exact schema defined in the `parameters` field. Only a subset of JSON Schema is supported when `strict` is `true`. Currently only compatible with `OpenAI` models.
   */
  strict?: boolean | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object. See the `OpenAI` [guide](https://platform.openai.com/docs/guides/function-calling) for examples, and the [JSON Schema reference](https://json-schema.org/understanding-json-schema/) for documentation about the format.
   */
  parameters?: DuplicateToolResponseBodyParameters | undefined;
};

export type DuplicateToolResponseBody1 = {
  id?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Unique key of the tool as it will be displayed in the UI
   */
  key: string;
  /**
   * The name of the tool as it will be displayed in the UI. This is optional and if not provided, the `key` will be used.
   */
  displayName?: string | undefined;
  /**
   * A description of the tool, used by the model to choose when and how to call the tool. We do recommend using the `description` field as accurate as possible to give enough context to the model to make the right decision.
   */
  description: string;
  /**
   * The id of the user that created the tool
   */
  createdById?: string | undefined;
  /**
   * The id of the user that last updated the tool
   */
  updatedById?: string | undefined;
  projectId: string;
  workspaceId: string;
  created: string;
  updated: string;
  /**
   * The status of the tool. `Live` is the latest version of the tool. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status?: DuplicateToolResponseBodyStatus | undefined;
  versionHash?: string | undefined;
  type: DuplicateToolResponseBodyType;
  function: DuplicateToolResponseBodyFunction;
};

/**
 * Successfully duplicated the tool.
 */
export type DuplicateToolResponseBody =
  | DuplicateToolResponseBody1
  | DuplicateToolResponseBody2
  | DuplicateToolResponseBody3
  | DuplicateToolResponseBody4
  | DuplicateToolResponseBody5;

/** @internal */
export const DuplicateToolRequestBody$inboundSchema: z.ZodType<
  DuplicateToolRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  display_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type DuplicateToolRequestBody$Outbound = {
  display_name?: string | undefined;
};

/** @internal */
export const DuplicateToolRequestBody$outboundSchema: z.ZodType<
  DuplicateToolRequestBody$Outbound,
  z.ZodTypeDef,
  DuplicateToolRequestBody
> = z.object({
  displayName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function duplicateToolRequestBodyToJSON(
  duplicateToolRequestBody: DuplicateToolRequestBody,
): string {
  return JSON.stringify(
    DuplicateToolRequestBody$outboundSchema.parse(duplicateToolRequestBody),
  );
}
export function duplicateToolRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolRequestBody' from JSON`,
  );
}

/** @internal */
export const DuplicateToolRequest$inboundSchema: z.ZodType<
  DuplicateToolRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  tool_id: z.string(),
  RequestBody: z.lazy(() => DuplicateToolRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type DuplicateToolRequest$Outbound = {
  tool_id: string;
  RequestBody?: DuplicateToolRequestBody$Outbound | undefined;
};

/** @internal */
export const DuplicateToolRequest$outboundSchema: z.ZodType<
  DuplicateToolRequest$Outbound,
  z.ZodTypeDef,
  DuplicateToolRequest
> = z.object({
  toolId: z.string(),
  requestBody: z.lazy(() => DuplicateToolRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    requestBody: "RequestBody",
  });
});

export function duplicateToolRequestToJSON(
  duplicateToolRequest: DuplicateToolRequest,
): string {
  return JSON.stringify(
    DuplicateToolRequest$outboundSchema.parse(duplicateToolRequest),
  );
}
export function duplicateToolRequestFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolRequest' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJSONType
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsParameters$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type DuplicateToolResponseBodyToolsParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DuplicateToolResponseBodyToolsParameters$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsParameters$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyToolsParameters
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson5Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function duplicateToolResponseBodyToolsParametersToJSON(
  duplicateToolResponseBodyToolsParameters:
    DuplicateToolResponseBodyToolsParameters,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyToolsParameters$outboundSchema.parse(
      duplicateToolResponseBodyToolsParameters,
    ),
  );
}
export function duplicateToolResponseBodyToolsParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateToolResponseBodyToolsParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyToolsParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateToolResponseBodyToolsParameters' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyLanguage$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyLanguage
> = z.nativeEnum(DuplicateToolResponseBodyLanguage);
/** @internal */
export const DuplicateToolResponseBodyLanguage$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyLanguage
> = DuplicateToolResponseBodyLanguage$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyCodeTool$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyCodeTool,
  z.ZodTypeDef,
  unknown
> = z.object({
  parameters: z.lazy(() =>
    DuplicateToolResponseBodyToolsParameters$inboundSchema
  ).optional(),
  language: DuplicateToolResponseBodyLanguage$inboundSchema,
  code: z.string(),
});
/** @internal */
export type DuplicateToolResponseBodyCodeTool$Outbound = {
  parameters?: DuplicateToolResponseBodyToolsParameters$Outbound | undefined;
  language: string;
  code: string;
};

/** @internal */
export const DuplicateToolResponseBodyCodeTool$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyCodeTool$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyCodeTool
> = z.object({
  parameters: z.lazy(() =>
    DuplicateToolResponseBodyToolsParameters$outboundSchema
  ).optional(),
  language: DuplicateToolResponseBodyLanguage$outboundSchema,
  code: z.string(),
});

export function duplicateToolResponseBodyCodeToolToJSON(
  duplicateToolResponseBodyCodeTool: DuplicateToolResponseBodyCodeTool,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyCodeTool$outboundSchema.parse(
      duplicateToolResponseBodyCodeTool,
    ),
  );
}
export function duplicateToolResponseBodyCodeToolFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyCodeTool, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyCodeTool$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyCodeTool' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody5$inboundSchema: z.ZodType<
  DuplicateToolResponseBody5,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1AV0T3JJDNQ5GHJX01JY0M"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$inboundSchema
      .default("live"),
  version_hash: z.string().optional(),
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$inboundSchema,
  code_tool: z.lazy(() => DuplicateToolResponseBodyCodeTool$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "code_tool": "codeTool",
  });
});
/** @internal */
export type DuplicateToolResponseBody5$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  code_tool: DuplicateToolResponseBodyCodeTool$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody5$outboundSchema: z.ZodType<
  DuplicateToolResponseBody5$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody5
> = z.object({
  id: z.string().default("tool_01KA1AV0T3JJDNQ5GHJX01JY0M"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONStatus$outboundSchema
      .default("live"),
  versionHash: z.string().optional(),
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJSONType$outboundSchema,
  codeTool: z.lazy(() => DuplicateToolResponseBodyCodeTool$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    codeTool: "code_tool",
  });
});

export function duplicateToolResponseBody5ToJSON(
  duplicateToolResponseBody5: DuplicateToolResponseBody5,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody5$outboundSchema.parse(duplicateToolResponseBody5),
  );
}
export function duplicateToolResponseBody5FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody5, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody5$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody5' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Status$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Status> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponse200Status);
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Status$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Status> =
    DuplicateToolResponseBodyToolsResponse200Status$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Type> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponse200Type);
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponse200Type> =
    DuplicateToolResponseBodyToolsResponse200Type$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyHeaders$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyHeaders,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type DuplicateToolResponseBodyHeaders$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DuplicateToolResponseBodyHeaders$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyHeaders$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyHeaders
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function duplicateToolResponseBodyHeadersToJSON(
  duplicateToolResponseBodyHeaders: DuplicateToolResponseBodyHeaders,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyHeaders$outboundSchema.parse(
      duplicateToolResponseBodyHeaders,
    ),
  );
}
export function duplicateToolResponseBodyHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyHeaders' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsSchema$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$inboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});
/** @internal */
export type DuplicateToolResponseBodyToolsSchema$Outbound = {
  type: string;
  properties?: { [k: string]: any } | undefined;
  required?: Array<string> | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyToolsSchema$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsSchema$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyToolsSchema
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson4Type$outboundSchema,
  properties: z.record(z.any()).optional(),
  required: z.array(z.string()).optional(),
});

export function duplicateToolResponseBodyToolsSchemaToJSON(
  duplicateToolResponseBodyToolsSchema: DuplicateToolResponseBodyToolsSchema,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyToolsSchema$outboundSchema.parse(
      duplicateToolResponseBodyToolsSchema,
    ),
  );
}
export function duplicateToolResponseBodyToolsSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyToolsSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyToolsSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyToolsSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyTools$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => DuplicateToolResponseBodyToolsSchema$inboundSchema),
});
/** @internal */
export type DuplicateToolResponseBodyTools$Outbound = {
  name: string;
  description?: string | undefined;
  schema: DuplicateToolResponseBodyToolsSchema$Outbound;
};

/** @internal */
export const DuplicateToolResponseBodyTools$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyTools$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyTools
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  schema: z.lazy(() => DuplicateToolResponseBodyToolsSchema$outboundSchema),
});

export function duplicateToolResponseBodyToolsToJSON(
  duplicateToolResponseBodyTools: DuplicateToolResponseBodyTools,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyTools$outboundSchema.parse(
      duplicateToolResponseBodyTools,
    ),
  );
}
export function duplicateToolResponseBodyToolsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyTools' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyConnectionType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyConnectionType> = z
    .nativeEnum(DuplicateToolResponseBodyConnectionType);
/** @internal */
export const DuplicateToolResponseBodyConnectionType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyConnectionType> =
    DuplicateToolResponseBodyConnectionType$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyMcp$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyMcp,
  z.ZodTypeDef,
  unknown
> = z.object({
  server_url: z.string(),
  headers: z.record(
    z.lazy(() => DuplicateToolResponseBodyHeaders$inboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => DuplicateToolResponseBodyTools$inboundSchema)),
  connection_type: DuplicateToolResponseBodyConnectionType$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "server_url": "serverUrl",
    "connection_type": "connectionType",
  });
});
/** @internal */
export type DuplicateToolResponseBodyMcp$Outbound = {
  server_url: string;
  headers?:
    | { [k: string]: DuplicateToolResponseBodyHeaders$Outbound }
    | undefined;
  tools: Array<DuplicateToolResponseBodyTools$Outbound>;
  connection_type: string;
};

/** @internal */
export const DuplicateToolResponseBodyMcp$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyMcp$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyMcp
> = z.object({
  serverUrl: z.string(),
  headers: z.record(
    z.lazy(() => DuplicateToolResponseBodyHeaders$outboundSchema),
  ).optional(),
  tools: z.array(z.lazy(() => DuplicateToolResponseBodyTools$outboundSchema)),
  connectionType: DuplicateToolResponseBodyConnectionType$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    serverUrl: "server_url",
    connectionType: "connection_type",
  });
});

export function duplicateToolResponseBodyMcpToJSON(
  duplicateToolResponseBodyMcp: DuplicateToolResponseBodyMcp,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyMcp$outboundSchema.parse(
      duplicateToolResponseBodyMcp,
    ),
  );
}
export function duplicateToolResponseBodyMcpFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyMcp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyMcp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyMcp' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody4$inboundSchema: z.ZodType<
  DuplicateToolResponseBody4,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1AV0STH2E66VVSF85FXXVT"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponse200Status$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponse200Type$inboundSchema,
  mcp: z.lazy(() => DuplicateToolResponseBodyMcp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DuplicateToolResponseBody4$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  mcp: DuplicateToolResponseBodyMcp$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody4$outboundSchema: z.ZodType<
  DuplicateToolResponseBody4$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody4
> = z.object({
  id: z.string().default("tool_01KA1AV0STH2E66VVSF85FXXVT"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponse200Status$outboundSchema
    .default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponse200Type$outboundSchema,
  mcp: z.lazy(() => DuplicateToolResponseBodyMcp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function duplicateToolResponseBody4ToJSON(
  duplicateToolResponseBody4: DuplicateToolResponseBody4,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody4$outboundSchema.parse(duplicateToolResponseBody4),
  );
}
export function duplicateToolResponseBody4FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody4' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponseStatus$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseStatus> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponseStatus);
/** @internal */
export const DuplicateToolResponseBodyToolsResponseStatus$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseStatus> =
    DuplicateToolResponseBodyToolsResponseStatus$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseType> = z
    .nativeEnum(DuplicateToolResponseBodyToolsResponseType);
/** @internal */
export const DuplicateToolResponseBodyToolsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsResponseType> =
    DuplicateToolResponseBodyToolsResponseType$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyMethod$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyMethod
> = z.nativeEnum(DuplicateToolResponseBodyMethod);
/** @internal */
export const DuplicateToolResponseBodyMethod$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyMethod
> = DuplicateToolResponseBodyMethod$inboundSchema;

/** @internal */
export const DuplicateToolHeaders2$inboundSchema: z.ZodType<
  DuplicateToolHeaders2,
  z.ZodTypeDef,
  unknown
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});
/** @internal */
export type DuplicateToolHeaders2$Outbound = {
  value: string;
  encrypted: boolean;
};

/** @internal */
export const DuplicateToolHeaders2$outboundSchema: z.ZodType<
  DuplicateToolHeaders2$Outbound,
  z.ZodTypeDef,
  DuplicateToolHeaders2
> = z.object({
  value: z.string(),
  encrypted: z.boolean().default(false),
});

export function duplicateToolHeaders2ToJSON(
  duplicateToolHeaders2: DuplicateToolHeaders2,
): string {
  return JSON.stringify(
    DuplicateToolHeaders2$outboundSchema.parse(duplicateToolHeaders2),
  );
}
export function duplicateToolHeaders2FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolHeaders2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolHeaders2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolHeaders2' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsHeaders$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsHeaders,
  z.ZodTypeDef,
  unknown
> = z.union([z.lazy(() => DuplicateToolHeaders2$inboundSchema), z.string()]);
/** @internal */
export type DuplicateToolResponseBodyToolsHeaders$Outbound =
  | DuplicateToolHeaders2$Outbound
  | string;

/** @internal */
export const DuplicateToolResponseBodyToolsHeaders$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyToolsHeaders$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyToolsHeaders
> = z.union([z.lazy(() => DuplicateToolHeaders2$outboundSchema), z.string()]);

export function duplicateToolResponseBodyToolsHeadersToJSON(
  duplicateToolResponseBodyToolsHeaders: DuplicateToolResponseBodyToolsHeaders,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyToolsHeaders$outboundSchema.parse(
      duplicateToolResponseBodyToolsHeaders,
    ),
  );
}
export function duplicateToolResponseBodyToolsHeadersFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyToolsHeaders, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyToolsHeaders$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyToolsHeaders' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyBlueprint$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyBlueprint,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  method: DuplicateToolResponseBodyMethod$inboundSchema,
  headers: z.record(
    z.union([z.lazy(() => DuplicateToolHeaders2$inboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});
/** @internal */
export type DuplicateToolResponseBodyBlueprint$Outbound = {
  url: string;
  method: string;
  headers?:
    | { [k: string]: DuplicateToolHeaders2$Outbound | string }
    | undefined;
  body?: { [k: string]: any } | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyBlueprint$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyBlueprint$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyBlueprint
> = z.object({
  url: z.string(),
  method: DuplicateToolResponseBodyMethod$outboundSchema,
  headers: z.record(
    z.union([z.lazy(() => DuplicateToolHeaders2$outboundSchema), z.string()]),
  ).optional(),
  body: z.record(z.any()).optional(),
});

export function duplicateToolResponseBodyBlueprintToJSON(
  duplicateToolResponseBodyBlueprint: DuplicateToolResponseBodyBlueprint,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyBlueprint$outboundSchema.parse(
      duplicateToolResponseBodyBlueprint,
    ),
  );
}
export function duplicateToolResponseBodyBlueprintFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyBlueprint, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyBlueprint$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyBlueprint' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyDefaultValue$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyDefaultValue,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DuplicateToolResponseBodyDefaultValue$Outbound =
  | string
  | number
  | boolean;

/** @internal */
export const DuplicateToolResponseBodyDefaultValue$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyDefaultValue$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyDefaultValue
> = z.union([z.string(), z.number(), z.boolean()]);

export function duplicateToolResponseBodyDefaultValueToJSON(
  duplicateToolResponseBodyDefaultValue: DuplicateToolResponseBodyDefaultValue,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyDefaultValue$outboundSchema.parse(
      duplicateToolResponseBodyDefaultValue,
    ),
  );
}
export function duplicateToolResponseBodyDefaultValueFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyDefaultValue, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyDefaultValue$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyDefaultValue' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyArguments$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyArguments,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$inboundSchema,
  description: z.string(),
  send_to_model: z.boolean().default(true),
  default_value: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    "send_to_model": "sendToModel",
    "default_value": "defaultValue",
  });
});
/** @internal */
export type DuplicateToolResponseBodyArguments$Outbound = {
  type: string;
  description: string;
  send_to_model: boolean;
  default_value?: string | number | boolean | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyArguments$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyArguments$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyArguments
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson3Type$outboundSchema,
  description: z.string(),
  sendToModel: z.boolean().default(true),
  defaultValue: z.union([z.string(), z.number(), z.boolean()]).optional(),
}).transform((v) => {
  return remap$(v, {
    sendToModel: "send_to_model",
    defaultValue: "default_value",
  });
});

export function duplicateToolResponseBodyArgumentsToJSON(
  duplicateToolResponseBodyArguments: DuplicateToolResponseBodyArguments,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyArguments$outboundSchema.parse(
      duplicateToolResponseBodyArguments,
    ),
  );
}
export function duplicateToolResponseBodyArgumentsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyArguments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyArguments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyArguments' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyHttp$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyHttp,
  z.ZodTypeDef,
  unknown
> = z.object({
  blueprint: z.lazy(() => DuplicateToolResponseBodyBlueprint$inboundSchema),
  arguments: z.record(
    z.lazy(() => DuplicateToolResponseBodyArguments$inboundSchema),
  ).optional(),
});
/** @internal */
export type DuplicateToolResponseBodyHttp$Outbound = {
  blueprint: DuplicateToolResponseBodyBlueprint$Outbound;
  arguments?:
    | { [k: string]: DuplicateToolResponseBodyArguments$Outbound }
    | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyHttp$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyHttp$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyHttp
> = z.object({
  blueprint: z.lazy(() => DuplicateToolResponseBodyBlueprint$outboundSchema),
  arguments: z.record(
    z.lazy(() => DuplicateToolResponseBodyArguments$outboundSchema),
  ).optional(),
});

export function duplicateToolResponseBodyHttpToJSON(
  duplicateToolResponseBodyHttp: DuplicateToolResponseBodyHttp,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyHttp$outboundSchema.parse(
      duplicateToolResponseBodyHttp,
    ),
  );
}
export function duplicateToolResponseBodyHttpFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyHttp, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyHttp$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyHttp' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody3$inboundSchema: z.ZodType<
  DuplicateToolResponseBody3,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1AV0SRARA53WSWZXA5BNZX"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponseStatus$inboundSchema.default(
    "live",
  ),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponseType$inboundSchema,
  http: z.lazy(() => DuplicateToolResponseBodyHttp$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DuplicateToolResponseBody3$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  http: DuplicateToolResponseBodyHttp$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody3$outboundSchema: z.ZodType<
  DuplicateToolResponseBody3$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody3
> = z.object({
  id: z.string().default("tool_01KA1AV0SRARA53WSWZXA5BNZX"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsResponseStatus$outboundSchema.default(
    "live",
  ),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsResponseType$outboundSchema,
  http: z.lazy(() => DuplicateToolResponseBodyHttp$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function duplicateToolResponseBody3ToJSON(
  duplicateToolResponseBody3: DuplicateToolResponseBody3,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody3$outboundSchema.parse(duplicateToolResponseBody3),
  );
}
export function duplicateToolResponseBody3FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody3' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyToolsStatus$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsStatus> = z.nativeEnum(
    DuplicateToolResponseBodyToolsStatus,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsStatus$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateToolResponseBodyToolsStatus> =
    DuplicateToolResponseBodyToolsStatus$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyToolsType
> = z.nativeEnum(DuplicateToolResponseBodyToolsType);
/** @internal */
export const DuplicateToolResponseBodyToolsType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyToolsType
> = DuplicateToolResponseBodyToolsType$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodySchema$inboundSchema: z.ZodType<
  DuplicateToolResponseBodySchema,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type: z.string(),
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type DuplicateToolResponseBodySchema$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DuplicateToolResponseBodySchema$outboundSchema: z.ZodType<
  DuplicateToolResponseBodySchema$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodySchema
> = z.object({
  type: z.string(),
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function duplicateToolResponseBodySchemaToJSON(
  duplicateToolResponseBodySchema: DuplicateToolResponseBodySchema,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodySchema$outboundSchema.parse(
      duplicateToolResponseBodySchema,
    ),
  );
}
export function duplicateToolResponseBodySchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodySchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodySchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodySchema' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyJsonSchema$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => DuplicateToolResponseBodySchema$inboundSchema),
  strict: z.boolean().optional(),
});
/** @internal */
export type DuplicateToolResponseBodyJsonSchema$Outbound = {
  name: string;
  description: string;
  schema: DuplicateToolResponseBodySchema$Outbound;
  strict?: boolean | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyJsonSchema$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyJsonSchema$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyJsonSchema
> = z.object({
  name: z.string(),
  description: z.string(),
  schema: z.lazy(() => DuplicateToolResponseBodySchema$outboundSchema),
  strict: z.boolean().optional(),
});

export function duplicateToolResponseBodyJsonSchemaToJSON(
  duplicateToolResponseBodyJsonSchema: DuplicateToolResponseBodyJsonSchema,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyJsonSchema$outboundSchema.parse(
      duplicateToolResponseBodyJsonSchema,
    ),
  );
}
export function duplicateToolResponseBodyJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyJsonSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody2$inboundSchema: z.ZodType<
  DuplicateToolResponseBody2,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1AV0SNK3S7XFC4KY215WW8"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsType$inboundSchema,
  json_schema: z.lazy(() => DuplicateToolResponseBodyJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type DuplicateToolResponseBody2$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  json_schema: DuplicateToolResponseBodyJsonSchema$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody2$outboundSchema: z.ZodType<
  DuplicateToolResponseBody2$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody2
> = z.object({
  id: z.string().default("tool_01KA1AV0SNK3S7XFC4KY215WW8"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyToolsStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyToolsType$outboundSchema,
  jsonSchema: z.lazy(() => DuplicateToolResponseBodyJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
    jsonSchema: "json_schema",
  });
});

export function duplicateToolResponseBody2ToJSON(
  duplicateToolResponseBody2: DuplicateToolResponseBody2,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody2$outboundSchema.parse(duplicateToolResponseBody2),
  );
}
export function duplicateToolResponseBody2FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody2' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyStatus$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyStatus
> = z.nativeEnum(DuplicateToolResponseBodyStatus);
/** @internal */
export const DuplicateToolResponseBodyStatus$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyStatus
> = DuplicateToolResponseBodyStatus$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyType
> = z.nativeEnum(DuplicateToolResponseBodyType);
/** @internal */
export const DuplicateToolResponseBodyType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateToolResponseBodyType
> = DuplicateToolResponseBodyType$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type
  > = z.nativeEnum(
    DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type,
  );
/** @internal */
export const DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type
  > =
    DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema;

/** @internal */
export const DuplicateToolResponseBodyParameters$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyParameters,
  z.ZodTypeDef,
  unknown
> = collectExtraKeys$(
  z.object({
    type:
      DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type$inboundSchema,
    properties: z.record(z.any()),
    required: z.array(z.string()),
  }).catchall(z.any()),
  "additionalProperties",
  true,
);
/** @internal */
export type DuplicateToolResponseBodyParameters$Outbound = {
  type: string;
  properties: { [k: string]: any };
  required: Array<string>;
  [additionalProperties: string]: unknown;
};

/** @internal */
export const DuplicateToolResponseBodyParameters$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyParameters$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyParameters
> = z.object({
  type:
    DuplicateToolResponseBodyToolsResponse200ApplicationJson1Type$outboundSchema,
  properties: z.record(z.any()),
  required: z.array(z.string()),
  additionalProperties: z.record(z.any()).optional(),
}).transform((v) => {
  return {
    ...v.additionalProperties,
    ...remap$(v, {
      additionalProperties: null,
    }),
  };
});

export function duplicateToolResponseBodyParametersToJSON(
  duplicateToolResponseBodyParameters: DuplicateToolResponseBodyParameters,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyParameters$outboundSchema.parse(
      duplicateToolResponseBodyParameters,
    ),
  );
}
export function duplicateToolResponseBodyParametersFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateToolResponseBodyParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyParameters' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBodyFunction$inboundSchema: z.ZodType<
  DuplicateToolResponseBodyFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DuplicateToolResponseBodyParameters$inboundSchema)
    .optional(),
});
/** @internal */
export type DuplicateToolResponseBodyFunction$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  parameters?: DuplicateToolResponseBodyParameters$Outbound | undefined;
};

/** @internal */
export const DuplicateToolResponseBodyFunction$outboundSchema: z.ZodType<
  DuplicateToolResponseBodyFunction$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBodyFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  strict: z.boolean().optional(),
  parameters: z.lazy(() => DuplicateToolResponseBodyParameters$outboundSchema)
    .optional(),
});

export function duplicateToolResponseBodyFunctionToJSON(
  duplicateToolResponseBodyFunction: DuplicateToolResponseBodyFunction,
): string {
  return JSON.stringify(
    DuplicateToolResponseBodyFunction$outboundSchema.parse(
      duplicateToolResponseBodyFunction,
    ),
  );
}
export function duplicateToolResponseBodyFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBodyFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBodyFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBodyFunction' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody1$inboundSchema: z.ZodType<
  DuplicateToolResponseBody1,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string().default("tool_01KA1AV0SK10FZJ0DC5DXZG2A1"),
  path: z.string(),
  key: z.string(),
  display_name: z.string().optional(),
  description: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  project_id: z.string(),
  workspace_id: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyStatus$inboundSchema.default("live"),
  version_hash: z.string().optional(),
  type: DuplicateToolResponseBodyType$inboundSchema,
  function: z.lazy(() => DuplicateToolResponseBodyFunction$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "project_id": "projectId",
    "workspace_id": "workspaceId",
    "version_hash": "versionHash",
  });
});
/** @internal */
export type DuplicateToolResponseBody1$Outbound = {
  _id: string;
  path: string;
  key: string;
  display_name?: string | undefined;
  description: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  project_id: string;
  workspace_id: string;
  created: string;
  updated: string;
  status: string;
  version_hash?: string | undefined;
  type: string;
  function: DuplicateToolResponseBodyFunction$Outbound;
};

/** @internal */
export const DuplicateToolResponseBody1$outboundSchema: z.ZodType<
  DuplicateToolResponseBody1$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody1
> = z.object({
  id: z.string().default("tool_01KA1AV0SK10FZJ0DC5DXZG2A1"),
  path: z.string(),
  key: z.string(),
  displayName: z.string().optional(),
  description: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  projectId: z.string(),
  workspaceId: z.string(),
  created: z.string(),
  updated: z.string(),
  status: DuplicateToolResponseBodyStatus$outboundSchema.default("live"),
  versionHash: z.string().optional(),
  type: DuplicateToolResponseBodyType$outboundSchema,
  function: z.lazy(() => DuplicateToolResponseBodyFunction$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    projectId: "project_id",
    workspaceId: "workspace_id",
    versionHash: "version_hash",
  });
});

export function duplicateToolResponseBody1ToJSON(
  duplicateToolResponseBody1: DuplicateToolResponseBody1,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody1$outboundSchema.parse(duplicateToolResponseBody1),
  );
}
export function duplicateToolResponseBody1FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody1' from JSON`,
  );
}

/** @internal */
export const DuplicateToolResponseBody$inboundSchema: z.ZodType<
  DuplicateToolResponseBody,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DuplicateToolResponseBody1$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody2$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody3$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody4$inboundSchema),
  z.lazy(() => DuplicateToolResponseBody5$inboundSchema),
]);
/** @internal */
export type DuplicateToolResponseBody$Outbound =
  | DuplicateToolResponseBody1$Outbound
  | DuplicateToolResponseBody2$Outbound
  | DuplicateToolResponseBody3$Outbound
  | DuplicateToolResponseBody4$Outbound
  | DuplicateToolResponseBody5$Outbound;

/** @internal */
export const DuplicateToolResponseBody$outboundSchema: z.ZodType<
  DuplicateToolResponseBody$Outbound,
  z.ZodTypeDef,
  DuplicateToolResponseBody
> = z.union([
  z.lazy(() => DuplicateToolResponseBody1$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody2$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody3$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody4$outboundSchema),
  z.lazy(() => DuplicateToolResponseBody5$outboundSchema),
]);

export function duplicateToolResponseBodyToJSON(
  duplicateToolResponseBody: DuplicateToolResponseBody,
): string {
  return JSON.stringify(
    DuplicateToolResponseBody$outboundSchema.parse(duplicateToolResponseBody),
  );
}
export function duplicateToolResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateToolResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateToolResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateToolResponseBody' from JSON`,
  );
}
