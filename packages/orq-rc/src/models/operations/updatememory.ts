/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type UpdateMemoryRequestBody = {
  /**
   * Unique identifier for the entity this memory is associated with (e.g., user ID, session ID, conversation ID). Must be a valid UUID or ULID.
   */
  entityId: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization. Clients can add arbitrary string metadata to enable future filtering of memory access based on their specific needs (e.g., user segments, topics, contexts, or any custom taxonomy).
   */
  metadata?: { [k: string]: string } | undefined;
};

export type UpdateMemoryRequest = {
  /**
   * The unique key identifier of the memory store
   */
  memoryStoreKey: string;
  /**
   * The unique identifier of the memory
   */
  memoryId: string;
  requestBody?: UpdateMemoryRequestBody | undefined;
};

/**
 * Memory successfully updated.
 */
export type UpdateMemoryResponseBody = {
  id: string;
  entityId: string;
  created: string;
  updated: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  storeId: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization. Clients can add arbitrary string metadata to enable future filtering of memory access based on their specific needs (e.g., user segments, topics, contexts, or any custom taxonomy).
   */
  metadata: { [k: string]: string };
  workspaceId: string;
  /**
   * The number of memories in the entity
   */
  documentsCount: number;
};

/** @internal */
export const UpdateMemoryRequestBody$inboundSchema: z.ZodType<
  UpdateMemoryRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type UpdateMemoryRequestBody$Outbound = {
  entity_id: string;
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const UpdateMemoryRequestBody$outboundSchema: z.ZodType<
  UpdateMemoryRequestBody$Outbound,
  z.ZodTypeDef,
  UpdateMemoryRequestBody
> = z.object({
  entityId: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function updateMemoryRequestBodyToJSON(
  updateMemoryRequestBody: UpdateMemoryRequestBody,
): string {
  return JSON.stringify(
    UpdateMemoryRequestBody$outboundSchema.parse(updateMemoryRequestBody),
  );
}
export function updateMemoryRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMemoryRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMemoryRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMemoryRequestBody' from JSON`,
  );
}

/** @internal */
export const UpdateMemoryRequest$inboundSchema: z.ZodType<
  UpdateMemoryRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  memory_store_key: z.string(),
  memory_id: z.string(),
  RequestBody: z.lazy(() => UpdateMemoryRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "memory_store_key": "memoryStoreKey",
    "memory_id": "memoryId",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type UpdateMemoryRequest$Outbound = {
  memory_store_key: string;
  memory_id: string;
  RequestBody?: UpdateMemoryRequestBody$Outbound | undefined;
};

/** @internal */
export const UpdateMemoryRequest$outboundSchema: z.ZodType<
  UpdateMemoryRequest$Outbound,
  z.ZodTypeDef,
  UpdateMemoryRequest
> = z.object({
  memoryStoreKey: z.string(),
  memoryId: z.string(),
  requestBody: z.lazy(() => UpdateMemoryRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    memoryStoreKey: "memory_store_key",
    memoryId: "memory_id",
    requestBody: "RequestBody",
  });
});

export function updateMemoryRequestToJSON(
  updateMemoryRequest: UpdateMemoryRequest,
): string {
  return JSON.stringify(
    UpdateMemoryRequest$outboundSchema.parse(updateMemoryRequest),
  );
}
export function updateMemoryRequestFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMemoryRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMemoryRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMemoryRequest' from JSON`,
  );
}

/** @internal */
export const UpdateMemoryResponseBody$inboundSchema: z.ZodType<
  UpdateMemoryResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  entity_id: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  store_id: z.string(),
  metadata: z.record(z.string()),
  workspace_id: z.string(),
  documents_count: z.number(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "entity_id": "entityId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "store_id": "storeId",
    "workspace_id": "workspaceId",
    "documents_count": "documentsCount",
  });
});
/** @internal */
export type UpdateMemoryResponseBody$Outbound = {
  _id: string;
  entity_id: string;
  created: string;
  updated: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  store_id: string;
  metadata: { [k: string]: string };
  workspace_id: string;
  documents_count: number;
};

/** @internal */
export const UpdateMemoryResponseBody$outboundSchema: z.ZodType<
  UpdateMemoryResponseBody$Outbound,
  z.ZodTypeDef,
  UpdateMemoryResponseBody
> = z.object({
  id: z.string(),
  entityId: z.string(),
  created: z.string(),
  updated: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  storeId: z.string(),
  metadata: z.record(z.string()),
  workspaceId: z.string(),
  documentsCount: z.number(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    entityId: "entity_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    storeId: "store_id",
    workspaceId: "workspace_id",
    documentsCount: "documents_count",
  });
});

export function updateMemoryResponseBodyToJSON(
  updateMemoryResponseBody: UpdateMemoryResponseBody,
): string {
  return JSON.stringify(
    UpdateMemoryResponseBody$outboundSchema.parse(updateMemoryResponseBody),
  );
}
export function updateMemoryResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<UpdateMemoryResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UpdateMemoryResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UpdateMemoryResponseBody' from JSON`,
  );
}
