/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type RetrieveMemoryDocumentRequest = {
  /**
   * The unique key identifier of the memory store
   */
  memoryStoreKey: string;
  /**
   * The unique identifier of the memory
   */
  memoryEntityId: string;
  /**
   * The unique identifier of the document
   */
  documentId: string;
};

/**
 * Memory document successfully retrieved.
 */
export type RetrieveMemoryDocumentResponseBody = {
  id: string;
  memoryId: string;
  storeId: string;
  /**
   * The content of the memory document (whitespace trimmed).
   */
  text: string;
  created: string;
  updated: string;
  createdById?: string | undefined;
  updatedById?: string | undefined;
  workspaceId: string;
  /**
   * Flexible key-value pairs for custom filtering and categorization. Clients can add arbitrary string metadata to enable future filtering of memory documents based on their specific needs (e.g., document type, source, topic, relevance score, or any custom taxonomy).
   */
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const RetrieveMemoryDocumentRequest$inboundSchema: z.ZodType<
  RetrieveMemoryDocumentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  memory_store_key: z.string(),
  memory_entity_id: z.string(),
  document_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "memory_store_key": "memoryStoreKey",
    "memory_entity_id": "memoryEntityId",
    "document_id": "documentId",
  });
});
/** @internal */
export type RetrieveMemoryDocumentRequest$Outbound = {
  memory_store_key: string;
  memory_entity_id: string;
  document_id: string;
};

/** @internal */
export const RetrieveMemoryDocumentRequest$outboundSchema: z.ZodType<
  RetrieveMemoryDocumentRequest$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryDocumentRequest
> = z.object({
  memoryStoreKey: z.string(),
  memoryEntityId: z.string(),
  documentId: z.string(),
}).transform((v) => {
  return remap$(v, {
    memoryStoreKey: "memory_store_key",
    memoryEntityId: "memory_entity_id",
    documentId: "document_id",
  });
});

export function retrieveMemoryDocumentRequestToJSON(
  retrieveMemoryDocumentRequest: RetrieveMemoryDocumentRequest,
): string {
  return JSON.stringify(
    RetrieveMemoryDocumentRequest$outboundSchema.parse(
      retrieveMemoryDocumentRequest,
    ),
  );
}
export function retrieveMemoryDocumentRequestFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryDocumentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RetrieveMemoryDocumentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryDocumentRequest' from JSON`,
  );
}

/** @internal */
export const RetrieveMemoryDocumentResponseBody$inboundSchema: z.ZodType<
  RetrieveMemoryDocumentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  memory_id: z.string(),
  store_id: z.string(),
  text: z.string(),
  created: z.string(),
  updated: z.string(),
  created_by_id: z.string().optional(),
  updated_by_id: z.string().optional(),
  workspace_id: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "memory_id": "memoryId",
    "store_id": "storeId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "workspace_id": "workspaceId",
  });
});
/** @internal */
export type RetrieveMemoryDocumentResponseBody$Outbound = {
  _id: string;
  memory_id: string;
  store_id: string;
  text: string;
  created: string;
  updated: string;
  created_by_id?: string | undefined;
  updated_by_id?: string | undefined;
  workspace_id: string;
  metadata?: { [k: string]: string } | undefined;
};

/** @internal */
export const RetrieveMemoryDocumentResponseBody$outboundSchema: z.ZodType<
  RetrieveMemoryDocumentResponseBody$Outbound,
  z.ZodTypeDef,
  RetrieveMemoryDocumentResponseBody
> = z.object({
  id: z.string(),
  memoryId: z.string(),
  storeId: z.string(),
  text: z.string(),
  created: z.string(),
  updated: z.string(),
  createdById: z.string().optional(),
  updatedById: z.string().optional(),
  workspaceId: z.string(),
  metadata: z.record(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    memoryId: "memory_id",
    storeId: "store_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    workspaceId: "workspace_id",
  });
});

export function retrieveMemoryDocumentResponseBodyToJSON(
  retrieveMemoryDocumentResponseBody: RetrieveMemoryDocumentResponseBody,
): string {
  return JSON.stringify(
    RetrieveMemoryDocumentResponseBody$outboundSchema.parse(
      retrieveMemoryDocumentResponseBody,
    ),
  );
}
export function retrieveMemoryDocumentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<RetrieveMemoryDocumentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      RetrieveMemoryDocumentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RetrieveMemoryDocumentResponseBody' from JSON`,
  );
}
