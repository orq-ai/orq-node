/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`.
 */
export const Background = {
  Transparent: "transparent",
  Opaque: "opaque",
  Auto: "auto",
} as const;
/**
 * Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`.
 */
export type Background = ClosedEnum<typeof Background>;

/**
 * Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`.
 */
export const Moderation = {
  Low: "low",
  Auto: "auto",
} as const;
/**
 * Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`.
 */
export type Moderation = ClosedEnum<typeof Moderation>;

/**
 * The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`.
 */
export const OutputFormat = {
  Png: "png",
  Jpeg: "jpeg",
  Webp: "webp",
} as const;
/**
 * The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`.
 */
export type OutputFormat = ClosedEnum<typeof OutputFormat>;

/**
 * The quality of the image that will be generated. `auto` will automatically select the best quality for the given model.
 */
export const Quality = {
  Auto: "auto",
  High: "high",
  Medium: "medium",
  Low: "low",
  Hd: "hd",
  Standard: "standard",
} as const;
/**
 * The quality of the image that will be generated. `auto` will automatically select the best quality for the given model.
 */
export type Quality = ClosedEnum<typeof Quality>;

/**
 * The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images.
 */
export const CreateImageResponseFormat = {
  Url: "url",
  B64Json: "b64_json",
} as const;
/**
 * The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images.
 */
export type CreateImageResponseFormat = ClosedEnum<
  typeof CreateImageResponseFormat
>;

/**
 * The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`.
 */
export const Style = {
  Vivid: "vivid",
  Natural: "natural",
} as const;
/**
 * The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`.
 */
export type Style = ClosedEnum<typeof Style>;

/**
 * Retry configuration for the request
 */
export type CreateImageRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

export type CreateImageFallbacks = {
  /**
   * Fallback model identifier
   */
  model: string;
};

export const CreateImageType = {
  ExactMatch: "exact_match",
} as const;
export type CreateImageType = ClosedEnum<typeof CreateImageType>;

/**
 * Cache configuration for the request.
 */
export type CreateImageCache = {
  /**
   * Time to live for cached responses in seconds. Maximum 259200 seconds (3 days).
   */
  ttl?: number | undefined;
  type: CreateImageType;
};

export const CreateImageLoadBalancerType = {
  WeightBased: "weight_based",
} as const;
export type CreateImageLoadBalancerType = ClosedEnum<
  typeof CreateImageLoadBalancerType
>;

export type CreateImageLoadBalancerModels = {
  /**
   * Model identifier for load balancing
   */
  model: string;
  /**
   * Weight assigned to this model for load balancing
   */
  weight?: number | undefined;
};

export type CreateImageLoadBalancer1 = {
  type: CreateImageLoadBalancerType;
  models: Array<CreateImageLoadBalancerModels>;
};

/**
 * Array of models with weights for load balancing requests
 */
export type CreateImageLoadBalancer = CreateImageLoadBalancer1;

/**
 * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
 */
export type CreateImageTimeout = {
  /**
   * Timeout value in milliseconds
   */
  callTimeout: number;
};

export type CreateImageOrq = {
  /**
   * The name to display on the trace. If not specified, the default system name will be used.
   */
  name?: string | undefined;
  /**
   * Retry configuration for the request
   */
  retry?: CreateImageRetry | undefined;
  /**
   * Array of fallback models to use if primary model fails
   */
  fallbacks?: Array<CreateImageFallbacks> | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: components.PublicIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: components.PublicContact | undefined;
  /**
   * Cache configuration for the request.
   */
  cache?: CreateImageCache | undefined;
  /**
   * Array of models with weights for load balancing requests
   */
  loadBalancer?: CreateImageLoadBalancer1 | undefined;
  /**
   * Timeout configuration to apply to the request. If the request exceeds the timeout, it will be retried or fallback to the next model if configured.
   */
  timeout?: CreateImageTimeout | undefined;
};

/**
 * input
 */
export type CreateImageRequestBody = {
  /**
   * A text description of the desired image(s).
   */
  prompt: string;
  /**
   * Allows to set transparency for the background of the generated image(s). This parameter is only supported for `openai/gpt-image-1`.
   */
  background?: Background | null | undefined;
  /**
   * The model to use for image generation. One of `openai/dall-e-2`, `openai/dall-e-3`, or `openai/gpt-image-1`.
   */
  model: string;
  /**
   * Control the content-moderation level for images generated by `gpt-image-1`. Must be either `low` or `auto`.
   */
  moderation?: Moderation | null | undefined;
  /**
   * The number of images to generate. Must be between 1 and 10. For `dall-e-3`, only `n=1` is supported.
   */
  n?: number | null | undefined;
  /**
   * The compression level (0-100%) for the generated images. This parameter is only supported for `gpt-image-1` with the `webp` or `jpeg` output formats.
   */
  outputCompression?: number | null | undefined;
  /**
   * The format in which the generated images are returned. This parameter is only supported for `openai/gpt-image-1`.
   */
  outputFormat?: OutputFormat | null | undefined;
  /**
   * The quality of the image that will be generated. `auto` will automatically select the best quality for the given model.
   */
  quality?: Quality | null | undefined;
  /**
   * The format in which generated images are returned. Must be one of `url` or `b64_json`. This parameter isn't supported for `gpt-image-1` which will always return base64-encoded images.
   */
  responseFormat?: CreateImageResponseFormat | null | undefined;
  /**
   * The size of the generated images. Must be one of the specified sizes for each model.
   */
  size?: string | null | undefined;
  /**
   * The style of the generated images. This parameter is only supported for `openai/dall-e-3`. Must be one of `vivid` or `natural`.
   */
  style?: Style | null | undefined;
  orq?: CreateImageOrq | undefined;
};

export type CreateImageData = {
  /**
   * The prompt that was used to generate the image, if there was any revision to the prompt.
   */
  revisedPrompt?: string | null | undefined;
  /**
   * The base64-encoded JSON of the generated image, if `response_format` is `b64_json`
   */
  b64Json?: string | undefined;
  /**
   * The url of the generated image, if `response_format` is `url` (default)
   */
  url?: string | undefined;
};

export type InputTokensDetails = {
  imageTokens?: number | undefined;
  textTokens?: number | undefined;
};

export type CreateImageUsage = {
  inputTokens?: number | undefined;
  inputTokensDetails: InputTokensDetails;
  outputTokens?: number | undefined;
  totalTokens?: number | undefined;
};

/**
 * Represents an image generation response from the API.
 */
export type CreateImageResponseBody = {
  /**
   * The Unix timestamp (in seconds) of when the image was created.
   */
  created: number;
  /**
   * Represents the url or the content of an image generated.
   */
  data: Array<CreateImageData>;
  usage?: CreateImageUsage | undefined;
};

/** @internal */
export const Background$outboundSchema: z.ZodNativeEnum<typeof Background> = z
  .nativeEnum(Background);

/** @internal */
export const Moderation$outboundSchema: z.ZodNativeEnum<typeof Moderation> = z
  .nativeEnum(Moderation);

/** @internal */
export const OutputFormat$outboundSchema: z.ZodNativeEnum<typeof OutputFormat> =
  z.nativeEnum(OutputFormat);

/** @internal */
export const Quality$outboundSchema: z.ZodNativeEnum<typeof Quality> = z
  .nativeEnum(Quality);

/** @internal */
export const CreateImageResponseFormat$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageResponseFormat
> = z.nativeEnum(CreateImageResponseFormat);

/** @internal */
export const Style$outboundSchema: z.ZodNativeEnum<typeof Style> = z.nativeEnum(
  Style,
);

/** @internal */
export type CreateImageRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const CreateImageRetry$outboundSchema: z.ZodType<
  CreateImageRetry$Outbound,
  z.ZodTypeDef,
  CreateImageRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function createImageRetryToJSON(
  createImageRetry: CreateImageRetry,
): string {
  return JSON.stringify(
    CreateImageRetry$outboundSchema.parse(createImageRetry),
  );
}

/** @internal */
export type CreateImageFallbacks$Outbound = {
  model: string;
};

/** @internal */
export const CreateImageFallbacks$outboundSchema: z.ZodType<
  CreateImageFallbacks$Outbound,
  z.ZodTypeDef,
  CreateImageFallbacks
> = z.object({
  model: z.string(),
});

export function createImageFallbacksToJSON(
  createImageFallbacks: CreateImageFallbacks,
): string {
  return JSON.stringify(
    CreateImageFallbacks$outboundSchema.parse(createImageFallbacks),
  );
}

/** @internal */
export const CreateImageType$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageType
> = z.nativeEnum(CreateImageType);

/** @internal */
export type CreateImageCache$Outbound = {
  ttl: number;
  type: string;
};

/** @internal */
export const CreateImageCache$outboundSchema: z.ZodType<
  CreateImageCache$Outbound,
  z.ZodTypeDef,
  CreateImageCache
> = z.object({
  ttl: z.number().default(1800),
  type: CreateImageType$outboundSchema,
});

export function createImageCacheToJSON(
  createImageCache: CreateImageCache,
): string {
  return JSON.stringify(
    CreateImageCache$outboundSchema.parse(createImageCache),
  );
}

/** @internal */
export const CreateImageLoadBalancerType$outboundSchema: z.ZodNativeEnum<
  typeof CreateImageLoadBalancerType
> = z.nativeEnum(CreateImageLoadBalancerType);

/** @internal */
export type CreateImageLoadBalancerModels$Outbound = {
  model: string;
  weight: number;
};

/** @internal */
export const CreateImageLoadBalancerModels$outboundSchema: z.ZodType<
  CreateImageLoadBalancerModels$Outbound,
  z.ZodTypeDef,
  CreateImageLoadBalancerModels
> = z.object({
  model: z.string(),
  weight: z.number().default(0.5),
});

export function createImageLoadBalancerModelsToJSON(
  createImageLoadBalancerModels: CreateImageLoadBalancerModels,
): string {
  return JSON.stringify(
    CreateImageLoadBalancerModels$outboundSchema.parse(
      createImageLoadBalancerModels,
    ),
  );
}

/** @internal */
export type CreateImageLoadBalancer1$Outbound = {
  type: string;
  models: Array<CreateImageLoadBalancerModels$Outbound>;
};

/** @internal */
export const CreateImageLoadBalancer1$outboundSchema: z.ZodType<
  CreateImageLoadBalancer1$Outbound,
  z.ZodTypeDef,
  CreateImageLoadBalancer1
> = z.object({
  type: CreateImageLoadBalancerType$outboundSchema,
  models: z.array(z.lazy(() => CreateImageLoadBalancerModels$outboundSchema)),
});

export function createImageLoadBalancer1ToJSON(
  createImageLoadBalancer1: CreateImageLoadBalancer1,
): string {
  return JSON.stringify(
    CreateImageLoadBalancer1$outboundSchema.parse(createImageLoadBalancer1),
  );
}

/** @internal */
export type CreateImageLoadBalancer$Outbound =
  CreateImageLoadBalancer1$Outbound;

/** @internal */
export const CreateImageLoadBalancer$outboundSchema: z.ZodType<
  CreateImageLoadBalancer$Outbound,
  z.ZodTypeDef,
  CreateImageLoadBalancer
> = z.lazy(() => CreateImageLoadBalancer1$outboundSchema);

export function createImageLoadBalancerToJSON(
  createImageLoadBalancer: CreateImageLoadBalancer,
): string {
  return JSON.stringify(
    CreateImageLoadBalancer$outboundSchema.parse(createImageLoadBalancer),
  );
}

/** @internal */
export type CreateImageTimeout$Outbound = {
  call_timeout: number;
};

/** @internal */
export const CreateImageTimeout$outboundSchema: z.ZodType<
  CreateImageTimeout$Outbound,
  z.ZodTypeDef,
  CreateImageTimeout
> = z.object({
  callTimeout: z.number(),
}).transform((v) => {
  return remap$(v, {
    callTimeout: "call_timeout",
  });
});

export function createImageTimeoutToJSON(
  createImageTimeout: CreateImageTimeout,
): string {
  return JSON.stringify(
    CreateImageTimeout$outboundSchema.parse(createImageTimeout),
  );
}

/** @internal */
export type CreateImageOrq$Outbound = {
  name?: string | undefined;
  retry?: CreateImageRetry$Outbound | undefined;
  fallbacks?: Array<CreateImageFallbacks$Outbound> | undefined;
  identity?: components.PublicIdentity$Outbound | undefined;
  contact?: components.PublicContact$Outbound | undefined;
  cache?: CreateImageCache$Outbound | undefined;
  load_balancer?: CreateImageLoadBalancer1$Outbound | undefined;
  timeout?: CreateImageTimeout$Outbound | undefined;
};

/** @internal */
export const CreateImageOrq$outboundSchema: z.ZodType<
  CreateImageOrq$Outbound,
  z.ZodTypeDef,
  CreateImageOrq
> = z.object({
  name: z.string().optional(),
  retry: z.lazy(() => CreateImageRetry$outboundSchema).optional(),
  fallbacks: z.array(z.lazy(() => CreateImageFallbacks$outboundSchema))
    .optional(),
  identity: components.PublicIdentity$outboundSchema.optional(),
  contact: components.PublicContact$outboundSchema.optional(),
  cache: z.lazy(() => CreateImageCache$outboundSchema).optional(),
  loadBalancer: z.lazy(() => CreateImageLoadBalancer1$outboundSchema)
    .optional(),
  timeout: z.lazy(() => CreateImageTimeout$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    loadBalancer: "load_balancer",
  });
});

export function createImageOrqToJSON(createImageOrq: CreateImageOrq): string {
  return JSON.stringify(CreateImageOrq$outboundSchema.parse(createImageOrq));
}

/** @internal */
export type CreateImageRequestBody$Outbound = {
  prompt: string;
  background?: string | null | undefined;
  model: string;
  moderation?: string | null | undefined;
  n: number | null;
  output_compression?: number | null | undefined;
  output_format?: string | null | undefined;
  quality?: string | null | undefined;
  response_format?: string | null | undefined;
  size?: string | null | undefined;
  style?: string | null | undefined;
  orq?: CreateImageOrq$Outbound | undefined;
};

/** @internal */
export const CreateImageRequestBody$outboundSchema: z.ZodType<
  CreateImageRequestBody$Outbound,
  z.ZodTypeDef,
  CreateImageRequestBody
> = z.object({
  prompt: z.string(),
  background: z.nullable(Background$outboundSchema).optional(),
  model: z.string(),
  moderation: z.nullable(Moderation$outboundSchema).optional(),
  n: z.nullable(z.number().int().default(1)),
  outputCompression: z.nullable(z.number().int()).optional(),
  outputFormat: z.nullable(OutputFormat$outboundSchema).optional(),
  quality: z.nullable(Quality$outboundSchema).optional(),
  responseFormat: z.nullable(CreateImageResponseFormat$outboundSchema)
    .optional(),
  size: z.nullable(z.string()).optional(),
  style: z.nullable(Style$outboundSchema).optional(),
  orq: z.lazy(() => CreateImageOrq$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    outputCompression: "output_compression",
    outputFormat: "output_format",
    responseFormat: "response_format",
  });
});

export function createImageRequestBodyToJSON(
  createImageRequestBody: CreateImageRequestBody,
): string {
  return JSON.stringify(
    CreateImageRequestBody$outboundSchema.parse(createImageRequestBody),
  );
}

/** @internal */
export const CreateImageData$inboundSchema: z.ZodType<
  CreateImageData,
  z.ZodTypeDef,
  unknown
> = z.object({
  revised_prompt: z.nullable(z.string()).optional(),
  b64_json: z.string().optional(),
  url: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "revised_prompt": "revisedPrompt",
    "b64_json": "b64Json",
  });
});

export function createImageDataFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageData' from JSON`,
  );
}

/** @internal */
export const InputTokensDetails$inboundSchema: z.ZodType<
  InputTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  image_tokens: z.number().optional(),
  text_tokens: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "image_tokens": "imageTokens",
    "text_tokens": "textTokens",
  });
});

export function inputTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<InputTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateImageUsage$inboundSchema: z.ZodType<
  CreateImageUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  input_tokens: z.number().optional(),
  input_tokens_details: z.lazy(() => InputTokensDetails$inboundSchema),
  output_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "input_tokens": "inputTokens",
    "input_tokens_details": "inputTokensDetails",
    "output_tokens": "outputTokens",
    "total_tokens": "totalTokens",
  });
});

export function createImageUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageUsage' from JSON`,
  );
}

/** @internal */
export const CreateImageResponseBody$inboundSchema: z.ZodType<
  CreateImageResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  created: z.number(),
  data: z.array(z.lazy(() => CreateImageData$inboundSchema)),
  usage: z.lazy(() => CreateImageUsage$inboundSchema).optional(),
});

export function createImageResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateImageResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateImageResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateImageResponseBody' from JSON`,
  );
}
