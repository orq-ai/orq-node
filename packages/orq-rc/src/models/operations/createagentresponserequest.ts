/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { EventStream } from "../../lib/event-streams.js";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const RoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type RoleToolMessage = ClosedEnum<typeof RoleToolMessage>;

/**
 * Message from the end user
 */
export const RoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type RoleUserMessage = ClosedEnum<typeof RoleUserMessage>;

/**
 * Message role (user or tool for continuing executions)
 */
export type CreateAgentResponseRequestRole = RoleUserMessage | RoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type PublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type A2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: RoleUserMessage | RoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    components.TextPart | components.FilePart | components.ToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type Contact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type CreateAgentResponseRequestThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type Memory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type Conversation = {
  /**
   * Unique ULID identifier for the conversation, prefixed with "conv_". Used to link agent executions to a specific conversation thread.
   */
  id: string;
};

export type CreateAgentResponseRequestRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: A2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: Contact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateAgentResponseRequestThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: Memory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors.
   */
  background?: boolean | undefined;
  /**
   * If true, returns Server-Sent Events (SSE) streaming response with real-time events. If false (default), returns standard JSON response.
   */
  stream?: boolean | undefined;
  conversation?: Conversation | undefined;
};

export type CreateAgentResponseRequestRequest = {
  /**
   * The unique key of identifier of the agent to invoke
   */
  agentKey: string;
  requestBody: CreateAgentResponseRequestRequestBody;
};

/**
 * Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details. In streaming mode, returns Server-Sent Events (SSE) with real-time events.
 */
export type CreateAgentResponseRequestResponseBody = {
  /**
   * Union of all possible streaming events. Each event has a type field for discrimination.
   */
  data?: components.ResponseStreamingEvent | undefined;
};

export type CreateAgentResponseRequestResponse =
  | components.CreateAgentResponse
  | EventStream<CreateAgentResponseRequestResponseBody>;

/** @internal */
export const RoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = z.nativeEnum(RoleToolMessage);
/** @internal */
export const RoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = RoleToolMessage$inboundSchema;

/** @internal */
export const RoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = z.nativeEnum(RoleUserMessage);
/** @internal */
export const RoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = RoleUserMessage$inboundSchema;

/** @internal */
export const CreateAgentResponseRequestRole$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRole,
  z.ZodTypeDef,
  unknown
> = z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]);
/** @internal */
export type CreateAgentResponseRequestRole$Outbound = string | string;

/** @internal */
export const CreateAgentResponseRequestRole$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRole$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRole
> = z.union([RoleUserMessage$outboundSchema, RoleToolMessage$outboundSchema]);

export function createAgentResponseRequestRoleToJSON(
  createAgentResponseRequestRole: CreateAgentResponseRequestRole,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRole$outboundSchema.parse(
      createAgentResponseRequestRole,
    ),
  );
}
export function createAgentResponseRequestRoleFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRole' from JSON`,
  );
}

/** @internal */
export const PublicMessagePart$inboundSchema: z.ZodType<
  PublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolResultPart$inboundSchema,
]);
/** @internal */
export type PublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound;

/** @internal */
export const PublicMessagePart$outboundSchema: z.ZodType<
  PublicMessagePart$Outbound,
  z.ZodTypeDef,
  PublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
]);

export function publicMessagePartToJSON(
  publicMessagePart: PublicMessagePart,
): string {
  return JSON.stringify(
    PublicMessagePart$outboundSchema.parse(publicMessagePart),
  );
}
export function publicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePart' from JSON`,
  );
}

/** @internal */
export const A2AMessage$inboundSchema: z.ZodType<
  A2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]),
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolResultPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type A2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
  >;
};

/** @internal */
export const A2AMessage$outboundSchema: z.ZodType<
  A2AMessage$Outbound,
  z.ZodTypeDef,
  A2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RoleUserMessage$outboundSchema,
    RoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
    ]),
  ),
});

export function a2AMessageToJSON(a2AMessage: A2AMessage): string {
  return JSON.stringify(A2AMessage$outboundSchema.parse(a2AMessage));
}
export function a2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<A2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => A2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'A2AMessage' from JSON`,
  );
}

/** @internal */
export const Contact$inboundSchema: z.ZodType<Contact, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    display_name: z.string().optional(),
    email: z.string().optional(),
    metadata: z.array(z.record(z.any())).optional(),
    logo_url: z.string().optional(),
    tags: z.array(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
      "logo_url": "logoUrl",
    });
  });
/** @internal */
export type Contact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Contact$outboundSchema: z.ZodType<
  Contact$Outbound,
  z.ZodTypeDef,
  Contact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function contactToJSON(contact: Contact): string {
  return JSON.stringify(Contact$outboundSchema.parse(contact));
}
export function contactFromJSON(
  jsonString: string,
): SafeParseResult<Contact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contact' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestThread$inboundSchema: z.ZodType<
  CreateAgentResponseRequestThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type CreateAgentResponseRequestThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateAgentResponseRequestThread$outboundSchema: z.ZodType<
  CreateAgentResponseRequestThread$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createAgentResponseRequestThreadToJSON(
  createAgentResponseRequestThread: CreateAgentResponseRequestThread,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestThread$outboundSchema.parse(
      createAgentResponseRequestThread,
    ),
  );
}
export function createAgentResponseRequestThreadFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestThread' from JSON`,
  );
}

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    entity_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entity_id": "entityId",
    });
  });
/** @internal */
export type Memory$Outbound = {
  entity_id: string;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}
export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const Conversation$inboundSchema: z.ZodType<
  Conversation,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
  });
});
/** @internal */
export type Conversation$Outbound = {
  _id: string;
};

/** @internal */
export const Conversation$outboundSchema: z.ZodType<
  Conversation$Outbound,
  z.ZodTypeDef,
  Conversation
> = z.object({
  id: z.string(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
  });
});

export function conversationToJSON(conversation: Conversation): string {
  return JSON.stringify(Conversation$outboundSchema.parse(conversation));
}
export function conversationFromJSON(
  jsonString: string,
): SafeParseResult<Conversation, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Conversation$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Conversation' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestRequestBody$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => A2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$inboundSchema).optional(),
  thread: z.lazy(() => CreateAgentResponseRequestThread$inboundSchema)
    .optional(),
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  background: z.boolean().default(false),
  stream: z.boolean().default(false),
  conversation: z.lazy(() => Conversation$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type CreateAgentResponseRequestRequestBody$Outbound = {
  task_id?: string | undefined;
  message: A2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: Contact$Outbound | undefined;
  thread?: CreateAgentResponseRequestThread$Outbound | undefined;
  memory?: Memory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  background: boolean;
  stream: boolean;
  conversation?: Conversation$Outbound | undefined;
};

/** @internal */
export const CreateAgentResponseRequestRequestBody$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => A2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$outboundSchema).optional(),
  thread: z.lazy(() => CreateAgentResponseRequestThread$outboundSchema)
    .optional(),
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  background: z.boolean().default(false),
  stream: z.boolean().default(false),
  conversation: z.lazy(() => Conversation$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function createAgentResponseRequestRequestBodyToJSON(
  createAgentResponseRequestRequestBody: CreateAgentResponseRequestRequestBody,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRequestBody$outboundSchema.parse(
      createAgentResponseRequestRequestBody,
    ),
  );
}
export function createAgentResponseRequestRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseRequestRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestRequest$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  RequestBody: z.lazy(() =>
    CreateAgentResponseRequestRequestBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateAgentResponseRequestRequest$Outbound = {
  agent_key: string;
  RequestBody: CreateAgentResponseRequestRequestBody$Outbound;
};

/** @internal */
export const CreateAgentResponseRequestRequest$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRequest$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRequest
> = z.object({
  agentKey: z.string(),
  requestBody: z.lazy(() =>
    CreateAgentResponseRequestRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    requestBody: "RequestBody",
  });
});

export function createAgentResponseRequestRequestToJSON(
  createAgentResponseRequestRequest: CreateAgentResponseRequestRequest,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRequest$outboundSchema.parse(
      createAgentResponseRequestRequest,
    ),
  );
}
export function createAgentResponseRequestRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRequest' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestResponseBody$inboundSchema: z.ZodType<
  CreateAgentResponseRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string().optional().transform((v, ctx) => {
    if (v === undefined) return undefined;
    try {
      return JSON.parse(v);
    } catch (err) {
      ctx.addIssue({ code: "custom", message: `malformed json: ${err}` });
      return z.NEVER;
    }
  }).pipe(components.ResponseStreamingEvent$inboundSchema.optional()),
});
/** @internal */
export type CreateAgentResponseRequestResponseBody$Outbound = {
  data?: components.ResponseStreamingEvent$Outbound | undefined;
};

/** @internal */
export const CreateAgentResponseRequestResponseBody$outboundSchema: z.ZodType<
  CreateAgentResponseRequestResponseBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestResponseBody
> = z.object({
  data: components.ResponseStreamingEvent$outboundSchema.optional(),
});

export function createAgentResponseRequestResponseBodyToJSON(
  createAgentResponseRequestResponseBody:
    CreateAgentResponseRequestResponseBody,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestResponseBody$outboundSchema.parse(
      createAgentResponseRequestResponseBody,
    ),
  );
}
export function createAgentResponseRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestResponseBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestResponse$inboundSchema: z.ZodType<
  CreateAgentResponseRequestResponse,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.CreateAgentResponse$inboundSchema,
  z.instanceof(ReadableStream<Uint8Array>)
    .transform(stream => {
      return new EventStream(stream, rawEvent => {
        if (rawEvent.data === "[DONE]") return { done: true };
        return {
          value: z.lazy(() =>
            CreateAgentResponseRequestResponseBody$inboundSchema
          ).parse(rawEvent),
        };
      });
    }),
]);
/** @internal */
export type CreateAgentResponseRequestResponse$Outbound =
  | components.CreateAgentResponse$Outbound
  | never;

/** @internal */
export const CreateAgentResponseRequestResponse$outboundSchema: z.ZodType<
  CreateAgentResponseRequestResponse$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestResponse
> = z.union([components.CreateAgentResponse$outboundSchema, z.never()]);

export function createAgentResponseRequestResponseToJSON(
  createAgentResponseRequestResponse: CreateAgentResponseRequestResponse,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestResponse$outboundSchema.parse(
      createAgentResponseRequestResponse,
    ),
  );
}
export function createAgentResponseRequestResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseRequestResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestResponse' from JSON`,
  );
}
