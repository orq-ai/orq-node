/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const RoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type RoleToolMessage = ClosedEnum<typeof RoleToolMessage>;

/**
 * Message from the end user
 */
export const RoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type RoleUserMessage = ClosedEnum<typeof RoleUserMessage>;

/**
 * Message role (user or tool for continuing executions)
 */
export type CreateAgentResponseRequestRole = RoleUserMessage | RoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type PublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type A2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: RoleUserMessage | RoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    components.TextPart | components.FilePart | components.ToolResultPart
  >;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type Contact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type CreateAgentResponseRequestThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type Memory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type CreateAgentResponseRequestRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: A2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: Contact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: CreateAgentResponseRequestThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: Memory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * If true, returns immediately without waiting for completion. If false (default), waits until the agent becomes inactive or errors.
   */
  background?: boolean | undefined;
};

export type CreateAgentResponseRequestRequest = {
  /**
   * The unique key of identifier of the agent to invoke
   */
  agentKey: string;
  requestBody: CreateAgentResponseRequestRequestBody;
};

export const CreateAgentResponseRequestAgentsResponsesRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
export type CreateAgentResponseRequestAgentsResponsesRole = ClosedEnum<
  typeof CreateAgentResponseRequestAgentsResponsesRole
>;

export type Parts =
  | (components.ToolCallPart & { kind: "tool_call" })
  | (components.TextPart & { kind: "text" })
  | (components.DataPart & { kind: "data" })
  | (components.FilePart & { kind: "file" })
  | (components.ToolResultPart & { kind: "tool_result" });

export type Output = {
  messageId: string;
  role: CreateAgentResponseRequestAgentsResponsesRole;
  parts: Array<
    | (components.ToolCallPart & { kind: "tool_call" })
    | (components.TextPart & { kind: "text" })
    | (components.DataPart & { kind: "data" })
    | (components.FilePart & { kind: "file" })
    | (components.ToolResultPart & { kind: "tool_result" })
  >;
  metadata?: { [k: string]: any } | undefined;
};

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the agent execution
 */
export type CreateAgentResponseRequestUsage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | null | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

/**
 * Agent response successfully created and completed. Returns the full conversation including all messages, tool interactions, model used, and token usage statistics. In background mode, returns immediately with initial task details.
 */
export type CreateAgentResponseRequestResponseBody = {
  /**
   * The unique response ID
   */
  id: string;
  /**
   * The agent execution task ID
   */
  taskId: string;
  /**
   * Array of messages from the agent execution
   */
  output: Array<Output>;
  /**
   * ISO timestamp of response creation
   */
  createdAt: string;
  /**
   * Model used in provider/model format
   */
  model: string;
  /**
   * Token usage from the agent execution
   */
  usage?: CreateAgentResponseRequestUsage | null | undefined;
};

/** @internal */
export const RoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = z.nativeEnum(RoleToolMessage);
/** @internal */
export const RoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = RoleToolMessage$inboundSchema;

/** @internal */
export const RoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = z.nativeEnum(RoleUserMessage);
/** @internal */
export const RoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = RoleUserMessage$inboundSchema;

/** @internal */
export const CreateAgentResponseRequestRole$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRole,
  z.ZodTypeDef,
  unknown
> = z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]);
/** @internal */
export type CreateAgentResponseRequestRole$Outbound = string | string;

/** @internal */
export const CreateAgentResponseRequestRole$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRole$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRole
> = z.union([RoleUserMessage$outboundSchema, RoleToolMessage$outboundSchema]);

export function createAgentResponseRequestRoleToJSON(
  createAgentResponseRequestRole: CreateAgentResponseRequestRole,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRole$outboundSchema.parse(
      createAgentResponseRequestRole,
    ),
  );
}
export function createAgentResponseRequestRoleFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRole' from JSON`,
  );
}

/** @internal */
export const PublicMessagePart$inboundSchema: z.ZodType<
  PublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolResultPart$inboundSchema,
]);
/** @internal */
export type PublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound;

/** @internal */
export const PublicMessagePart$outboundSchema: z.ZodType<
  PublicMessagePart$Outbound,
  z.ZodTypeDef,
  PublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
]);

export function publicMessagePartToJSON(
  publicMessagePart: PublicMessagePart,
): string {
  return JSON.stringify(
    PublicMessagePart$outboundSchema.parse(publicMessagePart),
  );
}
export function publicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePart' from JSON`,
  );
}

/** @internal */
export const A2AMessage$inboundSchema: z.ZodType<
  A2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]),
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolResultPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type A2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
  >;
};

/** @internal */
export const A2AMessage$outboundSchema: z.ZodType<
  A2AMessage$Outbound,
  z.ZodTypeDef,
  A2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RoleUserMessage$outboundSchema,
    RoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
    ]),
  ),
});

export function a2AMessageToJSON(a2AMessage: A2AMessage): string {
  return JSON.stringify(A2AMessage$outboundSchema.parse(a2AMessage));
}
export function a2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<A2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => A2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'A2AMessage' from JSON`,
  );
}

/** @internal */
export const Contact$inboundSchema: z.ZodType<Contact, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    display_name: z.string().optional(),
    email: z.string().optional(),
    metadata: z.array(z.record(z.any())).optional(),
    logo_url: z.string().optional(),
    tags: z.array(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
      "logo_url": "logoUrl",
    });
  });
/** @internal */
export type Contact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Contact$outboundSchema: z.ZodType<
  Contact$Outbound,
  z.ZodTypeDef,
  Contact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function contactToJSON(contact: Contact): string {
  return JSON.stringify(Contact$outboundSchema.parse(contact));
}
export function contactFromJSON(
  jsonString: string,
): SafeParseResult<Contact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contact' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestThread$inboundSchema: z.ZodType<
  CreateAgentResponseRequestThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type CreateAgentResponseRequestThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const CreateAgentResponseRequestThread$outboundSchema: z.ZodType<
  CreateAgentResponseRequestThread$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function createAgentResponseRequestThreadToJSON(
  createAgentResponseRequestThread: CreateAgentResponseRequestThread,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestThread$outboundSchema.parse(
      createAgentResponseRequestThread,
    ),
  );
}
export function createAgentResponseRequestThreadFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestThread' from JSON`,
  );
}

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    entity_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entity_id": "entityId",
    });
  });
/** @internal */
export type Memory$Outbound = {
  entity_id: string;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}
export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestRequestBody$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => A2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$inboundSchema).optional(),
  thread: z.lazy(() => CreateAgentResponseRequestThread$inboundSchema)
    .optional(),
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  background: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type CreateAgentResponseRequestRequestBody$Outbound = {
  task_id?: string | undefined;
  message: A2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: Contact$Outbound | undefined;
  thread?: CreateAgentResponseRequestThread$Outbound | undefined;
  memory?: Memory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
  background: boolean;
};

/** @internal */
export const CreateAgentResponseRequestRequestBody$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRequestBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => A2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$outboundSchema).optional(),
  thread: z.lazy(() => CreateAgentResponseRequestThread$outboundSchema)
    .optional(),
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
  background: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function createAgentResponseRequestRequestBodyToJSON(
  createAgentResponseRequestRequestBody: CreateAgentResponseRequestRequestBody,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRequestBody$outboundSchema.parse(
      createAgentResponseRequestRequestBody,
    ),
  );
}
export function createAgentResponseRequestRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseRequestRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRequestBody' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestRequest$inboundSchema: z.ZodType<
  CreateAgentResponseRequestRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  RequestBody: z.lazy(() =>
    CreateAgentResponseRequestRequestBody$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type CreateAgentResponseRequestRequest$Outbound = {
  agent_key: string;
  RequestBody: CreateAgentResponseRequestRequestBody$Outbound;
};

/** @internal */
export const CreateAgentResponseRequestRequest$outboundSchema: z.ZodType<
  CreateAgentResponseRequestRequest$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestRequest
> = z.object({
  agentKey: z.string(),
  requestBody: z.lazy(() =>
    CreateAgentResponseRequestRequestBody$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    requestBody: "RequestBody",
  });
});

export function createAgentResponseRequestRequestToJSON(
  createAgentResponseRequestRequest: CreateAgentResponseRequestRequest,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestRequest$outboundSchema.parse(
      createAgentResponseRequestRequest,
    ),
  );
}
export function createAgentResponseRequestRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestRequest' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestAgentsResponsesRole$inboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseRequestAgentsResponsesRole> = z
    .nativeEnum(CreateAgentResponseRequestAgentsResponsesRole);
/** @internal */
export const CreateAgentResponseRequestAgentsResponsesRole$outboundSchema:
  z.ZodNativeEnum<typeof CreateAgentResponseRequestAgentsResponsesRole> =
    CreateAgentResponseRequestAgentsResponsesRole$inboundSchema;

/** @internal */
export const Parts$inboundSchema: z.ZodType<Parts, z.ZodTypeDef, unknown> = z
  .union([
    components.ToolCallPart$inboundSchema.and(
      z.object({ kind: z.literal("tool_call") }).transform((v) => ({
        kind: v.kind,
      })),
    ),
    components.TextPart$inboundSchema.and(
      z.object({ kind: z.literal("text") }).transform((v) => ({
        kind: v.kind,
      })),
    ),
    components.DataPart$inboundSchema.and(
      z.object({ kind: z.literal("data") }).transform((v) => ({
        kind: v.kind,
      })),
    ),
    components.FilePart$inboundSchema.and(
      z.object({ kind: z.literal("file") }).transform((v) => ({
        kind: v.kind,
      })),
    ),
    components.ToolResultPart$inboundSchema.and(
      z.object({ kind: z.literal("tool_result") }).transform((v) => ({
        kind: v.kind,
      })),
    ),
  ]);
/** @internal */
export type Parts$Outbound =
  | (components.ToolCallPart$Outbound & { kind: "tool_call" })
  | (components.TextPart$Outbound & { kind: "text" })
  | (components.DataPart$Outbound & { kind: "data" })
  | (components.FilePart$Outbound & { kind: "file" })
  | (components.ToolResultPart$Outbound & { kind: "tool_result" });

/** @internal */
export const Parts$outboundSchema: z.ZodType<
  Parts$Outbound,
  z.ZodTypeDef,
  Parts
> = z.union([
  components.ToolCallPart$outboundSchema.and(
    z.object({ kind: z.literal("tool_call") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
  components.TextPart$outboundSchema.and(
    z.object({ kind: z.literal("text") }).transform((v) => ({ kind: v.kind })),
  ),
  components.DataPart$outboundSchema.and(
    z.object({ kind: z.literal("data") }).transform((v) => ({ kind: v.kind })),
  ),
  components.FilePart$outboundSchema.and(
    z.object({ kind: z.literal("file") }).transform((v) => ({ kind: v.kind })),
  ),
  components.ToolResultPart$outboundSchema.and(
    z.object({ kind: z.literal("tool_result") }).transform((v) => ({
      kind: v.kind,
    })),
  ),
]);

export function partsToJSON(parts: Parts): string {
  return JSON.stringify(Parts$outboundSchema.parse(parts));
}
export function partsFromJSON(
  jsonString: string,
): SafeParseResult<Parts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts' from JSON`,
  );
}

/** @internal */
export const Output$inboundSchema: z.ZodType<Output, z.ZodTypeDef, unknown> = z
  .object({
    messageId: z.string(),
    role: CreateAgentResponseRequestAgentsResponsesRole$inboundSchema,
    parts: z.array(
      z.union([
        components.ToolCallPart$inboundSchema.and(
          z.object({ kind: z.literal("tool_call") }).transform((v) => ({
            kind: v.kind,
          })),
        ),
        components.TextPart$inboundSchema.and(
          z.object({ kind: z.literal("text") }).transform((v) => ({
            kind: v.kind,
          })),
        ),
        components.DataPart$inboundSchema.and(
          z.object({ kind: z.literal("data") }).transform((v) => ({
            kind: v.kind,
          })),
        ),
        components.FilePart$inboundSchema.and(
          z.object({ kind: z.literal("file") }).transform((v) => ({
            kind: v.kind,
          })),
        ),
        components.ToolResultPart$inboundSchema.and(
          z.object({ kind: z.literal("tool_result") }).transform((v) => ({
            kind: v.kind,
          })),
        ),
      ]),
    ),
    metadata: z.record(z.any()).optional(),
  });
/** @internal */
export type Output$Outbound = {
  messageId: string;
  role: string;
  parts: Array<
    | (components.ToolCallPart$Outbound & { kind: "tool_call" })
    | (components.TextPart$Outbound & { kind: "text" })
    | (components.DataPart$Outbound & { kind: "data" })
    | (components.FilePart$Outbound & { kind: "file" })
    | (components.ToolResultPart$Outbound & { kind: "tool_result" })
  >;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const Output$outboundSchema: z.ZodType<
  Output$Outbound,
  z.ZodTypeDef,
  Output
> = z.object({
  messageId: z.string(),
  role: CreateAgentResponseRequestAgentsResponsesRole$outboundSchema,
  parts: z.array(
    z.union([
      components.ToolCallPart$outboundSchema.and(
        z.object({ kind: z.literal("tool_call") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      components.TextPart$outboundSchema.and(
        z.object({ kind: z.literal("text") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      components.DataPart$outboundSchema.and(
        z.object({ kind: z.literal("data") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      components.FilePart$outboundSchema.and(
        z.object({ kind: z.literal("file") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
      components.ToolResultPart$outboundSchema.and(
        z.object({ kind: z.literal("tool_result") }).transform((v) => ({
          kind: v.kind,
        })),
      ),
    ]),
  ),
  metadata: z.record(z.any()).optional(),
});

export function outputToJSON(output: Output): string {
  return JSON.stringify(Output$outboundSchema.parse(output));
}
export function outputFromJSON(
  jsonString: string,
): SafeParseResult<Output, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Output$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Output' from JSON`,
  );
}

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type PromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const PromptTokensDetails$outboundSchema: z.ZodType<
  PromptTokensDetails$Outbound,
  z.ZodTypeDef,
  PromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    audioTokens: "audio_tokens",
  });
});

export function promptTokensDetailsToJSON(
  promptTokensDetails: PromptTokensDetails,
): string {
  return JSON.stringify(
    PromptTokensDetails$outboundSchema.parse(promptTokensDetails),
  );
}
export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type CompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CompletionTokensDetails$outboundSchema: z.ZodType<
  CompletionTokensDetails$Outbound,
  z.ZodTypeDef,
  CompletionTokensDetails
> = z.object({
  reasoningTokens: z.nullable(z.number()).optional(),
  acceptedPredictionTokens: z.nullable(z.number()).optional(),
  rejectedPredictionTokens: z.nullable(z.number()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningTokens: "reasoning_tokens",
    acceptedPredictionTokens: "accepted_prediction_tokens",
    rejectedPredictionTokens: "rejected_prediction_tokens",
    audioTokens: "audio_tokens",
  });
});

export function completionTokensDetailsToJSON(
  completionTokensDetails: CompletionTokensDetails,
): string {
  return JSON.stringify(
    CompletionTokensDetails$outboundSchema.parse(completionTokensDetails),
  );
}
export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestUsage$inboundSchema: z.ZodType<
  CreateAgentResponseRequestUsage,
  z.ZodTypeDef,
  unknown
> = z.object({
  completion_tokens: z.number().optional(),
  prompt_tokens: z.number().optional(),
  total_tokens: z.number().optional(),
  prompt_tokens_details: z.nullable(
    z.lazy(() => PromptTokensDetails$inboundSchema),
  ).optional(),
  completion_tokens_details: z.nullable(
    z.lazy(() => CompletionTokensDetails$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "completion_tokens": "completionTokens",
    "prompt_tokens": "promptTokens",
    "total_tokens": "totalTokens",
    "prompt_tokens_details": "promptTokensDetails",
    "completion_tokens_details": "completionTokensDetails",
  });
});
/** @internal */
export type CreateAgentResponseRequestUsage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?: PromptTokensDetails$Outbound | null | undefined;
  completion_tokens_details?:
    | CompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const CreateAgentResponseRequestUsage$outboundSchema: z.ZodType<
  CreateAgentResponseRequestUsage$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestUsage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => PromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => CompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function createAgentResponseRequestUsageToJSON(
  createAgentResponseRequestUsage: CreateAgentResponseRequestUsage,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestUsage$outboundSchema.parse(
      createAgentResponseRequestUsage,
    ),
  );
}
export function createAgentResponseRequestUsageFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestUsage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponseRequestUsage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestUsage' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponseRequestResponseBody$inboundSchema: z.ZodType<
  CreateAgentResponseRequestResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  task_id: z.string(),
  output: z.array(z.lazy(() => Output$inboundSchema)),
  created_at: z.string(),
  model: z.string(),
  usage: z.nullable(z.lazy(() => CreateAgentResponseRequestUsage$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "task_id": "taskId",
    "created_at": "createdAt",
  });
});
/** @internal */
export type CreateAgentResponseRequestResponseBody$Outbound = {
  _id: string;
  task_id: string;
  output: Array<Output$Outbound>;
  created_at: string;
  model: string;
  usage?: CreateAgentResponseRequestUsage$Outbound | null | undefined;
};

/** @internal */
export const CreateAgentResponseRequestResponseBody$outboundSchema: z.ZodType<
  CreateAgentResponseRequestResponseBody$Outbound,
  z.ZodTypeDef,
  CreateAgentResponseRequestResponseBody
> = z.object({
  id: z.string(),
  taskId: z.string(),
  output: z.array(z.lazy(() => Output$outboundSchema)),
  createdAt: z.string(),
  model: z.string(),
  usage: z.nullable(
    z.lazy(() => CreateAgentResponseRequestUsage$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    taskId: "task_id",
    createdAt: "created_at",
  });
});

export function createAgentResponseRequestResponseBodyToJSON(
  createAgentResponseRequestResponseBody:
    CreateAgentResponseRequestResponseBody,
): string {
  return JSON.stringify(
    CreateAgentResponseRequestResponseBody$outboundSchema.parse(
      createAgentResponseRequestResponseBody,
    ),
  );
}
export function createAgentResponseRequestResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponseRequestResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      CreateAgentResponseRequestResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponseRequestResponseBody' from JSON`,
  );
}
