/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type GetAgentRequest = {
  /**
   * The unique key of the agent to retrieve
   */
  agentKey: string;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const GetAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type GetAgentStatus = ClosedEnum<typeof GetAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const GetAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type GetAgentToolApprovalRequired = ClosedEnum<
  typeof GetAgentToolApprovalRequired
>;

export type GetAgentConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type GetAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<GetAgentConditions> | undefined;
  /**
   * Optional MCP server reference for tools from MCP servers
   */
  mcpServer?: string | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const GetAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type GetAgentExecuteOn = ClosedEnum<typeof GetAgentExecuteOn>;

export type GetAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: GetAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const GetAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type GetAgentAgentsExecuteOn = ClosedEnum<
  typeof GetAgentAgentsExecuteOn
>;

export type GetAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: GetAgentAgentsExecuteOn;
};

export type GetAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: GetAgentToolApprovalRequired | undefined;
  tools?: Array<GetAgentTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<GetAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<GetAgentGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const GetAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type GetAgentVoice = ClosedEnum<typeof GetAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const GetAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type GetAgentFormat = ClosedEnum<typeof GetAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type GetAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: GetAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: GetAgentFormat;
};

export const GetAgentResponseFormatAgentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type GetAgentResponseFormatAgentsResponseType = ClosedEnum<
  typeof GetAgentResponseFormatAgentsResponseType
>;

export type GetAgentResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type GetAgentResponseFormatAgentsJSONSchema = {
  type: GetAgentResponseFormatAgentsResponseType;
  jsonSchema: GetAgentResponseFormatJsonSchema;
};

export const GetAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type GetAgentResponseFormatAgentsType = ClosedEnum<
  typeof GetAgentResponseFormatAgentsType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type GetAgentResponseFormatJSONObject = {
  type: GetAgentResponseFormatAgentsType;
};

export const GetAgentResponseFormatType = {
  Text: "text",
} as const;
export type GetAgentResponseFormatType = ClosedEnum<
  typeof GetAgentResponseFormatType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type GetAgentResponseFormatText = {
  type: GetAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type GetAgentResponseFormat =
  | GetAgentResponseFormatAgentsJSONSchema
  | GetAgentResponseFormatText
  | GetAgentResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type GetAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type GetAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const GetAgentType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type GetAgentType = ClosedEnum<typeof GetAgentType>;

export type GetAgentThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: GetAgentType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const GetAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type GetAgentToolChoiceType = ClosedEnum<typeof GetAgentToolChoiceType>;

export type GetAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type GetAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: GetAgentToolChoiceType | undefined;
  function: GetAgentToolChoiceFunction;
};

export const GetAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type GetAgentToolChoice1 = ClosedEnum<typeof GetAgentToolChoice1>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type GetAgentToolChoice = GetAgentToolChoice2 | GetAgentToolChoice1;

export const GetAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type GetAgentModalities = ClosedEnum<typeof GetAgentModalities>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type GetAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: GetAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | GetAgentResponseFormatAgentsJSONSchema
    | GetAgentResponseFormatText
    | GetAgentResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: GetAgentStreamOptions | null | undefined;
  thinking?: GetAgentThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?: GetAgentToolChoice2 | GetAgentToolChoice1 | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<GetAgentModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type GetAgentRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const GetAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type GetAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof GetAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const GetAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type GetAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof GetAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type GetAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: GetAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: GetAgentFallbackModelConfigurationFormat;
};

export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  >;

export type GetAgentResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type GetAgentResponseFormatAgentsResponse200JSONSchema = {
  type: GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType;
  jsonSchema: GetAgentResponseFormatAgentsResponseJsonSchema;
};

export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType = {
  JsonObject: "json_object",
} as const;
export type GetAgentResponseFormatAgentsResponse200ApplicationJSONType =
  ClosedEnum<typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type GetAgentResponseFormatAgentsJSONObject = {
  type: GetAgentResponseFormatAgentsResponse200ApplicationJSONType;
};

export const GetAgentResponseFormatAgentsResponse200Type = {
  Text: "text",
} as const;
export type GetAgentResponseFormatAgentsResponse200Type = ClosedEnum<
  typeof GetAgentResponseFormatAgentsResponse200Type
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type GetAgentResponseFormatAgentsText = {
  type: GetAgentResponseFormatAgentsResponse200Type;
};

/**
 * An object specifying the format that the model must output
 */
export type GetAgentFallbackModelConfigurationResponseFormat =
  | GetAgentResponseFormatAgentsResponse200JSONSchema
  | GetAgentResponseFormatAgentsText
  | GetAgentResponseFormatAgentsJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type GetAgentFallbackModelConfigurationStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type GetAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const GetAgentFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type GetAgentFallbackModelConfigurationType = ClosedEnum<
  typeof GetAgentFallbackModelConfigurationType
>;

export type GetAgentFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: GetAgentFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const GetAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type GetAgentToolChoiceAgentsType = ClosedEnum<
  typeof GetAgentToolChoiceAgentsType
>;

export type GetAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type GetAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: GetAgentToolChoiceAgentsType | undefined;
  function: GetAgentToolChoiceAgentsFunction;
};

export const GetAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type GetAgentToolChoiceAgents1 = ClosedEnum<
  typeof GetAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type GetAgentFallbackModelConfigurationToolChoice =
  | GetAgentToolChoiceAgents2
  | GetAgentToolChoiceAgents1;

export const GetAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type GetAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof GetAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type GetAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: GetAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | GetAgentResponseFormatAgentsResponse200JSONSchema
    | GetAgentResponseFormatAgentsText
    | GetAgentResponseFormatAgentsJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | GetAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: GetAgentFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | GetAgentToolChoiceAgents2
    | GetAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<GetAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type GetAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: GetAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type GetAgentFallbackModelConfiguration =
  | GetAgentFallbackModelConfiguration2
  | string;

export type GetAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: GetAgentParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: GetAgentRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<GetAgentFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type GetAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type GetAgentMetrics = {
  totalCost?: number | undefined;
};

export type GetAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

/**
 * Agent retrieved successfully
 */
export type GetAgentResponseBody = {
  id: string;
  key: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: GetAgentStatus;
  settings?: GetAgentSettings | undefined;
  model: GetAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<GetAgentTeamOfAgents>;
  metrics?: GetAgentMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<GetAgentKnowledgeBases> | undefined;
};

/** @internal */
export const GetAgentRequest$inboundSchema: z.ZodType<
  GetAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
  });
});
/** @internal */
export type GetAgentRequest$Outbound = {
  agent_key: string;
};

/** @internal */
export const GetAgentRequest$outboundSchema: z.ZodType<
  GetAgentRequest$Outbound,
  z.ZodTypeDef,
  GetAgentRequest
> = z.object({
  agentKey: z.string(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
  });
});

export function getAgentRequestToJSON(
  getAgentRequest: GetAgentRequest,
): string {
  return JSON.stringify(GetAgentRequest$outboundSchema.parse(getAgentRequest));
}
export function getAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentRequest' from JSON`,
  );
}

/** @internal */
export const GetAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentStatus
> = z.nativeEnum(GetAgentStatus);
/** @internal */
export const GetAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentStatus
> = GetAgentStatus$inboundSchema;

/** @internal */
export const GetAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolApprovalRequired
> = z.nativeEnum(GetAgentToolApprovalRequired);
/** @internal */
export const GetAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolApprovalRequired
> = GetAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const GetAgentConditions$inboundSchema: z.ZodType<
  GetAgentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type GetAgentConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const GetAgentConditions$outboundSchema: z.ZodType<
  GetAgentConditions$Outbound,
  z.ZodTypeDef,
  GetAgentConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function getAgentConditionsToJSON(
  getAgentConditions: GetAgentConditions,
): string {
  return JSON.stringify(
    GetAgentConditions$outboundSchema.parse(getAgentConditions),
  );
}
export function getAgentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentConditions' from JSON`,
  );
}

/** @internal */
export const GetAgentTools$inboundSchema: z.ZodType<
  GetAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => GetAgentConditions$inboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type GetAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<GetAgentConditions$Outbound> | undefined;
  mcpServer?: string | undefined;
  timeout: number;
};

/** @internal */
export const GetAgentTools$outboundSchema: z.ZodType<
  GetAgentTools$Outbound,
  z.ZodTypeDef,
  GetAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => GetAgentConditions$outboundSchema))
    .optional(),
  mcpServer: z.string().optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function getAgentToolsToJSON(getAgentTools: GetAgentTools): string {
  return JSON.stringify(GetAgentTools$outboundSchema.parse(getAgentTools));
}
export function getAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentTools' from JSON`,
  );
}

/** @internal */
export const GetAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentExecuteOn
> = z.nativeEnum(GetAgentExecuteOn);
/** @internal */
export const GetAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentExecuteOn
> = GetAgentExecuteOn$inboundSchema;

/** @internal */
export const GetAgentEvaluators$inboundSchema: z.ZodType<
  GetAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: GetAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type GetAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const GetAgentEvaluators$outboundSchema: z.ZodType<
  GetAgentEvaluators$Outbound,
  z.ZodTypeDef,
  GetAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: GetAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function getAgentEvaluatorsToJSON(
  getAgentEvaluators: GetAgentEvaluators,
): string {
  return JSON.stringify(
    GetAgentEvaluators$outboundSchema.parse(getAgentEvaluators),
  );
}
export function getAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const GetAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentAgentsExecuteOn
> = z.nativeEnum(GetAgentAgentsExecuteOn);
/** @internal */
export const GetAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentAgentsExecuteOn
> = GetAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const GetAgentGuardrails$inboundSchema: z.ZodType<
  GetAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: GetAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type GetAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const GetAgentGuardrails$outboundSchema: z.ZodType<
  GetAgentGuardrails$Outbound,
  z.ZodTypeDef,
  GetAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: GetAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function getAgentGuardrailsToJSON(
  getAgentGuardrails: GetAgentGuardrails,
): string {
  return JSON.stringify(
    GetAgentGuardrails$outboundSchema.parse(getAgentGuardrails),
  );
}
export function getAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const GetAgentSettings$inboundSchema: z.ZodType<
  GetAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: GetAgentToolApprovalRequired$inboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => GetAgentTools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => GetAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => GetAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type GetAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<GetAgentTools$Outbound> | undefined;
  evaluators?: Array<GetAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<GetAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const GetAgentSettings$outboundSchema: z.ZodType<
  GetAgentSettings$Outbound,
  z.ZodTypeDef,
  GetAgentSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: GetAgentToolApprovalRequired$outboundSchema.default(
    "respect_tool",
  ),
  tools: z.array(z.lazy(() => GetAgentTools$outboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => GetAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => GetAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function getAgentSettingsToJSON(
  getAgentSettings: GetAgentSettings,
): string {
  return JSON.stringify(
    GetAgentSettings$outboundSchema.parse(getAgentSettings),
  );
}
export function getAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentSettings' from JSON`,
  );
}

/** @internal */
export const GetAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentVoice
> = z.nativeEnum(GetAgentVoice);
/** @internal */
export const GetAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentVoice
> = GetAgentVoice$inboundSchema;

/** @internal */
export const GetAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentFormat
> = z.nativeEnum(GetAgentFormat);
/** @internal */
export const GetAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentFormat
> = GetAgentFormat$inboundSchema;

/** @internal */
export const GetAgentAudio$inboundSchema: z.ZodType<
  GetAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: GetAgentVoice$inboundSchema,
  format: GetAgentFormat$inboundSchema,
});
/** @internal */
export type GetAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const GetAgentAudio$outboundSchema: z.ZodType<
  GetAgentAudio$Outbound,
  z.ZodTypeDef,
  GetAgentAudio
> = z.object({
  voice: GetAgentVoice$outboundSchema,
  format: GetAgentFormat$outboundSchema,
});

export function getAgentAudioToJSON(getAgentAudio: GetAgentAudio): string {
  return JSON.stringify(GetAgentAudio$outboundSchema.parse(getAgentAudio));
}
export function getAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentAudio' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponseType> = z
    .nativeEnum(GetAgentResponseFormatAgentsResponseType);
/** @internal */
export const GetAgentResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponseType> =
    GetAgentResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatJsonSchema$inboundSchema: z.ZodType<
  GetAgentResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});
/** @internal */
export type GetAgentResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const GetAgentResponseFormatJsonSchema$outboundSchema: z.ZodType<
  GetAgentResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.boolean().optional(),
});

export function getAgentResponseFormatJsonSchemaToJSON(
  getAgentResponseFormatJsonSchema: GetAgentResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatJsonSchema$outboundSchema.parse(
      getAgentResponseFormatJsonSchema,
    ),
  );
}
export function getAgentResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsJSONSchema$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJSONSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsResponseType$inboundSchema,
  json_schema: z.lazy(() => GetAgentResponseFormatJsonSchema$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type GetAgentResponseFormatAgentsJSONSchema$Outbound = {
  type: string;
  json_schema: GetAgentResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const GetAgentResponseFormatAgentsJSONSchema$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJSONSchema$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgentsJSONSchema
> = z.object({
  type: GetAgentResponseFormatAgentsResponseType$outboundSchema,
  jsonSchema: z.lazy(() => GetAgentResponseFormatJsonSchema$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    jsonSchema: "json_schema",
  });
});

export function getAgentResponseFormatAgentsJSONSchemaToJSON(
  getAgentResponseFormatAgentsJSONSchema:
    GetAgentResponseFormatAgentsJSONSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsJSONSchema$outboundSchema.parse(
      getAgentResponseFormatAgentsJSONSchema,
    ),
  );
}
export function getAgentResponseFormatAgentsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgentsJSONSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentResponseFormatAgentsJSONSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgentsJSONSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatAgentsType
> = z.nativeEnum(GetAgentResponseFormatAgentsType);
/** @internal */
export const GetAgentResponseFormatAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatAgentsType
> = GetAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  GetAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  GetAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatJSONObject
> = z.object({
  type: GetAgentResponseFormatAgentsType$outboundSchema,
});

export function getAgentResponseFormatJSONObjectToJSON(
  getAgentResponseFormatJSONObject: GetAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    GetAgentResponseFormatJSONObject$outboundSchema.parse(
      getAgentResponseFormatJSONObject,
    ),
  );
}
export function getAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatType
> = z.nativeEnum(GetAgentResponseFormatType);
/** @internal */
export const GetAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentResponseFormatType
> = GetAgentResponseFormatType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatText$inboundSchema: z.ZodType<
  GetAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatText$outboundSchema: z.ZodType<
  GetAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatText
> = z.object({
  type: GetAgentResponseFormatType$outboundSchema,
});

export function getAgentResponseFormatTextToJSON(
  getAgentResponseFormatText: GetAgentResponseFormatText,
): string {
  return JSON.stringify(
    GetAgentResponseFormatText$outboundSchema.parse(getAgentResponseFormatText),
  );
}
export function getAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormat$inboundSchema: z.ZodType<
  GetAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentResponseFormatAgentsJSONSchema$inboundSchema),
  z.lazy(() => GetAgentResponseFormatText$inboundSchema),
  z.lazy(() => GetAgentResponseFormatJSONObject$inboundSchema),
]);
/** @internal */
export type GetAgentResponseFormat$Outbound =
  | GetAgentResponseFormatAgentsJSONSchema$Outbound
  | GetAgentResponseFormatText$Outbound
  | GetAgentResponseFormatJSONObject$Outbound;

/** @internal */
export const GetAgentResponseFormat$outboundSchema: z.ZodType<
  GetAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormat
> = z.union([
  z.lazy(() => GetAgentResponseFormatAgentsJSONSchema$outboundSchema),
  z.lazy(() => GetAgentResponseFormatText$outboundSchema),
  z.lazy(() => GetAgentResponseFormatJSONObject$outboundSchema),
]);

export function getAgentResponseFormatToJSON(
  getAgentResponseFormat: GetAgentResponseFormat,
): string {
  return JSON.stringify(
    GetAgentResponseFormat$outboundSchema.parse(getAgentResponseFormat),
  );
}
export function getAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAgentStop$inboundSchema: z.ZodType<
  GetAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type GetAgentStop$Outbound = string | Array<string>;

/** @internal */
export const GetAgentStop$outboundSchema: z.ZodType<
  GetAgentStop$Outbound,
  z.ZodTypeDef,
  GetAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function getAgentStopToJSON(getAgentStop: GetAgentStop): string {
  return JSON.stringify(GetAgentStop$outboundSchema.parse(getAgentStop));
}
export function getAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentStop' from JSON`,
  );
}

/** @internal */
export const GetAgentStreamOptions$inboundSchema: z.ZodType<
  GetAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type GetAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const GetAgentStreamOptions$outboundSchema: z.ZodType<
  GetAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  GetAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function getAgentStreamOptionsToJSON(
  getAgentStreamOptions: GetAgentStreamOptions,
): string {
  return JSON.stringify(
    GetAgentStreamOptions$outboundSchema.parse(getAgentStreamOptions),
  );
}
export function getAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentType$inboundSchema: z.ZodNativeEnum<typeof GetAgentType> =
  z.nativeEnum(GetAgentType);
/** @internal */
export const GetAgentType$outboundSchema: z.ZodNativeEnum<typeof GetAgentType> =
  GetAgentType$inboundSchema;

/** @internal */
export const GetAgentThinking$inboundSchema: z.ZodType<
  GetAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentType$inboundSchema,
  budget_tokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
  });
});
/** @internal */
export type GetAgentThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const GetAgentThinking$outboundSchema: z.ZodType<
  GetAgentThinking$Outbound,
  z.ZodTypeDef,
  GetAgentThinking
> = z.object({
  type: GetAgentType$outboundSchema,
  budgetTokens: z.number(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
  });
});

export function getAgentThinkingToJSON(
  getAgentThinking: GetAgentThinking,
): string {
  return JSON.stringify(
    GetAgentThinking$outboundSchema.parse(getAgentThinking),
  );
}
export function getAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentThinking' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceType
> = z.nativeEnum(GetAgentToolChoiceType);
/** @internal */
export const GetAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceType
> = GetAgentToolChoiceType$inboundSchema;

/** @internal */
export const GetAgentToolChoiceFunction$inboundSchema: z.ZodType<
  GetAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type GetAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const GetAgentToolChoiceFunction$outboundSchema: z.ZodType<
  GetAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function getAgentToolChoiceFunctionToJSON(
  getAgentToolChoiceFunction: GetAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    GetAgentToolChoiceFunction$outboundSchema.parse(getAgentToolChoiceFunction),
  );
}
export function getAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoice2$inboundSchema: z.ZodType<
  GetAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type GetAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: GetAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const GetAgentToolChoice2$outboundSchema: z.ZodType<
  GetAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoice2
> = z.object({
  type: GetAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceFunction$outboundSchema),
});

export function getAgentToolChoice2ToJSON(
  getAgentToolChoice2: GetAgentToolChoice2,
): string {
  return JSON.stringify(
    GetAgentToolChoice2$outboundSchema.parse(getAgentToolChoice2),
  );
}
export function getAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoice1
> = z.nativeEnum(GetAgentToolChoice1);
/** @internal */
export const GetAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoice1
> = GetAgentToolChoice1$inboundSchema;

/** @internal */
export const GetAgentToolChoice$inboundSchema: z.ZodType<
  GetAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentToolChoice2$inboundSchema),
  GetAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type GetAgentToolChoice$Outbound = GetAgentToolChoice2$Outbound | string;

/** @internal */
export const GetAgentToolChoice$outboundSchema: z.ZodType<
  GetAgentToolChoice$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoice
> = z.union([
  z.lazy(() => GetAgentToolChoice2$outboundSchema),
  GetAgentToolChoice1$outboundSchema,
]);

export function getAgentToolChoiceToJSON(
  getAgentToolChoice: GetAgentToolChoice,
): string {
  return JSON.stringify(
    GetAgentToolChoice$outboundSchema.parse(getAgentToolChoice),
  );
}
export function getAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const GetAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentModalities
> = z.nativeEnum(GetAgentModalities);
/** @internal */
export const GetAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentModalities
> = GetAgentModalities$inboundSchema;

/** @internal */
export const GetAgentParameters$inboundSchema: z.ZodType<
  GetAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => GetAgentResponseFormatAgentsJSONSchema$inboundSchema),
    z.lazy(() => GetAgentResponseFormatText$inboundSchema),
    z.lazy(() => GetAgentResponseFormatJSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(z.lazy(() => GetAgentStreamOptions$inboundSchema))
    .optional(),
  thinking: z.lazy(() => GetAgentThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => GetAgentToolChoice2$inboundSchema),
    GetAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(GetAgentModalities$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type GetAgentParameters$Outbound = {
  audio?: GetAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | GetAgentResponseFormatAgentsJSONSchema$Outbound
    | GetAgentResponseFormatText$Outbound
    | GetAgentResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: GetAgentStreamOptions$Outbound | null | undefined;
  thinking?: GetAgentThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: GetAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const GetAgentParameters$outboundSchema: z.ZodType<
  GetAgentParameters$Outbound,
  z.ZodTypeDef,
  GetAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => GetAgentAudio$outboundSchema)).optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => GetAgentResponseFormatAgentsJSONSchema$outboundSchema),
    z.lazy(() => GetAgentResponseFormatText$outboundSchema),
    z.lazy(() => GetAgentResponseFormatJSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(z.lazy(() => GetAgentStreamOptions$outboundSchema))
    .optional(),
  thinking: z.lazy(() => GetAgentThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => GetAgentToolChoice2$outboundSchema),
    GetAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(GetAgentModalities$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function getAgentParametersToJSON(
  getAgentParameters: GetAgentParameters,
): string {
  return JSON.stringify(
    GetAgentParameters$outboundSchema.parse(getAgentParameters),
  );
}
export function getAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentParameters' from JSON`,
  );
}

/** @internal */
export const GetAgentRetry$inboundSchema: z.ZodType<
  GetAgentRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type GetAgentRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const GetAgentRetry$outboundSchema: z.ZodType<
  GetAgentRetry$Outbound,
  z.ZodTypeDef,
  GetAgentRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function getAgentRetryToJSON(getAgentRetry: GetAgentRetry): string {
  return JSON.stringify(GetAgentRetry$outboundSchema.parse(getAgentRetry));
}
export function getAgentRetryFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentRetry' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(GetAgentFallbackModelConfigurationVoice);
/** @internal */
export const GetAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationVoice> =
    GetAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const GetAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(GetAgentFallbackModelConfigurationFormat);
/** @internal */
export const GetAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationFormat> =
    GetAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const GetAgentFallbackModelConfigurationAudio$inboundSchema: z.ZodType<
  GetAgentFallbackModelConfigurationAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: GetAgentFallbackModelConfigurationVoice$inboundSchema,
  format: GetAgentFallbackModelConfigurationFormat$inboundSchema,
});
/** @internal */
export type GetAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const GetAgentFallbackModelConfigurationAudio$outboundSchema: z.ZodType<
  GetAgentFallbackModelConfigurationAudio$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelConfigurationAudio
> = z.object({
  voice: GetAgentFallbackModelConfigurationVoice$outboundSchema,
  format: GetAgentFallbackModelConfigurationFormat$outboundSchema,
});

export function getAgentFallbackModelConfigurationAudioToJSON(
  getAgentFallbackModelConfigurationAudio:
    GetAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      getAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function getAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType,
  );
/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType
  > =
    GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    GetAgentResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });
/** @internal */
export type GetAgentResponseFormatAgentsResponseJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | undefined;
};

/** @internal */
export const GetAgentResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    GetAgentResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    GetAgentResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.boolean().optional(),
  });

export function getAgentResponseFormatAgentsResponseJsonSchemaToJSON(
  getAgentResponseFormatAgentsResponseJsonSchema:
    GetAgentResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsResponseJsonSchema$outboundSchema.parse(
      getAgentResponseFormatAgentsResponseJsonSchema,
    ),
  );
}
export function getAgentResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema:
  z.ZodType<
    GetAgentResponseFormatAgentsResponse200JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$inboundSchema,
    json_schema: z.lazy(() =>
      GetAgentResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type GetAgentResponseFormatAgentsResponse200JSONSchema$Outbound = {
  type: string;
  json_schema: GetAgentResponseFormatAgentsResponseJsonSchema$Outbound;
};

/** @internal */
export const GetAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema:
  z.ZodType<
    GetAgentResponseFormatAgentsResponse200JSONSchema$Outbound,
    z.ZodTypeDef,
    GetAgentResponseFormatAgentsResponse200JSONSchema
  > = z.object({
    type:
      GetAgentResponseFormatAgentsResponse200ApplicationJSONResponseBodyType$outboundSchema,
    jsonSchema: z.lazy(() =>
      GetAgentResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function getAgentResponseFormatAgentsResponse200JSONSchemaToJSON(
  getAgentResponseFormatAgentsResponse200JSONSchema:
    GetAgentResponseFormatAgentsResponse200JSONSchema,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema.parse(
      getAgentResponseFormatAgentsResponse200JSONSchema,
    ),
  );
}
export function getAgentResponseFormatAgentsResponse200JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentResponseFormatAgentsResponse200JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentResponseFormatAgentsResponse200JSONSchema' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType
  > = z.nativeEnum(GetAgentResponseFormatAgentsResponse200ApplicationJSONType);
/** @internal */
export const GetAgentResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof GetAgentResponseFormatAgentsResponse200ApplicationJSONType
  > = GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgentsJSONObject$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONType$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatAgentsJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatAgentsJSONObject$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsJSONObject$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgentsJSONObject
> = z.object({
  type:
    GetAgentResponseFormatAgentsResponse200ApplicationJSONType$outboundSchema,
});

export function getAgentResponseFormatAgentsJSONObjectToJSON(
  getAgentResponseFormatAgentsJSONObject:
    GetAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      getAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function getAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgentsJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentResponseFormatAgentsJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseFormatAgentsResponse200Type$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponse200Type> = z
    .nativeEnum(GetAgentResponseFormatAgentsResponse200Type);
/** @internal */
export const GetAgentResponseFormatAgentsResponse200Type$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentResponseFormatAgentsResponse200Type> =
    GetAgentResponseFormatAgentsResponse200Type$inboundSchema;

/** @internal */
export const GetAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentResponseFormatAgentsResponse200Type$inboundSchema,
});
/** @internal */
export type GetAgentResponseFormatAgentsText$Outbound = {
  type: string;
};

/** @internal */
export const GetAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  GetAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  GetAgentResponseFormatAgentsText
> = z.object({
  type: GetAgentResponseFormatAgentsResponse200Type$outboundSchema,
});

export function getAgentResponseFormatAgentsTextToJSON(
  getAgentResponseFormatAgentsText: GetAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    GetAgentResponseFormatAgentsText$outboundSchema.parse(
      getAgentResponseFormatAgentsText,
    ),
  );
}
export function getAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() =>
      GetAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
    ),
    z.lazy(() => GetAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => GetAgentResponseFormatAgentsJSONObject$inboundSchema),
  ]);
/** @internal */
export type GetAgentFallbackModelConfigurationResponseFormat$Outbound =
  | GetAgentResponseFormatAgentsResponse200JSONSchema$Outbound
  | GetAgentResponseFormatAgentsText$Outbound
  | GetAgentResponseFormatAgentsJSONObject$Outbound;

/** @internal */
export const GetAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    GetAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() =>
      GetAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema
    ),
    z.lazy(() => GetAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => GetAgentResponseFormatAgentsJSONObject$outboundSchema),
  ]);

export function getAgentFallbackModelConfigurationResponseFormatToJSON(
  getAgentFallbackModelConfigurationResponseFormat:
    GetAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      getAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function getAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationResponseFormat$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationStop$inboundSchema: z.ZodType<
  GetAgentFallbackModelConfigurationStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type GetAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const GetAgentFallbackModelConfigurationStop$outboundSchema: z.ZodType<
  GetAgentFallbackModelConfigurationStop$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelConfigurationStop
> = z.union([z.string(), z.array(z.string())]);

export function getAgentFallbackModelConfigurationStopToJSON(
  getAgentFallbackModelConfigurationStop:
    GetAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationStop$outboundSchema.parse(
      getAgentFallbackModelConfigurationStop,
    ),
  );
}
export function getAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelConfigurationStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type GetAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const GetAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    GetAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function getAgentFallbackModelConfigurationStreamOptionsToJSON(
  getAgentFallbackModelConfigurationStreamOptions:
    GetAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      getAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function getAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationType> = z.nativeEnum(
    GetAgentFallbackModelConfigurationType,
  );
/** @internal */
export const GetAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationType> =
    GetAgentFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const GetAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<GetAgentFallbackModelConfigurationThinking, z.ZodTypeDef, unknown> =
    z.object({
      type: GetAgentFallbackModelConfigurationType$inboundSchema,
      budget_tokens: z.number(),
    }).transform((v) => {
      return remap$(v, {
        "budget_tokens": "budgetTokens",
      });
    });
/** @internal */
export type GetAgentFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
};

/** @internal */
export const GetAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    GetAgentFallbackModelConfigurationThinking
  > = z.object({
    type: GetAgentFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
    });
  });

export function getAgentFallbackModelConfigurationThinkingToJSON(
  getAgentFallbackModelConfigurationThinking:
    GetAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      getAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function getAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgentsType
> = z.nativeEnum(GetAgentToolChoiceAgentsType);
/** @internal */
export const GetAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgentsType
> = GetAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const GetAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  GetAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type GetAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const GetAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  GetAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function getAgentToolChoiceAgentsFunctionToJSON(
  getAgentToolChoiceAgentsFunction: GetAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    GetAgentToolChoiceAgentsFunction$outboundSchema.parse(
      getAgentToolChoiceAgentsFunction,
    ),
  );
}
export function getAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  GetAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: GetAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type GetAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: GetAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const GetAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  GetAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  GetAgentToolChoiceAgents2
> = z.object({
  type: GetAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => GetAgentToolChoiceAgentsFunction$outboundSchema),
});

export function getAgentToolChoiceAgents2ToJSON(
  getAgentToolChoiceAgents2: GetAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    GetAgentToolChoiceAgents2$outboundSchema.parse(getAgentToolChoiceAgents2),
  );
}
export function getAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const GetAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgents1
> = z.nativeEnum(GetAgentToolChoiceAgents1);
/** @internal */
export const GetAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof GetAgentToolChoiceAgents1
> = GetAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const GetAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => GetAgentToolChoiceAgents2$inboundSchema),
    GetAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type GetAgentFallbackModelConfigurationToolChoice$Outbound =
  | GetAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const GetAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    GetAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => GetAgentToolChoiceAgents2$outboundSchema),
    GetAgentToolChoiceAgents1$outboundSchema,
  ]);

export function getAgentFallbackModelConfigurationToolChoiceToJSON(
  getAgentFallbackModelConfigurationToolChoice:
    GetAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      getAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function getAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(GetAgentFallbackModelConfigurationModalities);
/** @internal */
export const GetAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof GetAgentFallbackModelConfigurationModalities> =
    GetAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const GetAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => GetAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        GetAgentResponseFormatAgentsResponse200JSONSchema$inboundSchema
      ),
      z.lazy(() => GetAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => GetAgentResponseFormatAgentsJSONObject$inboundSchema),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        GetAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      GetAgentFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => GetAgentToolChoiceAgents2$inboundSchema),
      GetAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(GetAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type GetAgentFallbackModelConfigurationParameters$Outbound = {
  audio?: GetAgentFallbackModelConfigurationAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | GetAgentResponseFormatAgentsResponse200JSONSchema$Outbound
    | GetAgentResponseFormatAgentsText$Outbound
    | GetAgentResponseFormatAgentsJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | GetAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?: GetAgentFallbackModelConfigurationThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: GetAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const GetAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    GetAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    GetAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() => GetAgentFallbackModelConfigurationAudio$outboundSchema),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        GetAgentResponseFormatAgentsResponse200JSONSchema$outboundSchema
      ),
      z.lazy(() => GetAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => GetAgentResponseFormatAgentsJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        GetAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      GetAgentFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => GetAgentToolChoiceAgents2$outboundSchema),
      GetAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(GetAgentFallbackModelConfigurationModalities$outboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function getAgentFallbackModelConfigurationParametersToJSON(
  getAgentFallbackModelConfigurationParameters:
    GetAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      getAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function getAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  GetAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'GetAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  GetAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    GetAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type GetAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | GetAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const GetAgentFallbackModelConfiguration2$outboundSchema: z.ZodType<
  GetAgentFallbackModelConfiguration2$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelConfiguration2
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    GetAgentFallbackModelConfigurationParameters$outboundSchema
  ).optional(),
});

export function getAgentFallbackModelConfiguration2ToJSON(
  getAgentFallbackModelConfiguration2: GetAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfiguration2$outboundSchema.parse(
      getAgentFallbackModelConfiguration2,
    ),
  );
}
export function getAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelConfiguration2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfiguration2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const GetAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  GetAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => GetAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type GetAgentFallbackModelConfiguration$Outbound =
  | GetAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const GetAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  GetAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  GetAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => GetAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function getAgentFallbackModelConfigurationToJSON(
  getAgentFallbackModelConfiguration: GetAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    GetAgentFallbackModelConfiguration$outboundSchema.parse(
      getAgentFallbackModelConfiguration,
    ),
  );
}
export function getAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentFallbackModelConfiguration, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      GetAgentFallbackModelConfiguration$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const GetAgentModel$inboundSchema: z.ZodType<
  GetAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentParameters$inboundSchema).optional(),
  retry: z.lazy(() => GetAgentRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => GetAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type GetAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: GetAgentParameters$Outbound | undefined;
  retry?: GetAgentRetry$Outbound | undefined;
  fallback_models?:
    | Array<GetAgentFallbackModelConfiguration2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const GetAgentModel$outboundSchema: z.ZodType<
  GetAgentModel$Outbound,
  z.ZodTypeDef,
  GetAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => GetAgentParameters$outboundSchema).optional(),
  retry: z.lazy(() => GetAgentRetry$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => GetAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function getAgentModelToJSON(getAgentModel: GetAgentModel): string {
  return JSON.stringify(GetAgentModel$outboundSchema.parse(getAgentModel));
}
export function getAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentModel' from JSON`,
  );
}

/** @internal */
export const GetAgentTeamOfAgents$inboundSchema: z.ZodType<
  GetAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type GetAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const GetAgentTeamOfAgents$outboundSchema: z.ZodType<
  GetAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  GetAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function getAgentTeamOfAgentsToJSON(
  getAgentTeamOfAgents: GetAgentTeamOfAgents,
): string {
  return JSON.stringify(
    GetAgentTeamOfAgents$outboundSchema.parse(getAgentTeamOfAgents),
  );
}
export function getAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const GetAgentMetrics$inboundSchema: z.ZodType<
  GetAgentMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type GetAgentMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const GetAgentMetrics$outboundSchema: z.ZodType<
  GetAgentMetrics$Outbound,
  z.ZodTypeDef,
  GetAgentMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function getAgentMetricsToJSON(
  getAgentMetrics: GetAgentMetrics,
): string {
  return JSON.stringify(GetAgentMetrics$outboundSchema.parse(getAgentMetrics));
}
export function getAgentMetricsFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentMetrics' from JSON`,
  );
}

/** @internal */
export const GetAgentKnowledgeBases$inboundSchema: z.ZodType<
  GetAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type GetAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const GetAgentKnowledgeBases$outboundSchema: z.ZodType<
  GetAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  GetAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function getAgentKnowledgeBasesToJSON(
  getAgentKnowledgeBases: GetAgentKnowledgeBases,
): string {
  return JSON.stringify(
    GetAgentKnowledgeBases$outboundSchema.parse(getAgentKnowledgeBases),
  );
}
export function getAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const GetAgentResponseBody$inboundSchema: z.ZodType<
  GetAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: GetAgentStatus$inboundSchema,
  settings: z.lazy(() => GetAgentSettings$inboundSchema).optional(),
  model: z.lazy(() => GetAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(z.lazy(() => GetAgentTeamOfAgents$inboundSchema)),
  metrics: z.lazy(() => GetAgentMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(z.lazy(() => GetAgentKnowledgeBases$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});
/** @internal */
export type GetAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: GetAgentSettings$Outbound | undefined;
  model: GetAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<GetAgentTeamOfAgents$Outbound>;
  metrics?: GetAgentMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<GetAgentKnowledgeBases$Outbound> | undefined;
};

/** @internal */
export const GetAgentResponseBody$outboundSchema: z.ZodType<
  GetAgentResponseBody$Outbound,
  z.ZodTypeDef,
  GetAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: GetAgentStatus$outboundSchema,
  settings: z.lazy(() => GetAgentSettings$outboundSchema).optional(),
  model: z.lazy(() => GetAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(z.lazy(() => GetAgentTeamOfAgents$outboundSchema)),
  metrics: z.lazy(() => GetAgentMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(z.lazy(() => GetAgentKnowledgeBases$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
  });
});

export function getAgentResponseBodyToJSON(
  getAgentResponseBody: GetAgentResponseBody,
): string {
  return JSON.stringify(
    GetAgentResponseBody$outboundSchema.parse(getAgentResponseBody),
  );
}
export function getAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<GetAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => GetAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'GetAgentResponseBody' from JSON`,
  );
}
