/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const InvokeAgentRoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type InvokeAgentRoleToolMessage = ClosedEnum<
  typeof InvokeAgentRoleToolMessage
>;

/**
 * Message from the end user
 */
export const InvokeAgentRoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type InvokeAgentRoleUserMessage = ClosedEnum<
  typeof InvokeAgentRoleUserMessage
>;

/**
 * Message role (user or tool for continuing executions)
 */
export type InvokeAgentRole =
  | InvokeAgentRoleUserMessage
  | InvokeAgentRoleToolMessage;

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type InvokeAgentPublicMessagePart =
  | components.TextPart
  | components.FilePart
  | components.ToolResultPart
  | components.ErrorPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type InvokeAgentA2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: InvokeAgentRoleUserMessage | InvokeAgentRoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<
    | components.TextPart
    | components.FilePart
    | components.ToolResultPart
    | components.ErrorPart
  >;
};

/**
 * Information about the identity making the request. If the identity does not exist, it will be created automatically.
 */
export type InvokeAgentIdentity = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * @deprecated Use identity instead. Information about the contact making the request.
 *
 * @deprecated class: This will be removed in a future release, please migrate away from it as soon as possible.
 */
export type InvokeAgentContact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type InvokeAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type InvokeAgentMemory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type InvokeAgentRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: InvokeAgentA2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the identity making the request. If the identity does not exist, it will be created automatically.
   */
  identity?: InvokeAgentIdentity | undefined;
  /**
   * @deprecated Use identity instead. Information about the contact making the request.
   *
   * @deprecated field: This will be removed in a future release, please migrate away from it as soon as possible.
   */
  contact?: InvokeAgentContact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: InvokeAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: InvokeAgentMemory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

export type InvokeAgentRequest = {
  /**
   * The key or ID of the agent to invoke
   */
  key: string;
  requestBody?: InvokeAgentRequestBody | undefined;
};

/**
 * A2A entity type identifier
 */
export const Kind = {
  Task: "task",
} as const;
/**
 * A2A entity type identifier
 */
export type Kind = ClosedEnum<typeof Kind>;

/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export const TaskState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  AuthRequired: "auth-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
} as const;
/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export type TaskState = ClosedEnum<typeof TaskState>;

export const InvokeAgentKind = {
  Message: "message",
} as const;
export type InvokeAgentKind = ClosedEnum<typeof InvokeAgentKind>;

/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export const ExtendedMessageRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export type ExtendedMessageRole = ClosedEnum<typeof ExtendedMessageRole>;

export type Parts =
  | components.TextPart
  | components.ErrorPart
  | components.DataPart
  | components.FilePart
  | components.ToolCallPart
  | components.ToolResultPart;

/**
 * Optional A2A message providing additional context about the current status
 */
export type TaskStatusMessage = {
  kind: InvokeAgentKind;
  messageId: string;
  /**
   * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
   */
  role: ExtendedMessageRole;
  parts: Array<
    | components.TextPart
    | components.ErrorPart
    | components.DataPart
    | components.FilePart
    | components.ToolCallPart
    | components.ToolResultPart
  >;
};

/**
 * Current task status information
 */
export type TaskStatus = {
  /**
   * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
   */
  state: TaskState;
  /**
   * ISO 8601 timestamp of when the status was updated
   */
  timestamp?: string | undefined;
  /**
   * Optional A2A message providing additional context about the current status
   */
  message?: TaskStatusMessage | undefined;
};

/**
 * Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution.
 */
export type InvokeAgentA2ATaskResponse = {
  /**
   * The unique ID of the created agent execution task
   */
  id: string;
  /**
   * The correlation ID for this execution (used for tracking)
   */
  contextId: string;
  /**
   * A2A entity type identifier
   */
  kind: Kind;
  /**
   * Current task status information
   */
  status: TaskStatus;
  /**
   * Task metadata containing workspace_id and trace_id for feedback and tracking
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentRoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleToolMessage
> = z.nativeEnum(InvokeAgentRoleToolMessage);
/** @internal */
export const InvokeAgentRoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleToolMessage
> = InvokeAgentRoleToolMessage$inboundSchema;

/** @internal */
export const InvokeAgentRoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleUserMessage
> = z.nativeEnum(InvokeAgentRoleUserMessage);
/** @internal */
export const InvokeAgentRoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentRoleUserMessage
> = InvokeAgentRoleUserMessage$inboundSchema;

/** @internal */
export const InvokeAgentRole$inboundSchema: z.ZodType<
  InvokeAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([
  InvokeAgentRoleUserMessage$inboundSchema,
  InvokeAgentRoleToolMessage$inboundSchema,
]);
/** @internal */
export type InvokeAgentRole$Outbound = string | string;

/** @internal */
export const InvokeAgentRole$outboundSchema: z.ZodType<
  InvokeAgentRole$Outbound,
  z.ZodTypeDef,
  InvokeAgentRole
> = z.union([
  InvokeAgentRoleUserMessage$outboundSchema,
  InvokeAgentRoleToolMessage$outboundSchema,
]);

export function invokeAgentRoleToJSON(
  invokeAgentRole: InvokeAgentRole,
): string {
  return JSON.stringify(InvokeAgentRole$outboundSchema.parse(invokeAgentRole));
}
export function invokeAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRole' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePart$inboundSchema: z.ZodType<
  InvokeAgentPublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextPart$inboundSchema,
  components.FilePart$inboundSchema,
  components.ToolResultPart$inboundSchema,
  components.ErrorPart$inboundSchema,
]);
/** @internal */
export type InvokeAgentPublicMessagePart$Outbound =
  | components.TextPart$Outbound
  | components.FilePart$Outbound
  | components.ToolResultPart$Outbound
  | components.ErrorPart$Outbound;

/** @internal */
export const InvokeAgentPublicMessagePart$outboundSchema: z.ZodType<
  InvokeAgentPublicMessagePart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPublicMessagePart
> = z.union([
  components.TextPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolResultPart$outboundSchema,
  components.ErrorPart$outboundSchema,
]);

export function invokeAgentPublicMessagePartToJSON(
  invokeAgentPublicMessagePart: InvokeAgentPublicMessagePart,
): string {
  return JSON.stringify(
    InvokeAgentPublicMessagePart$outboundSchema.parse(
      invokeAgentPublicMessagePart,
    ),
  );
}
export function invokeAgentPublicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPublicMessagePart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentA2AMessage$inboundSchema: z.ZodType<
  InvokeAgentA2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    InvokeAgentRoleUserMessage$inboundSchema,
    InvokeAgentRoleToolMessage$inboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolResultPart$inboundSchema,
      components.ErrorPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type InvokeAgentA2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<
    | components.TextPart$Outbound
    | components.FilePart$Outbound
    | components.ToolResultPart$Outbound
    | components.ErrorPart$Outbound
  >;
};

/** @internal */
export const InvokeAgentA2AMessage$outboundSchema: z.ZodType<
  InvokeAgentA2AMessage$Outbound,
  z.ZodTypeDef,
  InvokeAgentA2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    InvokeAgentRoleUserMessage$outboundSchema,
    InvokeAgentRoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolResultPart$outboundSchema,
      components.ErrorPart$outboundSchema,
    ]),
  ),
});

export function invokeAgentA2AMessageToJSON(
  invokeAgentA2AMessage: InvokeAgentA2AMessage,
): string {
  return JSON.stringify(
    InvokeAgentA2AMessage$outboundSchema.parse(invokeAgentA2AMessage),
  );
}
export function invokeAgentA2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentA2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentA2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentA2AMessage' from JSON`,
  );
}

/** @internal */
export const InvokeAgentIdentity$inboundSchema: z.ZodType<
  InvokeAgentIdentity,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type InvokeAgentIdentity$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentIdentity$outboundSchema: z.ZodType<
  InvokeAgentIdentity$Outbound,
  z.ZodTypeDef,
  InvokeAgentIdentity
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function invokeAgentIdentityToJSON(
  invokeAgentIdentity: InvokeAgentIdentity,
): string {
  return JSON.stringify(
    InvokeAgentIdentity$outboundSchema.parse(invokeAgentIdentity),
  );
}
export function invokeAgentIdentityFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentIdentity, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentIdentity$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentIdentity' from JSON`,
  );
}

/** @internal */
export const InvokeAgentContact$inboundSchema: z.ZodType<
  InvokeAgentContact,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  display_name: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logo_url: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "logo_url": "logoUrl",
  });
});
/** @internal */
export type InvokeAgentContact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentContact$outboundSchema: z.ZodType<
  InvokeAgentContact$Outbound,
  z.ZodTypeDef,
  InvokeAgentContact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function invokeAgentContactToJSON(
  invokeAgentContact: InvokeAgentContact,
): string {
  return JSON.stringify(
    InvokeAgentContact$outboundSchema.parse(invokeAgentContact),
  );
}
export function invokeAgentContactFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentContact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentContact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentContact' from JSON`,
  );
}

/** @internal */
export const InvokeAgentThread$inboundSchema: z.ZodType<
  InvokeAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type InvokeAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentThread$outboundSchema: z.ZodType<
  InvokeAgentThread$Outbound,
  z.ZodTypeDef,
  InvokeAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function invokeAgentThreadToJSON(
  invokeAgentThread: InvokeAgentThread,
): string {
  return JSON.stringify(
    InvokeAgentThread$outboundSchema.parse(invokeAgentThread),
  );
}
export function invokeAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentThread' from JSON`,
  );
}

/** @internal */
export const InvokeAgentMemory$inboundSchema: z.ZodType<
  InvokeAgentMemory,
  z.ZodTypeDef,
  unknown
> = z.object({
  entity_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "entity_id": "entityId",
  });
});
/** @internal */
export type InvokeAgentMemory$Outbound = {
  entity_id: string;
};

/** @internal */
export const InvokeAgentMemory$outboundSchema: z.ZodType<
  InvokeAgentMemory$Outbound,
  z.ZodTypeDef,
  InvokeAgentMemory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function invokeAgentMemoryToJSON(
  invokeAgentMemory: InvokeAgentMemory,
): string {
  return JSON.stringify(
    InvokeAgentMemory$outboundSchema.parse(invokeAgentMemory),
  );
}
export function invokeAgentMemoryFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentMemory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentMemory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentMemory' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequestBody$inboundSchema: z.ZodType<
  InvokeAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => InvokeAgentA2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => InvokeAgentIdentity$inboundSchema).optional(),
  contact: z.lazy(() => InvokeAgentContact$inboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => InvokeAgentMemory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type InvokeAgentRequestBody$Outbound = {
  task_id?: string | undefined;
  message: InvokeAgentA2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  identity?: InvokeAgentIdentity$Outbound | undefined;
  contact?: InvokeAgentContact$Outbound | undefined;
  thread?: InvokeAgentThread$Outbound | undefined;
  memory?: InvokeAgentMemory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentRequestBody$outboundSchema: z.ZodType<
  InvokeAgentRequestBody$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => InvokeAgentA2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  identity: z.lazy(() => InvokeAgentIdentity$outboundSchema).optional(),
  contact: z.lazy(() => InvokeAgentContact$outboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => InvokeAgentMemory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function invokeAgentRequestBodyToJSON(
  invokeAgentRequestBody: InvokeAgentRequestBody,
): string {
  return JSON.stringify(
    InvokeAgentRequestBody$outboundSchema.parse(invokeAgentRequestBody),
  );
}
export function invokeAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequest$inboundSchema: z.ZodType<
  InvokeAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  RequestBody: z.lazy(() => InvokeAgentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type InvokeAgentRequest$Outbound = {
  key: string;
  RequestBody?: InvokeAgentRequestBody$Outbound | undefined;
};

/** @internal */
export const InvokeAgentRequest$outboundSchema: z.ZodType<
  InvokeAgentRequest$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequest
> = z.object({
  key: z.string(),
  requestBody: z.lazy(() => InvokeAgentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function invokeAgentRequestToJSON(
  invokeAgentRequest: InvokeAgentRequest,
): string {
  return JSON.stringify(
    InvokeAgentRequest$outboundSchema.parse(invokeAgentRequest),
  );
}
export function invokeAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequest' from JSON`,
  );
}

/** @internal */
export const Kind$inboundSchema: z.ZodNativeEnum<typeof Kind> = z.nativeEnum(
  Kind,
);
/** @internal */
export const Kind$outboundSchema: z.ZodNativeEnum<typeof Kind> =
  Kind$inboundSchema;

/** @internal */
export const TaskState$inboundSchema: z.ZodNativeEnum<typeof TaskState> = z
  .nativeEnum(TaskState);
/** @internal */
export const TaskState$outboundSchema: z.ZodNativeEnum<typeof TaskState> =
  TaskState$inboundSchema;

/** @internal */
export const InvokeAgentKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = z.nativeEnum(InvokeAgentKind);
/** @internal */
export const InvokeAgentKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = InvokeAgentKind$inboundSchema;

/** @internal */
export const ExtendedMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof ExtendedMessageRole
> = z.nativeEnum(ExtendedMessageRole);
/** @internal */
export const ExtendedMessageRole$outboundSchema: z.ZodNativeEnum<
  typeof ExtendedMessageRole
> = ExtendedMessageRole$inboundSchema;

/** @internal */
export const Parts$inboundSchema: z.ZodType<Parts, z.ZodTypeDef, unknown> = z
  .union([
    components.TextPart$inboundSchema,
    components.ErrorPart$inboundSchema,
    components.DataPart$inboundSchema,
    components.FilePart$inboundSchema,
    components.ToolCallPart$inboundSchema,
    components.ToolResultPart$inboundSchema,
  ]);
/** @internal */
export type Parts$Outbound =
  | components.TextPart$Outbound
  | components.ErrorPart$Outbound
  | components.DataPart$Outbound
  | components.FilePart$Outbound
  | components.ToolCallPart$Outbound
  | components.ToolResultPart$Outbound;

/** @internal */
export const Parts$outboundSchema: z.ZodType<
  Parts$Outbound,
  z.ZodTypeDef,
  Parts
> = z.union([
  components.TextPart$outboundSchema,
  components.ErrorPart$outboundSchema,
  components.DataPart$outboundSchema,
  components.FilePart$outboundSchema,
  components.ToolCallPart$outboundSchema,
  components.ToolResultPart$outboundSchema,
]);

export function partsToJSON(parts: Parts): string {
  return JSON.stringify(Parts$outboundSchema.parse(parts));
}
export function partsFromJSON(
  jsonString: string,
): SafeParseResult<Parts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Parts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Parts' from JSON`,
  );
}

/** @internal */
export const TaskStatusMessage$inboundSchema: z.ZodType<
  TaskStatusMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentKind$inboundSchema,
  messageId: z.string(),
  role: ExtendedMessageRole$inboundSchema,
  parts: z.array(
    z.union([
      components.TextPart$inboundSchema,
      components.ErrorPart$inboundSchema,
      components.DataPart$inboundSchema,
      components.FilePart$inboundSchema,
      components.ToolCallPart$inboundSchema,
      components.ToolResultPart$inboundSchema,
    ]),
  ),
});
/** @internal */
export type TaskStatusMessage$Outbound = {
  kind: string;
  messageId: string;
  role: string;
  parts: Array<
    | components.TextPart$Outbound
    | components.ErrorPart$Outbound
    | components.DataPart$Outbound
    | components.FilePart$Outbound
    | components.ToolCallPart$Outbound
    | components.ToolResultPart$Outbound
  >;
};

/** @internal */
export const TaskStatusMessage$outboundSchema: z.ZodType<
  TaskStatusMessage$Outbound,
  z.ZodTypeDef,
  TaskStatusMessage
> = z.object({
  kind: InvokeAgentKind$outboundSchema,
  messageId: z.string(),
  role: ExtendedMessageRole$outboundSchema,
  parts: z.array(
    z.union([
      components.TextPart$outboundSchema,
      components.ErrorPart$outboundSchema,
      components.DataPart$outboundSchema,
      components.FilePart$outboundSchema,
      components.ToolCallPart$outboundSchema,
      components.ToolResultPart$outboundSchema,
    ]),
  ),
});

export function taskStatusMessageToJSON(
  taskStatusMessage: TaskStatusMessage,
): string {
  return JSON.stringify(
    TaskStatusMessage$outboundSchema.parse(taskStatusMessage),
  );
}
export function taskStatusMessageFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatusMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatusMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatusMessage' from JSON`,
  );
}

/** @internal */
export const TaskStatus$inboundSchema: z.ZodType<
  TaskStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: TaskState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$inboundSchema).optional(),
});
/** @internal */
export type TaskStatus$Outbound = {
  state: string;
  timestamp?: string | undefined;
  message?: TaskStatusMessage$Outbound | undefined;
};

/** @internal */
export const TaskStatus$outboundSchema: z.ZodType<
  TaskStatus$Outbound,
  z.ZodTypeDef,
  TaskStatus
> = z.object({
  state: TaskState$outboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$outboundSchema).optional(),
});

export function taskStatusToJSON(taskStatus: TaskStatus): string {
  return JSON.stringify(TaskStatus$outboundSchema.parse(taskStatus));
}
export function taskStatusFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatus' from JSON`,
  );
}

/** @internal */
export const InvokeAgentA2ATaskResponse$inboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: Kind$inboundSchema,
  status: z.lazy(() => TaskStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InvokeAgentA2ATaskResponse$Outbound = {
  id: string;
  contextId: string;
  kind: string;
  status: TaskStatus$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentA2ATaskResponse$outboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse$Outbound,
  z.ZodTypeDef,
  InvokeAgentA2ATaskResponse
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: Kind$outboundSchema,
  status: z.lazy(() => TaskStatus$outboundSchema),
  metadata: z.record(z.any()).optional(),
});

export function invokeAgentA2ATaskResponseToJSON(
  invokeAgentA2ATaskResponse: InvokeAgentA2ATaskResponse,
): string {
  return JSON.stringify(
    InvokeAgentA2ATaskResponse$outboundSchema.parse(invokeAgentA2ATaskResponse),
  );
}
export function invokeAgentA2ATaskResponseFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentA2ATaskResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentA2ATaskResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentA2ATaskResponse' from JSON`,
  );
}
