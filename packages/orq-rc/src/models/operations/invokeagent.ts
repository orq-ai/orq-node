/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Message containing tool execution results
 */
export const RoleToolMessage = {
  Tool: "tool",
} as const;
/**
 * Message containing tool execution results
 */
export type RoleToolMessage = ClosedEnum<typeof RoleToolMessage>;

/**
 * Message from the end user
 */
export const RoleUserMessage = {
  User: "user",
} as const;
/**
 * Message from the end user
 */
export type RoleUserMessage = ClosedEnum<typeof RoleUserMessage>;

/**
 * Message role (user or tool for continuing executions)
 */
export type InvokeAgentRole = RoleUserMessage | RoleToolMessage;

export const InvokeAgentPublicMessagePartKind = {
  ToolResult: "tool_result",
} as const;
export type InvokeAgentPublicMessagePartKind = ClosedEnum<
  typeof InvokeAgentPublicMessagePartKind
>;

/**
 * Tool execution result part. Use this ONLY when providing results for a pending tool call from the agent. The tool_call_id must match the ID from the agent's tool call request.
 */
export type ToolResultPart = {
  kind: InvokeAgentPublicMessagePartKind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const PublicMessagePartKind = {
  File: "file",
} as const;
export type PublicMessagePartKind = ClosedEnum<typeof PublicMessagePartKind>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type FileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type BinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type PublicMessagePartFile = BinaryFormat | FileInURIFormat;

/**
 * File attachment part. Use this to send files (images, documents, etc.) to the agent for processing.
 */
export type FilePart = {
  kind: PublicMessagePartKind;
  file: BinaryFormat | FileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const Kind = {
  Text: "text",
} as const;
export type Kind = ClosedEnum<typeof Kind>;

/**
 * Text content part. Use this to send text messages to the agent.
 */
export type TextPart = {
  kind: Kind;
  text: string;
};

/**
 * Message part that can be provided by users. Use "text" for regular messages, "file" for attachments, or "tool_result" when responding to tool call requests.
 */
export type PublicMessagePart = TextPart | FilePart | ToolResultPart;

/**
 * The A2A message to send to the agent (user input or tool results)
 */
export type A2AMessage = {
  /**
   * Optional A2A message ID in ULID format
   */
  messageId?: string | undefined;
  /**
   * Message role (user or tool for continuing executions)
   */
  role: RoleUserMessage | RoleToolMessage;
  /**
   * A2A message parts (text, file, or tool_result only)
   */
  parts: Array<TextPart | FilePart | ToolResultPart>;
};

/**
 * Information about the contact making the request. If the contact does not exist, it will be created automatically.
 */
export type Contact = {
  /**
   * Unique identifier for the contact
   */
  id: string;
  /**
   * Display name of the contact
   */
  displayName?: string | undefined;
  /**
   * Email address of the contact
   */
  email?: string | undefined;
  /**
   * A hash of key/value pairs containing any other data about the contact
   */
  metadata?: Array<{ [k: string]: any }> | undefined;
  /**
   * URL to the contact's avatar or logo
   */
  logoUrl?: string | undefined;
  /**
   * A list of tags associated with the contact
   */
  tags?: Array<string> | undefined;
};

/**
 * Thread information to group related requests
 */
export type InvokeAgentThread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
 */
export type Memory = {
  /**
   * An entity ID used to link memory stores to a specific user, session, or conversation. This ID is used to isolate and retrieve memories specific to the entity across agent executions.
   */
  entityId: string;
};

export type InvokeAgentRequestBody = {
  /**
   * Optional task ID to continue an existing agent execution. When provided, the agent will continue the conversation from the existing task state. The task must be in an inactive state to continue.
   */
  taskId?: string | undefined;
  /**
   * The A2A message to send to the agent (user input or tool results)
   */
  message: A2AMessage;
  /**
   * Optional variables for template replacement in system prompt, instructions, and messages
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Information about the contact making the request. If the contact does not exist, it will be created automatically.
   */
  contact?: Contact | undefined;
  /**
   * Thread information to group related requests
   */
  thread?: InvokeAgentThread | undefined;
  /**
   * Memory configuration for the agent execution. Used to associate memory stores with specific entities like users or sessions.
   */
  memory?: Memory | undefined;
  /**
   * Optional metadata for the agent invocation as key-value pairs that will be included in traces
   */
  metadata?: { [k: string]: any } | undefined;
};

export type InvokeAgentRequest = {
  /**
   * The key or ID of the agent to invoke
   */
  key: string;
  requestBody?: InvokeAgentRequestBody | undefined;
};

/**
 * A2A entity type identifier
 */
export const InvokeAgentKind = {
  Task: "task",
} as const;
/**
 * A2A entity type identifier
 */
export type InvokeAgentKind = ClosedEnum<typeof InvokeAgentKind>;

/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export const TaskState = {
  Submitted: "submitted",
  Working: "working",
  InputRequired: "input-required",
  AuthRequired: "auth-required",
  Completed: "completed",
  Failed: "failed",
  Canceled: "canceled",
  Rejected: "rejected",
} as const;
/**
 * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
 */
export type TaskState = ClosedEnum<typeof TaskState>;

export const InvokeAgentAgentsKind = {
  Message: "message",
} as const;
export type InvokeAgentAgentsKind = ClosedEnum<typeof InvokeAgentAgentsKind>;

/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export const InvokeAgentExtendedMessageRole = {
  User: "user",
  Agent: "agent",
  Tool: "tool",
  System: "system",
} as const;
/**
 * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
 */
export type InvokeAgentExtendedMessageRole = ClosedEnum<
  typeof InvokeAgentExtendedMessageRole
>;

export const InvokeAgentPartsAgentsResponse200Kind = {
  ToolResult: "tool_result",
} as const;
export type InvokeAgentPartsAgentsResponse200Kind = ClosedEnum<
  typeof InvokeAgentPartsAgentsResponse200Kind
>;

/**
 * The result of a tool execution. Contains the tool call ID for correlation and the result data from the tool invocation.
 */
export type InvokeAgentPartsToolResultPart = {
  kind: InvokeAgentPartsAgentsResponse200Kind;
  toolCallId: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsAgentsResponseKind = {
  ToolCall: "tool_call",
} as const;
export type InvokeAgentPartsAgentsResponseKind = ClosedEnum<
  typeof InvokeAgentPartsAgentsResponseKind
>;

/**
 * A tool invocation request from an agent. Contains the tool name, unique call ID, and arguments for the tool execution.
 */
export type InvokeAgentPartsToolCallPart = {
  kind: InvokeAgentPartsAgentsResponseKind;
  toolName: string;
  toolCallId: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsAgentsKind = {
  File: "file",
} as const;
export type InvokeAgentPartsAgentsKind = ClosedEnum<
  typeof InvokeAgentPartsAgentsKind
>;

/**
 * File in URI format. Check in the model's documentation for the supported mime types for the URI format
 */
export type InvokeAgentFileFileInURIFormat = {
  /**
   * URL for the File content
   */
  uri: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

/**
 * Binary in base64 format. Check in the model's documentation for the supported mime types for the binary format.
 */
export type InvokeAgentFileBinaryFormat = {
  /**
   * base64 encoded content of the file
   */
  bytes: string;
  /**
   * Optional mimeType for the file
   */
  mimeType?: string | undefined;
  /**
   * Optional name for the file
   */
  name?: string | undefined;
};

export type InvokeAgentPartsFile =
  | InvokeAgentFileBinaryFormat
  | InvokeAgentFileFileInURIFormat;

/**
 * A file content part that can contain either base64-encoded bytes or a URI reference. Used for images, documents, and other binary content in agent communications.
 */
export type InvokeAgentPartsFilePart = {
  kind: InvokeAgentPartsAgentsKind;
  file: InvokeAgentFileBinaryFormat | InvokeAgentFileFileInURIFormat;
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsKind = {
  Data: "data",
} as const;
export type InvokeAgentPartsKind = ClosedEnum<typeof InvokeAgentPartsKind>;

/**
 * A structured data part containing JSON-serializable key-value pairs. Used for passing structured information between agents and tools.
 */
export type InvokeAgentPartsDataPart = {
  kind: InvokeAgentPartsKind;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

export const InvokeAgentPartsAgentsResponse200ApplicationJSONKind = {
  Text: "text",
} as const;
export type InvokeAgentPartsAgentsResponse200ApplicationJSONKind = ClosedEnum<
  typeof InvokeAgentPartsAgentsResponse200ApplicationJSONKind
>;

/**
 * A text content part containing plain text or markdown. Used for agent messages, user input, and text-based responses.
 */
export type InvokeAgentPartsTextPart = {
  kind: InvokeAgentPartsAgentsResponse200ApplicationJSONKind;
  text: string;
};

export type InvokeAgentParts =
  | InvokeAgentPartsToolCallPart
  | InvokeAgentPartsTextPart
  | InvokeAgentPartsDataPart
  | InvokeAgentPartsFilePart
  | InvokeAgentPartsToolResultPart;

/**
 * Optional A2A message providing additional context about the current status
 */
export type TaskStatusMessage = {
  kind: InvokeAgentAgentsKind;
  messageId: string;
  /**
   * Role of the message sender in the A2A protocol. Values: user (end user), agent (AI agent), tool (tool execution result), system (system instructions/prompts).
   */
  role: InvokeAgentExtendedMessageRole;
  parts: Array<
    | InvokeAgentPartsToolCallPart
    | InvokeAgentPartsTextPart
    | InvokeAgentPartsDataPart
    | InvokeAgentPartsFilePart
    | InvokeAgentPartsToolResultPart
  >;
};

/**
 * Current task status information
 */
export type TaskStatus = {
  /**
   * Current state of the agent task execution. Values: submitted (queued), working (executing), input-required (awaiting user input), completed (finished successfully), failed (error occurred). Note: auth-required, canceled, and rejected statuses are defined for A2A protocol compatibility but are not currently supported in task execution.
   */
  state: TaskState;
  /**
   * ISO 8601 timestamp of when the status was updated
   */
  timestamp?: string | undefined;
  /**
   * Optional A2A message providing additional context about the current status
   */
  message?: TaskStatusMessage | undefined;
};

/**
 * Response format following the Agent-to-Agent (A2A) protocol. Returned when starting or continuing an agent task execution.
 */
export type InvokeAgentA2ATaskResponse = {
  /**
   * The unique ID of the created agent execution task
   */
  id: string;
  /**
   * The correlation ID for this execution (used for tracking)
   */
  contextId: string;
  /**
   * A2A entity type identifier
   */
  kind: InvokeAgentKind;
  /**
   * Current task status information
   */
  status: TaskStatus;
  /**
   * Task metadata containing workspace_id and trace_id for feedback and tracking
   */
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const RoleToolMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = z.nativeEnum(RoleToolMessage);
/** @internal */
export const RoleToolMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleToolMessage
> = RoleToolMessage$inboundSchema;

/** @internal */
export const RoleUserMessage$inboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = z.nativeEnum(RoleUserMessage);
/** @internal */
export const RoleUserMessage$outboundSchema: z.ZodNativeEnum<
  typeof RoleUserMessage
> = RoleUserMessage$inboundSchema;

/** @internal */
export const InvokeAgentRole$inboundSchema: z.ZodType<
  InvokeAgentRole,
  z.ZodTypeDef,
  unknown
> = z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]);
/** @internal */
export type InvokeAgentRole$Outbound = string | string;

/** @internal */
export const InvokeAgentRole$outboundSchema: z.ZodType<
  InvokeAgentRole$Outbound,
  z.ZodTypeDef,
  InvokeAgentRole
> = z.union([RoleUserMessage$outboundSchema, RoleToolMessage$outboundSchema]);

export function invokeAgentRoleToJSON(
  invokeAgentRole: InvokeAgentRole,
): string {
  return JSON.stringify(InvokeAgentRole$outboundSchema.parse(invokeAgentRole));
}
export function invokeAgentRoleFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRole, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRole$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRole' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPublicMessagePartKind
> = z.nativeEnum(InvokeAgentPublicMessagePartKind);
/** @internal */
export const InvokeAgentPublicMessagePartKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPublicMessagePartKind
> = InvokeAgentPublicMessagePartKind$inboundSchema;

/** @internal */
export const ToolResultPart$inboundSchema: z.ZodType<
  ToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPublicMessagePartKind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type ToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const ToolResultPart$outboundSchema: z.ZodType<
  ToolResultPart$Outbound,
  z.ZodTypeDef,
  ToolResultPart
> = z.object({
  kind: InvokeAgentPublicMessagePartKind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function toolResultPartToJSON(toolResultPart: ToolResultPart): string {
  return JSON.stringify(ToolResultPart$outboundSchema.parse(toolResultPart));
}
export function toolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<ToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolResultPart' from JSON`,
  );
}

/** @internal */
export const PublicMessagePartKind$inboundSchema: z.ZodNativeEnum<
  typeof PublicMessagePartKind
> = z.nativeEnum(PublicMessagePartKind);
/** @internal */
export const PublicMessagePartKind$outboundSchema: z.ZodNativeEnum<
  typeof PublicMessagePartKind
> = PublicMessagePartKind$inboundSchema;

/** @internal */
export const FileInURIFormat$inboundSchema: z.ZodType<
  FileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type FileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const FileInURIFormat$outboundSchema: z.ZodType<
  FileInURIFormat$Outbound,
  z.ZodTypeDef,
  FileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function fileInURIFormatToJSON(
  fileInURIFormat: FileInURIFormat,
): string {
  return JSON.stringify(FileInURIFormat$outboundSchema.parse(fileInURIFormat));
}
export function fileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<FileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileInURIFormat' from JSON`,
  );
}

/** @internal */
export const BinaryFormat$inboundSchema: z.ZodType<
  BinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type BinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const BinaryFormat$outboundSchema: z.ZodType<
  BinaryFormat$Outbound,
  z.ZodTypeDef,
  BinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function binaryFormatToJSON(binaryFormat: BinaryFormat): string {
  return JSON.stringify(BinaryFormat$outboundSchema.parse(binaryFormat));
}
export function binaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<BinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BinaryFormat' from JSON`,
  );
}

/** @internal */
export const PublicMessagePartFile$inboundSchema: z.ZodType<
  PublicMessagePartFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => BinaryFormat$inboundSchema),
  z.lazy(() => FileInURIFormat$inboundSchema),
]);
/** @internal */
export type PublicMessagePartFile$Outbound =
  | BinaryFormat$Outbound
  | FileInURIFormat$Outbound;

/** @internal */
export const PublicMessagePartFile$outboundSchema: z.ZodType<
  PublicMessagePartFile$Outbound,
  z.ZodTypeDef,
  PublicMessagePartFile
> = z.union([
  z.lazy(() => BinaryFormat$outboundSchema),
  z.lazy(() => FileInURIFormat$outboundSchema),
]);

export function publicMessagePartFileToJSON(
  publicMessagePartFile: PublicMessagePartFile,
): string {
  return JSON.stringify(
    PublicMessagePartFile$outboundSchema.parse(publicMessagePartFile),
  );
}
export function publicMessagePartFileFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePartFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePartFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePartFile' from JSON`,
  );
}

/** @internal */
export const FilePart$inboundSchema: z.ZodType<
  FilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: PublicMessagePartKind$inboundSchema,
  file: z.union([
    z.lazy(() => BinaryFormat$inboundSchema),
    z.lazy(() => FileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type FilePart$Outbound = {
  kind: string;
  file: BinaryFormat$Outbound | FileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const FilePart$outboundSchema: z.ZodType<
  FilePart$Outbound,
  z.ZodTypeDef,
  FilePart
> = z.object({
  kind: PublicMessagePartKind$outboundSchema,
  file: z.union([
    z.lazy(() => BinaryFormat$outboundSchema),
    z.lazy(() => FileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function filePartToJSON(filePart: FilePart): string {
  return JSON.stringify(FilePart$outboundSchema.parse(filePart));
}
export function filePartFromJSON(
  jsonString: string,
): SafeParseResult<FilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FilePart' from JSON`,
  );
}

/** @internal */
export const Kind$inboundSchema: z.ZodNativeEnum<typeof Kind> = z.nativeEnum(
  Kind,
);
/** @internal */
export const Kind$outboundSchema: z.ZodNativeEnum<typeof Kind> =
  Kind$inboundSchema;

/** @internal */
export const TextPart$inboundSchema: z.ZodType<
  TextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: Kind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type TextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const TextPart$outboundSchema: z.ZodType<
  TextPart$Outbound,
  z.ZodTypeDef,
  TextPart
> = z.object({
  kind: Kind$outboundSchema,
  text: z.string(),
});

export function textPartToJSON(textPart: TextPart): string {
  return JSON.stringify(TextPart$outboundSchema.parse(textPart));
}
export function textPartFromJSON(
  jsonString: string,
): SafeParseResult<TextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextPart' from JSON`,
  );
}

/** @internal */
export const PublicMessagePart$inboundSchema: z.ZodType<
  PublicMessagePart,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TextPart$inboundSchema),
  z.lazy(() => FilePart$inboundSchema),
  z.lazy(() => ToolResultPart$inboundSchema),
]);
/** @internal */
export type PublicMessagePart$Outbound =
  | TextPart$Outbound
  | FilePart$Outbound
  | ToolResultPart$Outbound;

/** @internal */
export const PublicMessagePart$outboundSchema: z.ZodType<
  PublicMessagePart$Outbound,
  z.ZodTypeDef,
  PublicMessagePart
> = z.union([
  z.lazy(() => TextPart$outboundSchema),
  z.lazy(() => FilePart$outboundSchema),
  z.lazy(() => ToolResultPart$outboundSchema),
]);

export function publicMessagePartToJSON(
  publicMessagePart: PublicMessagePart,
): string {
  return JSON.stringify(
    PublicMessagePart$outboundSchema.parse(publicMessagePart),
  );
}
export function publicMessagePartFromJSON(
  jsonString: string,
): SafeParseResult<PublicMessagePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PublicMessagePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PublicMessagePart' from JSON`,
  );
}

/** @internal */
export const A2AMessage$inboundSchema: z.ZodType<
  A2AMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  messageId: z.string().optional(),
  role: z.union([RoleUserMessage$inboundSchema, RoleToolMessage$inboundSchema]),
  parts: z.array(
    z.union([
      z.lazy(() => TextPart$inboundSchema),
      z.lazy(() => FilePart$inboundSchema),
      z.lazy(() => ToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type A2AMessage$Outbound = {
  messageId?: string | undefined;
  role: string | string;
  parts: Array<TextPart$Outbound | FilePart$Outbound | ToolResultPart$Outbound>;
};

/** @internal */
export const A2AMessage$outboundSchema: z.ZodType<
  A2AMessage$Outbound,
  z.ZodTypeDef,
  A2AMessage
> = z.object({
  messageId: z.string().optional(),
  role: z.union([
    RoleUserMessage$outboundSchema,
    RoleToolMessage$outboundSchema,
  ]),
  parts: z.array(
    z.union([
      z.lazy(() => TextPart$outboundSchema),
      z.lazy(() => FilePart$outboundSchema),
      z.lazy(() => ToolResultPart$outboundSchema),
    ]),
  ),
});

export function a2AMessageToJSON(a2AMessage: A2AMessage): string {
  return JSON.stringify(A2AMessage$outboundSchema.parse(a2AMessage));
}
export function a2AMessageFromJSON(
  jsonString: string,
): SafeParseResult<A2AMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => A2AMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'A2AMessage' from JSON`,
  );
}

/** @internal */
export const Contact$inboundSchema: z.ZodType<Contact, z.ZodTypeDef, unknown> =
  z.object({
    id: z.string(),
    display_name: z.string().optional(),
    email: z.string().optional(),
    metadata: z.array(z.record(z.any())).optional(),
    logo_url: z.string().optional(),
    tags: z.array(z.string()).optional(),
  }).transform((v) => {
    return remap$(v, {
      "display_name": "displayName",
      "logo_url": "logoUrl",
    });
  });
/** @internal */
export type Contact$Outbound = {
  id: string;
  display_name?: string | undefined;
  email?: string | undefined;
  metadata?: Array<{ [k: string]: any }> | undefined;
  logo_url?: string | undefined;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Contact$outboundSchema: z.ZodType<
  Contact$Outbound,
  z.ZodTypeDef,
  Contact
> = z.object({
  id: z.string(),
  displayName: z.string().optional(),
  email: z.string().optional(),
  metadata: z.array(z.record(z.any())).optional(),
  logoUrl: z.string().optional(),
  tags: z.array(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    logoUrl: "logo_url",
  });
});

export function contactToJSON(contact: Contact): string {
  return JSON.stringify(Contact$outboundSchema.parse(contact));
}
export function contactFromJSON(
  jsonString: string,
): SafeParseResult<Contact, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Contact$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Contact' from JSON`,
  );
}

/** @internal */
export const InvokeAgentThread$inboundSchema: z.ZodType<
  InvokeAgentThread,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});
/** @internal */
export type InvokeAgentThread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const InvokeAgentThread$outboundSchema: z.ZodType<
  InvokeAgentThread$Outbound,
  z.ZodTypeDef,
  InvokeAgentThread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function invokeAgentThreadToJSON(
  invokeAgentThread: InvokeAgentThread,
): string {
  return JSON.stringify(
    InvokeAgentThread$outboundSchema.parse(invokeAgentThread),
  );
}
export function invokeAgentThreadFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentThread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentThread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentThread' from JSON`,
  );
}

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    entity_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entity_id": "entityId",
    });
  });
/** @internal */
export type Memory$Outbound = {
  entity_id: string;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}
export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequestBody$inboundSchema: z.ZodType<
  InvokeAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  task_id: z.string().optional(),
  message: z.lazy(() => A2AMessage$inboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$inboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$inboundSchema).optional(),
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "task_id": "taskId",
  });
});
/** @internal */
export type InvokeAgentRequestBody$Outbound = {
  task_id?: string | undefined;
  message: A2AMessage$Outbound;
  variables?: { [k: string]: any } | undefined;
  contact?: Contact$Outbound | undefined;
  thread?: InvokeAgentThread$Outbound | undefined;
  memory?: Memory$Outbound | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentRequestBody$outboundSchema: z.ZodType<
  InvokeAgentRequestBody$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequestBody
> = z.object({
  taskId: z.string().optional(),
  message: z.lazy(() => A2AMessage$outboundSchema),
  variables: z.record(z.any()).optional(),
  contact: z.lazy(() => Contact$outboundSchema).optional(),
  thread: z.lazy(() => InvokeAgentThread$outboundSchema).optional(),
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    taskId: "task_id",
  });
});

export function invokeAgentRequestBodyToJSON(
  invokeAgentRequestBody: InvokeAgentRequestBody,
): string {
  return JSON.stringify(
    InvokeAgentRequestBody$outboundSchema.parse(invokeAgentRequestBody),
  );
}
export function invokeAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const InvokeAgentRequest$inboundSchema: z.ZodType<
  InvokeAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  RequestBody: z.lazy(() => InvokeAgentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type InvokeAgentRequest$Outbound = {
  key: string;
  RequestBody?: InvokeAgentRequestBody$Outbound | undefined;
};

/** @internal */
export const InvokeAgentRequest$outboundSchema: z.ZodType<
  InvokeAgentRequest$Outbound,
  z.ZodTypeDef,
  InvokeAgentRequest
> = z.object({
  key: z.string(),
  requestBody: z.lazy(() => InvokeAgentRequestBody$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    requestBody: "RequestBody",
  });
});

export function invokeAgentRequestToJSON(
  invokeAgentRequest: InvokeAgentRequest,
): string {
  return JSON.stringify(
    InvokeAgentRequest$outboundSchema.parse(invokeAgentRequest),
  );
}
export function invokeAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentRequest' from JSON`,
  );
}

/** @internal */
export const InvokeAgentKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = z.nativeEnum(InvokeAgentKind);
/** @internal */
export const InvokeAgentKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentKind
> = InvokeAgentKind$inboundSchema;

/** @internal */
export const TaskState$inboundSchema: z.ZodNativeEnum<typeof TaskState> = z
  .nativeEnum(TaskState);
/** @internal */
export const TaskState$outboundSchema: z.ZodNativeEnum<typeof TaskState> =
  TaskState$inboundSchema;

/** @internal */
export const InvokeAgentAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentAgentsKind
> = z.nativeEnum(InvokeAgentAgentsKind);
/** @internal */
export const InvokeAgentAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentAgentsKind
> = InvokeAgentAgentsKind$inboundSchema;

/** @internal */
export const InvokeAgentExtendedMessageRole$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentExtendedMessageRole
> = z.nativeEnum(InvokeAgentExtendedMessageRole);
/** @internal */
export const InvokeAgentExtendedMessageRole$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentExtendedMessageRole
> = InvokeAgentExtendedMessageRole$inboundSchema;

/** @internal */
export const InvokeAgentPartsAgentsResponse200Kind$inboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200Kind> = z.nativeEnum(
    InvokeAgentPartsAgentsResponse200Kind,
  );
/** @internal */
export const InvokeAgentPartsAgentsResponse200Kind$outboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200Kind> =
    InvokeAgentPartsAgentsResponse200Kind$inboundSchema;

/** @internal */
export const InvokeAgentPartsToolResultPart$inboundSchema: z.ZodType<
  InvokeAgentPartsToolResultPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200Kind$inboundSchema,
  tool_call_id: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type InvokeAgentPartsToolResultPart$Outbound = {
  kind: string;
  tool_call_id: string;
  result?: any | undefined;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentPartsToolResultPart$outboundSchema: z.ZodType<
  InvokeAgentPartsToolResultPart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsToolResultPart
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200Kind$outboundSchema,
  toolCallId: z.string(),
  result: z.any().optional(),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

export function invokeAgentPartsToolResultPartToJSON(
  invokeAgentPartsToolResultPart: InvokeAgentPartsToolResultPart,
): string {
  return JSON.stringify(
    InvokeAgentPartsToolResultPart$outboundSchema.parse(
      invokeAgentPartsToolResultPart,
    ),
  );
}
export function invokeAgentPartsToolResultPartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsToolResultPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsToolResultPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsToolResultPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsAgentsResponseKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsResponseKind
> = z.nativeEnum(InvokeAgentPartsAgentsResponseKind);
/** @internal */
export const InvokeAgentPartsAgentsResponseKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsResponseKind
> = InvokeAgentPartsAgentsResponseKind$inboundSchema;

/** @internal */
export const InvokeAgentPartsToolCallPart$inboundSchema: z.ZodType<
  InvokeAgentPartsToolCallPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsResponseKind$inboundSchema,
  tool_name: z.string(),
  tool_call_id: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_name": "toolName",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type InvokeAgentPartsToolCallPart$Outbound = {
  kind: string;
  tool_name: string;
  tool_call_id: string;
  arguments: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentPartsToolCallPart$outboundSchema: z.ZodType<
  InvokeAgentPartsToolCallPart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsToolCallPart
> = z.object({
  kind: InvokeAgentPartsAgentsResponseKind$outboundSchema,
  toolName: z.string(),
  toolCallId: z.string(),
  arguments: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolName: "tool_name",
    toolCallId: "tool_call_id",
  });
});

export function invokeAgentPartsToolCallPartToJSON(
  invokeAgentPartsToolCallPart: InvokeAgentPartsToolCallPart,
): string {
  return JSON.stringify(
    InvokeAgentPartsToolCallPart$outboundSchema.parse(
      invokeAgentPartsToolCallPart,
    ),
  );
}
export function invokeAgentPartsToolCallPartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsToolCallPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsToolCallPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsToolCallPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsAgentsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsKind
> = z.nativeEnum(InvokeAgentPartsAgentsKind);
/** @internal */
export const InvokeAgentPartsAgentsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsAgentsKind
> = InvokeAgentPartsAgentsKind$inboundSchema;

/** @internal */
export const InvokeAgentFileFileInURIFormat$inboundSchema: z.ZodType<
  InvokeAgentFileFileInURIFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type InvokeAgentFileFileInURIFormat$Outbound = {
  uri: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const InvokeAgentFileFileInURIFormat$outboundSchema: z.ZodType<
  InvokeAgentFileFileInURIFormat$Outbound,
  z.ZodTypeDef,
  InvokeAgentFileFileInURIFormat
> = z.object({
  uri: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function invokeAgentFileFileInURIFormatToJSON(
  invokeAgentFileFileInURIFormat: InvokeAgentFileFileInURIFormat,
): string {
  return JSON.stringify(
    InvokeAgentFileFileInURIFormat$outboundSchema.parse(
      invokeAgentFileFileInURIFormat,
    ),
  );
}
export function invokeAgentFileFileInURIFormatFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentFileFileInURIFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentFileFileInURIFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentFileFileInURIFormat' from JSON`,
  );
}

/** @internal */
export const InvokeAgentFileBinaryFormat$inboundSchema: z.ZodType<
  InvokeAgentFileBinaryFormat,
  z.ZodTypeDef,
  unknown
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});
/** @internal */
export type InvokeAgentFileBinaryFormat$Outbound = {
  bytes: string;
  mimeType?: string | undefined;
  name?: string | undefined;
};

/** @internal */
export const InvokeAgentFileBinaryFormat$outboundSchema: z.ZodType<
  InvokeAgentFileBinaryFormat$Outbound,
  z.ZodTypeDef,
  InvokeAgentFileBinaryFormat
> = z.object({
  bytes: z.string(),
  mimeType: z.string().optional(),
  name: z.string().optional(),
});

export function invokeAgentFileBinaryFormatToJSON(
  invokeAgentFileBinaryFormat: InvokeAgentFileBinaryFormat,
): string {
  return JSON.stringify(
    InvokeAgentFileBinaryFormat$outboundSchema.parse(
      invokeAgentFileBinaryFormat,
    ),
  );
}
export function invokeAgentFileBinaryFormatFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentFileBinaryFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentFileBinaryFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentFileBinaryFormat' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsFile$inboundSchema: z.ZodType<
  InvokeAgentPartsFile,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InvokeAgentFileBinaryFormat$inboundSchema),
  z.lazy(() => InvokeAgentFileFileInURIFormat$inboundSchema),
]);
/** @internal */
export type InvokeAgentPartsFile$Outbound =
  | InvokeAgentFileBinaryFormat$Outbound
  | InvokeAgentFileFileInURIFormat$Outbound;

/** @internal */
export const InvokeAgentPartsFile$outboundSchema: z.ZodType<
  InvokeAgentPartsFile$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsFile
> = z.union([
  z.lazy(() => InvokeAgentFileBinaryFormat$outboundSchema),
  z.lazy(() => InvokeAgentFileFileInURIFormat$outboundSchema),
]);

export function invokeAgentPartsFileToJSON(
  invokeAgentPartsFile: InvokeAgentPartsFile,
): string {
  return JSON.stringify(
    InvokeAgentPartsFile$outboundSchema.parse(invokeAgentPartsFile),
  );
}
export function invokeAgentPartsFileFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsFile' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsFilePart$inboundSchema: z.ZodType<
  InvokeAgentPartsFilePart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsKind$inboundSchema,
  file: z.union([
    z.lazy(() => InvokeAgentFileBinaryFormat$inboundSchema),
    z.lazy(() => InvokeAgentFileFileInURIFormat$inboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InvokeAgentPartsFilePart$Outbound = {
  kind: string;
  file:
    | InvokeAgentFileBinaryFormat$Outbound
    | InvokeAgentFileFileInURIFormat$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentPartsFilePart$outboundSchema: z.ZodType<
  InvokeAgentPartsFilePart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsFilePart
> = z.object({
  kind: InvokeAgentPartsAgentsKind$outboundSchema,
  file: z.union([
    z.lazy(() => InvokeAgentFileBinaryFormat$outboundSchema),
    z.lazy(() => InvokeAgentFileFileInURIFormat$outboundSchema),
  ]),
  metadata: z.record(z.any()).optional(),
});

export function invokeAgentPartsFilePartToJSON(
  invokeAgentPartsFilePart: InvokeAgentPartsFilePart,
): string {
  return JSON.stringify(
    InvokeAgentPartsFilePart$outboundSchema.parse(invokeAgentPartsFilePart),
  );
}
export function invokeAgentPartsFilePartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsFilePart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsFilePart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsFilePart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsKind$inboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsKind
> = z.nativeEnum(InvokeAgentPartsKind);
/** @internal */
export const InvokeAgentPartsKind$outboundSchema: z.ZodNativeEnum<
  typeof InvokeAgentPartsKind
> = InvokeAgentPartsKind$inboundSchema;

/** @internal */
export const InvokeAgentPartsDataPart$inboundSchema: z.ZodType<
  InvokeAgentPartsDataPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsKind$inboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InvokeAgentPartsDataPart$Outbound = {
  kind: string;
  data: { [k: string]: any };
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentPartsDataPart$outboundSchema: z.ZodType<
  InvokeAgentPartsDataPart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsDataPart
> = z.object({
  kind: InvokeAgentPartsKind$outboundSchema,
  data: z.record(z.any()),
  metadata: z.record(z.any()).optional(),
});

export function invokeAgentPartsDataPartToJSON(
  invokeAgentPartsDataPart: InvokeAgentPartsDataPart,
): string {
  return JSON.stringify(
    InvokeAgentPartsDataPart$outboundSchema.parse(invokeAgentPartsDataPart),
  );
}
export function invokeAgentPartsDataPartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsDataPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsDataPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsDataPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200ApplicationJSONKind> =
    z.nativeEnum(InvokeAgentPartsAgentsResponse200ApplicationJSONKind);
/** @internal */
export const InvokeAgentPartsAgentsResponse200ApplicationJSONKind$outboundSchema:
  z.ZodNativeEnum<typeof InvokeAgentPartsAgentsResponse200ApplicationJSONKind> =
    InvokeAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema;

/** @internal */
export const InvokeAgentPartsTextPart$inboundSchema: z.ZodType<
  InvokeAgentPartsTextPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200ApplicationJSONKind$inboundSchema,
  text: z.string(),
});
/** @internal */
export type InvokeAgentPartsTextPart$Outbound = {
  kind: string;
  text: string;
};

/** @internal */
export const InvokeAgentPartsTextPart$outboundSchema: z.ZodType<
  InvokeAgentPartsTextPart$Outbound,
  z.ZodTypeDef,
  InvokeAgentPartsTextPart
> = z.object({
  kind: InvokeAgentPartsAgentsResponse200ApplicationJSONKind$outboundSchema,
  text: z.string(),
});

export function invokeAgentPartsTextPartToJSON(
  invokeAgentPartsTextPart: InvokeAgentPartsTextPart,
): string {
  return JSON.stringify(
    InvokeAgentPartsTextPart$outboundSchema.parse(invokeAgentPartsTextPart),
  );
}
export function invokeAgentPartsTextPartFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentPartsTextPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentPartsTextPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentPartsTextPart' from JSON`,
  );
}

/** @internal */
export const InvokeAgentParts$inboundSchema: z.ZodType<
  InvokeAgentParts,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => InvokeAgentPartsToolCallPart$inboundSchema),
  z.lazy(() => InvokeAgentPartsTextPart$inboundSchema),
  z.lazy(() => InvokeAgentPartsDataPart$inboundSchema),
  z.lazy(() => InvokeAgentPartsFilePart$inboundSchema),
  z.lazy(() => InvokeAgentPartsToolResultPart$inboundSchema),
]);
/** @internal */
export type InvokeAgentParts$Outbound =
  | InvokeAgentPartsToolCallPart$Outbound
  | InvokeAgentPartsTextPart$Outbound
  | InvokeAgentPartsDataPart$Outbound
  | InvokeAgentPartsFilePart$Outbound
  | InvokeAgentPartsToolResultPart$Outbound;

/** @internal */
export const InvokeAgentParts$outboundSchema: z.ZodType<
  InvokeAgentParts$Outbound,
  z.ZodTypeDef,
  InvokeAgentParts
> = z.union([
  z.lazy(() => InvokeAgentPartsToolCallPart$outboundSchema),
  z.lazy(() => InvokeAgentPartsTextPart$outboundSchema),
  z.lazy(() => InvokeAgentPartsDataPart$outboundSchema),
  z.lazy(() => InvokeAgentPartsFilePart$outboundSchema),
  z.lazy(() => InvokeAgentPartsToolResultPart$outboundSchema),
]);

export function invokeAgentPartsToJSON(
  invokeAgentParts: InvokeAgentParts,
): string {
  return JSON.stringify(
    InvokeAgentParts$outboundSchema.parse(invokeAgentParts),
  );
}
export function invokeAgentPartsFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentParts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentParts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentParts' from JSON`,
  );
}

/** @internal */
export const TaskStatusMessage$inboundSchema: z.ZodType<
  TaskStatusMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  kind: InvokeAgentAgentsKind$inboundSchema,
  messageId: z.string(),
  role: InvokeAgentExtendedMessageRole$inboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => InvokeAgentPartsToolCallPart$inboundSchema),
      z.lazy(() => InvokeAgentPartsTextPart$inboundSchema),
      z.lazy(() => InvokeAgentPartsDataPart$inboundSchema),
      z.lazy(() => InvokeAgentPartsFilePart$inboundSchema),
      z.lazy(() => InvokeAgentPartsToolResultPart$inboundSchema),
    ]),
  ),
});
/** @internal */
export type TaskStatusMessage$Outbound = {
  kind: string;
  messageId: string;
  role: string;
  parts: Array<
    | InvokeAgentPartsToolCallPart$Outbound
    | InvokeAgentPartsTextPart$Outbound
    | InvokeAgentPartsDataPart$Outbound
    | InvokeAgentPartsFilePart$Outbound
    | InvokeAgentPartsToolResultPart$Outbound
  >;
};

/** @internal */
export const TaskStatusMessage$outboundSchema: z.ZodType<
  TaskStatusMessage$Outbound,
  z.ZodTypeDef,
  TaskStatusMessage
> = z.object({
  kind: InvokeAgentAgentsKind$outboundSchema,
  messageId: z.string(),
  role: InvokeAgentExtendedMessageRole$outboundSchema,
  parts: z.array(
    z.union([
      z.lazy(() => InvokeAgentPartsToolCallPart$outboundSchema),
      z.lazy(() => InvokeAgentPartsTextPart$outboundSchema),
      z.lazy(() => InvokeAgentPartsDataPart$outboundSchema),
      z.lazy(() => InvokeAgentPartsFilePart$outboundSchema),
      z.lazy(() => InvokeAgentPartsToolResultPart$outboundSchema),
    ]),
  ),
});

export function taskStatusMessageToJSON(
  taskStatusMessage: TaskStatusMessage,
): string {
  return JSON.stringify(
    TaskStatusMessage$outboundSchema.parse(taskStatusMessage),
  );
}
export function taskStatusMessageFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatusMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatusMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatusMessage' from JSON`,
  );
}

/** @internal */
export const TaskStatus$inboundSchema: z.ZodType<
  TaskStatus,
  z.ZodTypeDef,
  unknown
> = z.object({
  state: TaskState$inboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$inboundSchema).optional(),
});
/** @internal */
export type TaskStatus$Outbound = {
  state: string;
  timestamp?: string | undefined;
  message?: TaskStatusMessage$Outbound | undefined;
};

/** @internal */
export const TaskStatus$outboundSchema: z.ZodType<
  TaskStatus$Outbound,
  z.ZodTypeDef,
  TaskStatus
> = z.object({
  state: TaskState$outboundSchema,
  timestamp: z.string().optional(),
  message: z.lazy(() => TaskStatusMessage$outboundSchema).optional(),
});

export function taskStatusToJSON(taskStatus: TaskStatus): string {
  return JSON.stringify(TaskStatus$outboundSchema.parse(taskStatus));
}
export function taskStatusFromJSON(
  jsonString: string,
): SafeParseResult<TaskStatus, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TaskStatus$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TaskStatus' from JSON`,
  );
}

/** @internal */
export const InvokeAgentA2ATaskResponse$inboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: InvokeAgentKind$inboundSchema,
  status: z.lazy(() => TaskStatus$inboundSchema),
  metadata: z.record(z.any()).optional(),
});
/** @internal */
export type InvokeAgentA2ATaskResponse$Outbound = {
  id: string;
  contextId: string;
  kind: string;
  status: TaskStatus$Outbound;
  metadata?: { [k: string]: any } | undefined;
};

/** @internal */
export const InvokeAgentA2ATaskResponse$outboundSchema: z.ZodType<
  InvokeAgentA2ATaskResponse$Outbound,
  z.ZodTypeDef,
  InvokeAgentA2ATaskResponse
> = z.object({
  id: z.string(),
  contextId: z.string(),
  kind: InvokeAgentKind$outboundSchema,
  status: z.lazy(() => TaskStatus$outboundSchema),
  metadata: z.record(z.any()).optional(),
});

export function invokeAgentA2ATaskResponseToJSON(
  invokeAgentA2ATaskResponse: InvokeAgentA2ATaskResponse,
): string {
  return JSON.stringify(
    InvokeAgentA2ATaskResponse$outboundSchema.parse(invokeAgentA2ATaskResponse),
  );
}
export function invokeAgentA2ATaskResponseFromJSON(
  jsonString: string,
): SafeParseResult<InvokeAgentA2ATaskResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeAgentA2ATaskResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeAgentA2ATaskResponse' from JSON`,
  );
}
