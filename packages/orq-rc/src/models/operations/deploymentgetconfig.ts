/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import * as components from "../components/index.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DeploymentGetConfigContentDeployments2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfigPrefixMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfigPrefixMessagesType = ClosedEnum<
  typeof DeploymentGetConfigPrefixMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const PrefixMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type PrefixMessagesTtl = ClosedEnum<typeof PrefixMessagesTtl>;

export type PrefixMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfigPrefixMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: PrefixMessagesTtl | undefined;
};

export type ToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
  cacheControl?: PrefixMessagesCacheControl | undefined;
};

export type DeploymentGetConfigContent2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type Audio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const PrefixMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type PrefixMessagesType = ClosedEnum<typeof PrefixMessagesType>;

export type PrefixMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type PrefixMessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: PrefixMessagesType;
  function: PrefixMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type AssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: Audio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<PrefixMessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfig2DeploymentsType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfig2DeploymentsType = ClosedEnum<
  typeof DeploymentGetConfig2DeploymentsType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type Ttl = ClosedEnum<typeof Ttl>;

export type CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfig2DeploymentsType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: Ttl | undefined;
};

export type Four = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type Content2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | Four;

/**
 * The contents of the user message.
 */
export type DeploymentGetConfigPrefixMessagesDeploymentsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | Four
  >;

export type UserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | Four
    >;
};

/**
 * The contents of the developer message.
 */
export type DeploymentGetConfigPrefixMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

export type DeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type PrefixMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type SystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type PrefixMessages =
  | SystemMessage
  | DeveloperMessage
  | UserMessage
  | AssistantMessage
  | ToolMessage;

export type DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2 =
  components.TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent =
  | string
  | Array<components.TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfigMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfigMessagesType = ClosedEnum<
  typeof DeploymentGetConfigMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const MessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type MessagesTtl = ClosedEnum<typeof MessagesTtl>;

export type MessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfigMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: MessagesTtl | undefined;
};

export type MessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
  cacheControl?: MessagesCacheControl | undefined;
};

export type DeploymentGetConfigContentDeploymentsRequestRequestBody2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.RefusalPartSchema
  | components.ReasoningPartSchema
  | components.RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type DeploymentGetConfigMessagesDeploymentsRequestContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.RefusalPartSchema
    | components.ReasoningPartSchema
    | components.RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type MessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const MessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type MessagesType = ClosedEnum<typeof MessagesType>;

export type MessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type MessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: MessagesType;
  function: MessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type MessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.RefusalPartSchema
      | components.ReasoningPartSchema
      | components.RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: MessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<MessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const DeploymentGetConfig2DeploymentsRequestRequestBodyType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type DeploymentGetConfig2DeploymentsRequestRequestBodyType = ClosedEnum<
  typeof DeploymentGetConfig2DeploymentsRequestRequestBodyType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const TwoTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type TwoTtl = ClosedEnum<typeof TwoTtl>;

export type TwoCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: DeploymentGetConfig2DeploymentsRequestRequestBodyType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: TwoTtl | undefined;
};

export type Two4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: TwoCacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: components.FileContentPartSchema;
};

export type DeploymentGetConfigContentDeploymentsRequest2 =
  | (components.TextContentPartSchema & { type: "text" })
  | components.ImageContentPartSchema
  | components.AudioContentPartSchema
  | Two4;

/**
 * The contents of the user message.
 */
export type DeploymentGetConfigMessagesDeploymentsContent =
  | string
  | Array<
    | (components.TextContentPartSchema & { type: "text" })
    | components.ImageContentPartSchema
    | components.AudioContentPartSchema
    | Two4
  >;

export type MessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (components.TextContentPartSchema & { type: "text" })
      | components.ImageContentPartSchema
      | components.AudioContentPartSchema
      | Two4
    >;
};

/**
 * The contents of the developer message.
 */
export type DeploymentGetConfigMessagesContent =
  | string
  | Array<components.TextContentPartSchema>;

export type MessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type MessagesContent = string | Array<components.TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type MessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<components.TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type DeploymentGetConfigMessages =
  | MessagesSystemMessage
  | MessagesDeveloperMessage
  | MessagesUserMessage
  | MessagesAssistantMessage
  | MessagesToolMessage;

/**
 * Metadata about the document
 */
export type Metadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: Metadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
  /**
   * Whether to include the usage metrics in the response.
   */
  includeUsage?: boolean | undefined;
  /**
   * A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage.
   */
  mockResponse?: string | undefined;
};

export type Thread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Exists
 */
export type OrExists = {
  exists: boolean;
};

export type DeploymentGetConfigOrNin = string | number | boolean;

/**
 * Not in
 */
export type OrNin = {
  nin: Array<string | number | boolean>;
};

export type DeploymentGetConfigOrIn = string | number | boolean;

/**
 * In
 */
export type OrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type OrLte = {
  lte: number;
};

/**
 * Less than
 */
export type OrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type OrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type OrGt = {
  gt: number;
};

export type DeploymentGetConfigOrNe = string | number | boolean;

/**
 * Not equal to
 */
export type OrNe = {
  ne: string | number | boolean;
};

export type DeploymentGetConfigOrEq = string | number | boolean;

/**
 * Equal to
 */
export type OrEq = {
  eq: string | number | boolean;
};

export type KnowledgeFilterOr =
  | OrEq
  | OrNe
  | OrGt
  | OrGte
  | OrLt
  | OrLte
  | OrIn
  | OrNin
  | OrExists;

/**
 * Or
 */
export type Or = {
  or: Array<
    {
      [k: string]:
        | OrEq
        | OrNe
        | OrGt
        | OrGte
        | OrLt
        | OrLte
        | OrIn
        | OrNin
        | OrExists;
    }
  >;
};

/**
 * Exists
 */
export type AndExists = {
  exists: boolean;
};

export type DeploymentGetConfigAndNin = string | number | boolean;

/**
 * Not in
 */
export type AndNin = {
  nin: Array<string | number | boolean>;
};

export type DeploymentGetConfigAndIn = string | number | boolean;

/**
 * In
 */
export type AndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type AndLte = {
  lte: number;
};

/**
 * Less than
 */
export type AndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type AndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type AndGt = {
  gt: number;
};

export type DeploymentGetConfigAndNe = string | number | boolean;

/**
 * Not equal to
 */
export type AndNe = {
  ne: string | number | boolean;
};

export type DeploymentGetConfigAndEq = string | number | boolean;

/**
 * Equal to
 */
export type AndEq = {
  eq: string | number | boolean;
};

export type KnowledgeFilterAnd =
  | AndEq
  | AndNe
  | AndGt
  | AndGte
  | AndLt
  | AndLte
  | AndIn
  | AndNin
  | AndExists;

/**
 * And
 */
export type And = {
  and: Array<
    {
      [k: string]:
        | AndEq
        | AndNe
        | AndGt
        | AndGte
        | AndLt
        | AndLte
        | AndIn
        | AndNin
        | AndExists;
    }
  >;
};

/**
 * Exists
 */
export type Exists = {
  exists: boolean;
};

export type OneNin = string | number | boolean;

/**
 * Not in
 */
export type Nin = {
  nin: Array<string | number | boolean>;
};

export type OneIn = string | number | boolean;

/**
 * In
 */
export type In = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type Lte = {
  lte: number;
};

/**
 * Less than
 */
export type Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type Gt = {
  gt: number;
};

export type OneNe = string | number | boolean;

/**
 * Not equal to
 */
export type Ne = {
  ne: string | number | boolean;
};

export type OneEq = string | number | boolean;

/**
 * Equal to
 */
export type Eq = {
  eq: string | number | boolean;
};

export type KnowledgeFilter1 =
  | Eq
  | Ne
  | Gt
  | Gte
  | Lt
  | Lte
  | In
  | Nin
  | Exists;

/**
 * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
 */
export type KnowledgeFilter = And | Or | {
  [k: string]: Eq | Ne | Gt | Gte | Lt | Lte | In | Nin | Exists;
};

export type DeploymentGetConfigRequestBody = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: any } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your deployment routing configuration
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?:
    | Array<
      | SystemMessage
      | DeveloperMessage
      | UserMessage
      | AssistantMessage
      | ToolMessage
    >
    | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?:
    | Array<
      | MessagesSystemMessage
      | MessagesDeveloperMessage
      | MessagesUserMessage
      | MessagesAssistantMessage
      | MessagesToolMessage
    >
    | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
  thread?: Thread | undefined;
  /**
   * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
   */
  knowledgeFilter?: And | Or | {
    [k: string]: Eq | Ne | Gt | Gte | Lt | Lte | In | Nin | Exists;
  } | undefined;
};

/**
 * The type of the model. Current `chat`,`completion` and `image` are supported
 */
export const DeploymentGetConfigType = {
  Chat: "chat",
  Completion: "completion",
  Embedding: "embedding",
  Image: "image",
  Tts: "tts",
  Stt: "stt",
  Rerank: "rerank",
  Moderation: "moderation",
  Vision: "vision",
} as const;
/**
 * The type of the model. Current `chat`,`completion` and `image` are supported
 */
export type DeploymentGetConfigType = ClosedEnum<
  typeof DeploymentGetConfigType
>;

/**
 * The role of the prompt message
 */
export const DeploymentGetConfigRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentGetConfigRole = ClosedEnum<
  typeof DeploymentGetConfigRole
>;

export type DeploymentGetConfig2File = {
  /**
   * The file data as a data URI string in the format 'data:<mime-type>;base64,<base64-encoded-data>'. Example: 'data:image/png;base64,iVBORw0KGgoAAAANS...'
   */
  fileData?: string | undefined;
  /**
   * URL to the file. Only supported by Anthropic Claude models for PDF files.
   */
  uri?: string | undefined;
  /**
   * MIME type of the file (e.g., application/pdf, image/png)
   */
  mimeType?: string | undefined;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type DeploymentGetConfig23 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  file: DeploymentGetConfig2File;
};

export type DeploymentGetConfig2ImageUrl = {
  /**
   * The orq.ai id of the image
   */
  id?: string | undefined;
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type DeploymentGetConfig22 = {
  type: "image_url";
  imageUrl: DeploymentGetConfig2ImageUrl;
};

/**
 * Text content part of a prompt message
 */
export type DeploymentGetConfig21 = {
  type: "text";
  text: string;
};

export type DeploymentGetConfigContentDeploymentsResponse2 =
  | DeploymentGetConfig21
  | DeploymentGetConfig22
  | DeploymentGetConfig23;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
 */
export type DeploymentGetConfigContent =
  | string
  | Array<
    DeploymentGetConfig21 | DeploymentGetConfig22 | DeploymentGetConfig23
  >;

export const DeploymentGetConfigDeploymentsResponseType = {
  Function: "function",
} as const;
export type DeploymentGetConfigDeploymentsResponseType = ClosedEnum<
  typeof DeploymentGetConfigDeploymentsResponseType
>;

export type DeploymentGetConfigDeploymentsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type DeploymentGetConfigToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentGetConfigDeploymentsResponseType;
  function: DeploymentGetConfigDeploymentsFunction;
};

export type DeploymentGetConfigDeploymentsMessages = {
  /**
   * The role of the prompt message
   */
  role: DeploymentGetConfigRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts. Can be null for tool messages in certain scenarios.
   */
  content:
    | string
    | Array<
      DeploymentGetConfig21 | DeploymentGetConfig22 | DeploymentGetConfig23
    >
    | null;
  toolCalls?: Array<DeploymentGetConfigToolCalls> | undefined;
  toolCallId?: string | null | undefined;
};

/**
 * Only supported on `image` models.
 */
export const DeploymentGetConfigFormat = {
  Url: "url",
  B64Json: "b64_json",
  Text: "text",
  JsonObject: "json_object",
} as const;
/**
 * Only supported on `image` models.
 */
export type DeploymentGetConfigFormat = ClosedEnum<
  typeof DeploymentGetConfigFormat
>;

export const DeploymentGetConfigResponseFormat6 = {
  Json: "json",
  Text: "text",
  Srt: "srt",
  VerboseJson: "verbose_json",
  Vtt: "vtt",
} as const;
export type DeploymentGetConfigResponseFormat6 = ClosedEnum<
  typeof DeploymentGetConfigResponseFormat6
>;

export const DeploymentGetConfigResponseFormat5 = {
  Url: "url",
  Base64Json: "base64_json",
} as const;
export type DeploymentGetConfigResponseFormat5 = ClosedEnum<
  typeof DeploymentGetConfigResponseFormat5
>;

export const DeploymentGetConfigResponseFormat4 = {
  Mp3: "mp3",
  Opus: "opus",
  Aac: "aac",
  Flac: "flac",
  Wav: "wav",
  Pcm: "pcm",
} as const;
export type DeploymentGetConfigResponseFormat4 = ClosedEnum<
  typeof DeploymentGetConfigResponseFormat4
>;

export const DeploymentGetConfigResponseFormatDeploymentsType = {
  Text: "text",
} as const;
export type DeploymentGetConfigResponseFormatDeploymentsType = ClosedEnum<
  typeof DeploymentGetConfigResponseFormatDeploymentsType
>;

export type DeploymentGetConfigResponseFormat3 = {
  type: DeploymentGetConfigResponseFormatDeploymentsType;
};

export const DeploymentGetConfigResponseFormatType = {
  JsonObject: "json_object",
} as const;
export type DeploymentGetConfigResponseFormatType = ClosedEnum<
  typeof DeploymentGetConfigResponseFormatType
>;

export type DeploymentGetConfigResponseFormat2 = {
  type: DeploymentGetConfigResponseFormatType;
};

export const DeploymentGetConfigResponseFormatDeploymentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type DeploymentGetConfigResponseFormatDeploymentsResponseType =
  ClosedEnum<typeof DeploymentGetConfigResponseFormatDeploymentsResponseType>;

export type DeploymentGetConfigResponseFormatJsonSchema = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

export type DeploymentGetConfigResponseFormat1 = {
  type: DeploymentGetConfigResponseFormatDeploymentsResponseType;
  displayName?: string | undefined;
  jsonSchema: DeploymentGetConfigResponseFormatJsonSchema;
};

/**
 * An object specifying the format that the model must output.
 *
 * @remarks
 *
 *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
 *
 *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
 *
 * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
 */
export type DeploymentGetConfigResponseFormat =
  | DeploymentGetConfigResponseFormat1
  | DeploymentGetConfigResponseFormat2
  | DeploymentGetConfigResponseFormat3
  | DeploymentGetConfigResponseFormat4
  | DeploymentGetConfigResponseFormat5
  | DeploymentGetConfigResponseFormat6;

/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export const DeploymentGetConfigPhotoRealVersion = {
  V1: "v1",
  V2: "v2",
} as const;
/**
 * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
 */
export type DeploymentGetConfigPhotoRealVersion = ClosedEnum<
  typeof DeploymentGetConfigPhotoRealVersion
>;

/**
 * The format to return the embeddings
 */
export const DeploymentGetConfigEncodingFormat = {
  Float: "float",
  Base64: "base64",
} as const;
/**
 * The format to return the embeddings
 */
export type DeploymentGetConfigEncodingFormat = ClosedEnum<
  typeof DeploymentGetConfigEncodingFormat
>;

/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export const DeploymentGetConfigReasoningEffort = {
  None: "none",
  Disable: "disable",
  Minimal: "minimal",
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
 */
export type DeploymentGetConfigReasoningEffort = ClosedEnum<
  typeof DeploymentGetConfigReasoningEffort
>;

/**
 * Controls the verbosity of the model output.
 */
export const DeploymentGetConfigVerbosity = {
  Low: "low",
  Medium: "medium",
  High: "high",
} as const;
/**
 * Controls the verbosity of the model output.
 */
export type DeploymentGetConfigVerbosity = ClosedEnum<
  typeof DeploymentGetConfigVerbosity
>;

/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export const DeploymentGetConfigThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of thinking to use for the model. Only supported by `Google AI`
 */
export type DeploymentGetConfigThinkingLevel = ClosedEnum<
  typeof DeploymentGetConfigThinkingLevel
>;

/**
 * Model Parameters: Not all parameters apply to every model
 */
export type DeploymentGetConfigParameters = {
  /**
   * Only supported on `chat` and `completion` models.
   */
  temperature?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  maxTokens?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topK?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  topP?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  frequencyPenalty?: number | undefined;
  /**
   * Only supported on `chat` and `completion` models.
   */
  presencePenalty?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  numImages?: number | undefined;
  /**
   * Best effort deterministic seed for the model. Currently only OpenAI models support these
   */
  seed?: number | undefined;
  /**
   * Only supported on `image` models.
   */
  format?: DeploymentGetConfigFormat | undefined;
  /**
   * Only supported on `image` models.
   */
  dimensions?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  quality?: string | undefined;
  /**
   * Only supported on `image` models.
   */
  style?: string | undefined;
  /**
   * An object specifying the format that the model must output.
   *
   * @remarks
   *
   *  Setting to `{ "type": "json_schema", "json_schema": {...} }` enables Structured Outputs which ensures the model will match your supplied JSON schema
   *
   *  Setting to `{ "type": "json_object" }` enables JSON mode, which ensures the message the model generates is valid JSON.
   *
   * Important: when using JSON mode, you must also instruct the model to produce JSON yourself via a system or user message. Without this, the model may generate an unending stream of whitespace until the generation reaches the token limit, resulting in a long-running and seemingly "stuck" request. Also note that the message content may be partially cut off if finish_reason="length", which indicates the generation exceeded max_tokens or the conversation exceeded the max context length.
   */
  responseFormat?:
    | DeploymentGetConfigResponseFormat1
    | DeploymentGetConfigResponseFormat2
    | DeploymentGetConfigResponseFormat3
    | DeploymentGetConfigResponseFormat4
    | DeploymentGetConfigResponseFormat5
    | DeploymentGetConfigResponseFormat6
    | null
    | undefined;
  /**
   * The version of photoReal to use. Must be v1 or v2. Only available for `leonardoai` provider
   */
  photoRealVersion?: DeploymentGetConfigPhotoRealVersion | undefined;
  /**
   * The format to return the embeddings
   */
  encodingFormat?: DeploymentGetConfigEncodingFormat | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: DeploymentGetConfigReasoningEffort | undefined;
  /**
   * Gives the model enhanced reasoning capabilities for complex tasks. A value of 0 disables thinking. The minimum budget tokens for thinking are 1024. The Budget Tokens should never exceed the Max Tokens parameter. Only supported by `Anthropic`
   */
  budgetTokens?: number | undefined;
  /**
   * Controls the verbosity of the model output.
   */
  verbosity?: DeploymentGetConfigVerbosity | undefined;
  /**
   * The level of thinking to use for the model. Only supported by `Google AI`
   */
  thinkingLevel?: DeploymentGetConfigThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const DeploymentGetConfigDeploymentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type DeploymentGetConfigDeploymentsType = ClosedEnum<
  typeof DeploymentGetConfigDeploymentsType
>;

export type DeploymentGetConfigFunction = {
  /**
   * The name of the function to be called. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * A description of what the function does, used by the model to choose when and how to call the function.
   */
  description?: string | undefined;
  /**
   * The parameters the functions accepts, described as a JSON Schema object.
   *
   * @remarks
   *
   *  Omitting `parameters` defines a function with an empty parameter list.
   */
  parameters?: { [k: string]: any } | undefined;
};

export type DeploymentGetConfigTools = {
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: DeploymentGetConfigDeploymentsType;
  function: DeploymentGetConfigFunction;
};

/**
 * The deployment configuration
 */
export type DeploymentGetConfigResponseBody = {
  /**
   * A unique identifier for the response. Can be used to add metrics to the transaction.
   */
  id: string;
  /**
   * The provider of the model
   */
  provider: string;
  /**
   * The model of the configuration
   */
  model: string;
  /**
   * The type of the model. Current `chat`,`completion` and `image` are supported
   */
  type?: DeploymentGetConfigType | undefined;
  /**
   * The current version of the deployment
   */
  version: string;
  messages: Array<DeploymentGetConfigDeploymentsMessages>;
  /**
   * Model Parameters: Not all parameters apply to every model
   */
  parameters: DeploymentGetConfigParameters;
  /**
   * A list of tools the model may call. Currently, only functions are supported as a tool. Use this to provide a list of functions the model may generate JSON inputs for.
   */
  tools?: Array<DeploymentGetConfigTools> | undefined;
};

/** @internal */
export const DeploymentGetConfigContentDeployments2$inboundSchema: z.ZodType<
  DeploymentGetConfigContentDeployments2,
  z.ZodTypeDef,
  unknown
> = components.TextContentPartSchema$inboundSchema;
/** @internal */
export type DeploymentGetConfigContentDeployments2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeployments2$outboundSchema: z.ZodType<
  DeploymentGetConfigContentDeployments2$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigContentDeployments2
> = components.TextContentPartSchema$outboundSchema;

export function deploymentGetConfigContentDeployments2ToJSON(
  deploymentGetConfigContentDeployments2:
    DeploymentGetConfigContentDeployments2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeployments2$outboundSchema.parse(
      deploymentGetConfigContentDeployments2,
    ),
  );
}
export function deploymentGetConfigContentDeployments2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigContentDeployments2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeployments2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContentDeployments2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);
/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent:
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$outboundSchema
      .parse(
        deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
      ),
  );
}
export function deploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigPrefixMessagesDeploymentsRequestRequestBodyContent' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigPrefixMessagesType> = z.nativeEnum(
    DeploymentGetConfigPrefixMessagesType,
  );
/** @internal */
export const DeploymentGetConfigPrefixMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigPrefixMessagesType> =
    DeploymentGetConfigPrefixMessagesType$inboundSchema;

/** @internal */
export const PrefixMessagesTtl$inboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesTtl
> = z.nativeEnum(PrefixMessagesTtl);
/** @internal */
export const PrefixMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesTtl
> = PrefixMessagesTtl$inboundSchema;

/** @internal */
export const PrefixMessagesCacheControl$inboundSchema: z.ZodType<
  PrefixMessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigPrefixMessagesType$inboundSchema,
  ttl: PrefixMessagesTtl$inboundSchema.default("5m"),
});
/** @internal */
export type PrefixMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const PrefixMessagesCacheControl$outboundSchema: z.ZodType<
  PrefixMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  PrefixMessagesCacheControl
> = z.object({
  type: DeploymentGetConfigPrefixMessagesType$outboundSchema,
  ttl: PrefixMessagesTtl$outboundSchema.default("5m"),
});

export function prefixMessagesCacheControlToJSON(
  prefixMessagesCacheControl: PrefixMessagesCacheControl,
): string {
  return JSON.stringify(
    PrefixMessagesCacheControl$outboundSchema.parse(prefixMessagesCacheControl),
  );
}
export function prefixMessagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const ToolMessage$inboundSchema: z.ZodType<
  ToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.string(),
  cache_control: z.lazy(() => PrefixMessagesCacheControl$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type ToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string;
  cache_control?: PrefixMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const ToolMessage$outboundSchema: z.ZodType<
  ToolMessage$Outbound,
  z.ZodTypeDef,
  ToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.string(),
  cacheControl: z.lazy(() => PrefixMessagesCacheControl$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function toolMessageToJSON(toolMessage: ToolMessage): string {
  return JSON.stringify(ToolMessage$outboundSchema.parse(toolMessage));
}
export function toolMessageFromJSON(
  jsonString: string,
): SafeParseResult<ToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContent2$inboundSchema: z.ZodType<
  DeploymentGetConfigContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$inboundSchema,
  components.ReasoningPartSchema$inboundSchema,
  components.RedactedReasoningPartSchema$inboundSchema,
]);
/** @internal */
export type DeploymentGetConfigContent2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContent2$outboundSchema: z.ZodType<
  DeploymentGetConfigContent2$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigContent2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.RefusalPartSchema$outboundSchema,
  components.ReasoningPartSchema$outboundSchema,
  components.RedactedReasoningPartSchema$outboundSchema,
]);

export function deploymentGetConfigContent2ToJSON(
  deploymentGetConfigContent2: DeploymentGetConfigContent2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContent2$outboundSchema.parse(
      deploymentGetConfigContent2,
    ),
  );
}
export function deploymentGetConfigContent2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContent2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);
/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsRequestContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsRequestContent:
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$outboundSchema
      .parse(deploymentGetConfigPrefixMessagesDeploymentsRequestContent),
  );
}
export function deploymentGetConfigPrefixMessagesDeploymentsRequestContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigPrefixMessagesDeploymentsRequestContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigPrefixMessagesDeploymentsRequestContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigPrefixMessagesDeploymentsRequestContent' from JSON`,
  );
}

/** @internal */
export const Audio$inboundSchema: z.ZodType<Audio, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });
/** @internal */
export type Audio$Outbound = {
  id: string;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
});

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}
export function audioFromJSON(
  jsonString: string,
): SafeParseResult<Audio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Audio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Audio' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesType
> = z.nativeEnum(PrefixMessagesType);
/** @internal */
export const PrefixMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesType
> = PrefixMessagesType$inboundSchema;

/** @internal */
export const PrefixMessagesFunction$inboundSchema: z.ZodType<
  PrefixMessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type PrefixMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const PrefixMessagesFunction$outboundSchema: z.ZodType<
  PrefixMessagesFunction$Outbound,
  z.ZodTypeDef,
  PrefixMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function prefixMessagesFunctionToJSON(
  prefixMessagesFunction: PrefixMessagesFunction,
): string {
  return JSON.stringify(
    PrefixMessagesFunction$outboundSchema.parse(prefixMessagesFunction),
  );
}
export function prefixMessagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesFunction' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesToolCalls$inboundSchema: z.ZodType<
  PrefixMessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: PrefixMessagesType$inboundSchema,
  function: z.lazy(() => PrefixMessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type PrefixMessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: PrefixMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const PrefixMessagesToolCalls$outboundSchema: z.ZodType<
  PrefixMessagesToolCalls$Outbound,
  z.ZodTypeDef,
  PrefixMessagesToolCalls
> = z.object({
  id: z.string(),
  type: PrefixMessagesType$outboundSchema,
  function: z.lazy(() => PrefixMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function prefixMessagesToolCallsToJSON(
  prefixMessagesToolCalls: PrefixMessagesToolCalls,
): string {
  return JSON.stringify(
    PrefixMessagesToolCalls$outboundSchema.parse(prefixMessagesToolCalls),
  );
}
export function prefixMessagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const AssistantMessage$inboundSchema: z.ZodType<
  AssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$inboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$inboundSchema,
          components.ReasoningPartSchema$inboundSchema,
          components.RedactedReasoningPartSchema$inboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => PrefixMessagesToolCalls$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});
/** @internal */
export type AssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: Audio$Outbound | null | undefined;
  tool_calls?: Array<PrefixMessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const AssistantMessage$outboundSchema: z.ZodType<
  AssistantMessage$Outbound,
  z.ZodTypeDef,
  AssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => PrefixMessagesToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function assistantMessageToJSON(
  assistantMessage: AssistantMessage,
): string {
  return JSON.stringify(
    AssistantMessage$outboundSchema.parse(assistantMessage),
  );
}
export function assistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<AssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AssistantMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig2DeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfig2DeploymentsType
> = z.nativeEnum(DeploymentGetConfig2DeploymentsType);
/** @internal */
export const DeploymentGetConfig2DeploymentsType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfig2DeploymentsType> =
    DeploymentGetConfig2DeploymentsType$inboundSchema;

/** @internal */
export const Ttl$inboundSchema: z.ZodNativeEnum<typeof Ttl> = z.nativeEnum(Ttl);
/** @internal */
export const Ttl$outboundSchema: z.ZodNativeEnum<typeof Ttl> =
  Ttl$inboundSchema;

/** @internal */
export const CacheControl$inboundSchema: z.ZodType<
  CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfig2DeploymentsType$inboundSchema,
  ttl: Ttl$inboundSchema.default("5m"),
});
/** @internal */
export type CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CacheControl$outboundSchema: z.ZodType<
  CacheControl$Outbound,
  z.ZodTypeDef,
  CacheControl
> = z.object({
  type: DeploymentGetConfig2DeploymentsType$outboundSchema,
  ttl: Ttl$outboundSchema.default("5m"),
});

export function cacheControlToJSON(cacheControl: CacheControl): string {
  return JSON.stringify(CacheControl$outboundSchema.parse(cacheControl));
}
export function cacheControlFromJSON(
  jsonString: string,
): SafeParseResult<CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CacheControl' from JSON`,
  );
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("file"),
    cache_control: z.lazy(() => CacheControl$inboundSchema).optional(),
    file: components.FileContentPartSchema$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "cache_control": "cacheControl",
    });
  });
/** @internal */
export type Four$Outbound = {
  type: "file";
  cache_control?: CacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() => CacheControl$outboundSchema).optional(),
    file: components.FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}
export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const Content2$inboundSchema: z.ZodType<
  Content2,
  z.ZodTypeDef,
  unknown
> = z.union([
  components.TextContentPartSchema$inboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$inboundSchema,
  components.AudioContentPartSchema$inboundSchema,
  z.lazy(() => Four$inboundSchema),
]);
/** @internal */
export type Content2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | Four$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  components.TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  components.ImageContentPartSchema$outboundSchema,
  components.AudioContentPartSchema$outboundSchema,
  z.lazy(() => Four$outboundSchema),
]);

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}
export function content2FromJSON(
  jsonString: string,
): SafeParseResult<Content2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => Four$inboundSchema),
      ]),
    ),
  ]);
/** @internal */
export type DeploymentGetConfigPrefixMessagesDeploymentsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | Four$Outbound
  >;

/** @internal */
export const DeploymentGetConfigPrefixMessagesDeploymentsContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigPrefixMessagesDeploymentsContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigPrefixMessagesDeploymentsContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]);

export function deploymentGetConfigPrefixMessagesDeploymentsContentToJSON(
  deploymentGetConfigPrefixMessagesDeploymentsContent:
    DeploymentGetConfigPrefixMessagesDeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesDeploymentsContent$outboundSchema.parse(
      deploymentGetConfigPrefixMessagesDeploymentsContent,
    ),
  );
}
export function deploymentGetConfigPrefixMessagesDeploymentsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigPrefixMessagesDeploymentsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigPrefixMessagesDeploymentsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigPrefixMessagesDeploymentsContent' from JSON`,
  );
}

/** @internal */
export const UserMessage$inboundSchema: z.ZodType<
  UserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => Four$inboundSchema),
      ]),
    ),
  ]),
});
/** @internal */
export type UserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | Four$Outbound
    >;
};

/** @internal */
export const UserMessage$outboundSchema: z.ZodType<
  UserMessage$Outbound,
  z.ZodTypeDef,
  UserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]),
});

export function userMessageToJSON(userMessage: UserMessage): string {
  return JSON.stringify(UserMessage$outboundSchema.parse(userMessage));
}
export function userMessageFromJSON(
  jsonString: string,
): SafeParseResult<UserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPrefixMessagesContent$inboundSchema: z.ZodType<
  DeploymentGetConfigPrefixMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type DeploymentGetConfigPrefixMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigPrefixMessagesContent$outboundSchema: z.ZodType<
  DeploymentGetConfigPrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigPrefixMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function deploymentGetConfigPrefixMessagesContentToJSON(
  deploymentGetConfigPrefixMessagesContent:
    DeploymentGetConfigPrefixMessagesContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigPrefixMessagesContent$outboundSchema.parse(
      deploymentGetConfigPrefixMessagesContent,
    ),
  );
}
export function deploymentGetConfigPrefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigPrefixMessagesContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigPrefixMessagesContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigPrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const DeveloperMessage$inboundSchema: z.ZodType<
  DeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type DeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const DeveloperMessage$outboundSchema: z.ZodType<
  DeveloperMessage$Outbound,
  z.ZodTypeDef,
  DeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function developerMessageToJSON(
  developerMessage: DeveloperMessage,
): string {
  return JSON.stringify(
    DeveloperMessage$outboundSchema.parse(developerMessage),
  );
}
export function developerMessageFromJSON(
  jsonString: string,
): SafeParseResult<DeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeveloperMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesContent$inboundSchema: z.ZodType<
  PrefixMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type PrefixMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const PrefixMessagesContent$outboundSchema: z.ZodType<
  PrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  PrefixMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function prefixMessagesContentToJSON(
  prefixMessagesContent: PrefixMessagesContent,
): string {
  return JSON.stringify(
    PrefixMessagesContent$outboundSchema.parse(prefixMessagesContent),
  );
}
export function prefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const SystemMessage$inboundSchema: z.ZodType<
  SystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type SystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const SystemMessage$outboundSchema: z.ZodType<
  SystemMessage$Outbound,
  z.ZodTypeDef,
  SystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function systemMessageToJSON(systemMessage: SystemMessage): string {
  return JSON.stringify(SystemMessage$outboundSchema.parse(systemMessage));
}
export function systemMessageFromJSON(
  jsonString: string,
): SafeParseResult<SystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SystemMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessages$inboundSchema: z.ZodType<
  PrefixMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SystemMessage$inboundSchema),
  z.lazy(() => DeveloperMessage$inboundSchema),
  z.lazy(() => UserMessage$inboundSchema),
  z.lazy(() => AssistantMessage$inboundSchema),
  z.lazy(() => ToolMessage$inboundSchema),
]);
/** @internal */
export type PrefixMessages$Outbound =
  | SystemMessage$Outbound
  | DeveloperMessage$Outbound
  | UserMessage$Outbound
  | AssistantMessage$Outbound
  | ToolMessage$Outbound;

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.union([
  z.lazy(() => SystemMessage$outboundSchema),
  z.lazy(() => DeveloperMessage$outboundSchema),
  z.lazy(() => UserMessage$outboundSchema),
  z.lazy(() => AssistantMessage$outboundSchema),
  z.lazy(() => ToolMessage$outboundSchema),
]);

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}
export function prefixMessagesFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$inboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2,
    z.ZodTypeDef,
    unknown
  > = components.TextContentPartSchema$inboundSchema;
/** @internal */
export type DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$Outbound =
  components.TextContentPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2
  > = components.TextContentPartSchema$outboundSchema;

export function deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2ToJSON(
  deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2:
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$outboundSchema
      .parse(deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2),
  );
}
export function deploymentGetConfigContentDeploymentsRequestRequestBodyMessages2FromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContentDeploymentsRequestRequestBodyMessages2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]);
/** @internal */
export type DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent
  > = z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]);

export function deploymentGetConfigMessagesDeploymentsRequestRequestBodyContentToJSON(
  deploymentGetConfigMessagesDeploymentsRequestRequestBodyContent:
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$outboundSchema
      .parse(deploymentGetConfigMessagesDeploymentsRequestRequestBodyContent),
  );
}
export function deploymentGetConfigMessagesDeploymentsRequestRequestBodyContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigMessagesDeploymentsRequestRequestBodyContent' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigMessagesType
> = z.nativeEnum(DeploymentGetConfigMessagesType);
/** @internal */
export const DeploymentGetConfigMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigMessagesType
> = DeploymentGetConfigMessagesType$inboundSchema;

/** @internal */
export const MessagesTtl$inboundSchema: z.ZodNativeEnum<typeof MessagesTtl> = z
  .nativeEnum(MessagesTtl);
/** @internal */
export const MessagesTtl$outboundSchema: z.ZodNativeEnum<typeof MessagesTtl> =
  MessagesTtl$inboundSchema;

/** @internal */
export const MessagesCacheControl$inboundSchema: z.ZodType<
  MessagesCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigMessagesType$inboundSchema,
  ttl: MessagesTtl$inboundSchema.default("5m"),
});
/** @internal */
export type MessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const MessagesCacheControl$outboundSchema: z.ZodType<
  MessagesCacheControl$Outbound,
  z.ZodTypeDef,
  MessagesCacheControl
> = z.object({
  type: DeploymentGetConfigMessagesType$outboundSchema,
  ttl: MessagesTtl$outboundSchema.default("5m"),
});

export function messagesCacheControlToJSON(
  messagesCacheControl: MessagesCacheControl,
): string {
  return JSON.stringify(
    MessagesCacheControl$outboundSchema.parse(messagesCacheControl),
  );
}
export function messagesCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<MessagesCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesCacheControl' from JSON`,
  );
}

/** @internal */
export const MessagesToolMessage$inboundSchema: z.ZodType<
  MessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  tool_call_id: z.string(),
  cache_control: z.lazy(() => MessagesCacheControl$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type MessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  tool_call_id: string;
  cache_control?: MessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const MessagesToolMessage$outboundSchema: z.ZodType<
  MessagesToolMessage$Outbound,
  z.ZodTypeDef,
  MessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  toolCallId: z.string(),
  cacheControl: z.lazy(() => MessagesCacheControl$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function messagesToolMessageToJSON(
  messagesToolMessage: MessagesToolMessage,
): string {
  return JSON.stringify(
    MessagesToolMessage$outboundSchema.parse(messagesToolMessage),
  );
}
export function messagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBody2$inboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBody2,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.TextContentPartSchema$inboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.RefusalPartSchema$inboundSchema,
    components.ReasoningPartSchema$inboundSchema,
    components.RedactedReasoningPartSchema$inboundSchema,
  ]);
/** @internal */
export type DeploymentGetConfigContentDeploymentsRequestRequestBody2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.RefusalPartSchema$Outbound
  | components.ReasoningPartSchema$Outbound
  | components.RedactedReasoningPartSchema$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequestRequestBody2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequestRequestBody2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequestRequestBody2
  > = z.union([
    components.TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.RefusalPartSchema$outboundSchema,
    components.ReasoningPartSchema$outboundSchema,
    components.RedactedReasoningPartSchema$outboundSchema,
  ]);

export function deploymentGetConfigContentDeploymentsRequestRequestBody2ToJSON(
  deploymentGetConfigContentDeploymentsRequestRequestBody2:
    DeploymentGetConfigContentDeploymentsRequestRequestBody2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequestRequestBody2$outboundSchema
      .parse(deploymentGetConfigContentDeploymentsRequestRequestBody2),
  );
}
export function deploymentGetConfigContentDeploymentsRequestRequestBody2FromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigContentDeploymentsRequestRequestBody2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeploymentsRequestRequestBody2$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContentDeploymentsRequestRequestBody2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$inboundSchema,
        components.ReasoningPartSchema$inboundSchema,
        components.RedactedReasoningPartSchema$inboundSchema,
      ]),
    ),
  ]);
/** @internal */
export type DeploymentGetConfigMessagesDeploymentsRequestContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.RefusalPartSchema$Outbound
    | components.ReasoningPartSchema$Outbound
    | components.RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsRequestContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsRequestContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsRequestContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.RefusalPartSchema$outboundSchema,
        components.ReasoningPartSchema$outboundSchema,
        components.RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function deploymentGetConfigMessagesDeploymentsRequestContentToJSON(
  deploymentGetConfigMessagesDeploymentsRequestContent:
    DeploymentGetConfigMessagesDeploymentsRequestContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsRequestContent$outboundSchema.parse(
      deploymentGetConfigMessagesDeploymentsRequestContent,
    ),
  );
}
export function deploymentGetConfigMessagesDeploymentsRequestContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigMessagesDeploymentsRequestContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigMessagesDeploymentsRequestContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigMessagesDeploymentsRequestContent' from JSON`,
  );
}

/** @internal */
export const MessagesAudio$inboundSchema: z.ZodType<
  MessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});
/** @internal */
export type MessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const MessagesAudio$outboundSchema: z.ZodType<
  MessagesAudio$Outbound,
  z.ZodTypeDef,
  MessagesAudio
> = z.object({
  id: z.string(),
});

export function messagesAudioToJSON(messagesAudio: MessagesAudio): string {
  return JSON.stringify(MessagesAudio$outboundSchema.parse(messagesAudio));
}
export function messagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAudio' from JSON`,
  );
}

/** @internal */
export const MessagesType$inboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  z.nativeEnum(MessagesType);
/** @internal */
export const MessagesType$outboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  MessagesType$inboundSchema;

/** @internal */
export const MessagesFunction$inboundSchema: z.ZodType<
  MessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type MessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const MessagesFunction$outboundSchema: z.ZodType<
  MessagesFunction$Outbound,
  z.ZodTypeDef,
  MessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function messagesFunctionToJSON(
  messagesFunction: MessagesFunction,
): string {
  return JSON.stringify(
    MessagesFunction$outboundSchema.parse(messagesFunction),
  );
}
export function messagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<MessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesFunction' from JSON`,
  );
}

/** @internal */
export const MessagesToolCalls$inboundSchema: z.ZodType<
  MessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: MessagesType$inboundSchema,
  function: z.lazy(() => MessagesFunction$inboundSchema),
  thought_signature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "thought_signature": "thoughtSignature",
  });
});
/** @internal */
export type MessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: MessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const MessagesToolCalls$outboundSchema: z.ZodType<
  MessagesToolCalls$Outbound,
  z.ZodTypeDef,
  MessagesToolCalls
> = z.object({
  id: z.string(),
  type: MessagesType$outboundSchema,
  function: z.lazy(() => MessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function messagesToolCallsToJSON(
  messagesToolCalls: MessagesToolCalls,
): string {
  return JSON.stringify(
    MessagesToolCalls$outboundSchema.parse(messagesToolCalls),
  );
}
export function messagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const MessagesAssistantMessage$inboundSchema: z.ZodType<
  MessagesAssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$inboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$inboundSchema,
          components.ReasoningPartSchema$inboundSchema,
          components.RedactedReasoningPartSchema$inboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => MessagesToolCalls$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});
/** @internal */
export type MessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.RefusalPartSchema$Outbound
      | components.ReasoningPartSchema$Outbound
      | components.RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: MessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<MessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const MessagesAssistantMessage$outboundSchema: z.ZodType<
  MessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  MessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          components.TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          components.RefusalPartSchema$outboundSchema,
          components.ReasoningPartSchema$outboundSchema,
          components.RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => MessagesToolCalls$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function messagesAssistantMessageToJSON(
  messagesAssistantMessage: MessagesAssistantMessage,
): string {
  return JSON.stringify(
    MessagesAssistantMessage$outboundSchema.parse(messagesAssistantMessage),
  );
}
export function messagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig2DeploymentsRequestRequestBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfig2DeploymentsRequestRequestBodyType
  > = z.nativeEnum(DeploymentGetConfig2DeploymentsRequestRequestBodyType);
/** @internal */
export const DeploymentGetConfig2DeploymentsRequestRequestBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfig2DeploymentsRequestRequestBodyType
  > = DeploymentGetConfig2DeploymentsRequestRequestBodyType$inboundSchema;

/** @internal */
export const TwoTtl$inboundSchema: z.ZodNativeEnum<typeof TwoTtl> = z
  .nativeEnum(TwoTtl);
/** @internal */
export const TwoTtl$outboundSchema: z.ZodNativeEnum<typeof TwoTtl> =
  TwoTtl$inboundSchema;

/** @internal */
export const TwoCacheControl$inboundSchema: z.ZodType<
  TwoCacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfig2DeploymentsRequestRequestBodyType$inboundSchema,
  ttl: TwoTtl$inboundSchema.default("5m"),
});
/** @internal */
export type TwoCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const TwoCacheControl$outboundSchema: z.ZodType<
  TwoCacheControl$Outbound,
  z.ZodTypeDef,
  TwoCacheControl
> = z.object({
  type: DeploymentGetConfig2DeploymentsRequestRequestBodyType$outboundSchema,
  ttl: TwoTtl$outboundSchema.default("5m"),
});

export function twoCacheControlToJSON(
  twoCacheControl: TwoCacheControl,
): string {
  return JSON.stringify(TwoCacheControl$outboundSchema.parse(twoCacheControl));
}
export function twoCacheControlFromJSON(
  jsonString: string,
): SafeParseResult<TwoCacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoCacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoCacheControl' from JSON`,
  );
}

/** @internal */
export const Two4$inboundSchema: z.ZodType<Two4, z.ZodTypeDef, unknown> = z
  .object({
    type: z.literal("file"),
    cache_control: z.lazy(() => TwoCacheControl$inboundSchema).optional(),
    file: components.FileContentPartSchema$inboundSchema,
  }).transform((v) => {
    return remap$(v, {
      "cache_control": "cacheControl",
    });
  });
/** @internal */
export type Two4$Outbound = {
  type: "file";
  cache_control?: TwoCacheControl$Outbound | undefined;
  file: components.FileContentPartSchema$Outbound;
};

/** @internal */
export const Two4$outboundSchema: z.ZodType<Two4$Outbound, z.ZodTypeDef, Two4> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() => TwoCacheControl$outboundSchema).optional(),
    file: components.FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function two4ToJSON(two4: Two4): string {
  return JSON.stringify(Two4$outboundSchema.parse(two4));
}
export function two4FromJSON(
  jsonString: string,
): SafeParseResult<Two4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two4' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequest2$inboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequest2,
    z.ZodTypeDef,
    unknown
  > = z.union([
    components.TextContentPartSchema$inboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.ImageContentPartSchema$inboundSchema,
    components.AudioContentPartSchema$inboundSchema,
    z.lazy(() => Two4$inboundSchema),
  ]);
/** @internal */
export type DeploymentGetConfigContentDeploymentsRequest2$Outbound =
  | (components.TextContentPartSchema$Outbound & { type: "text" })
  | components.ImageContentPartSchema$Outbound
  | components.AudioContentPartSchema$Outbound
  | Two4$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsRequest2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsRequest2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsRequest2
  > = z.union([
    components.TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    components.ImageContentPartSchema$outboundSchema,
    components.AudioContentPartSchema$outboundSchema,
    z.lazy(() => Two4$outboundSchema),
  ]);

export function deploymentGetConfigContentDeploymentsRequest2ToJSON(
  deploymentGetConfigContentDeploymentsRequest2:
    DeploymentGetConfigContentDeploymentsRequest2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsRequest2$outboundSchema.parse(
      deploymentGetConfigContentDeploymentsRequest2,
    ),
  );
}
export function deploymentGetConfigContentDeploymentsRequest2FromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigContentDeploymentsRequest2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeploymentsRequest2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigContentDeploymentsRequest2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsContent$inboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsContent,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => Two4$inboundSchema),
      ]),
    ),
  ]);
/** @internal */
export type DeploymentGetConfigMessagesDeploymentsContent$Outbound =
  | string
  | Array<
    | (components.TextContentPartSchema$Outbound & { type: "text" })
    | components.ImageContentPartSchema$Outbound
    | components.AudioContentPartSchema$Outbound
    | Two4$Outbound
  >;

/** @internal */
export const DeploymentGetConfigMessagesDeploymentsContent$outboundSchema:
  z.ZodType<
    DeploymentGetConfigMessagesDeploymentsContent$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigMessagesDeploymentsContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Two4$outboundSchema),
      ]),
    ),
  ]);

export function deploymentGetConfigMessagesDeploymentsContentToJSON(
  deploymentGetConfigMessagesDeploymentsContent:
    DeploymentGetConfigMessagesDeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesDeploymentsContent$outboundSchema.parse(
      deploymentGetConfigMessagesDeploymentsContent,
    ),
  );
}
export function deploymentGetConfigMessagesDeploymentsContentFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigMessagesDeploymentsContent,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigMessagesDeploymentsContent$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigMessagesDeploymentsContent' from JSON`,
  );
}

/** @internal */
export const MessagesUserMessage$inboundSchema: z.ZodType<
  MessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$inboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$inboundSchema,
        components.AudioContentPartSchema$inboundSchema,
        z.lazy(() => Two4$inboundSchema),
      ]),
    ),
  ]),
});
/** @internal */
export type MessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (components.TextContentPartSchema$Outbound & { type: "text" })
      | components.ImageContentPartSchema$Outbound
      | components.AudioContentPartSchema$Outbound
      | Two4$Outbound
    >;
};

/** @internal */
export const MessagesUserMessage$outboundSchema: z.ZodType<
  MessagesUserMessage$Outbound,
  z.ZodTypeDef,
  MessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        components.TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        components.ImageContentPartSchema$outboundSchema,
        components.AudioContentPartSchema$outboundSchema,
        z.lazy(() => Two4$outboundSchema),
      ]),
    ),
  ]),
});

export function messagesUserMessageToJSON(
  messagesUserMessage: MessagesUserMessage,
): string {
  return JSON.stringify(
    MessagesUserMessage$outboundSchema.parse(messagesUserMessage),
  );
}
export function messagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessagesContent$inboundSchema: z.ZodType<
  DeploymentGetConfigMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type DeploymentGetConfigMessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const DeploymentGetConfigMessagesContent$outboundSchema: z.ZodType<
  DeploymentGetConfigMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigMessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function deploymentGetConfigMessagesContentToJSON(
  deploymentGetConfigMessagesContent: DeploymentGetConfigMessagesContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessagesContent$outboundSchema.parse(
      deploymentGetConfigMessagesContent,
    ),
  );
}
export function deploymentGetConfigMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigMessagesContent' from JSON`,
  );
}

/** @internal */
export const MessagesDeveloperMessage$inboundSchema: z.ZodType<
  MessagesDeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type MessagesDeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesDeveloperMessage$outboundSchema: z.ZodType<
  MessagesDeveloperMessage$Outbound,
  z.ZodTypeDef,
  MessagesDeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function messagesDeveloperMessageToJSON(
  messagesDeveloperMessage: MessagesDeveloperMessage,
): string {
  return JSON.stringify(
    MessagesDeveloperMessage$outboundSchema.parse(messagesDeveloperMessage),
  );
}
export function messagesDeveloperMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesDeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesDeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesDeveloperMessage' from JSON`,
  );
}

/** @internal */
export const MessagesContent$inboundSchema: z.ZodType<
  MessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$inboundSchema),
]);
/** @internal */
export type MessagesContent$Outbound =
  | string
  | Array<components.TextContentPartSchema$Outbound>;

/** @internal */
export const MessagesContent$outboundSchema: z.ZodType<
  MessagesContent$Outbound,
  z.ZodTypeDef,
  MessagesContent
> = z.union([
  z.string(),
  z.array(components.TextContentPartSchema$outboundSchema),
]);

export function messagesContentToJSON(
  messagesContent: MessagesContent,
): string {
  return JSON.stringify(MessagesContent$outboundSchema.parse(messagesContent));
}
export function messagesContentFromJSON(
  jsonString: string,
): SafeParseResult<MessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesContent' from JSON`,
  );
}

/** @internal */
export const MessagesSystemMessage$inboundSchema: z.ZodType<
  MessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$inboundSchema),
  ]),
  name: z.string().optional(),
});
/** @internal */
export type MessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<components.TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesSystemMessage$outboundSchema: z.ZodType<
  MessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  MessagesSystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([
    z.string(),
    z.array(components.TextContentPartSchema$outboundSchema),
  ]),
  name: z.string().optional(),
});

export function messagesSystemMessageToJSON(
  messagesSystemMessage: MessagesSystemMessage,
): string {
  return JSON.stringify(
    MessagesSystemMessage$outboundSchema.parse(messagesSystemMessage),
  );
}
export function messagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesSystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesSystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigMessages$inboundSchema: z.ZodType<
  DeploymentGetConfigMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => MessagesSystemMessage$inboundSchema),
  z.lazy(() => MessagesDeveloperMessage$inboundSchema),
  z.lazy(() => MessagesUserMessage$inboundSchema),
  z.lazy(() => MessagesAssistantMessage$inboundSchema),
  z.lazy(() => MessagesToolMessage$inboundSchema),
]);
/** @internal */
export type DeploymentGetConfigMessages$Outbound =
  | MessagesSystemMessage$Outbound
  | MessagesDeveloperMessage$Outbound
  | MessagesUserMessage$Outbound
  | MessagesAssistantMessage$Outbound
  | MessagesToolMessage$Outbound;

/** @internal */
export const DeploymentGetConfigMessages$outboundSchema: z.ZodType<
  DeploymentGetConfigMessages$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigMessages
> = z.union([
  z.lazy(() => MessagesSystemMessage$outboundSchema),
  z.lazy(() => MessagesDeveloperMessage$outboundSchema),
  z.lazy(() => MessagesUserMessage$outboundSchema),
  z.lazy(() => MessagesAssistantMessage$outboundSchema),
  z.lazy(() => MessagesToolMessage$outboundSchema),
]);

export function deploymentGetConfigMessagesToJSON(
  deploymentGetConfigMessages: DeploymentGetConfigMessages,
): string {
  return JSON.stringify(
    DeploymentGetConfigMessages$outboundSchema.parse(
      deploymentGetConfigMessages,
    ),
  );
}
export function deploymentGetConfigMessagesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigMessages' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string().optional(),
  file_type: z.string().optional(),
  page_number: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "file_type": "fileType",
    "page_number": "pageNumber",
  });
});
/** @internal */
export type Metadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}
export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const Documents$inboundSchema: z.ZodType<
  Documents,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$inboundSchema).optional(),
});
/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$outboundSchema).optional(),
});

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}
export function documentsFromJSON(
  jsonString: string,
): SafeParseResult<Documents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Documents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Documents' from JSON`,
  );
}

/** @internal */
export const InvokeOptions$inboundSchema: z.ZodType<
  InvokeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_retrievals: z.boolean().default(false),
  include_usage: z.boolean().default(false),
  mock_response: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_retrievals": "includeRetrievals",
    "include_usage": "includeUsage",
    "mock_response": "mockResponse",
  });
});
/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
  include_usage: boolean;
  mock_response?: string | undefined;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
  includeUsage: z.boolean().default(false),
  mockResponse: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
    includeUsage: "include_usage",
    mockResponse: "mock_response",
  });
});

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}
export function invokeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<InvokeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeOptions' from JSON`,
  );
}

/** @internal */
export const Thread$inboundSchema: z.ZodType<Thread, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    tags: z.array(z.string()).optional(),
  });
/** @internal */
export type Thread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Thread$outboundSchema: z.ZodType<
  Thread$Outbound,
  z.ZodTypeDef,
  Thread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function threadToJSON(thread: Thread): string {
  return JSON.stringify(Thread$outboundSchema.parse(thread));
}
export function threadFromJSON(
  jsonString: string,
): SafeParseResult<Thread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thread' from JSON`,
  );
}

/** @internal */
export const OrExists$inboundSchema: z.ZodType<
  OrExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type OrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const OrExists$outboundSchema: z.ZodType<
  OrExists$Outbound,
  z.ZodTypeDef,
  OrExists
> = z.object({
  exists: z.boolean(),
});

export function orExistsToJSON(orExists: OrExists): string {
  return JSON.stringify(OrExists$outboundSchema.parse(orExists));
}
export function orExistsFromJSON(
  jsonString: string,
): SafeParseResult<OrExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrExists' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigOrNin$inboundSchema: z.ZodType<
  DeploymentGetConfigOrNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigOrNin$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrNin$outboundSchema: z.ZodType<
  DeploymentGetConfigOrNin$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrNinToJSON(
  deploymentGetConfigOrNin: DeploymentGetConfigOrNin,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrNin$outboundSchema.parse(deploymentGetConfigOrNin),
  );
}
export function deploymentGetConfigOrNinFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigOrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigOrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigOrNin' from JSON`,
  );
}

/** @internal */
export const OrNin$inboundSchema: z.ZodType<OrNin, z.ZodTypeDef, unknown> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type OrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const OrNin$outboundSchema: z.ZodType<
  OrNin$Outbound,
  z.ZodTypeDef,
  OrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function orNinToJSON(orNin: OrNin): string {
  return JSON.stringify(OrNin$outboundSchema.parse(orNin));
}
export function orNinFromJSON(
  jsonString: string,
): SafeParseResult<OrNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrNin' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigOrIn$inboundSchema: z.ZodType<
  DeploymentGetConfigOrIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigOrIn$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrIn$outboundSchema: z.ZodType<
  DeploymentGetConfigOrIn$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrInToJSON(
  deploymentGetConfigOrIn: DeploymentGetConfigOrIn,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrIn$outboundSchema.parse(deploymentGetConfigOrIn),
  );
}
export function deploymentGetConfigOrInFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigOrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigOrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigOrIn' from JSON`,
  );
}

/** @internal */
export const OrIn$inboundSchema: z.ZodType<OrIn, z.ZodTypeDef, unknown> = z
  .object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type OrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const OrIn$outboundSchema: z.ZodType<OrIn$Outbound, z.ZodTypeDef, OrIn> =
  z.object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function orInToJSON(orIn: OrIn): string {
  return JSON.stringify(OrIn$outboundSchema.parse(orIn));
}
export function orInFromJSON(
  jsonString: string,
): SafeParseResult<OrIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrIn' from JSON`,
  );
}

/** @internal */
export const OrLte$inboundSchema: z.ZodType<OrLte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type OrLte$Outbound = {
  lte: number;
};

/** @internal */
export const OrLte$outboundSchema: z.ZodType<
  OrLte$Outbound,
  z.ZodTypeDef,
  OrLte
> = z.object({
  lte: z.number(),
});

export function orLteToJSON(orLte: OrLte): string {
  return JSON.stringify(OrLte$outboundSchema.parse(orLte));
}
export function orLteFromJSON(
  jsonString: string,
): SafeParseResult<OrLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrLte' from JSON`,
  );
}

/** @internal */
export const OrLt$inboundSchema: z.ZodType<OrLt, z.ZodTypeDef, unknown> = z
  .object({
    lt: z.number(),
  });
/** @internal */
export type OrLt$Outbound = {
  lt: number;
};

/** @internal */
export const OrLt$outboundSchema: z.ZodType<OrLt$Outbound, z.ZodTypeDef, OrLt> =
  z.object({
    lt: z.number(),
  });

export function orLtToJSON(orLt: OrLt): string {
  return JSON.stringify(OrLt$outboundSchema.parse(orLt));
}
export function orLtFromJSON(
  jsonString: string,
): SafeParseResult<OrLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrLt' from JSON`,
  );
}

/** @internal */
export const OrGte$inboundSchema: z.ZodType<OrGte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type OrGte$Outbound = {
  gte: number;
};

/** @internal */
export const OrGte$outboundSchema: z.ZodType<
  OrGte$Outbound,
  z.ZodTypeDef,
  OrGte
> = z.object({
  gte: z.number(),
});

export function orGteToJSON(orGte: OrGte): string {
  return JSON.stringify(OrGte$outboundSchema.parse(orGte));
}
export function orGteFromJSON(
  jsonString: string,
): SafeParseResult<OrGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrGte' from JSON`,
  );
}

/** @internal */
export const OrGt$inboundSchema: z.ZodType<OrGt, z.ZodTypeDef, unknown> = z
  .object({
    gt: z.number(),
  });
/** @internal */
export type OrGt$Outbound = {
  gt: number;
};

/** @internal */
export const OrGt$outboundSchema: z.ZodType<OrGt$Outbound, z.ZodTypeDef, OrGt> =
  z.object({
    gt: z.number(),
  });

export function orGtToJSON(orGt: OrGt): string {
  return JSON.stringify(OrGt$outboundSchema.parse(orGt));
}
export function orGtFromJSON(
  jsonString: string,
): SafeParseResult<OrGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrGt' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigOrNe$inboundSchema: z.ZodType<
  DeploymentGetConfigOrNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigOrNe$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrNe$outboundSchema: z.ZodType<
  DeploymentGetConfigOrNe$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrNeToJSON(
  deploymentGetConfigOrNe: DeploymentGetConfigOrNe,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrNe$outboundSchema.parse(deploymentGetConfigOrNe),
  );
}
export function deploymentGetConfigOrNeFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigOrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigOrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigOrNe' from JSON`,
  );
}

/** @internal */
export const OrNe$inboundSchema: z.ZodType<OrNe, z.ZodTypeDef, unknown> = z
  .object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type OrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const OrNe$outboundSchema: z.ZodType<OrNe$Outbound, z.ZodTypeDef, OrNe> =
  z.object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });

export function orNeToJSON(orNe: OrNe): string {
  return JSON.stringify(OrNe$outboundSchema.parse(orNe));
}
export function orNeFromJSON(
  jsonString: string,
): SafeParseResult<OrNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrNe' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigOrEq$inboundSchema: z.ZodType<
  DeploymentGetConfigOrEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigOrEq$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigOrEq$outboundSchema: z.ZodType<
  DeploymentGetConfigOrEq$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigOrEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigOrEqToJSON(
  deploymentGetConfigOrEq: DeploymentGetConfigOrEq,
): string {
  return JSON.stringify(
    DeploymentGetConfigOrEq$outboundSchema.parse(deploymentGetConfigOrEq),
  );
}
export function deploymentGetConfigOrEqFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigOrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigOrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigOrEq' from JSON`,
  );
}

/** @internal */
export const OrEq$inboundSchema: z.ZodType<OrEq, z.ZodTypeDef, unknown> = z
  .object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type OrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const OrEq$outboundSchema: z.ZodType<OrEq$Outbound, z.ZodTypeDef, OrEq> =
  z.object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });

export function orEqToJSON(orEq: OrEq): string {
  return JSON.stringify(OrEq$outboundSchema.parse(orEq));
}
export function orEqFromJSON(
  jsonString: string,
): SafeParseResult<OrEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OrEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OrEq' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterOr$inboundSchema: z.ZodType<
  KnowledgeFilterOr,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => OrEq$inboundSchema),
  z.lazy(() => OrNe$inboundSchema),
  z.lazy(() => OrGt$inboundSchema),
  z.lazy(() => OrGte$inboundSchema),
  z.lazy(() => OrLt$inboundSchema),
  z.lazy(() => OrLte$inboundSchema),
  z.lazy(() => OrIn$inboundSchema),
  z.lazy(() => OrNin$inboundSchema),
  z.lazy(() => OrExists$inboundSchema),
]);
/** @internal */
export type KnowledgeFilterOr$Outbound =
  | OrEq$Outbound
  | OrNe$Outbound
  | OrGt$Outbound
  | OrGte$Outbound
  | OrLt$Outbound
  | OrLte$Outbound
  | OrIn$Outbound
  | OrNin$Outbound
  | OrExists$Outbound;

/** @internal */
export const KnowledgeFilterOr$outboundSchema: z.ZodType<
  KnowledgeFilterOr$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterOr
> = z.union([
  z.lazy(() => OrEq$outboundSchema),
  z.lazy(() => OrNe$outboundSchema),
  z.lazy(() => OrGt$outboundSchema),
  z.lazy(() => OrGte$outboundSchema),
  z.lazy(() => OrLt$outboundSchema),
  z.lazy(() => OrLte$outboundSchema),
  z.lazy(() => OrIn$outboundSchema),
  z.lazy(() => OrNin$outboundSchema),
  z.lazy(() => OrExists$outboundSchema),
]);

export function knowledgeFilterOrToJSON(
  knowledgeFilterOr: KnowledgeFilterOr,
): string {
  return JSON.stringify(
    KnowledgeFilterOr$outboundSchema.parse(knowledgeFilterOr),
  );
}
export function knowledgeFilterOrFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterOr' from JSON`,
  );
}

/** @internal */
export const Or$inboundSchema: z.ZodType<Or, z.ZodTypeDef, unknown> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => OrEq$inboundSchema),
      z.lazy(() =>
        OrNe$inboundSchema
      ),
      z.lazy(() => OrGt$inboundSchema),
      z.lazy(() => OrGte$inboundSchema),
      z.lazy(() => OrLt$inboundSchema),
      z.lazy(() => OrLte$inboundSchema),
      z.lazy(() => OrIn$inboundSchema),
      z.lazy(() => OrNin$inboundSchema),
      z.lazy(() => OrExists$inboundSchema),
    ])),
  ),
});
/** @internal */
export type Or$Outbound = {
  or: Array<
    {
      [k: string]:
        | OrEq$Outbound
        | OrNe$Outbound
        | OrGt$Outbound
        | OrGte$Outbound
        | OrLt$Outbound
        | OrLte$Outbound
        | OrIn$Outbound
        | OrNin$Outbound
        | OrExists$Outbound;
    }
  >;
};

/** @internal */
export const Or$outboundSchema: z.ZodType<Or$Outbound, z.ZodTypeDef, Or> = z
  .object({
    or: z.array(
      z.record(z.union([
        z.lazy(() => OrEq$outboundSchema),
        z.lazy(() =>
          OrNe$outboundSchema
        ),
        z.lazy(() => OrGt$outboundSchema),
        z.lazy(() => OrGte$outboundSchema),
        z.lazy(() => OrLt$outboundSchema),
        z.lazy(() => OrLte$outboundSchema),
        z.lazy(() => OrIn$outboundSchema),
        z.lazy(() => OrNin$outboundSchema),
        z.lazy(() => OrExists$outboundSchema),
      ])),
    ),
  });

export function orToJSON(or: Or): string {
  return JSON.stringify(Or$outboundSchema.parse(or));
}
export function orFromJSON(
  jsonString: string,
): SafeParseResult<Or, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Or$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Or' from JSON`,
  );
}

/** @internal */
export const AndExists$inboundSchema: z.ZodType<
  AndExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  exists: z.boolean(),
});
/** @internal */
export type AndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const AndExists$outboundSchema: z.ZodType<
  AndExists$Outbound,
  z.ZodTypeDef,
  AndExists
> = z.object({
  exists: z.boolean(),
});

export function andExistsToJSON(andExists: AndExists): string {
  return JSON.stringify(AndExists$outboundSchema.parse(andExists));
}
export function andExistsFromJSON(
  jsonString: string,
): SafeParseResult<AndExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndExists' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigAndNin$inboundSchema: z.ZodType<
  DeploymentGetConfigAndNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigAndNin$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndNin$outboundSchema: z.ZodType<
  DeploymentGetConfigAndNin$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndNinToJSON(
  deploymentGetConfigAndNin: DeploymentGetConfigAndNin,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndNin$outboundSchema.parse(deploymentGetConfigAndNin),
  );
}
export function deploymentGetConfigAndNinFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigAndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigAndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigAndNin' from JSON`,
  );
}

/** @internal */
export const AndNin$inboundSchema: z.ZodType<AndNin, z.ZodTypeDef, unknown> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type AndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const AndNin$outboundSchema: z.ZodType<
  AndNin$Outbound,
  z.ZodTypeDef,
  AndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function andNinToJSON(andNin: AndNin): string {
  return JSON.stringify(AndNin$outboundSchema.parse(andNin));
}
export function andNinFromJSON(
  jsonString: string,
): SafeParseResult<AndNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndNin' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigAndIn$inboundSchema: z.ZodType<
  DeploymentGetConfigAndIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigAndIn$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndIn$outboundSchema: z.ZodType<
  DeploymentGetConfigAndIn$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndInToJSON(
  deploymentGetConfigAndIn: DeploymentGetConfigAndIn,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndIn$outboundSchema.parse(deploymentGetConfigAndIn),
  );
}
export function deploymentGetConfigAndInFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigAndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigAndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigAndIn' from JSON`,
  );
}

/** @internal */
export const AndIn$inboundSchema: z.ZodType<AndIn, z.ZodTypeDef, unknown> = z
  .object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type AndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const AndIn$outboundSchema: z.ZodType<
  AndIn$Outbound,
  z.ZodTypeDef,
  AndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function andInToJSON(andIn: AndIn): string {
  return JSON.stringify(AndIn$outboundSchema.parse(andIn));
}
export function andInFromJSON(
  jsonString: string,
): SafeParseResult<AndIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndIn' from JSON`,
  );
}

/** @internal */
export const AndLte$inboundSchema: z.ZodType<AndLte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type AndLte$Outbound = {
  lte: number;
};

/** @internal */
export const AndLte$outboundSchema: z.ZodType<
  AndLte$Outbound,
  z.ZodTypeDef,
  AndLte
> = z.object({
  lte: z.number(),
});

export function andLteToJSON(andLte: AndLte): string {
  return JSON.stringify(AndLte$outboundSchema.parse(andLte));
}
export function andLteFromJSON(
  jsonString: string,
): SafeParseResult<AndLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndLte' from JSON`,
  );
}

/** @internal */
export const AndLt$inboundSchema: z.ZodType<AndLt, z.ZodTypeDef, unknown> = z
  .object({
    lt: z.number(),
  });
/** @internal */
export type AndLt$Outbound = {
  lt: number;
};

/** @internal */
export const AndLt$outboundSchema: z.ZodType<
  AndLt$Outbound,
  z.ZodTypeDef,
  AndLt
> = z.object({
  lt: z.number(),
});

export function andLtToJSON(andLt: AndLt): string {
  return JSON.stringify(AndLt$outboundSchema.parse(andLt));
}
export function andLtFromJSON(
  jsonString: string,
): SafeParseResult<AndLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndLt' from JSON`,
  );
}

/** @internal */
export const AndGte$inboundSchema: z.ZodType<AndGte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type AndGte$Outbound = {
  gte: number;
};

/** @internal */
export const AndGte$outboundSchema: z.ZodType<
  AndGte$Outbound,
  z.ZodTypeDef,
  AndGte
> = z.object({
  gte: z.number(),
});

export function andGteToJSON(andGte: AndGte): string {
  return JSON.stringify(AndGte$outboundSchema.parse(andGte));
}
export function andGteFromJSON(
  jsonString: string,
): SafeParseResult<AndGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndGte' from JSON`,
  );
}

/** @internal */
export const AndGt$inboundSchema: z.ZodType<AndGt, z.ZodTypeDef, unknown> = z
  .object({
    gt: z.number(),
  });
/** @internal */
export type AndGt$Outbound = {
  gt: number;
};

/** @internal */
export const AndGt$outboundSchema: z.ZodType<
  AndGt$Outbound,
  z.ZodTypeDef,
  AndGt
> = z.object({
  gt: z.number(),
});

export function andGtToJSON(andGt: AndGt): string {
  return JSON.stringify(AndGt$outboundSchema.parse(andGt));
}
export function andGtFromJSON(
  jsonString: string,
): SafeParseResult<AndGt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndGt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndGt' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigAndNe$inboundSchema: z.ZodType<
  DeploymentGetConfigAndNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigAndNe$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndNe$outboundSchema: z.ZodType<
  DeploymentGetConfigAndNe$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndNeToJSON(
  deploymentGetConfigAndNe: DeploymentGetConfigAndNe,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndNe$outboundSchema.parse(deploymentGetConfigAndNe),
  );
}
export function deploymentGetConfigAndNeFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigAndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigAndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigAndNe' from JSON`,
  );
}

/** @internal */
export const AndNe$inboundSchema: z.ZodType<AndNe, z.ZodTypeDef, unknown> = z
  .object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type AndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const AndNe$outboundSchema: z.ZodType<
  AndNe$Outbound,
  z.ZodTypeDef,
  AndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function andNeToJSON(andNe: AndNe): string {
  return JSON.stringify(AndNe$outboundSchema.parse(andNe));
}
export function andNeFromJSON(
  jsonString: string,
): SafeParseResult<AndNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndNe' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigAndEq$inboundSchema: z.ZodType<
  DeploymentGetConfigAndEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type DeploymentGetConfigAndEq$Outbound = string | number | boolean;

/** @internal */
export const DeploymentGetConfigAndEq$outboundSchema: z.ZodType<
  DeploymentGetConfigAndEq$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigAndEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function deploymentGetConfigAndEqToJSON(
  deploymentGetConfigAndEq: DeploymentGetConfigAndEq,
): string {
  return JSON.stringify(
    DeploymentGetConfigAndEq$outboundSchema.parse(deploymentGetConfigAndEq),
  );
}
export function deploymentGetConfigAndEqFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigAndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigAndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigAndEq' from JSON`,
  );
}

/** @internal */
export const AndEq$inboundSchema: z.ZodType<AndEq, z.ZodTypeDef, unknown> = z
  .object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });
/** @internal */
export type AndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const AndEq$outboundSchema: z.ZodType<
  AndEq$Outbound,
  z.ZodTypeDef,
  AndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function andEqToJSON(andEq: AndEq): string {
  return JSON.stringify(AndEq$outboundSchema.parse(andEq));
}
export function andEqFromJSON(
  jsonString: string,
): SafeParseResult<AndEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AndEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AndEq' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterAnd$inboundSchema: z.ZodType<
  KnowledgeFilterAnd,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => AndEq$inboundSchema),
  z.lazy(() => AndNe$inboundSchema),
  z.lazy(() => AndGt$inboundSchema),
  z.lazy(() => AndGte$inboundSchema),
  z.lazy(() => AndLt$inboundSchema),
  z.lazy(() => AndLte$inboundSchema),
  z.lazy(() => AndIn$inboundSchema),
  z.lazy(() => AndNin$inboundSchema),
  z.lazy(() => AndExists$inboundSchema),
]);
/** @internal */
export type KnowledgeFilterAnd$Outbound =
  | AndEq$Outbound
  | AndNe$Outbound
  | AndGt$Outbound
  | AndGte$Outbound
  | AndLt$Outbound
  | AndLte$Outbound
  | AndIn$Outbound
  | AndNin$Outbound
  | AndExists$Outbound;

/** @internal */
export const KnowledgeFilterAnd$outboundSchema: z.ZodType<
  KnowledgeFilterAnd$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterAnd
> = z.union([
  z.lazy(() => AndEq$outboundSchema),
  z.lazy(() => AndNe$outboundSchema),
  z.lazy(() => AndGt$outboundSchema),
  z.lazy(() => AndGte$outboundSchema),
  z.lazy(() => AndLt$outboundSchema),
  z.lazy(() => AndLte$outboundSchema),
  z.lazy(() => AndIn$outboundSchema),
  z.lazy(() => AndNin$outboundSchema),
  z.lazy(() => AndExists$outboundSchema),
]);

export function knowledgeFilterAndToJSON(
  knowledgeFilterAnd: KnowledgeFilterAnd,
): string {
  return JSON.stringify(
    KnowledgeFilterAnd$outboundSchema.parse(knowledgeFilterAnd),
  );
}
export function knowledgeFilterAndFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterAnd' from JSON`,
  );
}

/** @internal */
export const And$inboundSchema: z.ZodType<And, z.ZodTypeDef, unknown> = z
  .object({
    and: z.array(
      z.record(z.union([
        z.lazy(() => AndEq$inboundSchema),
        z.lazy(() =>
          AndNe$inboundSchema
        ),
        z.lazy(() => AndGt$inboundSchema),
        z.lazy(() => AndGte$inboundSchema),
        z.lazy(() => AndLt$inboundSchema),
        z.lazy(() => AndLte$inboundSchema),
        z.lazy(() => AndIn$inboundSchema),
        z.lazy(() => AndNin$inboundSchema),
        z.lazy(() => AndExists$inboundSchema),
      ])),
    ),
  });
/** @internal */
export type And$Outbound = {
  and: Array<
    {
      [k: string]:
        | AndEq$Outbound
        | AndNe$Outbound
        | AndGt$Outbound
        | AndGte$Outbound
        | AndLt$Outbound
        | AndLte$Outbound
        | AndIn$Outbound
        | AndNin$Outbound
        | AndExists$Outbound;
    }
  >;
};

/** @internal */
export const And$outboundSchema: z.ZodType<And$Outbound, z.ZodTypeDef, And> = z
  .object({
    and: z.array(
      z.record(z.union([
        z.lazy(() => AndEq$outboundSchema),
        z.lazy(() =>
          AndNe$outboundSchema
        ),
        z.lazy(() => AndGt$outboundSchema),
        z.lazy(() => AndGte$outboundSchema),
        z.lazy(() => AndLt$outboundSchema),
        z.lazy(() => AndLte$outboundSchema),
        z.lazy(() => AndIn$outboundSchema),
        z.lazy(() => AndNin$outboundSchema),
        z.lazy(() => AndExists$outboundSchema),
      ])),
    ),
  });

export function andToJSON(and: And): string {
  return JSON.stringify(And$outboundSchema.parse(and));
}
export function andFromJSON(
  jsonString: string,
): SafeParseResult<And, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => And$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'And' from JSON`,
  );
}

/** @internal */
export const Exists$inboundSchema: z.ZodType<Exists, z.ZodTypeDef, unknown> = z
  .object({
    exists: z.boolean(),
  });
/** @internal */
export type Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const Exists$outboundSchema: z.ZodType<
  Exists$Outbound,
  z.ZodTypeDef,
  Exists
> = z.object({
  exists: z.boolean(),
});

export function existsToJSON(exists: Exists): string {
  return JSON.stringify(Exists$outboundSchema.parse(exists));
}
export function existsFromJSON(
  jsonString: string,
): SafeParseResult<Exists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Exists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Exists' from JSON`,
  );
}

/** @internal */
export const OneNin$inboundSchema: z.ZodType<OneNin, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OneNin$Outbound = string | number | boolean;

/** @internal */
export const OneNin$outboundSchema: z.ZodType<
  OneNin$Outbound,
  z.ZodTypeDef,
  OneNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneNinToJSON(oneNin: OneNin): string {
  return JSON.stringify(OneNin$outboundSchema.parse(oneNin));
}
export function oneNinFromJSON(
  jsonString: string,
): SafeParseResult<OneNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneNin' from JSON`,
  );
}

/** @internal */
export const Nin$inboundSchema: z.ZodType<Nin, z.ZodTypeDef, unknown> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });
/** @internal */
export type Nin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const Nin$outboundSchema: z.ZodType<Nin$Outbound, z.ZodTypeDef, Nin> = z
  .object({
    nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function ninToJSON(nin: Nin): string {
  return JSON.stringify(Nin$outboundSchema.parse(nin));
}
export function ninFromJSON(
  jsonString: string,
): SafeParseResult<Nin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Nin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Nin' from JSON`,
  );
}

/** @internal */
export const OneIn$inboundSchema: z.ZodType<OneIn, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OneIn$Outbound = string | number | boolean;

/** @internal */
export const OneIn$outboundSchema: z.ZodType<
  OneIn$Outbound,
  z.ZodTypeDef,
  OneIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneInToJSON(oneIn: OneIn): string {
  return JSON.stringify(OneIn$outboundSchema.parse(oneIn));
}
export function oneInFromJSON(
  jsonString: string,
): SafeParseResult<OneIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneIn' from JSON`,
  );
}

/** @internal */
export const In$inboundSchema: z.ZodType<In, z.ZodTypeDef, unknown> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});
/** @internal */
export type In$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const In$outboundSchema: z.ZodType<In$Outbound, z.ZodTypeDef, In> = z
  .object({
    in: z.array(z.union([z.string(), z.number(), z.boolean()])),
  });

export function inToJSON(value: In): string {
  return JSON.stringify(In$outboundSchema.parse(value));
}
export function inFromJSON(
  jsonString: string,
): SafeParseResult<In, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => In$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'In' from JSON`,
  );
}

/** @internal */
export const Lte$inboundSchema: z.ZodType<Lte, z.ZodTypeDef, unknown> = z
  .object({
    lte: z.number(),
  });
/** @internal */
export type Lte$Outbound = {
  lte: number;
};

/** @internal */
export const Lte$outboundSchema: z.ZodType<Lte$Outbound, z.ZodTypeDef, Lte> = z
  .object({
    lte: z.number(),
  });

export function lteToJSON(lte: Lte): string {
  return JSON.stringify(Lte$outboundSchema.parse(lte));
}
export function lteFromJSON(
  jsonString: string,
): SafeParseResult<Lte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lte' from JSON`,
  );
}

/** @internal */
export const Lt$inboundSchema: z.ZodType<Lt, z.ZodTypeDef, unknown> = z.object({
  lt: z.number(),
});
/** @internal */
export type Lt$Outbound = {
  lt: number;
};

/** @internal */
export const Lt$outboundSchema: z.ZodType<Lt$Outbound, z.ZodTypeDef, Lt> = z
  .object({
    lt: z.number(),
  });

export function ltToJSON(lt: Lt): string {
  return JSON.stringify(Lt$outboundSchema.parse(lt));
}
export function ltFromJSON(
  jsonString: string,
): SafeParseResult<Lt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Lt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Lt' from JSON`,
  );
}

/** @internal */
export const Gte$inboundSchema: z.ZodType<Gte, z.ZodTypeDef, unknown> = z
  .object({
    gte: z.number(),
  });
/** @internal */
export type Gte$Outbound = {
  gte: number;
};

/** @internal */
export const Gte$outboundSchema: z.ZodType<Gte$Outbound, z.ZodTypeDef, Gte> = z
  .object({
    gte: z.number(),
  });

export function gteToJSON(gte: Gte): string {
  return JSON.stringify(Gte$outboundSchema.parse(gte));
}
export function gteFromJSON(
  jsonString: string,
): SafeParseResult<Gte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gte' from JSON`,
  );
}

/** @internal */
export const Gt$inboundSchema: z.ZodType<Gt, z.ZodTypeDef, unknown> = z.object({
  gt: z.number(),
});
/** @internal */
export type Gt$Outbound = {
  gt: number;
};

/** @internal */
export const Gt$outboundSchema: z.ZodType<Gt$Outbound, z.ZodTypeDef, Gt> = z
  .object({
    gt: z.number(),
  });

export function gtToJSON(gt: Gt): string {
  return JSON.stringify(Gt$outboundSchema.parse(gt));
}
export function gtFromJSON(
  jsonString: string,
): SafeParseResult<Gt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Gt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Gt' from JSON`,
  );
}

/** @internal */
export const OneNe$inboundSchema: z.ZodType<OneNe, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OneNe$Outbound = string | number | boolean;

/** @internal */
export const OneNe$outboundSchema: z.ZodType<
  OneNe$Outbound,
  z.ZodTypeDef,
  OneNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneNeToJSON(oneNe: OneNe): string {
  return JSON.stringify(OneNe$outboundSchema.parse(oneNe));
}
export function oneNeFromJSON(
  jsonString: string,
): SafeParseResult<OneNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneNe' from JSON`,
  );
}

/** @internal */
export const Ne$inboundSchema: z.ZodType<Ne, z.ZodTypeDef, unknown> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type Ne$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const Ne$outboundSchema: z.ZodType<Ne$Outbound, z.ZodTypeDef, Ne> = z
  .object({
    ne: z.union([z.string(), z.number(), z.boolean()]),
  });

export function neToJSON(ne: Ne): string {
  return JSON.stringify(Ne$outboundSchema.parse(ne));
}
export function neFromJSON(
  jsonString: string,
): SafeParseResult<Ne, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Ne$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Ne' from JSON`,
  );
}

/** @internal */
export const OneEq$inboundSchema: z.ZodType<OneEq, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);
/** @internal */
export type OneEq$Outbound = string | number | boolean;

/** @internal */
export const OneEq$outboundSchema: z.ZodType<
  OneEq$Outbound,
  z.ZodTypeDef,
  OneEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function oneEqToJSON(oneEq: OneEq): string {
  return JSON.stringify(OneEq$outboundSchema.parse(oneEq));
}
export function oneEqFromJSON(
  jsonString: string,
): SafeParseResult<OneEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneEq' from JSON`,
  );
}

/** @internal */
export const Eq$inboundSchema: z.ZodType<Eq, z.ZodTypeDef, unknown> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});
/** @internal */
export type Eq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const Eq$outboundSchema: z.ZodType<Eq$Outbound, z.ZodTypeDef, Eq> = z
  .object({
    eq: z.union([z.string(), z.number(), z.boolean()]),
  });

export function eqToJSON(eq: Eq): string {
  return JSON.stringify(Eq$outboundSchema.parse(eq));
}
export function eqFromJSON(
  jsonString: string,
): SafeParseResult<Eq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Eq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Eq' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilter1$inboundSchema: z.ZodType<
  KnowledgeFilter1,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Eq$inboundSchema),
  z.lazy(() => Ne$inboundSchema),
  z.lazy(() => Gt$inboundSchema),
  z.lazy(() => Gte$inboundSchema),
  z.lazy(() => Lt$inboundSchema),
  z.lazy(() => Lte$inboundSchema),
  z.lazy(() => In$inboundSchema),
  z.lazy(() => Nin$inboundSchema),
  z.lazy(() => Exists$inboundSchema),
]);
/** @internal */
export type KnowledgeFilter1$Outbound =
  | Eq$Outbound
  | Ne$Outbound
  | Gt$Outbound
  | Gte$Outbound
  | Lt$Outbound
  | Lte$Outbound
  | In$Outbound
  | Nin$Outbound
  | Exists$Outbound;

/** @internal */
export const KnowledgeFilter1$outboundSchema: z.ZodType<
  KnowledgeFilter1$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter1
> = z.union([
  z.lazy(() => Eq$outboundSchema),
  z.lazy(() => Ne$outboundSchema),
  z.lazy(() => Gt$outboundSchema),
  z.lazy(() => Gte$outboundSchema),
  z.lazy(() => Lt$outboundSchema),
  z.lazy(() => Lte$outboundSchema),
  z.lazy(() => In$outboundSchema),
  z.lazy(() => Nin$outboundSchema),
  z.lazy(() => Exists$outboundSchema),
]);

export function knowledgeFilter1ToJSON(
  knowledgeFilter1: KnowledgeFilter1,
): string {
  return JSON.stringify(
    KnowledgeFilter1$outboundSchema.parse(knowledgeFilter1),
  );
}
export function knowledgeFilter1FromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilter1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilter1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilter1' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilter$inboundSchema: z.ZodType<
  KnowledgeFilter,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => And$inboundSchema),
  z.lazy(() => Or$inboundSchema),
  z.record(z.union([
    z.lazy(() => Eq$inboundSchema),
    z.lazy(() => Ne$inboundSchema),
    z.lazy(() => Gt$inboundSchema),
    z.lazy(() => Gte$inboundSchema),
    z.lazy(() => Lt$inboundSchema),
    z.lazy(() => Lte$inboundSchema),
    z.lazy(() => In$inboundSchema),
    z.lazy(() => Nin$inboundSchema),
    z.lazy(() => Exists$inboundSchema),
  ])),
]);
/** @internal */
export type KnowledgeFilter$Outbound = And$Outbound | Or$Outbound | {
  [k: string]:
    | Eq$Outbound
    | Ne$Outbound
    | Gt$Outbound
    | Gte$Outbound
    | Lt$Outbound
    | Lte$Outbound
    | In$Outbound
    | Nin$Outbound
    | Exists$Outbound;
};

/** @internal */
export const KnowledgeFilter$outboundSchema: z.ZodType<
  KnowledgeFilter$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter
> = z.union([
  z.lazy(() => And$outboundSchema),
  z.lazy(() => Or$outboundSchema),
  z.record(z.union([
    z.lazy(() => Eq$outboundSchema),
    z.lazy(() => Ne$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => In$outboundSchema),
    z.lazy(() => Nin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ])),
]);

export function knowledgeFilterToJSON(
  knowledgeFilter: KnowledgeFilter,
): string {
  return JSON.stringify(KnowledgeFilter$outboundSchema.parse(knowledgeFilter));
}
export function knowledgeFilterFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilter' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigRequestBody$inboundSchema: z.ZodType<
  DeploymentGetConfigRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefix_messages: z.array(
    z.union([
      z.lazy(() => SystemMessage$inboundSchema),
      z.lazy(() => DeveloperMessage$inboundSchema),
      z.lazy(() => UserMessage$inboundSchema),
      z.lazy(() => AssistantMessage$inboundSchema),
      z.lazy(() => ToolMessage$inboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesSystemMessage$inboundSchema),
      z.lazy(() => MessagesDeveloperMessage$inboundSchema),
      z.lazy(() => MessagesUserMessage$inboundSchema),
      z.lazy(() => MessagesAssistantMessage$inboundSchema),
      z.lazy(() => MessagesToolMessage$inboundSchema),
    ]),
  ).optional(),
  file_ids: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extra_params: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$inboundSchema)).optional(),
  invoke_options: z.lazy(() => InvokeOptions$inboundSchema).optional(),
  thread: z.lazy(() => Thread$inboundSchema).optional(),
  knowledge_filter: z.union([
    z.lazy(() => And$inboundSchema),
    z.lazy(() => Or$inboundSchema),
    z.record(z.union([
      z.lazy(() => Eq$inboundSchema),
      z.lazy(() => Ne$inboundSchema),
      z.lazy(() => Gt$inboundSchema),
      z.lazy(() => Gte$inboundSchema),
      z.lazy(() => Lt$inboundSchema),
      z.lazy(() => Lte$inboundSchema),
      z.lazy(() => In$inboundSchema),
      z.lazy(() => Nin$inboundSchema),
      z.lazy(() => Exists$inboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "prefix_messages": "prefixMessages",
    "file_ids": "fileIds",
    "extra_params": "extraParams",
    "invoke_options": "invokeOptions",
    "knowledge_filter": "knowledgeFilter",
  });
});
/** @internal */
export type DeploymentGetConfigRequestBody$Outbound = {
  key: string;
  inputs?: { [k: string]: any } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?:
    | Array<
      | SystemMessage$Outbound
      | DeveloperMessage$Outbound
      | UserMessage$Outbound
      | AssistantMessage$Outbound
      | ToolMessage$Outbound
    >
    | undefined;
  messages?:
    | Array<
      | MessagesSystemMessage$Outbound
      | MessagesDeveloperMessage$Outbound
      | MessagesUserMessage$Outbound
      | MessagesAssistantMessage$Outbound
      | MessagesToolMessage$Outbound
    >
    | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
  thread?: Thread$Outbound | undefined;
  knowledge_filter?: And$Outbound | Or$Outbound | {
    [k: string]:
      | Eq$Outbound
      | Ne$Outbound
      | Gt$Outbound
      | Gte$Outbound
      | Lt$Outbound
      | Lte$Outbound
      | In$Outbound
      | Nin$Outbound
      | Exists$Outbound;
  } | undefined;
};

/** @internal */
export const DeploymentGetConfigRequestBody$outboundSchema: z.ZodType<
  DeploymentGetConfigRequestBody$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigRequestBody
> = z.object({
  key: z.string(),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(
    z.union([
      z.lazy(() => SystemMessage$outboundSchema),
      z.lazy(() => DeveloperMessage$outboundSchema),
      z.lazy(() => UserMessage$outboundSchema),
      z.lazy(() => AssistantMessage$outboundSchema),
      z.lazy(() => ToolMessage$outboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesSystemMessage$outboundSchema),
      z.lazy(() => MessagesDeveloperMessage$outboundSchema),
      z.lazy(() => MessagesUserMessage$outboundSchema),
      z.lazy(() => MessagesAssistantMessage$outboundSchema),
      z.lazy(() => MessagesToolMessage$outboundSchema),
    ]),
  ).optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
  thread: z.lazy(() => Thread$outboundSchema).optional(),
  knowledgeFilter: z.union([
    z.lazy(() => And$outboundSchema),
    z.lazy(() => Or$outboundSchema),
    z.record(z.union([
      z.lazy(() => Eq$outboundSchema),
      z.lazy(() => Ne$outboundSchema),
      z.lazy(() => Gt$outboundSchema),
      z.lazy(() => Gte$outboundSchema),
      z.lazy(() => Lt$outboundSchema),
      z.lazy(() => Lte$outboundSchema),
      z.lazy(() => In$outboundSchema),
      z.lazy(() => Nin$outboundSchema),
      z.lazy(() => Exists$outboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
    knowledgeFilter: "knowledge_filter",
  });
});

export function deploymentGetConfigRequestBodyToJSON(
  deploymentGetConfigRequestBody: DeploymentGetConfigRequestBody,
): string {
  return JSON.stringify(
    DeploymentGetConfigRequestBody$outboundSchema.parse(
      deploymentGetConfigRequestBody,
    ),
  );
}
export function deploymentGetConfigRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigRequestBody' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigType
> = z.nativeEnum(DeploymentGetConfigType);
/** @internal */
export const DeploymentGetConfigType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigType
> = DeploymentGetConfigType$inboundSchema;

/** @internal */
export const DeploymentGetConfigRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigRole
> = z.nativeEnum(DeploymentGetConfigRole);
/** @internal */
export const DeploymentGetConfigRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigRole
> = DeploymentGetConfigRole$inboundSchema;

/** @internal */
export const DeploymentGetConfig2File$inboundSchema: z.ZodType<
  DeploymentGetConfig2File,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_data: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_data": "fileData",
  });
});
/** @internal */
export type DeploymentGetConfig2File$Outbound = {
  file_data?: string | undefined;
  uri?: string | undefined;
  mimeType?: string | undefined;
  filename?: string | undefined;
};

/** @internal */
export const DeploymentGetConfig2File$outboundSchema: z.ZodType<
  DeploymentGetConfig2File$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfig2File
> = z.object({
  fileData: z.string().optional(),
  uri: z.string().optional(),
  mimeType: z.string().optional(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

export function deploymentGetConfig2FileToJSON(
  deploymentGetConfig2File: DeploymentGetConfig2File,
): string {
  return JSON.stringify(
    DeploymentGetConfig2File$outboundSchema.parse(deploymentGetConfig2File),
  );
}
export function deploymentGetConfig2FileFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig2File, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig2File$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig2File' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig23$inboundSchema: z.ZodType<
  DeploymentGetConfig23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => DeploymentGetConfig2File$inboundSchema),
});
/** @internal */
export type DeploymentGetConfig23$Outbound = {
  type: "file";
  file: DeploymentGetConfig2File$Outbound;
};

/** @internal */
export const DeploymentGetConfig23$outboundSchema: z.ZodType<
  DeploymentGetConfig23$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfig23
> = z.object({
  type: z.literal("file"),
  file: z.lazy(() => DeploymentGetConfig2File$outboundSchema),
});

export function deploymentGetConfig23ToJSON(
  deploymentGetConfig23: DeploymentGetConfig23,
): string {
  return JSON.stringify(
    DeploymentGetConfig23$outboundSchema.parse(deploymentGetConfig23),
  );
}
export function deploymentGetConfig23FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig23' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig2ImageUrl$inboundSchema: z.ZodType<
  DeploymentGetConfig2ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});
/** @internal */
export type DeploymentGetConfig2ImageUrl$Outbound = {
  id?: string | undefined;
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const DeploymentGetConfig2ImageUrl$outboundSchema: z.ZodType<
  DeploymentGetConfig2ImageUrl$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfig2ImageUrl
> = z.object({
  id: z.string().optional(),
  url: z.string(),
  detail: z.string().optional(),
});

export function deploymentGetConfig2ImageUrlToJSON(
  deploymentGetConfig2ImageUrl: DeploymentGetConfig2ImageUrl,
): string {
  return JSON.stringify(
    DeploymentGetConfig2ImageUrl$outboundSchema.parse(
      deploymentGetConfig2ImageUrl,
    ),
  );
}
export function deploymentGetConfig2ImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig2ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig2ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig2ImageUrl' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig22$inboundSchema: z.ZodType<
  DeploymentGetConfig22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("image_url"),
  image_url: z.lazy(() => DeploymentGetConfig2ImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});
/** @internal */
export type DeploymentGetConfig22$Outbound = {
  type: "image_url";
  image_url: DeploymentGetConfig2ImageUrl$Outbound;
};

/** @internal */
export const DeploymentGetConfig22$outboundSchema: z.ZodType<
  DeploymentGetConfig22$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfig22
> = z.object({
  type: z.literal("image_url"),
  imageUrl: z.lazy(() => DeploymentGetConfig2ImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

export function deploymentGetConfig22ToJSON(
  deploymentGetConfig22: DeploymentGetConfig22,
): string {
  return JSON.stringify(
    DeploymentGetConfig22$outboundSchema.parse(deploymentGetConfig22),
  );
}
export function deploymentGetConfig22FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig22' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfig21$inboundSchema: z.ZodType<
  DeploymentGetConfig21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});
/** @internal */
export type DeploymentGetConfig21$Outbound = {
  type: "text";
  text: string;
};

/** @internal */
export const DeploymentGetConfig21$outboundSchema: z.ZodType<
  DeploymentGetConfig21$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfig21
> = z.object({
  type: z.literal("text"),
  text: z.string(),
});

export function deploymentGetConfig21ToJSON(
  deploymentGetConfig21: DeploymentGetConfig21,
): string {
  return JSON.stringify(
    DeploymentGetConfig21$outboundSchema.parse(deploymentGetConfig21),
  );
}
export function deploymentGetConfig21FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfig21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfig21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfig21' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContentDeploymentsResponse2$inboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsResponse2,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => DeploymentGetConfig21$inboundSchema),
    z.lazy(() => DeploymentGetConfig22$inboundSchema),
    z.lazy(() => DeploymentGetConfig23$inboundSchema),
  ]);
/** @internal */
export type DeploymentGetConfigContentDeploymentsResponse2$Outbound =
  | DeploymentGetConfig21$Outbound
  | DeploymentGetConfig22$Outbound
  | DeploymentGetConfig23$Outbound;

/** @internal */
export const DeploymentGetConfigContentDeploymentsResponse2$outboundSchema:
  z.ZodType<
    DeploymentGetConfigContentDeploymentsResponse2$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigContentDeploymentsResponse2
  > = z.union([
    z.lazy(() => DeploymentGetConfig21$outboundSchema),
    z.lazy(() => DeploymentGetConfig22$outboundSchema),
    z.lazy(() => DeploymentGetConfig23$outboundSchema),
  ]);

export function deploymentGetConfigContentDeploymentsResponse2ToJSON(
  deploymentGetConfigContentDeploymentsResponse2:
    DeploymentGetConfigContentDeploymentsResponse2,
): string {
  return JSON.stringify(
    DeploymentGetConfigContentDeploymentsResponse2$outboundSchema.parse(
      deploymentGetConfigContentDeploymentsResponse2,
    ),
  );
}
export function deploymentGetConfigContentDeploymentsResponse2FromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigContentDeploymentsResponse2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigContentDeploymentsResponse2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigContentDeploymentsResponse2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigContent$inboundSchema: z.ZodType<
  DeploymentGetConfigContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => DeploymentGetConfig21$inboundSchema),
    z.lazy(() => DeploymentGetConfig22$inboundSchema),
    z.lazy(() => DeploymentGetConfig23$inboundSchema),
  ])),
]);
/** @internal */
export type DeploymentGetConfigContent$Outbound =
  | string
  | Array<
    | DeploymentGetConfig21$Outbound
    | DeploymentGetConfig22$Outbound
    | DeploymentGetConfig23$Outbound
  >;

/** @internal */
export const DeploymentGetConfigContent$outboundSchema: z.ZodType<
  DeploymentGetConfigContent$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => DeploymentGetConfig21$outboundSchema),
    z.lazy(() => DeploymentGetConfig22$outboundSchema),
    z.lazy(() => DeploymentGetConfig23$outboundSchema),
  ])),
]);

export function deploymentGetConfigContentToJSON(
  deploymentGetConfigContent: DeploymentGetConfigContent,
): string {
  return JSON.stringify(
    DeploymentGetConfigContent$outboundSchema.parse(deploymentGetConfigContent),
  );
}
export function deploymentGetConfigContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigContent' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigDeploymentsResponseType> = z
    .nativeEnum(DeploymentGetConfigDeploymentsResponseType);
/** @internal */
export const DeploymentGetConfigDeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigDeploymentsResponseType> =
    DeploymentGetConfigDeploymentsResponseType$inboundSchema;

/** @internal */
export const DeploymentGetConfigDeploymentsFunction$inboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});
/** @internal */
export type DeploymentGetConfigDeploymentsFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const DeploymentGetConfigDeploymentsFunction$outboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsFunction$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigDeploymentsFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

export function deploymentGetConfigDeploymentsFunctionToJSON(
  deploymentGetConfigDeploymentsFunction:
    DeploymentGetConfigDeploymentsFunction,
): string {
  return JSON.stringify(
    DeploymentGetConfigDeploymentsFunction$outboundSchema.parse(
      deploymentGetConfigDeploymentsFunction,
    ),
  );
}
export function deploymentGetConfigDeploymentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigDeploymentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigDeploymentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigDeploymentsFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigToolCalls$inboundSchema: z.ZodType<
  DeploymentGetConfigToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentGetConfigDeploymentsResponseType$inboundSchema,
  function: z.lazy(() => DeploymentGetConfigDeploymentsFunction$inboundSchema),
});
/** @internal */
export type DeploymentGetConfigToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: DeploymentGetConfigDeploymentsFunction$Outbound;
};

/** @internal */
export const DeploymentGetConfigToolCalls$outboundSchema: z.ZodType<
  DeploymentGetConfigToolCalls$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentGetConfigDeploymentsResponseType$outboundSchema,
  function: z.lazy(() => DeploymentGetConfigDeploymentsFunction$outboundSchema),
});

export function deploymentGetConfigToolCallsToJSON(
  deploymentGetConfigToolCalls: DeploymentGetConfigToolCalls,
): string {
  return JSON.stringify(
    DeploymentGetConfigToolCalls$outboundSchema.parse(
      deploymentGetConfigToolCalls,
    ),
  );
}
export function deploymentGetConfigToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigToolCalls' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsMessages$inboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentGetConfigRole$inboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => DeploymentGetConfig21$inboundSchema),
          z.lazy(() => DeploymentGetConfig22$inboundSchema),
          z.lazy(() => DeploymentGetConfig23$inboundSchema),
        ]),
      ),
    ]),
  ),
  tool_calls: z.array(z.lazy(() => DeploymentGetConfigToolCalls$inboundSchema))
    .optional(),
  tool_call_id: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "tool_call_id": "toolCallId",
  });
});
/** @internal */
export type DeploymentGetConfigDeploymentsMessages$Outbound = {
  role: string;
  content:
    | string
    | Array<
      | DeploymentGetConfig21$Outbound
      | DeploymentGetConfig22$Outbound
      | DeploymentGetConfig23$Outbound
    >
    | null;
  tool_calls?: Array<DeploymentGetConfigToolCalls$Outbound> | undefined;
  tool_call_id?: string | null | undefined;
};

/** @internal */
export const DeploymentGetConfigDeploymentsMessages$outboundSchema: z.ZodType<
  DeploymentGetConfigDeploymentsMessages$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigDeploymentsMessages
> = z.object({
  role: DeploymentGetConfigRole$outboundSchema,
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => DeploymentGetConfig21$outboundSchema),
          z.lazy(() => DeploymentGetConfig22$outboundSchema),
          z.lazy(() => DeploymentGetConfig23$outboundSchema),
        ]),
      ),
    ]),
  ),
  toolCalls: z.array(z.lazy(() => DeploymentGetConfigToolCalls$outboundSchema))
    .optional(),
  toolCallId: z.nullable(z.string()).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    toolCallId: "tool_call_id",
  });
});

export function deploymentGetConfigDeploymentsMessagesToJSON(
  deploymentGetConfigDeploymentsMessages:
    DeploymentGetConfigDeploymentsMessages,
): string {
  return JSON.stringify(
    DeploymentGetConfigDeploymentsMessages$outboundSchema.parse(
      deploymentGetConfigDeploymentsMessages,
    ),
  );
}
export function deploymentGetConfigDeploymentsMessagesFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigDeploymentsMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigDeploymentsMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigDeploymentsMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigFormat
> = z.nativeEnum(DeploymentGetConfigFormat);
/** @internal */
export const DeploymentGetConfigFormat$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigFormat
> = DeploymentGetConfigFormat$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormat6$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat6
> = z.nativeEnum(DeploymentGetConfigResponseFormat6);
/** @internal */
export const DeploymentGetConfigResponseFormat6$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat6
> = DeploymentGetConfigResponseFormat6$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormat5$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat5
> = z.nativeEnum(DeploymentGetConfigResponseFormat5);
/** @internal */
export const DeploymentGetConfigResponseFormat5$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat5
> = DeploymentGetConfigResponseFormat5$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormat4$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat4
> = z.nativeEnum(DeploymentGetConfigResponseFormat4);
/** @internal */
export const DeploymentGetConfigResponseFormat4$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigResponseFormat4
> = DeploymentGetConfigResponseFormat4$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatDeploymentsType> = z
    .nativeEnum(DeploymentGetConfigResponseFormatDeploymentsType);
/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatDeploymentsType> =
    DeploymentGetConfigResponseFormatDeploymentsType$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormat3$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat3,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsType$inboundSchema,
});
/** @internal */
export type DeploymentGetConfigResponseFormat3$Outbound = {
  type: string;
};

/** @internal */
export const DeploymentGetConfigResponseFormat3$outboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat3$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigResponseFormat3
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsType$outboundSchema,
});

export function deploymentGetConfigResponseFormat3ToJSON(
  deploymentGetConfigResponseFormat3: DeploymentGetConfigResponseFormat3,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseFormat3$outboundSchema.parse(
      deploymentGetConfigResponseFormat3,
    ),
  );
}
export function deploymentGetConfigResponseFormat3FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseFormat3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigResponseFormat3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseFormat3' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormatType$inboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatType> = z.nativeEnum(
    DeploymentGetConfigResponseFormatType,
  );
/** @internal */
export const DeploymentGetConfigResponseFormatType$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigResponseFormatType> =
    DeploymentGetConfigResponseFormatType$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormat2$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatType$inboundSchema,
});
/** @internal */
export type DeploymentGetConfigResponseFormat2$Outbound = {
  type: string;
};

/** @internal */
export const DeploymentGetConfigResponseFormat2$outboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat2$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigResponseFormat2
> = z.object({
  type: DeploymentGetConfigResponseFormatType$outboundSchema,
});

export function deploymentGetConfigResponseFormat2ToJSON(
  deploymentGetConfigResponseFormat2: DeploymentGetConfigResponseFormat2,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseFormat2$outboundSchema.parse(
      deploymentGetConfigResponseFormat2,
    ),
  );
}
export function deploymentGetConfigResponseFormat2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseFormat2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigResponseFormat2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseFormat2' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsResponseType$inboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfigResponseFormatDeploymentsResponseType
  > = z.nativeEnum(DeploymentGetConfigResponseFormatDeploymentsResponseType);
/** @internal */
export const DeploymentGetConfigResponseFormatDeploymentsResponseType$outboundSchema:
  z.ZodNativeEnum<
    typeof DeploymentGetConfigResponseFormatDeploymentsResponseType
  > = DeploymentGetConfigResponseFormatDeploymentsResponseType$inboundSchema;

/** @internal */
export const DeploymentGetConfigResponseFormatJsonSchema$inboundSchema:
  z.ZodType<
    DeploymentGetConfigResponseFormatJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });
/** @internal */
export type DeploymentGetConfigResponseFormatJsonSchema$Outbound = {
  name: string;
  description?: string | undefined;
  strict?: boolean | undefined;
  schema: { [k: string]: any };
};

/** @internal */
export const DeploymentGetConfigResponseFormatJsonSchema$outboundSchema:
  z.ZodType<
    DeploymentGetConfigResponseFormatJsonSchema$Outbound,
    z.ZodTypeDef,
    DeploymentGetConfigResponseFormatJsonSchema
  > = z.object({
    name: z.string(),
    description: z.string().optional(),
    strict: z.boolean().optional(),
    schema: z.record(z.any()),
  });

export function deploymentGetConfigResponseFormatJsonSchemaToJSON(
  deploymentGetConfigResponseFormatJsonSchema:
    DeploymentGetConfigResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseFormatJsonSchema$outboundSchema.parse(
      deploymentGetConfigResponseFormatJsonSchema,
    ),
  );
}
export function deploymentGetConfigResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  DeploymentGetConfigResponseFormatJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigResponseFormatJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DeploymentGetConfigResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormat1$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat1,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsResponseType$inboundSchema,
  display_name: z.string().optional(),
  json_schema: z.lazy(() =>
    DeploymentGetConfigResponseFormatJsonSchema$inboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
    "json_schema": "jsonSchema",
  });
});
/** @internal */
export type DeploymentGetConfigResponseFormat1$Outbound = {
  type: string;
  display_name?: string | undefined;
  json_schema: DeploymentGetConfigResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const DeploymentGetConfigResponseFormat1$outboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat1$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigResponseFormat1
> = z.object({
  type: DeploymentGetConfigResponseFormatDeploymentsResponseType$outboundSchema,
  displayName: z.string().optional(),
  jsonSchema: z.lazy(() =>
    DeploymentGetConfigResponseFormatJsonSchema$outboundSchema
  ),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
    jsonSchema: "json_schema",
  });
});

export function deploymentGetConfigResponseFormat1ToJSON(
  deploymentGetConfigResponseFormat1: DeploymentGetConfigResponseFormat1,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseFormat1$outboundSchema.parse(
      deploymentGetConfigResponseFormat1,
    ),
  );
}
export function deploymentGetConfigResponseFormat1FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseFormat1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DeploymentGetConfigResponseFormat1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseFormat1' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseFormat$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DeploymentGetConfigResponseFormat1$inboundSchema),
  z.lazy(() => DeploymentGetConfigResponseFormat2$inboundSchema),
  z.lazy(() => DeploymentGetConfigResponseFormat3$inboundSchema),
  DeploymentGetConfigResponseFormat4$inboundSchema,
  DeploymentGetConfigResponseFormat5$inboundSchema,
  DeploymentGetConfigResponseFormat6$inboundSchema,
]);
/** @internal */
export type DeploymentGetConfigResponseFormat$Outbound =
  | DeploymentGetConfigResponseFormat1$Outbound
  | DeploymentGetConfigResponseFormat2$Outbound
  | DeploymentGetConfigResponseFormat3$Outbound
  | string
  | string
  | string;

/** @internal */
export const DeploymentGetConfigResponseFormat$outboundSchema: z.ZodType<
  DeploymentGetConfigResponseFormat$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigResponseFormat
> = z.union([
  z.lazy(() => DeploymentGetConfigResponseFormat1$outboundSchema),
  z.lazy(() => DeploymentGetConfigResponseFormat2$outboundSchema),
  z.lazy(() => DeploymentGetConfigResponseFormat3$outboundSchema),
  DeploymentGetConfigResponseFormat4$outboundSchema,
  DeploymentGetConfigResponseFormat5$outboundSchema,
  DeploymentGetConfigResponseFormat6$outboundSchema,
]);

export function deploymentGetConfigResponseFormatToJSON(
  deploymentGetConfigResponseFormat: DeploymentGetConfigResponseFormat,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseFormat$outboundSchema.parse(
      deploymentGetConfigResponseFormat,
    ),
  );
}
export function deploymentGetConfigResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseFormat' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigPhotoRealVersion$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigPhotoRealVersion
> = z.nativeEnum(DeploymentGetConfigPhotoRealVersion);
/** @internal */
export const DeploymentGetConfigPhotoRealVersion$outboundSchema:
  z.ZodNativeEnum<typeof DeploymentGetConfigPhotoRealVersion> =
    DeploymentGetConfigPhotoRealVersion$inboundSchema;

/** @internal */
export const DeploymentGetConfigEncodingFormat$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigEncodingFormat
> = z.nativeEnum(DeploymentGetConfigEncodingFormat);
/** @internal */
export const DeploymentGetConfigEncodingFormat$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigEncodingFormat
> = DeploymentGetConfigEncodingFormat$inboundSchema;

/** @internal */
export const DeploymentGetConfigReasoningEffort$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigReasoningEffort
> = z.nativeEnum(DeploymentGetConfigReasoningEffort);
/** @internal */
export const DeploymentGetConfigReasoningEffort$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigReasoningEffort
> = DeploymentGetConfigReasoningEffort$inboundSchema;

/** @internal */
export const DeploymentGetConfigVerbosity$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigVerbosity
> = z.nativeEnum(DeploymentGetConfigVerbosity);
/** @internal */
export const DeploymentGetConfigVerbosity$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigVerbosity
> = DeploymentGetConfigVerbosity$inboundSchema;

/** @internal */
export const DeploymentGetConfigThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigThinkingLevel
> = z.nativeEnum(DeploymentGetConfigThinkingLevel);
/** @internal */
export const DeploymentGetConfigThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigThinkingLevel
> = DeploymentGetConfigThinkingLevel$inboundSchema;

/** @internal */
export const DeploymentGetConfigParameters$inboundSchema: z.ZodType<
  DeploymentGetConfigParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: DeploymentGetConfigFormat$inboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => DeploymentGetConfigResponseFormat1$inboundSchema),
      z.lazy(() => DeploymentGetConfigResponseFormat2$inboundSchema),
      z.lazy(() => DeploymentGetConfigResponseFormat3$inboundSchema),
      DeploymentGetConfigResponseFormat4$inboundSchema,
      DeploymentGetConfigResponseFormat5$inboundSchema,
      DeploymentGetConfigResponseFormat6$inboundSchema,
    ]),
  ).optional(),
  photoRealVersion: DeploymentGetConfigPhotoRealVersion$inboundSchema
    .optional(),
  encoding_format: DeploymentGetConfigEncodingFormat$inboundSchema.optional(),
  reasoningEffort: DeploymentGetConfigReasoningEffort$inboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: DeploymentGetConfigVerbosity$inboundSchema.optional(),
  thinkingLevel: DeploymentGetConfigThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "encoding_format": "encodingFormat",
  });
});
/** @internal */
export type DeploymentGetConfigParameters$Outbound = {
  temperature?: number | undefined;
  maxTokens?: number | undefined;
  topK?: number | undefined;
  topP?: number | undefined;
  frequencyPenalty?: number | undefined;
  presencePenalty?: number | undefined;
  numImages?: number | undefined;
  seed?: number | undefined;
  format?: string | undefined;
  dimensions?: string | undefined;
  quality?: string | undefined;
  style?: string | undefined;
  responseFormat?:
    | DeploymentGetConfigResponseFormat1$Outbound
    | DeploymentGetConfigResponseFormat2$Outbound
    | DeploymentGetConfigResponseFormat3$Outbound
    | string
    | string
    | string
    | null
    | undefined;
  photoRealVersion?: string | undefined;
  encoding_format?: string | undefined;
  reasoningEffort?: string | undefined;
  budgetTokens?: number | undefined;
  verbosity?: string | undefined;
  thinkingLevel?: string | undefined;
};

/** @internal */
export const DeploymentGetConfigParameters$outboundSchema: z.ZodType<
  DeploymentGetConfigParameters$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigParameters
> = z.object({
  temperature: z.number().optional(),
  maxTokens: z.number().optional(),
  topK: z.number().optional(),
  topP: z.number().optional(),
  frequencyPenalty: z.number().optional(),
  presencePenalty: z.number().optional(),
  numImages: z.number().optional(),
  seed: z.number().optional(),
  format: DeploymentGetConfigFormat$outboundSchema.optional(),
  dimensions: z.string().optional(),
  quality: z.string().optional(),
  style: z.string().optional(),
  responseFormat: z.nullable(
    z.union([
      z.lazy(() => DeploymentGetConfigResponseFormat1$outboundSchema),
      z.lazy(() => DeploymentGetConfigResponseFormat2$outboundSchema),
      z.lazy(() => DeploymentGetConfigResponseFormat3$outboundSchema),
      DeploymentGetConfigResponseFormat4$outboundSchema,
      DeploymentGetConfigResponseFormat5$outboundSchema,
      DeploymentGetConfigResponseFormat6$outboundSchema,
    ]),
  ).optional(),
  photoRealVersion: DeploymentGetConfigPhotoRealVersion$outboundSchema
    .optional(),
  encodingFormat: DeploymentGetConfigEncodingFormat$outboundSchema.optional(),
  reasoningEffort: DeploymentGetConfigReasoningEffort$outboundSchema.optional(),
  budgetTokens: z.number().optional(),
  verbosity: DeploymentGetConfigVerbosity$outboundSchema.optional(),
  thinkingLevel: DeploymentGetConfigThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    encodingFormat: "encoding_format",
  });
});

export function deploymentGetConfigParametersToJSON(
  deploymentGetConfigParameters: DeploymentGetConfigParameters,
): string {
  return JSON.stringify(
    DeploymentGetConfigParameters$outboundSchema.parse(
      deploymentGetConfigParameters,
    ),
  );
}
export function deploymentGetConfigParametersFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigParameters' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigDeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigDeploymentsType
> = z.nativeEnum(DeploymentGetConfigDeploymentsType);
/** @internal */
export const DeploymentGetConfigDeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentGetConfigDeploymentsType
> = DeploymentGetConfigDeploymentsType$inboundSchema;

/** @internal */
export const DeploymentGetConfigFunction$inboundSchema: z.ZodType<
  DeploymentGetConfigFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.record(z.any()).optional(),
});
/** @internal */
export type DeploymentGetConfigFunction$Outbound = {
  name: string;
  description?: string | undefined;
  parameters?: { [k: string]: any } | undefined;
};

/** @internal */
export const DeploymentGetConfigFunction$outboundSchema: z.ZodType<
  DeploymentGetConfigFunction$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigFunction
> = z.object({
  name: z.string(),
  description: z.string().optional(),
  parameters: z.record(z.any()).optional(),
});

export function deploymentGetConfigFunctionToJSON(
  deploymentGetConfigFunction: DeploymentGetConfigFunction,
): string {
  return JSON.stringify(
    DeploymentGetConfigFunction$outboundSchema.parse(
      deploymentGetConfigFunction,
    ),
  );
}
export function deploymentGetConfigFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigTools$inboundSchema: z.ZodType<
  DeploymentGetConfigTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DeploymentGetConfigDeploymentsType$inboundSchema,
  function: z.lazy(() => DeploymentGetConfigFunction$inboundSchema),
});
/** @internal */
export type DeploymentGetConfigTools$Outbound = {
  type: string;
  function: DeploymentGetConfigFunction$Outbound;
};

/** @internal */
export const DeploymentGetConfigTools$outboundSchema: z.ZodType<
  DeploymentGetConfigTools$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigTools
> = z.object({
  type: DeploymentGetConfigDeploymentsType$outboundSchema,
  function: z.lazy(() => DeploymentGetConfigFunction$outboundSchema),
});

export function deploymentGetConfigToolsToJSON(
  deploymentGetConfigTools: DeploymentGetConfigTools,
): string {
  return JSON.stringify(
    DeploymentGetConfigTools$outboundSchema.parse(deploymentGetConfigTools),
  );
}
export function deploymentGetConfigToolsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigTools' from JSON`,
  );
}

/** @internal */
export const DeploymentGetConfigResponseBody$inboundSchema: z.ZodType<
  DeploymentGetConfigResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  provider: z.string(),
  model: z.string(),
  type: DeploymentGetConfigType$inboundSchema.optional(),
  version: z.string(),
  messages: z.array(
    z.lazy(() => DeploymentGetConfigDeploymentsMessages$inboundSchema),
  ),
  parameters: z.lazy(() => DeploymentGetConfigParameters$inboundSchema),
  tools: z.array(z.lazy(() => DeploymentGetConfigTools$inboundSchema))
    .optional(),
});
/** @internal */
export type DeploymentGetConfigResponseBody$Outbound = {
  id: string;
  provider: string;
  model: string;
  type?: string | undefined;
  version: string;
  messages: Array<DeploymentGetConfigDeploymentsMessages$Outbound>;
  parameters: DeploymentGetConfigParameters$Outbound;
  tools?: Array<DeploymentGetConfigTools$Outbound> | undefined;
};

/** @internal */
export const DeploymentGetConfigResponseBody$outboundSchema: z.ZodType<
  DeploymentGetConfigResponseBody$Outbound,
  z.ZodTypeDef,
  DeploymentGetConfigResponseBody
> = z.object({
  id: z.string(),
  provider: z.string(),
  model: z.string(),
  type: DeploymentGetConfigType$outboundSchema.optional(),
  version: z.string(),
  messages: z.array(
    z.lazy(() => DeploymentGetConfigDeploymentsMessages$outboundSchema),
  ),
  parameters: z.lazy(() => DeploymentGetConfigParameters$outboundSchema),
  tools: z.array(z.lazy(() => DeploymentGetConfigTools$outboundSchema))
    .optional(),
});

export function deploymentGetConfigResponseBodyToJSON(
  deploymentGetConfigResponseBody: DeploymentGetConfigResponseBody,
): string {
  return JSON.stringify(
    DeploymentGetConfigResponseBody$outboundSchema.parse(
      deploymentGetConfigResponseBody,
    ),
  );
}
export function deploymentGetConfigResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentGetConfigResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentGetConfigResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentGetConfigResponseBody' from JSON`,
  );
}
