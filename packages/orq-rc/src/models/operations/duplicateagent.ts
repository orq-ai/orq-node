/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type DuplicateAgentRequestBody = {
  /**
   * The unique key for the duplicated agent
   */
  key: string;
  /**
   * The display name for the duplicated agent
   */
  displayName?: string | undefined;
};

export type DuplicateAgentRequest = {
  /**
   * The key of the agent to duplicate
   */
  agentKey: string;
  requestBody?: DuplicateAgentRequestBody | undefined;
};

/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export const DuplicateAgentStatus = {
  Live: "live",
  Draft: "draft",
  Pending: "pending",
  Published: "published",
} as const;
/**
 * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
 */
export type DuplicateAgentStatus = ClosedEnum<typeof DuplicateAgentStatus>;

/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export const DuplicateAgentToolApprovalRequired = {
  All: "all",
  RespectTool: "respect_tool",
  None: "none",
} as const;
/**
 * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
 */
export type DuplicateAgentToolApprovalRequired = ClosedEnum<
  typeof DuplicateAgentToolApprovalRequired
>;

export type DuplicateAgentConditions = {
  /**
   * The argument of the tool call to evaluate
   */
  condition: string;
  /**
   * The operator to use
   */
  operator: string;
  /**
   * The value to compare against
   */
  value: string;
};

export type DuplicateAgentTools = {
  /**
   * The id of the resource
   */
  id: string;
  /**
   * Optional tool key for custom tools
   */
  key?: string | undefined;
  actionType: string;
  displayName?: string | undefined;
  /**
   * Optional tool description
   */
  description?: string | undefined;
  requiresApproval?: boolean | undefined;
  conditions?: Array<DuplicateAgentConditions> | undefined;
  /**
   * Tool execution timeout in seconds (default: 2 minutes, max: 10 minutes)
   */
  timeout?: number | undefined;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const DuplicateAgentExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type DuplicateAgentExecuteOn = ClosedEnum<
  typeof DuplicateAgentExecuteOn
>;

export type DuplicateAgentEvaluators = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: DuplicateAgentExecuteOn;
};

/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export const DuplicateAgentAgentsExecuteOn = {
  Input: "input",
  Output: "output",
} as const;
/**
 * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
 */
export type DuplicateAgentAgentsExecuteOn = ClosedEnum<
  typeof DuplicateAgentAgentsExecuteOn
>;

export type DuplicateAgentGuardrails = {
  /**
   * Unique key or identifier of the evaluator
   */
  id: string;
  /**
   * The percentage of executions to evaluate with this evaluator (1-100). For example, a value of 50 means the evaluator will run on approximately half of the executions.
   */
  sampleRate?: number | undefined;
  /**
   * Determines whether the evaluator runs on the agent input (user message) or output (agent response).
   */
  executeOn: DuplicateAgentAgentsExecuteOn;
};

export type DuplicateAgentSettings = {
  /**
   * Maximum iterations(llm calls) before the agent will stop executing.
   */
  maxIterations?: number | undefined;
  /**
   * Maximum time (in seconds) for the agent thinking process. This does not include the time for tool calls and sub agent calls. It will be loosely enforced, the in progress LLM calls will not be terminated and the last assistant message will be returned.
   */
  maxExecutionTime?: number | undefined;
  /**
   * If all, the agent will require approval for all tools. If respect_tool, the agent will require approval for tools that have the requires_approval flag set to true. If none, the agent will not require approval for any tools.
   */
  toolApprovalRequired?: DuplicateAgentToolApprovalRequired | undefined;
  tools?: Array<DuplicateAgentTools> | undefined;
  /**
   * Configuration for an evaluator applied to the agent
   */
  evaluators?: Array<DuplicateAgentEvaluators> | undefined;
  /**
   * Configuration for a guardrail applied to the agent
   */
  guardrails?: Array<DuplicateAgentGuardrails> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const DuplicateAgentVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type DuplicateAgentVoice = ClosedEnum<typeof DuplicateAgentVoice>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const DuplicateAgentFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type DuplicateAgentFormat = ClosedEnum<typeof DuplicateAgentFormat>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type DuplicateAgentAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: DuplicateAgentVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: DuplicateAgentFormat;
};

export const DuplicateAgentResponseFormatAgentsResponseType = {
  JsonSchema: "json_schema",
} as const;
export type DuplicateAgentResponseFormatAgentsResponseType = ClosedEnum<
  typeof DuplicateAgentResponseFormatAgentsResponseType
>;

export type DuplicateAgentResponseFormatJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | null | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type DuplicateAgentResponseFormatAgentsJSONSchema = {
  type: DuplicateAgentResponseFormatAgentsResponseType;
  jsonSchema: DuplicateAgentResponseFormatJsonSchema;
};

export const DuplicateAgentResponseFormatAgentsType = {
  JsonObject: "json_object",
} as const;
export type DuplicateAgentResponseFormatAgentsType = ClosedEnum<
  typeof DuplicateAgentResponseFormatAgentsType
>;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type DuplicateAgentResponseFormatJSONObject = {
  type: DuplicateAgentResponseFormatAgentsType;
};

export const DuplicateAgentResponseFormatType = {
  Text: "text",
} as const;
export type DuplicateAgentResponseFormatType = ClosedEnum<
  typeof DuplicateAgentResponseFormatType
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type DuplicateAgentResponseFormatText = {
  type: DuplicateAgentResponseFormatType;
};

/**
 * An object specifying the format that the model must output
 */
export type DuplicateAgentResponseFormat =
  | DuplicateAgentResponseFormatAgentsJSONSchema
  | DuplicateAgentResponseFormatText
  | DuplicateAgentResponseFormatJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type DuplicateAgentStop = string | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type DuplicateAgentStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const DuplicateAgentType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type DuplicateAgentType = ClosedEnum<typeof DuplicateAgentType>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const DuplicateAgentThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type DuplicateAgentThinkingLevel = ClosedEnum<
  typeof DuplicateAgentThinkingLevel
>;

export type DuplicateAgentThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: DuplicateAgentType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?: DuplicateAgentThinkingLevel | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const DuplicateAgentToolChoiceType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type DuplicateAgentToolChoiceType = ClosedEnum<
  typeof DuplicateAgentToolChoiceType
>;

export type DuplicateAgentToolChoiceFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type DuplicateAgentToolChoice2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: DuplicateAgentToolChoiceType | undefined;
  function: DuplicateAgentToolChoiceFunction;
};

export const DuplicateAgentToolChoice1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type DuplicateAgentToolChoice1 = ClosedEnum<
  typeof DuplicateAgentToolChoice1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type DuplicateAgentToolChoice =
  | DuplicateAgentToolChoice2
  | DuplicateAgentToolChoice1;

export const DuplicateAgentModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type DuplicateAgentModalities = ClosedEnum<
  typeof DuplicateAgentModalities
>;

/**
 * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
 */
export type DuplicateAgentParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: DuplicateAgentAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | DuplicateAgentResponseFormatAgentsJSONSchema
    | DuplicateAgentResponseFormatText
    | DuplicateAgentResponseFormatJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?: DuplicateAgentStreamOptions | null | undefined;
  thinking?: DuplicateAgentThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | DuplicateAgentToolChoice2
    | DuplicateAgentToolChoice1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?: Array<DuplicateAgentModalities> | null | undefined;
};

/**
 * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
 */
export type DuplicateAgentRetry = {
  /**
   * Number of retry attempts (1-5)
   */
  count?: number | undefined;
  /**
   * HTTP status codes that trigger retry logic
   */
  onCodes?: Array<number> | undefined;
};

/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export const DuplicateAgentFallbackModelConfigurationVoice = {
  Alloy: "alloy",
  Echo: "echo",
  Fable: "fable",
  Onyx: "onyx",
  Nova: "nova",
  Shimmer: "shimmer",
} as const;
/**
 * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
 */
export type DuplicateAgentFallbackModelConfigurationVoice = ClosedEnum<
  typeof DuplicateAgentFallbackModelConfigurationVoice
>;

/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export const DuplicateAgentFallbackModelConfigurationFormat = {
  Wav: "wav",
  Mp3: "mp3",
  Flac: "flac",
  Opus: "opus",
  Pcm16: "pcm16",
} as const;
/**
 * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
 */
export type DuplicateAgentFallbackModelConfigurationFormat = ClosedEnum<
  typeof DuplicateAgentFallbackModelConfigurationFormat
>;

/**
 * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
 */
export type DuplicateAgentFallbackModelConfigurationAudio = {
  /**
   * The voice the model uses to respond. Supported voices are alloy, echo, fable, onyx, nova, and shimmer.
   */
  voice: DuplicateAgentFallbackModelConfigurationVoice;
  /**
   * Specifies the output audio format. Must be one of wav, mp3, flac, opus, or pcm16.
   */
  format: DuplicateAgentFallbackModelConfigurationFormat;
};

export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  {
    JsonSchema: "json_schema",
  } as const;
export type DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType =
  ClosedEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  >;

export type DuplicateAgentResponseFormatAgentsResponseJsonSchema = {
  /**
   * A description of what the response format is for, used by the model to determine how to respond in the format.
   */
  description?: string | undefined;
  /**
   * The name of the response format. Must be a-z, A-Z, 0-9, or contain underscores and dashes, with a maximum length of 64.
   */
  name: string;
  /**
   * The schema for the response format, described as a JSON Schema object.
   */
  schema?: any | undefined;
  /**
   * Whether to enable strict schema adherence when generating the output. If set to true, the model will always follow the exact schema defined in the schema field. Only a subset of JSON Schema is supported when strict is true.
   */
  strict?: boolean | null | undefined;
};

/**
 * @remarks
 *
 * JSON Schema response format. Used to generate structured JSON responses
 */
export type DuplicateAgentResponseFormatAgentsResponse201JSONSchema = {
  type:
    DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType;
  jsonSchema: DuplicateAgentResponseFormatAgentsResponseJsonSchema;
};

export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType =
  {
    JsonObject: "json_object",
  } as const;
export type DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType =
  ClosedEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType
  >;

/**
 * @remarks
 *
 * JSON object response format. An older method of generating JSON responses. Using `json_schema` is recommended for models that support it. Note that the model will not generate JSON without a system or user message instructing it to do so.
 */
export type DuplicateAgentResponseFormatAgentsJSONObject = {
  type: DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType;
};

export const DuplicateAgentResponseFormatAgentsResponse201Type = {
  Text: "text",
} as const;
export type DuplicateAgentResponseFormatAgentsResponse201Type = ClosedEnum<
  typeof DuplicateAgentResponseFormatAgentsResponse201Type
>;

/**
 * @remarks
 *
 * Default response format. Used to generate text responses
 */
export type DuplicateAgentResponseFormatAgentsText = {
  type: DuplicateAgentResponseFormatAgentsResponse201Type;
};

/**
 * An object specifying the format that the model must output
 */
export type DuplicateAgentFallbackModelConfigurationResponseFormat =
  | DuplicateAgentResponseFormatAgentsResponse201JSONSchema
  | DuplicateAgentResponseFormatAgentsText
  | DuplicateAgentResponseFormatAgentsJSONObject;

/**
 * Up to 4 sequences where the API will stop generating further tokens.
 */
export type DuplicateAgentFallbackModelConfigurationStop =
  | string
  | Array<string>;

/**
 * Options for streaming response. Only set this when you set stream: true.
 */
export type DuplicateAgentFallbackModelConfigurationStreamOptions = {
  /**
   * If set, an additional chunk will be streamed before the data: [DONE] message. The usage field on this chunk shows the token usage statistics for the entire request, and the choices field will always be an empty array. All other chunks will also include a usage field, but with a null value.
   */
  includeUsage?: boolean | undefined;
};

/**
 * Enables or disables the thinking mode capability
 */
export const DuplicateAgentFallbackModelConfigurationType = {
  Enabled: "enabled",
  Disabled: "disabled",
} as const;
/**
 * Enables or disables the thinking mode capability
 */
export type DuplicateAgentFallbackModelConfigurationType = ClosedEnum<
  typeof DuplicateAgentFallbackModelConfigurationType
>;

/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export const DuplicateAgentFallbackModelConfigurationThinkingLevel = {
  Low: "low",
  High: "high",
} as const;
/**
 * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
 */
export type DuplicateAgentFallbackModelConfigurationThinkingLevel = ClosedEnum<
  typeof DuplicateAgentFallbackModelConfigurationThinkingLevel
>;

export type DuplicateAgentFallbackModelConfigurationThinking = {
  /**
   * Enables or disables the thinking mode capability
   */
  type: DuplicateAgentFallbackModelConfigurationType;
  /**
   * Determines how many tokens the model can use for its internal reasoning process. Larger budgets can enable more thorough analysis for complex problems, improving response quality. Must be ≥1024 and less than `max_tokens`.
   */
  budgetTokens: number;
  /**
   * The level of reasoning the model should use. This setting is supported only by `gemini-3` models. If budget_tokens is specified and `thinking_level` is available, `budget_tokens` will be ignored.
   */
  thinkingLevel?:
    | DuplicateAgentFallbackModelConfigurationThinkingLevel
    | undefined;
};

/**
 * The type of the tool. Currently, only function is supported.
 */
export const DuplicateAgentToolChoiceAgentsType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only function is supported.
 */
export type DuplicateAgentToolChoiceAgentsType = ClosedEnum<
  typeof DuplicateAgentToolChoiceAgentsType
>;

export type DuplicateAgentToolChoiceAgentsFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
};

export type DuplicateAgentToolChoiceAgents2 = {
  /**
   * The type of the tool. Currently, only function is supported.
   */
  type?: DuplicateAgentToolChoiceAgentsType | undefined;
  function: DuplicateAgentToolChoiceAgentsFunction;
};

export const DuplicateAgentToolChoiceAgents1 = {
  None: "none",
  Auto: "auto",
  Required: "required",
} as const;
export type DuplicateAgentToolChoiceAgents1 = ClosedEnum<
  typeof DuplicateAgentToolChoiceAgents1
>;

/**
 * Controls which (if any) tool is called by the model.
 */
export type DuplicateAgentFallbackModelConfigurationToolChoice =
  | DuplicateAgentToolChoiceAgents2
  | DuplicateAgentToolChoiceAgents1;

export const DuplicateAgentFallbackModelConfigurationModalities = {
  Text: "text",
  Audio: "audio",
} as const;
export type DuplicateAgentFallbackModelConfigurationModalities = ClosedEnum<
  typeof DuplicateAgentFallbackModelConfigurationModalities
>;

/**
 * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
 */
export type DuplicateAgentFallbackModelConfigurationParameters = {
  /**
   * Parameters for audio output. Required when audio output is requested with modalities: ["audio"]. Learn more.
   */
  audio?: DuplicateAgentFallbackModelConfigurationAudio | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on their existing frequency in the text so far, decreasing the model's likelihood to repeat the same line verbatim.
   */
  frequencyPenalty?: number | null | undefined;
  /**
   * `[Deprecated]`. The maximum number of tokens that can be generated in the chat completion. This value can be used to control costs for text generated via API.
   *
   * @remarks
   *
   *  This value is now `deprecated` in favor of `max_completion_tokens`, and is not compatible with o1 series models.
   */
  maxTokens?: number | null | undefined;
  /**
   * An upper bound for the number of tokens that can be generated for a completion, including visible output tokens and reasoning tokens
   */
  maxCompletionTokens?: number | null | undefined;
  /**
   * Whether to return log probabilities of the output tokens or not. If true, returns the log probabilities of each output token returned in the content of message.
   */
  logprobs?: boolean | null | undefined;
  /**
   * An integer between 0 and 20 specifying the number of most likely tokens to return at each token position, each with an associated log probability. logprobs must be set to true if this parameter is used.
   */
  topLogprobs?: number | null | undefined;
  /**
   * How many chat completion choices to generate for each input message. Note that you will be charged based on the number of generated tokens across all of the choices. Keep n as 1 to minimize costs.
   */
  n?: number | null | undefined;
  /**
   * Number between -2.0 and 2.0. Positive values penalize new tokens based on whether they appear in the text so far, increasing the model's likelihood to talk about new topics.
   */
  presencePenalty?: number | null | undefined;
  /**
   * An object specifying the format that the model must output
   */
  responseFormat?:
    | DuplicateAgentResponseFormatAgentsResponse201JSONSchema
    | DuplicateAgentResponseFormatAgentsText
    | DuplicateAgentResponseFormatAgentsJSONObject
    | undefined;
  /**
   * Constrains effort on reasoning for reasoning models. Reducing reasoning effort can result in faster responses and fewer tokens used on reasoning in a response.
   */
  reasoningEffort?: string | undefined;
  /**
   * Adjusts response verbosity. Lower levels yield shorter answers.
   */
  verbosity?: string | undefined;
  /**
   * If specified, our system will make a best effort to sample deterministically, such that repeated requests with the same seed and parameters should return the same result.
   */
  seed?: number | null | undefined;
  /**
   * Up to 4 sequences where the API will stop generating further tokens.
   */
  stop?: string | Array<string> | null | undefined;
  /**
   * Options for streaming response. Only set this when you set stream: true.
   */
  streamOptions?:
    | DuplicateAgentFallbackModelConfigurationStreamOptions
    | null
    | undefined;
  thinking?: DuplicateAgentFallbackModelConfigurationThinking | undefined;
  /**
   * What sampling temperature to use, between 0 and 2. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic.
   */
  temperature?: number | null | undefined;
  /**
   * An alternative to sampling with temperature, called nucleus sampling, where the model considers the results of the tokens with top_p probability mass.
   */
  topP?: number | null | undefined;
  /**
   * Limits the model to consider only the top k most likely tokens at each step.
   */
  topK?: number | null | undefined;
  /**
   * Controls which (if any) tool is called by the model.
   */
  toolChoice?:
    | DuplicateAgentToolChoiceAgents2
    | DuplicateAgentToolChoiceAgents1
    | undefined;
  /**
   * Whether to enable parallel function calling during tool use.
   */
  parallelToolCalls?: boolean | undefined;
  /**
   * Output types that you would like the model to generate. Most models are capable of generating text, which is the default: ["text"]. The gpt-4o-audio-preview model can also be used to generate audio. To request that this model generate both text and audio responses, you can use: ["text", "audio"].
   */
  modalities?:
    | Array<DuplicateAgentFallbackModelConfigurationModalities>
    | null
    | undefined;
};

/**
 * Fallback model configuration with optional parameters.
 */
export type DuplicateAgentFallbackModelConfiguration2 = {
  /**
   * A fallback model ID string. Must support tool calling.
   */
  id: string;
  /**
   * Optional model parameters specific to this fallback model. Overrides primary model parameters if this fallback is used.
   */
  parameters?: DuplicateAgentFallbackModelConfigurationParameters | undefined;
};

/**
 * Fallback model for automatic failover when primary model request fails. Supports optional parameter overrides. Can be a simple model ID string or a configuration object with model-specific parameters. Fallbacks are tried in order.
 */
export type DuplicateAgentFallbackModelConfiguration =
  | DuplicateAgentFallbackModelConfiguration2
  | string;

export type DuplicateAgentModel = {
  /**
   * The database ID of the primary model
   */
  id: string;
  /**
   * Optional integration ID for custom model configurations
   */
  integrationId?: string | null | undefined;
  /**
   * Model behavior parameters (snake_case) stored as part of the agent configuration. These become the default parameters used when the agent is executed. Commonly used: temperature (0-1, controls randomness), max_completion_tokens (response length), top_p (nucleus sampling). Advanced: frequency_penalty, presence_penalty, response_format (JSON/structured output), reasoning_effort (for o1/thinking models), seed (reproducibility), stop sequences. Model-specific support varies. Runtime parameters in agent execution requests can override these defaults.
   */
  parameters?: DuplicateAgentParameters | undefined;
  /**
   * Retry configuration for model requests. Allows customizing retry count (1-5) and HTTP status codes that trigger retries. Default codes: [429]. Common codes: 500 (internal error), 429 (rate limit), 502/503/504 (gateway errors).
   */
  retry?: DuplicateAgentRetry | undefined;
  /**
   * Optional array of fallback models (string IDs or config objects) that will be used automatically in order if the primary model fails
   */
  fallbackModels?:
    | Array<DuplicateAgentFallbackModelConfiguration2 | string>
    | null
    | undefined;
};

export type DuplicateAgentTeamOfAgents = {
  /**
   * The unique key of the agent within the workspace
   */
  key: string;
  /**
   * The role of the agent in this context. This is used to give extra information to the leader to help it decide which agent to hand off to.
   */
  role?: string | undefined;
};

export type DuplicateAgentMetrics = {
  totalCost?: number | undefined;
};

export type DuplicateAgentKnowledgeBases = {
  /**
   * Unique identifier of the knowledge base to search
   */
  knowledgeId: string;
};

/**
 * Agent duplicated successfully
 */
export type DuplicateAgentResponseBody = {
  id: string;
  key: string;
  displayName: string;
  workspaceId: string;
  projectId: string;
  createdById?: string | null | undefined;
  updatedById?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  systemPrompt?: string | undefined;
  instructions: string;
  /**
   * The status of the agent. `Live` is the latest version of the agent. `Draft` is a version that is not yet published. `Pending` is a version that is pending approval. `Published` is a version that was live and has been replaced by a new version.
   */
  status: DuplicateAgentStatus;
  settings?: DuplicateAgentSettings | undefined;
  model: DuplicateAgentModel;
  versionHash?: string | undefined;
  /**
   * Entity storage path in the format: `project/folder/subfolder/...`
   *
   * @remarks
   *
   * The first element identifies the project, followed by nested folders (auto-created as needed).
   *
   * With project-based API keys, the first element is treated as a folder name, as the project is predetermined by the API key.
   */
  path: string;
  /**
   * Array of memory store identifiers. Accepts both memory store IDs and keys.
   */
  memoryStores: Array<string>;
  /**
   * The agents that are accessible to this orchestrator. The main agent can hand off to these agents to perform tasks.
   */
  teamOfAgents: Array<DuplicateAgentTeamOfAgents>;
  metrics?: DuplicateAgentMetrics | undefined;
  /**
   * Extracted variables from agent instructions
   */
  variables?: { [k: string]: any } | undefined;
  /**
   * Agent knowledge bases reference
   */
  knowledgeBases?: Array<DuplicateAgentKnowledgeBases> | undefined;
};

/** @internal */
export const DuplicateAgentRequestBody$inboundSchema: z.ZodType<
  DuplicateAgentRequestBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  display_name: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "display_name": "displayName",
  });
});
/** @internal */
export type DuplicateAgentRequestBody$Outbound = {
  key: string;
  display_name?: string | undefined;
};

/** @internal */
export const DuplicateAgentRequestBody$outboundSchema: z.ZodType<
  DuplicateAgentRequestBody$Outbound,
  z.ZodTypeDef,
  DuplicateAgentRequestBody
> = z.object({
  key: z.string(),
  displayName: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    displayName: "display_name",
  });
});

export function duplicateAgentRequestBodyToJSON(
  duplicateAgentRequestBody: DuplicateAgentRequestBody,
): string {
  return JSON.stringify(
    DuplicateAgentRequestBody$outboundSchema.parse(duplicateAgentRequestBody),
  );
}
export function duplicateAgentRequestBodyFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentRequestBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentRequestBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentRequestBody' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentRequest$inboundSchema: z.ZodType<
  DuplicateAgentRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  agent_key: z.string(),
  RequestBody: z.lazy(() => DuplicateAgentRequestBody$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "agent_key": "agentKey",
    "RequestBody": "requestBody",
  });
});
/** @internal */
export type DuplicateAgentRequest$Outbound = {
  agent_key: string;
  RequestBody?: DuplicateAgentRequestBody$Outbound | undefined;
};

/** @internal */
export const DuplicateAgentRequest$outboundSchema: z.ZodType<
  DuplicateAgentRequest$Outbound,
  z.ZodTypeDef,
  DuplicateAgentRequest
> = z.object({
  agentKey: z.string(),
  requestBody: z.lazy(() => DuplicateAgentRequestBody$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    agentKey: "agent_key",
    requestBody: "RequestBody",
  });
});

export function duplicateAgentRequestToJSON(
  duplicateAgentRequest: DuplicateAgentRequest,
): string {
  return JSON.stringify(
    DuplicateAgentRequest$outboundSchema.parse(duplicateAgentRequest),
  );
}
export function duplicateAgentRequestFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentRequest' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentStatus$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentStatus
> = z.nativeEnum(DuplicateAgentStatus);
/** @internal */
export const DuplicateAgentStatus$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentStatus
> = DuplicateAgentStatus$inboundSchema;

/** @internal */
export const DuplicateAgentToolApprovalRequired$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolApprovalRequired
> = z.nativeEnum(DuplicateAgentToolApprovalRequired);
/** @internal */
export const DuplicateAgentToolApprovalRequired$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolApprovalRequired
> = DuplicateAgentToolApprovalRequired$inboundSchema;

/** @internal */
export const DuplicateAgentConditions$inboundSchema: z.ZodType<
  DuplicateAgentConditions,
  z.ZodTypeDef,
  unknown
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});
/** @internal */
export type DuplicateAgentConditions$Outbound = {
  condition: string;
  operator: string;
  value: string;
};

/** @internal */
export const DuplicateAgentConditions$outboundSchema: z.ZodType<
  DuplicateAgentConditions$Outbound,
  z.ZodTypeDef,
  DuplicateAgentConditions
> = z.object({
  condition: z.string(),
  operator: z.string(),
  value: z.string(),
});

export function duplicateAgentConditionsToJSON(
  duplicateAgentConditions: DuplicateAgentConditions,
): string {
  return JSON.stringify(
    DuplicateAgentConditions$outboundSchema.parse(duplicateAgentConditions),
  );
}
export function duplicateAgentConditionsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentConditions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentConditions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentConditions' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentTools$inboundSchema: z.ZodType<
  DuplicateAgentTools,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  action_type: z.string(),
  display_name: z.string().optional(),
  description: z.string().optional(),
  requires_approval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => DuplicateAgentConditions$inboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    "action_type": "actionType",
    "display_name": "displayName",
    "requires_approval": "requiresApproval",
  });
});
/** @internal */
export type DuplicateAgentTools$Outbound = {
  id: string;
  key?: string | undefined;
  action_type: string;
  display_name?: string | undefined;
  description?: string | undefined;
  requires_approval: boolean;
  conditions?: Array<DuplicateAgentConditions$Outbound> | undefined;
  timeout: number;
};

/** @internal */
export const DuplicateAgentTools$outboundSchema: z.ZodType<
  DuplicateAgentTools$Outbound,
  z.ZodTypeDef,
  DuplicateAgentTools
> = z.object({
  id: z.string(),
  key: z.string().optional(),
  actionType: z.string(),
  displayName: z.string().optional(),
  description: z.string().optional(),
  requiresApproval: z.boolean().default(false),
  conditions: z.array(z.lazy(() => DuplicateAgentConditions$outboundSchema))
    .optional(),
  timeout: z.number().default(120),
}).transform((v) => {
  return remap$(v, {
    actionType: "action_type",
    displayName: "display_name",
    requiresApproval: "requires_approval",
  });
});

export function duplicateAgentToolsToJSON(
  duplicateAgentTools: DuplicateAgentTools,
): string {
  return JSON.stringify(
    DuplicateAgentTools$outboundSchema.parse(duplicateAgentTools),
  );
}
export function duplicateAgentToolsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentTools, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentTools$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentTools' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentExecuteOn
> = z.nativeEnum(DuplicateAgentExecuteOn);
/** @internal */
export const DuplicateAgentExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentExecuteOn
> = DuplicateAgentExecuteOn$inboundSchema;

/** @internal */
export const DuplicateAgentEvaluators$inboundSchema: z.ZodType<
  DuplicateAgentEvaluators,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: DuplicateAgentExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type DuplicateAgentEvaluators$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const DuplicateAgentEvaluators$outboundSchema: z.ZodType<
  DuplicateAgentEvaluators$Outbound,
  z.ZodTypeDef,
  DuplicateAgentEvaluators
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: DuplicateAgentExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function duplicateAgentEvaluatorsToJSON(
  duplicateAgentEvaluators: DuplicateAgentEvaluators,
): string {
  return JSON.stringify(
    DuplicateAgentEvaluators$outboundSchema.parse(duplicateAgentEvaluators),
  );
}
export function duplicateAgentEvaluatorsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentEvaluators, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentEvaluators$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentEvaluators' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentAgentsExecuteOn$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentAgentsExecuteOn
> = z.nativeEnum(DuplicateAgentAgentsExecuteOn);
/** @internal */
export const DuplicateAgentAgentsExecuteOn$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentAgentsExecuteOn
> = DuplicateAgentAgentsExecuteOn$inboundSchema;

/** @internal */
export const DuplicateAgentGuardrails$inboundSchema: z.ZodType<
  DuplicateAgentGuardrails,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  sample_rate: z.number().default(50),
  execute_on: DuplicateAgentAgentsExecuteOn$inboundSchema,
}).transform((v) => {
  return remap$(v, {
    "sample_rate": "sampleRate",
    "execute_on": "executeOn",
  });
});
/** @internal */
export type DuplicateAgentGuardrails$Outbound = {
  id: string;
  sample_rate: number;
  execute_on: string;
};

/** @internal */
export const DuplicateAgentGuardrails$outboundSchema: z.ZodType<
  DuplicateAgentGuardrails$Outbound,
  z.ZodTypeDef,
  DuplicateAgentGuardrails
> = z.object({
  id: z.string(),
  sampleRate: z.number().default(50),
  executeOn: DuplicateAgentAgentsExecuteOn$outboundSchema,
}).transform((v) => {
  return remap$(v, {
    sampleRate: "sample_rate",
    executeOn: "execute_on",
  });
});

export function duplicateAgentGuardrailsToJSON(
  duplicateAgentGuardrails: DuplicateAgentGuardrails,
): string {
  return JSON.stringify(
    DuplicateAgentGuardrails$outboundSchema.parse(duplicateAgentGuardrails),
  );
}
export function duplicateAgentGuardrailsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentGuardrails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentGuardrails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentGuardrails' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentSettings$inboundSchema: z.ZodType<
  DuplicateAgentSettings,
  z.ZodTypeDef,
  unknown
> = z.object({
  max_iterations: z.number().int().default(15),
  max_execution_time: z.number().int().default(300),
  tool_approval_required: DuplicateAgentToolApprovalRequired$inboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => DuplicateAgentTools$inboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => DuplicateAgentEvaluators$inboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => DuplicateAgentGuardrails$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "max_iterations": "maxIterations",
    "max_execution_time": "maxExecutionTime",
    "tool_approval_required": "toolApprovalRequired",
  });
});
/** @internal */
export type DuplicateAgentSettings$Outbound = {
  max_iterations: number;
  max_execution_time: number;
  tool_approval_required: string;
  tools?: Array<DuplicateAgentTools$Outbound> | undefined;
  evaluators?: Array<DuplicateAgentEvaluators$Outbound> | undefined;
  guardrails?: Array<DuplicateAgentGuardrails$Outbound> | undefined;
};

/** @internal */
export const DuplicateAgentSettings$outboundSchema: z.ZodType<
  DuplicateAgentSettings$Outbound,
  z.ZodTypeDef,
  DuplicateAgentSettings
> = z.object({
  maxIterations: z.number().int().default(15),
  maxExecutionTime: z.number().int().default(300),
  toolApprovalRequired: DuplicateAgentToolApprovalRequired$outboundSchema
    .default("respect_tool"),
  tools: z.array(z.lazy(() => DuplicateAgentTools$outboundSchema)).optional(),
  evaluators: z.array(z.lazy(() => DuplicateAgentEvaluators$outboundSchema))
    .optional(),
  guardrails: z.array(z.lazy(() => DuplicateAgentGuardrails$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    maxIterations: "max_iterations",
    maxExecutionTime: "max_execution_time",
    toolApprovalRequired: "tool_approval_required",
  });
});

export function duplicateAgentSettingsToJSON(
  duplicateAgentSettings: DuplicateAgentSettings,
): string {
  return JSON.stringify(
    DuplicateAgentSettings$outboundSchema.parse(duplicateAgentSettings),
  );
}
export function duplicateAgentSettingsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentSettings, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentSettings$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentSettings' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentVoice$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentVoice
> = z.nativeEnum(DuplicateAgentVoice);
/** @internal */
export const DuplicateAgentVoice$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentVoice
> = DuplicateAgentVoice$inboundSchema;

/** @internal */
export const DuplicateAgentFormat$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentFormat
> = z.nativeEnum(DuplicateAgentFormat);
/** @internal */
export const DuplicateAgentFormat$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentFormat
> = DuplicateAgentFormat$inboundSchema;

/** @internal */
export const DuplicateAgentAudio$inboundSchema: z.ZodType<
  DuplicateAgentAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  voice: DuplicateAgentVoice$inboundSchema,
  format: DuplicateAgentFormat$inboundSchema,
});
/** @internal */
export type DuplicateAgentAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const DuplicateAgentAudio$outboundSchema: z.ZodType<
  DuplicateAgentAudio$Outbound,
  z.ZodTypeDef,
  DuplicateAgentAudio
> = z.object({
  voice: DuplicateAgentVoice$outboundSchema,
  format: DuplicateAgentFormat$outboundSchema,
});

export function duplicateAgentAudioToJSON(
  duplicateAgentAudio: DuplicateAgentAudio,
): string {
  return JSON.stringify(
    DuplicateAgentAudio$outboundSchema.parse(duplicateAgentAudio),
  );
}
export function duplicateAgentAudioFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentAudio' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponseType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsResponseType> = z
    .nativeEnum(DuplicateAgentResponseFormatAgentsResponseType);
/** @internal */
export const DuplicateAgentResponseFormatAgentsResponseType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsResponseType> =
    DuplicateAgentResponseFormatAgentsResponseType$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatJsonSchema$inboundSchema: z.ZodType<
  DuplicateAgentResponseFormatJsonSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.nullable(z.boolean()).optional(),
});
/** @internal */
export type DuplicateAgentResponseFormatJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | null | undefined;
};

/** @internal */
export const DuplicateAgentResponseFormatJsonSchema$outboundSchema: z.ZodType<
  DuplicateAgentResponseFormatJsonSchema$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseFormatJsonSchema
> = z.object({
  description: z.string().optional(),
  name: z.string(),
  schema: z.any().optional(),
  strict: z.nullable(z.boolean()).optional(),
});

export function duplicateAgentResponseFormatJsonSchemaToJSON(
  duplicateAgentResponseFormatJsonSchema:
    DuplicateAgentResponseFormatJsonSchema,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatJsonSchema$outboundSchema.parse(
      duplicateAgentResponseFormatJsonSchema,
    ),
  );
}
export function duplicateAgentResponseFormatJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseFormatJsonSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatJsonSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormatJsonSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsJSONSchema$inboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsJSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: DuplicateAgentResponseFormatAgentsResponseType$inboundSchema,
    json_schema: z.lazy(() =>
      DuplicateAgentResponseFormatJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type DuplicateAgentResponseFormatAgentsJSONSchema$Outbound = {
  type: string;
  json_schema: DuplicateAgentResponseFormatJsonSchema$Outbound;
};

/** @internal */
export const DuplicateAgentResponseFormatAgentsJSONSchema$outboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsJSONSchema$Outbound,
    z.ZodTypeDef,
    DuplicateAgentResponseFormatAgentsJSONSchema
  > = z.object({
    type: DuplicateAgentResponseFormatAgentsResponseType$outboundSchema,
    jsonSchema: z.lazy(() =>
      DuplicateAgentResponseFormatJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function duplicateAgentResponseFormatAgentsJSONSchemaToJSON(
  duplicateAgentResponseFormatAgentsJSONSchema:
    DuplicateAgentResponseFormatAgentsJSONSchema,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatAgentsJSONSchema$outboundSchema.parse(
      duplicateAgentResponseFormatAgentsJSONSchema,
    ),
  );
}
export function duplicateAgentResponseFormatAgentsJSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentResponseFormatAgentsJSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatAgentsJSONSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentResponseFormatAgentsJSONSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsType> = z.nativeEnum(
    DuplicateAgentResponseFormatAgentsType,
  );
/** @internal */
export const DuplicateAgentResponseFormatAgentsType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsType> =
    DuplicateAgentResponseFormatAgentsType$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatJSONObject$inboundSchema: z.ZodType<
  DuplicateAgentResponseFormatJSONObject,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentResponseFormatAgentsType$inboundSchema,
});
/** @internal */
export type DuplicateAgentResponseFormatJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const DuplicateAgentResponseFormatJSONObject$outboundSchema: z.ZodType<
  DuplicateAgentResponseFormatJSONObject$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseFormatJSONObject
> = z.object({
  type: DuplicateAgentResponseFormatAgentsType$outboundSchema,
});

export function duplicateAgentResponseFormatJSONObjectToJSON(
  duplicateAgentResponseFormatJSONObject:
    DuplicateAgentResponseFormatJSONObject,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatJSONObject$outboundSchema.parse(
      duplicateAgentResponseFormatJSONObject,
    ),
  );
}
export function duplicateAgentResponseFormatJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseFormatJSONObject, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatJSONObject$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormatJSONObject' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentResponseFormatType
> = z.nativeEnum(DuplicateAgentResponseFormatType);
/** @internal */
export const DuplicateAgentResponseFormatType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentResponseFormatType
> = DuplicateAgentResponseFormatType$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatText$inboundSchema: z.ZodType<
  DuplicateAgentResponseFormatText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentResponseFormatType$inboundSchema,
});
/** @internal */
export type DuplicateAgentResponseFormatText$Outbound = {
  type: string;
};

/** @internal */
export const DuplicateAgentResponseFormatText$outboundSchema: z.ZodType<
  DuplicateAgentResponseFormatText$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseFormatText
> = z.object({
  type: DuplicateAgentResponseFormatType$outboundSchema,
});

export function duplicateAgentResponseFormatTextToJSON(
  duplicateAgentResponseFormatText: DuplicateAgentResponseFormatText,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatText$outboundSchema.parse(
      duplicateAgentResponseFormatText,
    ),
  );
}
export function duplicateAgentResponseFormatTextFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseFormatText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentResponseFormatText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormatText' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormat$inboundSchema: z.ZodType<
  DuplicateAgentResponseFormat,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DuplicateAgentResponseFormatAgentsJSONSchema$inboundSchema),
  z.lazy(() => DuplicateAgentResponseFormatText$inboundSchema),
  z.lazy(() => DuplicateAgentResponseFormatJSONObject$inboundSchema),
]);
/** @internal */
export type DuplicateAgentResponseFormat$Outbound =
  | DuplicateAgentResponseFormatAgentsJSONSchema$Outbound
  | DuplicateAgentResponseFormatText$Outbound
  | DuplicateAgentResponseFormatJSONObject$Outbound;

/** @internal */
export const DuplicateAgentResponseFormat$outboundSchema: z.ZodType<
  DuplicateAgentResponseFormat$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseFormat
> = z.union([
  z.lazy(() => DuplicateAgentResponseFormatAgentsJSONSchema$outboundSchema),
  z.lazy(() => DuplicateAgentResponseFormatText$outboundSchema),
  z.lazy(() => DuplicateAgentResponseFormatJSONObject$outboundSchema),
]);

export function duplicateAgentResponseFormatToJSON(
  duplicateAgentResponseFormat: DuplicateAgentResponseFormat,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormat$outboundSchema.parse(
      duplicateAgentResponseFormat,
    ),
  );
}
export function duplicateAgentResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseFormat, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentResponseFormat$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormat' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentStop$inboundSchema: z.ZodType<
  DuplicateAgentStop,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type DuplicateAgentStop$Outbound = string | Array<string>;

/** @internal */
export const DuplicateAgentStop$outboundSchema: z.ZodType<
  DuplicateAgentStop$Outbound,
  z.ZodTypeDef,
  DuplicateAgentStop
> = z.union([z.string(), z.array(z.string())]);

export function duplicateAgentStopToJSON(
  duplicateAgentStop: DuplicateAgentStop,
): string {
  return JSON.stringify(
    DuplicateAgentStop$outboundSchema.parse(duplicateAgentStop),
  );
}
export function duplicateAgentStopFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentStop, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentStop$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentStop' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentStreamOptions$inboundSchema: z.ZodType<
  DuplicateAgentStreamOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_usage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_usage": "includeUsage",
  });
});
/** @internal */
export type DuplicateAgentStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const DuplicateAgentStreamOptions$outboundSchema: z.ZodType<
  DuplicateAgentStreamOptions$Outbound,
  z.ZodTypeDef,
  DuplicateAgentStreamOptions
> = z.object({
  includeUsage: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    includeUsage: "include_usage",
  });
});

export function duplicateAgentStreamOptionsToJSON(
  duplicateAgentStreamOptions: DuplicateAgentStreamOptions,
): string {
  return JSON.stringify(
    DuplicateAgentStreamOptions$outboundSchema.parse(
      duplicateAgentStreamOptions,
    ),
  );
}
export function duplicateAgentStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentStreamOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentStreamOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentStreamOptions' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentType
> = z.nativeEnum(DuplicateAgentType);
/** @internal */
export const DuplicateAgentType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentType
> = DuplicateAgentType$inboundSchema;

/** @internal */
export const DuplicateAgentThinkingLevel$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentThinkingLevel
> = z.nativeEnum(DuplicateAgentThinkingLevel);
/** @internal */
export const DuplicateAgentThinkingLevel$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentThinkingLevel
> = DuplicateAgentThinkingLevel$inboundSchema;

/** @internal */
export const DuplicateAgentThinking$inboundSchema: z.ZodType<
  DuplicateAgentThinking,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentType$inboundSchema,
  budget_tokens: z.number(),
  thinking_level: DuplicateAgentThinkingLevel$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "budget_tokens": "budgetTokens",
    "thinking_level": "thinkingLevel",
  });
});
/** @internal */
export type DuplicateAgentThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const DuplicateAgentThinking$outboundSchema: z.ZodType<
  DuplicateAgentThinking$Outbound,
  z.ZodTypeDef,
  DuplicateAgentThinking
> = z.object({
  type: DuplicateAgentType$outboundSchema,
  budgetTokens: z.number(),
  thinkingLevel: DuplicateAgentThinkingLevel$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    budgetTokens: "budget_tokens",
    thinkingLevel: "thinking_level",
  });
});

export function duplicateAgentThinkingToJSON(
  duplicateAgentThinking: DuplicateAgentThinking,
): string {
  return JSON.stringify(
    DuplicateAgentThinking$outboundSchema.parse(duplicateAgentThinking),
  );
}
export function duplicateAgentThinkingFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentThinking, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentThinking$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentThinking' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoiceType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceType
> = z.nativeEnum(DuplicateAgentToolChoiceType);
/** @internal */
export const DuplicateAgentToolChoiceType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceType
> = DuplicateAgentToolChoiceType$inboundSchema;

/** @internal */
export const DuplicateAgentToolChoiceFunction$inboundSchema: z.ZodType<
  DuplicateAgentToolChoiceFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type DuplicateAgentToolChoiceFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const DuplicateAgentToolChoiceFunction$outboundSchema: z.ZodType<
  DuplicateAgentToolChoiceFunction$Outbound,
  z.ZodTypeDef,
  DuplicateAgentToolChoiceFunction
> = z.object({
  name: z.string().optional(),
});

export function duplicateAgentToolChoiceFunctionToJSON(
  duplicateAgentToolChoiceFunction: DuplicateAgentToolChoiceFunction,
): string {
  return JSON.stringify(
    DuplicateAgentToolChoiceFunction$outboundSchema.parse(
      duplicateAgentToolChoiceFunction,
    ),
  );
}
export function duplicateAgentToolChoiceFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentToolChoiceFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentToolChoiceFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentToolChoiceFunction' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoice2$inboundSchema: z.ZodType<
  DuplicateAgentToolChoice2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentToolChoiceType$inboundSchema.optional(),
  function: z.lazy(() => DuplicateAgentToolChoiceFunction$inboundSchema),
});
/** @internal */
export type DuplicateAgentToolChoice2$Outbound = {
  type?: string | undefined;
  function: DuplicateAgentToolChoiceFunction$Outbound;
};

/** @internal */
export const DuplicateAgentToolChoice2$outboundSchema: z.ZodType<
  DuplicateAgentToolChoice2$Outbound,
  z.ZodTypeDef,
  DuplicateAgentToolChoice2
> = z.object({
  type: DuplicateAgentToolChoiceType$outboundSchema.optional(),
  function: z.lazy(() => DuplicateAgentToolChoiceFunction$outboundSchema),
});

export function duplicateAgentToolChoice2ToJSON(
  duplicateAgentToolChoice2: DuplicateAgentToolChoice2,
): string {
  return JSON.stringify(
    DuplicateAgentToolChoice2$outboundSchema.parse(duplicateAgentToolChoice2),
  );
}
export function duplicateAgentToolChoice2FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentToolChoice2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentToolChoice2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentToolChoice2' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoice1$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoice1
> = z.nativeEnum(DuplicateAgentToolChoice1);
/** @internal */
export const DuplicateAgentToolChoice1$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoice1
> = DuplicateAgentToolChoice1$inboundSchema;

/** @internal */
export const DuplicateAgentToolChoice$inboundSchema: z.ZodType<
  DuplicateAgentToolChoice,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DuplicateAgentToolChoice2$inboundSchema),
  DuplicateAgentToolChoice1$inboundSchema,
]);
/** @internal */
export type DuplicateAgentToolChoice$Outbound =
  | DuplicateAgentToolChoice2$Outbound
  | string;

/** @internal */
export const DuplicateAgentToolChoice$outboundSchema: z.ZodType<
  DuplicateAgentToolChoice$Outbound,
  z.ZodTypeDef,
  DuplicateAgentToolChoice
> = z.union([
  z.lazy(() => DuplicateAgentToolChoice2$outboundSchema),
  DuplicateAgentToolChoice1$outboundSchema,
]);

export function duplicateAgentToolChoiceToJSON(
  duplicateAgentToolChoice: DuplicateAgentToolChoice,
): string {
  return JSON.stringify(
    DuplicateAgentToolChoice$outboundSchema.parse(duplicateAgentToolChoice),
  );
}
export function duplicateAgentToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentToolChoice, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentToolChoice$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentToolChoice' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentModalities$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentModalities
> = z.nativeEnum(DuplicateAgentModalities);
/** @internal */
export const DuplicateAgentModalities$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentModalities
> = DuplicateAgentModalities$inboundSchema;

/** @internal */
export const DuplicateAgentParameters$inboundSchema: z.ZodType<
  DuplicateAgentParameters,
  z.ZodTypeDef,
  unknown
> = z.object({
  audio: z.nullable(z.lazy(() => DuplicateAgentAudio$inboundSchema)).optional(),
  frequency_penalty: z.nullable(z.number()).optional(),
  max_tokens: z.nullable(z.number().int()).optional(),
  max_completion_tokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  top_logprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presence_penalty: z.nullable(z.number()).optional(),
  response_format: z.union([
    z.lazy(() => DuplicateAgentResponseFormatAgentsJSONSchema$inboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatText$inboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatJSONObject$inboundSchema),
  ]).optional(),
  reasoning_effort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  stream_options: z.nullable(
    z.lazy(() => DuplicateAgentStreamOptions$inboundSchema),
  ).optional(),
  thinking: z.lazy(() => DuplicateAgentThinking$inboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  top_p: z.nullable(z.number()).optional(),
  top_k: z.nullable(z.number()).optional(),
  tool_choice: z.union([
    z.lazy(() => DuplicateAgentToolChoice2$inboundSchema),
    DuplicateAgentToolChoice1$inboundSchema,
  ]).optional(),
  parallel_tool_calls: z.boolean().optional(),
  modalities: z.nullable(z.array(DuplicateAgentModalities$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "frequency_penalty": "frequencyPenalty",
    "max_tokens": "maxTokens",
    "max_completion_tokens": "maxCompletionTokens",
    "top_logprobs": "topLogprobs",
    "presence_penalty": "presencePenalty",
    "response_format": "responseFormat",
    "reasoning_effort": "reasoningEffort",
    "stream_options": "streamOptions",
    "top_p": "topP",
    "top_k": "topK",
    "tool_choice": "toolChoice",
    "parallel_tool_calls": "parallelToolCalls",
  });
});
/** @internal */
export type DuplicateAgentParameters$Outbound = {
  audio?: DuplicateAgentAudio$Outbound | null | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | DuplicateAgentResponseFormatAgentsJSONSchema$Outbound
    | DuplicateAgentResponseFormatText$Outbound
    | DuplicateAgentResponseFormatJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?: DuplicateAgentStreamOptions$Outbound | null | undefined;
  thinking?: DuplicateAgentThinking$Outbound | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: DuplicateAgentToolChoice2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const DuplicateAgentParameters$outboundSchema: z.ZodType<
  DuplicateAgentParameters$Outbound,
  z.ZodTypeDef,
  DuplicateAgentParameters
> = z.object({
  audio: z.nullable(z.lazy(() => DuplicateAgentAudio$outboundSchema))
    .optional(),
  frequencyPenalty: z.nullable(z.number()).optional(),
  maxTokens: z.nullable(z.number().int()).optional(),
  maxCompletionTokens: z.nullable(z.number().int()).optional(),
  logprobs: z.nullable(z.boolean()).optional(),
  topLogprobs: z.nullable(z.number().int()).optional(),
  n: z.nullable(z.number().int()).optional(),
  presencePenalty: z.nullable(z.number()).optional(),
  responseFormat: z.union([
    z.lazy(() => DuplicateAgentResponseFormatAgentsJSONSchema$outboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatText$outboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatJSONObject$outboundSchema),
  ]).optional(),
  reasoningEffort: z.string().optional(),
  verbosity: z.string().optional(),
  seed: z.nullable(z.number()).optional(),
  stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
  streamOptions: z.nullable(
    z.lazy(() => DuplicateAgentStreamOptions$outboundSchema),
  ).optional(),
  thinking: z.lazy(() => DuplicateAgentThinking$outboundSchema).optional(),
  temperature: z.nullable(z.number()).optional(),
  topP: z.nullable(z.number()).optional(),
  topK: z.nullable(z.number()).optional(),
  toolChoice: z.union([
    z.lazy(() => DuplicateAgentToolChoice2$outboundSchema),
    DuplicateAgentToolChoice1$outboundSchema,
  ]).optional(),
  parallelToolCalls: z.boolean().optional(),
  modalities: z.nullable(z.array(DuplicateAgentModalities$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    frequencyPenalty: "frequency_penalty",
    maxTokens: "max_tokens",
    maxCompletionTokens: "max_completion_tokens",
    topLogprobs: "top_logprobs",
    presencePenalty: "presence_penalty",
    responseFormat: "response_format",
    reasoningEffort: "reasoning_effort",
    streamOptions: "stream_options",
    topP: "top_p",
    topK: "top_k",
    toolChoice: "tool_choice",
    parallelToolCalls: "parallel_tool_calls",
  });
});

export function duplicateAgentParametersToJSON(
  duplicateAgentParameters: DuplicateAgentParameters,
): string {
  return JSON.stringify(
    DuplicateAgentParameters$outboundSchema.parse(duplicateAgentParameters),
  );
}
export function duplicateAgentParametersFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentParameters, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentParameters$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentParameters' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentRetry$inboundSchema: z.ZodType<
  DuplicateAgentRetry,
  z.ZodTypeDef,
  unknown
> = z.object({
  count: z.number().default(3),
  on_codes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    "on_codes": "onCodes",
  });
});
/** @internal */
export type DuplicateAgentRetry$Outbound = {
  count: number;
  on_codes?: Array<number> | undefined;
};

/** @internal */
export const DuplicateAgentRetry$outboundSchema: z.ZodType<
  DuplicateAgentRetry$Outbound,
  z.ZodTypeDef,
  DuplicateAgentRetry
> = z.object({
  count: z.number().default(3),
  onCodes: z.array(z.number()).optional(),
}).transform((v) => {
  return remap$(v, {
    onCodes: "on_codes",
  });
});

export function duplicateAgentRetryToJSON(
  duplicateAgentRetry: DuplicateAgentRetry,
): string {
  return JSON.stringify(
    DuplicateAgentRetry$outboundSchema.parse(duplicateAgentRetry),
  );
}
export function duplicateAgentRetryFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentRetry, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentRetry$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentRetry' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationVoice$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationVoice> = z
    .nativeEnum(DuplicateAgentFallbackModelConfigurationVoice);
/** @internal */
export const DuplicateAgentFallbackModelConfigurationVoice$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationVoice> =
    DuplicateAgentFallbackModelConfigurationVoice$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationFormat$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationFormat> = z
    .nativeEnum(DuplicateAgentFallbackModelConfigurationFormat);
/** @internal */
export const DuplicateAgentFallbackModelConfigurationFormat$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationFormat> =
    DuplicateAgentFallbackModelConfigurationFormat$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationAudio$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationAudio,
    z.ZodTypeDef,
    unknown
  > = z.object({
    voice: DuplicateAgentFallbackModelConfigurationVoice$inboundSchema,
    format: DuplicateAgentFallbackModelConfigurationFormat$inboundSchema,
  });
/** @internal */
export type DuplicateAgentFallbackModelConfigurationAudio$Outbound = {
  voice: string;
  format: string;
};

/** @internal */
export const DuplicateAgentFallbackModelConfigurationAudio$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationAudio$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationAudio
  > = z.object({
    voice: DuplicateAgentFallbackModelConfigurationVoice$outboundSchema,
    format: DuplicateAgentFallbackModelConfigurationFormat$outboundSchema,
  });

export function duplicateAgentFallbackModelConfigurationAudioToJSON(
  duplicateAgentFallbackModelConfigurationAudio:
    DuplicateAgentFallbackModelConfigurationAudio,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationAudio$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationAudio,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationAudioFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationAudio,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationAudio$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationAudio' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > = z.nativeEnum(
    DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType,
  );
/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType
  > =
    DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsResponseJsonSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.nullable(z.boolean()).optional(),
  });
/** @internal */
export type DuplicateAgentResponseFormatAgentsResponseJsonSchema$Outbound = {
  description?: string | undefined;
  name: string;
  schema?: any | undefined;
  strict?: boolean | null | undefined;
};

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsResponseJsonSchema$Outbound,
    z.ZodTypeDef,
    DuplicateAgentResponseFormatAgentsResponseJsonSchema
  > = z.object({
    description: z.string().optional(),
    name: z.string(),
    schema: z.any().optional(),
    strict: z.nullable(z.boolean()).optional(),
  });

export function duplicateAgentResponseFormatAgentsResponseJsonSchemaToJSON(
  duplicateAgentResponseFormatAgentsResponseJsonSchema:
    DuplicateAgentResponseFormatAgentsResponseJsonSchema,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema.parse(
      duplicateAgentResponseFormatAgentsResponseJsonSchema,
    ),
  );
}
export function duplicateAgentResponseFormatAgentsResponseJsonSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentResponseFormatAgentsResponseJsonSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentResponseFormatAgentsResponseJsonSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsResponse201JSONSchema,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$inboundSchema,
    json_schema: z.lazy(() =>
      DuplicateAgentResponseFormatAgentsResponseJsonSchema$inboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      "json_schema": "jsonSchema",
    });
  });
/** @internal */
export type DuplicateAgentResponseFormatAgentsResponse201JSONSchema$Outbound = {
  type: string;
  json_schema: DuplicateAgentResponseFormatAgentsResponseJsonSchema$Outbound;
};

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsResponse201JSONSchema$Outbound,
    z.ZodTypeDef,
    DuplicateAgentResponseFormatAgentsResponse201JSONSchema
  > = z.object({
    type:
      DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONResponseBodyType$outboundSchema,
    jsonSchema: z.lazy(() =>
      DuplicateAgentResponseFormatAgentsResponseJsonSchema$outboundSchema
    ),
  }).transform((v) => {
    return remap$(v, {
      jsonSchema: "json_schema",
    });
  });

export function duplicateAgentResponseFormatAgentsResponse201JSONSchemaToJSON(
  duplicateAgentResponseFormatAgentsResponse201JSONSchema:
    DuplicateAgentResponseFormatAgentsResponse201JSONSchema,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema
      .parse(duplicateAgentResponseFormatAgentsResponse201JSONSchema),
  );
}
export function duplicateAgentResponseFormatAgentsResponse201JSONSchemaFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentResponseFormatAgentsResponse201JSONSchema,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormatAgentsResponse201JSONSchema' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > = z.nativeEnum(
    DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType,
  );
/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType
  > =
    DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatAgentsJSONObject$inboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsJSONObject,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type:
      DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType$inboundSchema,
  });
/** @internal */
export type DuplicateAgentResponseFormatAgentsJSONObject$Outbound = {
  type: string;
};

/** @internal */
export const DuplicateAgentResponseFormatAgentsJSONObject$outboundSchema:
  z.ZodType<
    DuplicateAgentResponseFormatAgentsJSONObject$Outbound,
    z.ZodTypeDef,
    DuplicateAgentResponseFormatAgentsJSONObject
  > = z.object({
    type:
      DuplicateAgentResponseFormatAgentsResponse201ApplicationJSONType$outboundSchema,
  });

export function duplicateAgentResponseFormatAgentsJSONObjectToJSON(
  duplicateAgentResponseFormatAgentsJSONObject:
    DuplicateAgentResponseFormatAgentsJSONObject,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatAgentsJSONObject$outboundSchema.parse(
      duplicateAgentResponseFormatAgentsJSONObject,
    ),
  );
}
export function duplicateAgentResponseFormatAgentsJSONObjectFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentResponseFormatAgentsJSONObject,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatAgentsJSONObject$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentResponseFormatAgentsJSONObject' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201Type$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsResponse201Type> = z
    .nativeEnum(DuplicateAgentResponseFormatAgentsResponse201Type);
/** @internal */
export const DuplicateAgentResponseFormatAgentsResponse201Type$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentResponseFormatAgentsResponse201Type> =
    DuplicateAgentResponseFormatAgentsResponse201Type$inboundSchema;

/** @internal */
export const DuplicateAgentResponseFormatAgentsText$inboundSchema: z.ZodType<
  DuplicateAgentResponseFormatAgentsText,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentResponseFormatAgentsResponse201Type$inboundSchema,
});
/** @internal */
export type DuplicateAgentResponseFormatAgentsText$Outbound = {
  type: string;
};

/** @internal */
export const DuplicateAgentResponseFormatAgentsText$outboundSchema: z.ZodType<
  DuplicateAgentResponseFormatAgentsText$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseFormatAgentsText
> = z.object({
  type: DuplicateAgentResponseFormatAgentsResponse201Type$outboundSchema,
});

export function duplicateAgentResponseFormatAgentsTextToJSON(
  duplicateAgentResponseFormatAgentsText:
    DuplicateAgentResponseFormatAgentsText,
): string {
  return JSON.stringify(
    DuplicateAgentResponseFormatAgentsText$outboundSchema.parse(
      duplicateAgentResponseFormatAgentsText,
    ),
  );
}
export function duplicateAgentResponseFormatAgentsTextFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseFormatAgentsText, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentResponseFormatAgentsText$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseFormatAgentsText' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationResponseFormat$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationResponseFormat,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() =>
      DuplicateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema
    ),
    z.lazy(() => DuplicateAgentResponseFormatAgentsText$inboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatAgentsJSONObject$inboundSchema),
  ]);
/** @internal */
export type DuplicateAgentFallbackModelConfigurationResponseFormat$Outbound =
  | DuplicateAgentResponseFormatAgentsResponse201JSONSchema$Outbound
  | DuplicateAgentResponseFormatAgentsText$Outbound
  | DuplicateAgentResponseFormatAgentsJSONObject$Outbound;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationResponseFormat$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationResponseFormat$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationResponseFormat
  > = z.union([
    z.lazy(() =>
      DuplicateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema
    ),
    z.lazy(() => DuplicateAgentResponseFormatAgentsText$outboundSchema),
    z.lazy(() => DuplicateAgentResponseFormatAgentsJSONObject$outboundSchema),
  ]);

export function duplicateAgentFallbackModelConfigurationResponseFormatToJSON(
  duplicateAgentFallbackModelConfigurationResponseFormat:
    DuplicateAgentFallbackModelConfigurationResponseFormat,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationResponseFormat$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationResponseFormat,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationResponseFormatFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationResponseFormat,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationResponseFormat$inboundSchema
        .parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationResponseFormat' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationStop$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationStop,
    z.ZodTypeDef,
    unknown
  > = z.union([z.string(), z.array(z.string())]);
/** @internal */
export type DuplicateAgentFallbackModelConfigurationStop$Outbound =
  | string
  | Array<string>;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationStop$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationStop$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationStop
  > = z.union([z.string(), z.array(z.string())]);

export function duplicateAgentFallbackModelConfigurationStopToJSON(
  duplicateAgentFallbackModelConfigurationStop:
    DuplicateAgentFallbackModelConfigurationStop,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationStop$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationStop,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationStopFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationStop,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationStop$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationStop' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationStreamOptions$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationStreamOptions,
    z.ZodTypeDef,
    unknown
  > = z.object({
    include_usage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      "include_usage": "includeUsage",
    });
  });
/** @internal */
export type DuplicateAgentFallbackModelConfigurationStreamOptions$Outbound = {
  include_usage?: boolean | undefined;
};

/** @internal */
export const DuplicateAgentFallbackModelConfigurationStreamOptions$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationStreamOptions$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationStreamOptions
  > = z.object({
    includeUsage: z.boolean().optional(),
  }).transform((v) => {
    return remap$(v, {
      includeUsage: "include_usage",
    });
  });

export function duplicateAgentFallbackModelConfigurationStreamOptionsToJSON(
  duplicateAgentFallbackModelConfigurationStreamOptions:
    DuplicateAgentFallbackModelConfigurationStreamOptions,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationStreamOptions$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationStreamOptions,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationStreamOptionsFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationStreamOptions,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationStreamOptions$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationStreamOptions' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationType$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationType> = z
    .nativeEnum(DuplicateAgentFallbackModelConfigurationType);
/** @internal */
export const DuplicateAgentFallbackModelConfigurationType$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationType> =
    DuplicateAgentFallbackModelConfigurationType$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationThinkingLevel$inboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentFallbackModelConfigurationThinkingLevel
  > = z.nativeEnum(DuplicateAgentFallbackModelConfigurationThinkingLevel);
/** @internal */
export const DuplicateAgentFallbackModelConfigurationThinkingLevel$outboundSchema:
  z.ZodNativeEnum<
    typeof DuplicateAgentFallbackModelConfigurationThinkingLevel
  > = DuplicateAgentFallbackModelConfigurationThinkingLevel$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationThinking$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationThinking,
    z.ZodTypeDef,
    unknown
  > = z.object({
    type: DuplicateAgentFallbackModelConfigurationType$inboundSchema,
    budget_tokens: z.number(),
    thinking_level:
      DuplicateAgentFallbackModelConfigurationThinkingLevel$inboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      "budget_tokens": "budgetTokens",
      "thinking_level": "thinkingLevel",
    });
  });
/** @internal */
export type DuplicateAgentFallbackModelConfigurationThinking$Outbound = {
  type: string;
  budget_tokens: number;
  thinking_level?: string | undefined;
};

/** @internal */
export const DuplicateAgentFallbackModelConfigurationThinking$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationThinking$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationThinking
  > = z.object({
    type: DuplicateAgentFallbackModelConfigurationType$outboundSchema,
    budgetTokens: z.number(),
    thinkingLevel:
      DuplicateAgentFallbackModelConfigurationThinkingLevel$outboundSchema
        .optional(),
  }).transform((v) => {
    return remap$(v, {
      budgetTokens: "budget_tokens",
      thinkingLevel: "thinking_level",
    });
  });

export function duplicateAgentFallbackModelConfigurationThinkingToJSON(
  duplicateAgentFallbackModelConfigurationThinking:
    DuplicateAgentFallbackModelConfigurationThinking,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationThinking$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationThinking,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationThinkingFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationThinking,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationThinking$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationThinking' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoiceAgentsType$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceAgentsType
> = z.nativeEnum(DuplicateAgentToolChoiceAgentsType);
/** @internal */
export const DuplicateAgentToolChoiceAgentsType$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceAgentsType
> = DuplicateAgentToolChoiceAgentsType$inboundSchema;

/** @internal */
export const DuplicateAgentToolChoiceAgentsFunction$inboundSchema: z.ZodType<
  DuplicateAgentToolChoiceAgentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
});
/** @internal */
export type DuplicateAgentToolChoiceAgentsFunction$Outbound = {
  name?: string | undefined;
};

/** @internal */
export const DuplicateAgentToolChoiceAgentsFunction$outboundSchema: z.ZodType<
  DuplicateAgentToolChoiceAgentsFunction$Outbound,
  z.ZodTypeDef,
  DuplicateAgentToolChoiceAgentsFunction
> = z.object({
  name: z.string().optional(),
});

export function duplicateAgentToolChoiceAgentsFunctionToJSON(
  duplicateAgentToolChoiceAgentsFunction:
    DuplicateAgentToolChoiceAgentsFunction,
): string {
  return JSON.stringify(
    DuplicateAgentToolChoiceAgentsFunction$outboundSchema.parse(
      duplicateAgentToolChoiceAgentsFunction,
    ),
  );
}
export function duplicateAgentToolChoiceAgentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentToolChoiceAgentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentToolChoiceAgentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentToolChoiceAgentsFunction' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoiceAgents2$inboundSchema: z.ZodType<
  DuplicateAgentToolChoiceAgents2,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: DuplicateAgentToolChoiceAgentsType$inboundSchema.optional(),
  function: z.lazy(() => DuplicateAgentToolChoiceAgentsFunction$inboundSchema),
});
/** @internal */
export type DuplicateAgentToolChoiceAgents2$Outbound = {
  type?: string | undefined;
  function: DuplicateAgentToolChoiceAgentsFunction$Outbound;
};

/** @internal */
export const DuplicateAgentToolChoiceAgents2$outboundSchema: z.ZodType<
  DuplicateAgentToolChoiceAgents2$Outbound,
  z.ZodTypeDef,
  DuplicateAgentToolChoiceAgents2
> = z.object({
  type: DuplicateAgentToolChoiceAgentsType$outboundSchema.optional(),
  function: z.lazy(() => DuplicateAgentToolChoiceAgentsFunction$outboundSchema),
});

export function duplicateAgentToolChoiceAgents2ToJSON(
  duplicateAgentToolChoiceAgents2: DuplicateAgentToolChoiceAgents2,
): string {
  return JSON.stringify(
    DuplicateAgentToolChoiceAgents2$outboundSchema.parse(
      duplicateAgentToolChoiceAgents2,
    ),
  );
}
export function duplicateAgentToolChoiceAgents2FromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentToolChoiceAgents2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentToolChoiceAgents2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentToolChoiceAgents2' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentToolChoiceAgents1$inboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceAgents1
> = z.nativeEnum(DuplicateAgentToolChoiceAgents1);
/** @internal */
export const DuplicateAgentToolChoiceAgents1$outboundSchema: z.ZodNativeEnum<
  typeof DuplicateAgentToolChoiceAgents1
> = DuplicateAgentToolChoiceAgents1$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationToolChoice$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationToolChoice,
    z.ZodTypeDef,
    unknown
  > = z.union([
    z.lazy(() => DuplicateAgentToolChoiceAgents2$inboundSchema),
    DuplicateAgentToolChoiceAgents1$inboundSchema,
  ]);
/** @internal */
export type DuplicateAgentFallbackModelConfigurationToolChoice$Outbound =
  | DuplicateAgentToolChoiceAgents2$Outbound
  | string;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationToolChoice$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationToolChoice$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationToolChoice
  > = z.union([
    z.lazy(() => DuplicateAgentToolChoiceAgents2$outboundSchema),
    DuplicateAgentToolChoiceAgents1$outboundSchema,
  ]);

export function duplicateAgentFallbackModelConfigurationToolChoiceToJSON(
  duplicateAgentFallbackModelConfigurationToolChoice:
    DuplicateAgentFallbackModelConfigurationToolChoice,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationToolChoice$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationToolChoice,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationToolChoiceFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationToolChoice,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationToolChoice$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationToolChoice' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfigurationModalities$inboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationModalities> = z
    .nativeEnum(DuplicateAgentFallbackModelConfigurationModalities);
/** @internal */
export const DuplicateAgentFallbackModelConfigurationModalities$outboundSchema:
  z.ZodNativeEnum<typeof DuplicateAgentFallbackModelConfigurationModalities> =
    DuplicateAgentFallbackModelConfigurationModalities$inboundSchema;

/** @internal */
export const DuplicateAgentFallbackModelConfigurationParameters$inboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationParameters,
    z.ZodTypeDef,
    unknown
  > = z.object({
    audio: z.nullable(
      z.lazy(() => DuplicateAgentFallbackModelConfigurationAudio$inboundSchema),
    ).optional(),
    frequency_penalty: z.nullable(z.number()).optional(),
    max_tokens: z.nullable(z.number().int()).optional(),
    max_completion_tokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    top_logprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presence_penalty: z.nullable(z.number()).optional(),
    response_format: z.union([
      z.lazy(() =>
        DuplicateAgentResponseFormatAgentsResponse201JSONSchema$inboundSchema
      ),
      z.lazy(() => DuplicateAgentResponseFormatAgentsText$inboundSchema),
      z.lazy(() => DuplicateAgentResponseFormatAgentsJSONObject$inboundSchema),
    ]).optional(),
    reasoning_effort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    stream_options: z.nullable(
      z.lazy(() =>
        DuplicateAgentFallbackModelConfigurationStreamOptions$inboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      DuplicateAgentFallbackModelConfigurationThinking$inboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    top_p: z.nullable(z.number()).optional(),
    top_k: z.nullable(z.number()).optional(),
    tool_choice: z.union([
      z.lazy(() => DuplicateAgentToolChoiceAgents2$inboundSchema),
      DuplicateAgentToolChoiceAgents1$inboundSchema,
    ]).optional(),
    parallel_tool_calls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(DuplicateAgentFallbackModelConfigurationModalities$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "frequency_penalty": "frequencyPenalty",
      "max_tokens": "maxTokens",
      "max_completion_tokens": "maxCompletionTokens",
      "top_logprobs": "topLogprobs",
      "presence_penalty": "presencePenalty",
      "response_format": "responseFormat",
      "reasoning_effort": "reasoningEffort",
      "stream_options": "streamOptions",
      "top_p": "topP",
      "top_k": "topK",
      "tool_choice": "toolChoice",
      "parallel_tool_calls": "parallelToolCalls",
    });
  });
/** @internal */
export type DuplicateAgentFallbackModelConfigurationParameters$Outbound = {
  audio?:
    | DuplicateAgentFallbackModelConfigurationAudio$Outbound
    | null
    | undefined;
  frequency_penalty?: number | null | undefined;
  max_tokens?: number | null | undefined;
  max_completion_tokens?: number | null | undefined;
  logprobs?: boolean | null | undefined;
  top_logprobs?: number | null | undefined;
  n?: number | null | undefined;
  presence_penalty?: number | null | undefined;
  response_format?:
    | DuplicateAgentResponseFormatAgentsResponse201JSONSchema$Outbound
    | DuplicateAgentResponseFormatAgentsText$Outbound
    | DuplicateAgentResponseFormatAgentsJSONObject$Outbound
    | undefined;
  reasoning_effort?: string | undefined;
  verbosity?: string | undefined;
  seed?: number | null | undefined;
  stop?: string | Array<string> | null | undefined;
  stream_options?:
    | DuplicateAgentFallbackModelConfigurationStreamOptions$Outbound
    | null
    | undefined;
  thinking?:
    | DuplicateAgentFallbackModelConfigurationThinking$Outbound
    | undefined;
  temperature?: number | null | undefined;
  top_p?: number | null | undefined;
  top_k?: number | null | undefined;
  tool_choice?: DuplicateAgentToolChoiceAgents2$Outbound | string | undefined;
  parallel_tool_calls?: boolean | undefined;
  modalities?: Array<string> | null | undefined;
};

/** @internal */
export const DuplicateAgentFallbackModelConfigurationParameters$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfigurationParameters$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfigurationParameters
  > = z.object({
    audio: z.nullable(
      z.lazy(() =>
        DuplicateAgentFallbackModelConfigurationAudio$outboundSchema
      ),
    ).optional(),
    frequencyPenalty: z.nullable(z.number()).optional(),
    maxTokens: z.nullable(z.number().int()).optional(),
    maxCompletionTokens: z.nullable(z.number().int()).optional(),
    logprobs: z.nullable(z.boolean()).optional(),
    topLogprobs: z.nullable(z.number().int()).optional(),
    n: z.nullable(z.number().int()).optional(),
    presencePenalty: z.nullable(z.number()).optional(),
    responseFormat: z.union([
      z.lazy(() =>
        DuplicateAgentResponseFormatAgentsResponse201JSONSchema$outboundSchema
      ),
      z.lazy(() => DuplicateAgentResponseFormatAgentsText$outboundSchema),
      z.lazy(() => DuplicateAgentResponseFormatAgentsJSONObject$outboundSchema),
    ]).optional(),
    reasoningEffort: z.string().optional(),
    verbosity: z.string().optional(),
    seed: z.nullable(z.number()).optional(),
    stop: z.nullable(z.union([z.string(), z.array(z.string())])).optional(),
    streamOptions: z.nullable(
      z.lazy(() =>
        DuplicateAgentFallbackModelConfigurationStreamOptions$outboundSchema
      ),
    ).optional(),
    thinking: z.lazy(() =>
      DuplicateAgentFallbackModelConfigurationThinking$outboundSchema
    ).optional(),
    temperature: z.nullable(z.number()).optional(),
    topP: z.nullable(z.number()).optional(),
    topK: z.nullable(z.number()).optional(),
    toolChoice: z.union([
      z.lazy(() => DuplicateAgentToolChoiceAgents2$outboundSchema),
      DuplicateAgentToolChoiceAgents1$outboundSchema,
    ]).optional(),
    parallelToolCalls: z.boolean().optional(),
    modalities: z.nullable(
      z.array(
        DuplicateAgentFallbackModelConfigurationModalities$outboundSchema,
      ),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      frequencyPenalty: "frequency_penalty",
      maxTokens: "max_tokens",
      maxCompletionTokens: "max_completion_tokens",
      topLogprobs: "top_logprobs",
      presencePenalty: "presence_penalty",
      responseFormat: "response_format",
      reasoningEffort: "reasoning_effort",
      streamOptions: "stream_options",
      topP: "top_p",
      topK: "top_k",
      toolChoice: "tool_choice",
      parallelToolCalls: "parallel_tool_calls",
    });
  });

export function duplicateAgentFallbackModelConfigurationParametersToJSON(
  duplicateAgentFallbackModelConfigurationParameters:
    DuplicateAgentFallbackModelConfigurationParameters,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfigurationParameters$outboundSchema.parse(
      duplicateAgentFallbackModelConfigurationParameters,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationParametersFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfigurationParameters,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfigurationParameters$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfigurationParameters' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfiguration2$inboundSchema: z.ZodType<
  DuplicateAgentFallbackModelConfiguration2,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  parameters: z.lazy(() =>
    DuplicateAgentFallbackModelConfigurationParameters$inboundSchema
  ).optional(),
});
/** @internal */
export type DuplicateAgentFallbackModelConfiguration2$Outbound = {
  id: string;
  parameters?:
    | DuplicateAgentFallbackModelConfigurationParameters$Outbound
    | undefined;
};

/** @internal */
export const DuplicateAgentFallbackModelConfiguration2$outboundSchema:
  z.ZodType<
    DuplicateAgentFallbackModelConfiguration2$Outbound,
    z.ZodTypeDef,
    DuplicateAgentFallbackModelConfiguration2
  > = z.object({
    id: z.string(),
    parameters: z.lazy(() =>
      DuplicateAgentFallbackModelConfigurationParameters$outboundSchema
    ).optional(),
  });

export function duplicateAgentFallbackModelConfiguration2ToJSON(
  duplicateAgentFallbackModelConfiguration2:
    DuplicateAgentFallbackModelConfiguration2,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfiguration2$outboundSchema.parse(
      duplicateAgentFallbackModelConfiguration2,
    ),
  );
}
export function duplicateAgentFallbackModelConfiguration2FromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfiguration2,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfiguration2$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfiguration2' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentFallbackModelConfiguration$inboundSchema: z.ZodType<
  DuplicateAgentFallbackModelConfiguration,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DuplicateAgentFallbackModelConfiguration2$inboundSchema),
  z.string(),
]);
/** @internal */
export type DuplicateAgentFallbackModelConfiguration$Outbound =
  | DuplicateAgentFallbackModelConfiguration2$Outbound
  | string;

/** @internal */
export const DuplicateAgentFallbackModelConfiguration$outboundSchema: z.ZodType<
  DuplicateAgentFallbackModelConfiguration$Outbound,
  z.ZodTypeDef,
  DuplicateAgentFallbackModelConfiguration
> = z.union([
  z.lazy(() => DuplicateAgentFallbackModelConfiguration2$outboundSchema),
  z.string(),
]);

export function duplicateAgentFallbackModelConfigurationToJSON(
  duplicateAgentFallbackModelConfiguration:
    DuplicateAgentFallbackModelConfiguration,
): string {
  return JSON.stringify(
    DuplicateAgentFallbackModelConfiguration$outboundSchema.parse(
      duplicateAgentFallbackModelConfiguration,
    ),
  );
}
export function duplicateAgentFallbackModelConfigurationFromJSON(
  jsonString: string,
): SafeParseResult<
  DuplicateAgentFallbackModelConfiguration,
  SDKValidationError
> {
  return safeParse(
    jsonString,
    (x) =>
      DuplicateAgentFallbackModelConfiguration$inboundSchema.parse(
        JSON.parse(x),
      ),
    `Failed to parse 'DuplicateAgentFallbackModelConfiguration' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentModel$inboundSchema: z.ZodType<
  DuplicateAgentModel,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  integration_id: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => DuplicateAgentParameters$inboundSchema).optional(),
  retry: z.lazy(() => DuplicateAgentRetry$inboundSchema).optional(),
  fallback_models: z.nullable(
    z.array(z.union([
      z.lazy(() => DuplicateAgentFallbackModelConfiguration2$inboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "integration_id": "integrationId",
    "fallback_models": "fallbackModels",
  });
});
/** @internal */
export type DuplicateAgentModel$Outbound = {
  id: string;
  integration_id?: string | null | undefined;
  parameters?: DuplicateAgentParameters$Outbound | undefined;
  retry?: DuplicateAgentRetry$Outbound | undefined;
  fallback_models?:
    | Array<DuplicateAgentFallbackModelConfiguration2$Outbound | string>
    | null
    | undefined;
};

/** @internal */
export const DuplicateAgentModel$outboundSchema: z.ZodType<
  DuplicateAgentModel$Outbound,
  z.ZodTypeDef,
  DuplicateAgentModel
> = z.object({
  id: z.string(),
  integrationId: z.nullable(z.string()).optional(),
  parameters: z.lazy(() => DuplicateAgentParameters$outboundSchema).optional(),
  retry: z.lazy(() => DuplicateAgentRetry$outboundSchema).optional(),
  fallbackModels: z.nullable(
    z.array(z.union([
      z.lazy(() => DuplicateAgentFallbackModelConfiguration2$outboundSchema),
      z.string(),
    ])),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    integrationId: "integration_id",
    fallbackModels: "fallback_models",
  });
});

export function duplicateAgentModelToJSON(
  duplicateAgentModel: DuplicateAgentModel,
): string {
  return JSON.stringify(
    DuplicateAgentModel$outboundSchema.parse(duplicateAgentModel),
  );
}
export function duplicateAgentModelFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentModel' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentTeamOfAgents$inboundSchema: z.ZodType<
  DuplicateAgentTeamOfAgents,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});
/** @internal */
export type DuplicateAgentTeamOfAgents$Outbound = {
  key: string;
  role?: string | undefined;
};

/** @internal */
export const DuplicateAgentTeamOfAgents$outboundSchema: z.ZodType<
  DuplicateAgentTeamOfAgents$Outbound,
  z.ZodTypeDef,
  DuplicateAgentTeamOfAgents
> = z.object({
  key: z.string(),
  role: z.string().optional(),
});

export function duplicateAgentTeamOfAgentsToJSON(
  duplicateAgentTeamOfAgents: DuplicateAgentTeamOfAgents,
): string {
  return JSON.stringify(
    DuplicateAgentTeamOfAgents$outboundSchema.parse(duplicateAgentTeamOfAgents),
  );
}
export function duplicateAgentTeamOfAgentsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentTeamOfAgents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentTeamOfAgents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentTeamOfAgents' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentMetrics$inboundSchema: z.ZodType<
  DuplicateAgentMetrics,
  z.ZodTypeDef,
  unknown
> = z.object({
  total_cost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    "total_cost": "totalCost",
  });
});
/** @internal */
export type DuplicateAgentMetrics$Outbound = {
  total_cost: number;
};

/** @internal */
export const DuplicateAgentMetrics$outboundSchema: z.ZodType<
  DuplicateAgentMetrics$Outbound,
  z.ZodTypeDef,
  DuplicateAgentMetrics
> = z.object({
  totalCost: z.number().default(0),
}).transform((v) => {
  return remap$(v, {
    totalCost: "total_cost",
  });
});

export function duplicateAgentMetricsToJSON(
  duplicateAgentMetrics: DuplicateAgentMetrics,
): string {
  return JSON.stringify(
    DuplicateAgentMetrics$outboundSchema.parse(duplicateAgentMetrics),
  );
}
export function duplicateAgentMetricsFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentMetrics, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentMetrics$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentMetrics' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentKnowledgeBases$inboundSchema: z.ZodType<
  DuplicateAgentKnowledgeBases,
  z.ZodTypeDef,
  unknown
> = z.object({
  knowledge_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "knowledge_id": "knowledgeId",
  });
});
/** @internal */
export type DuplicateAgentKnowledgeBases$Outbound = {
  knowledge_id: string;
};

/** @internal */
export const DuplicateAgentKnowledgeBases$outboundSchema: z.ZodType<
  DuplicateAgentKnowledgeBases$Outbound,
  z.ZodTypeDef,
  DuplicateAgentKnowledgeBases
> = z.object({
  knowledgeId: z.string(),
}).transform((v) => {
  return remap$(v, {
    knowledgeId: "knowledge_id",
  });
});

export function duplicateAgentKnowledgeBasesToJSON(
  duplicateAgentKnowledgeBases: DuplicateAgentKnowledgeBases,
): string {
  return JSON.stringify(
    DuplicateAgentKnowledgeBases$outboundSchema.parse(
      duplicateAgentKnowledgeBases,
    ),
  );
}
export function duplicateAgentKnowledgeBasesFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentKnowledgeBases, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentKnowledgeBases$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentKnowledgeBases' from JSON`,
  );
}

/** @internal */
export const DuplicateAgentResponseBody$inboundSchema: z.ZodType<
  DuplicateAgentResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  key: z.string(),
  display_name: z.string(),
  workspace_id: z.string(),
  project_id: z.string(),
  created_by_id: z.nullable(z.string()).optional(),
  updated_by_id: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  system_prompt: z.string().optional(),
  instructions: z.string(),
  status: DuplicateAgentStatus$inboundSchema,
  settings: z.lazy(() => DuplicateAgentSettings$inboundSchema).optional(),
  model: z.lazy(() => DuplicateAgentModel$inboundSchema),
  version_hash: z.string().optional(),
  path: z.string(),
  memory_stores: z.array(z.string()),
  team_of_agents: z.array(
    z.lazy(() => DuplicateAgentTeamOfAgents$inboundSchema),
  ),
  metrics: z.lazy(() => DuplicateAgentMetrics$inboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledge_bases: z.array(
    z.lazy(() => DuplicateAgentKnowledgeBases$inboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "display_name": "displayName",
    "workspace_id": "workspaceId",
    "project_id": "projectId",
    "created_by_id": "createdById",
    "updated_by_id": "updatedById",
    "system_prompt": "systemPrompt",
    "version_hash": "versionHash",
    "memory_stores": "memoryStores",
    "team_of_agents": "teamOfAgents",
    "knowledge_bases": "knowledgeBases",
  });
});
/** @internal */
export type DuplicateAgentResponseBody$Outbound = {
  _id: string;
  key: string;
  display_name: string;
  workspace_id: string;
  project_id: string;
  created_by_id?: string | null | undefined;
  updated_by_id?: string | null | undefined;
  created?: string | undefined;
  updated?: string | undefined;
  role: string;
  description: string;
  system_prompt?: string | undefined;
  instructions: string;
  status: string;
  settings?: DuplicateAgentSettings$Outbound | undefined;
  model: DuplicateAgentModel$Outbound;
  version_hash?: string | undefined;
  path: string;
  memory_stores: Array<string>;
  team_of_agents: Array<DuplicateAgentTeamOfAgents$Outbound>;
  metrics?: DuplicateAgentMetrics$Outbound | undefined;
  variables?: { [k: string]: any } | undefined;
  knowledge_bases?: Array<DuplicateAgentKnowledgeBases$Outbound> | undefined;
};

/** @internal */
export const DuplicateAgentResponseBody$outboundSchema: z.ZodType<
  DuplicateAgentResponseBody$Outbound,
  z.ZodTypeDef,
  DuplicateAgentResponseBody
> = z.object({
  id: z.string(),
  key: z.string(),
  displayName: z.string(),
  workspaceId: z.string(),
  projectId: z.string(),
  createdById: z.nullable(z.string()).optional(),
  updatedById: z.nullable(z.string()).optional(),
  created: z.string().optional(),
  updated: z.string().optional(),
  role: z.string(),
  description: z.string(),
  systemPrompt: z.string().optional(),
  instructions: z.string(),
  status: DuplicateAgentStatus$outboundSchema,
  settings: z.lazy(() => DuplicateAgentSettings$outboundSchema).optional(),
  model: z.lazy(() => DuplicateAgentModel$outboundSchema),
  versionHash: z.string().optional(),
  path: z.string(),
  memoryStores: z.array(z.string()),
  teamOfAgents: z.array(
    z.lazy(() => DuplicateAgentTeamOfAgents$outboundSchema),
  ),
  metrics: z.lazy(() => DuplicateAgentMetrics$outboundSchema).optional(),
  variables: z.record(z.any()).optional(),
  knowledgeBases: z.array(
    z.lazy(() => DuplicateAgentKnowledgeBases$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    displayName: "display_name",
    workspaceId: "workspace_id",
    projectId: "project_id",
    createdById: "created_by_id",
    updatedById: "updated_by_id",
    systemPrompt: "system_prompt",
    versionHash: "version_hash",
    memoryStores: "memory_stores",
    teamOfAgents: "team_of_agents",
    knowledgeBases: "knowledge_bases",
  });
});

export function duplicateAgentResponseBodyToJSON(
  duplicateAgentResponseBody: DuplicateAgentResponseBody,
): string {
  return JSON.stringify(
    DuplicateAgentResponseBody$outboundSchema.parse(duplicateAgentResponseBody),
  );
}
export function duplicateAgentResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<DuplicateAgentResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DuplicateAgentResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DuplicateAgentResponseBody' from JSON`,
  );
}
