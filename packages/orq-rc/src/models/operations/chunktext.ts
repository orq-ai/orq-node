/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType =
  {
    Chunks: "chunks",
    Texts: "texts",
  } as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType =
  ClosedEnum<
    typeof ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType
  >;

export const AgenticChunker = {
  Agentic: "agentic",
} as const;
export type AgenticChunker = ClosedEnum<typeof AgenticChunker>;

/**
 * Agentic LLM-powered chunker that uses AI to determine optimal split points. Best for complex documents requiring intelligent segmentation.
 */
export type AgenticChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?:
    | ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType
    | undefined;
  strategy: AgenticChunker;
  /**
   * Chat model to use for chunking. (Available models)[https://docs.orq.ai/docs/proxy#chat-models]
   */
  model: string;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Size of candidate splits for LLM evaluation
   */
  candidateSize?: number | undefined;
  /**
   * Minimum characters allowed per chunk
   */
  minCharactersPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkTextChunkingRequestKnowledgeBasesRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkTextChunkingRequestKnowledgeBasesRequestReturnType =
  ClosedEnum<typeof ChunkTextChunkingRequestKnowledgeBasesRequestReturnType>;

export const SDPMChunker = {
  Sdpm: "sdpm",
} as const;
export type SDPMChunker = ClosedEnum<typeof SDPMChunker>;

export const ChunkTextThreshold2 = {
  Auto: "auto",
} as const;
export type ChunkTextThreshold2 = ClosedEnum<typeof ChunkTextThreshold2>;

/**
 * Similarity threshold for grouping (0-1) or "auto" for automatic detection
 */
export type ChunkingRequestThreshold = number | ChunkTextThreshold2;

/**
 * Chunking mode: window-based or sentence-based similarity
 */
export const ChunkingRequestMode = {
  Window: "window",
  Sentence: "sentence",
} as const;
/**
 * Chunking mode: window-based or sentence-based similarity
 */
export type ChunkingRequestMode = ClosedEnum<typeof ChunkingRequestMode>;

/**
 * Sub-Document Prose Model chunker that uses skip-gram patterns to identify optimal split points. Good for technical documents with structured content.
 */
export type SDPMChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?:
    | ChunkTextChunkingRequestKnowledgeBasesRequestReturnType
    | undefined;
  strategy: SDPMChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Window size for skip-gram patterns
   */
  skipWindow?: number | undefined;
  /**
   * Similarity threshold for grouping (0-1) or "auto" for automatic detection
   */
  threshold?: number | ChunkTextThreshold2 | undefined;
  /**
   * Embedding model to use for semantic similarity. (Available embedding models)[https://docs.orq.ai/docs/proxy#embedding-models]
   */
  embeddingModel: string;
  /**
   * Chunking mode: window-based or sentence-based similarity
   */
  mode?: ChunkingRequestMode | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkTextChunkingRequestKnowledgeBasesReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkTextChunkingRequestKnowledgeBasesReturnType = ClosedEnum<
  typeof ChunkTextChunkingRequestKnowledgeBasesReturnType
>;

export const SemanticChunker = {
  Semantic: "semantic",
} as const;
export type SemanticChunker = ClosedEnum<typeof SemanticChunker>;

export const Threshold2 = {
  Auto: "auto",
} as const;
export type Threshold2 = ClosedEnum<typeof Threshold2>;

/**
 * Similarity threshold for grouping (0-1) or "auto" for automatic detection
 */
export type Threshold = number | Threshold2;

/**
 * Chunking mode: window-based or sentence-based similarity
 */
export const Mode = {
  Window: "window",
  Sentence: "sentence",
} as const;
/**
 * Chunking mode: window-based or sentence-based similarity
 */
export type Mode = ClosedEnum<typeof Mode>;

/**
 * Groups semantically similar sentences using embeddings. Excellent for maintaining topic coherence and context within chunks.
 */
export type SemanticChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ChunkTextChunkingRequestKnowledgeBasesReturnType | undefined;
  strategy: SemanticChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Similarity threshold for grouping (0-1) or "auto" for automatic detection
   */
  threshold?: number | Threshold2 | undefined;
  /**
   * Embedding model to use for semantic similarity. (Available embedding models)[https://docs.orq.ai/docs/proxy#embedding-models]
   */
  embeddingModel: string;
  /**
   * Chunking mode: window-based or sentence-based similarity
   */
  mode?: Mode | undefined;
  /**
   * Window size for similarity comparison
   */
  similarityWindow?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkTextChunkingRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkTextChunkingRequestReturnType = ClosedEnum<
  typeof ChunkTextChunkingRequestReturnType
>;

export const RecursiveChunker = {
  Recursive: "recursive",
} as const;
export type RecursiveChunker = ClosedEnum<typeof RecursiveChunker>;

/**
 * Recursively splits text using a hierarchy of separators (paragraphs, sentences, words). Versatile general-purpose chunker that preserves document structure.
 */
export type RecursiveChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ChunkTextChunkingRequestReturnType | undefined;
  strategy: RecursiveChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Hierarchy of separators to use for splitting
   */
  separators?: Array<string> | undefined;
  /**
   * Minimum characters allowed per chunk
   */
  minCharactersPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ChunkingRequestReturnType = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ChunkingRequestReturnType = ClosedEnum<
  typeof ChunkingRequestReturnType
>;

export const SentenceChunker = {
  Sentence: "sentence",
} as const;
export type SentenceChunker = ClosedEnum<typeof SentenceChunker>;

/**
 * Splits text at sentence boundaries while respecting token limits. Ideal for maintaining semantic coherence and readability.
 */
export type SentenceChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ChunkingRequestReturnType | undefined;
  strategy: SentenceChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Number of overlapping tokens between chunks
   */
  chunkOverlap?: number | undefined;
  /**
   * Minimum number of sentences per chunk
   */
  minSentencesPerChunk?: number | undefined;
};

/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export const ReturnTypeT = {
  Chunks: "chunks",
  Texts: "texts",
} as const;
/**
 * Return format: chunks (with metadata) or texts (plain strings)
 */
export type ReturnTypeT = ClosedEnum<typeof ReturnTypeT>;

export const TokenChunker = {
  Token: "token",
} as const;
export type TokenChunker = ClosedEnum<typeof TokenChunker>;

/**
 * Splits text based on token count. Best for ensuring chunks fit within LLM context windows and maintaining consistent chunk sizes for embedding models.
 */
export type TokenChunkerStrategy = {
  /**
   * The text content to be chunked
   */
  text: string;
  /**
   * Whether to include metadata for each chunk
   */
  metadata?: boolean | undefined;
  /**
   * Return format: chunks (with metadata) or texts (plain strings)
   */
  returnType?: ReturnTypeT | undefined;
  strategy: TokenChunker;
  /**
   * Maximum tokens per chunk
   */
  chunkSize?: number | undefined;
  /**
   * Number of tokens to overlap between chunks
   */
  chunkOverlap?: number | undefined;
};

/**
 * Request payload for text chunking with strategy-specific configuration
 */
export type ChunkTextChunkingRequest =
  | SemanticChunkerStrategy
  | SDPMChunkerStrategy
  | AgenticChunkerStrategy
  | TokenChunkerStrategy
  | SentenceChunkerStrategy
  | RecursiveChunkerStrategy;

export type ChunkTextMetadata = {
  startIndex: number | null;
  endIndex: number | null;
  tokenCount: number | null;
};

export type Chunks = {
  /**
   * The text content of the chunk
   */
  text: string;
  /**
   * The position index of this chunk in the sequence
   */
  index: number;
  metadata?: ChunkTextMetadata | undefined;
};

/**
 * Text successfully chunked
 */
export type ChunkTextResponseBody = {
  chunks: Array<Chunks>;
};

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$inboundSchema:
  z.ZodNativeEnum<
    typeof ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType
  > = z.nativeEnum(
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType,
  );

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$outboundSchema:
  z.ZodNativeEnum<
    typeof ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType
  > =
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$ {
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$inboundSchema` instead. */
  export const inboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$inboundSchema;
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$outboundSchema` instead. */
  export const outboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$outboundSchema;
}

/** @internal */
export const AgenticChunker$inboundSchema: z.ZodNativeEnum<
  typeof AgenticChunker
> = z.nativeEnum(AgenticChunker);

/** @internal */
export const AgenticChunker$outboundSchema: z.ZodNativeEnum<
  typeof AgenticChunker
> = AgenticChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgenticChunker$ {
  /** @deprecated use `AgenticChunker$inboundSchema` instead. */
  export const inboundSchema = AgenticChunker$inboundSchema;
  /** @deprecated use `AgenticChunker$outboundSchema` instead. */
  export const outboundSchema = AgenticChunker$outboundSchema;
}

/** @internal */
export const AgenticChunkerStrategy$inboundSchema: z.ZodType<
  AgenticChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type:
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$inboundSchema
      .default("chunks"),
  strategy: AgenticChunker$inboundSchema,
  model: z.string(),
  chunk_size: z.number().int().default(1024),
  candidate_size: z.number().int().default(128),
  min_characters_per_chunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "candidate_size": "candidateSize",
    "min_characters_per_chunk": "minCharactersPerChunk",
  });
});

/** @internal */
export type AgenticChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  model: string;
  chunk_size: number;
  candidate_size: number;
  min_characters_per_chunk: number;
};

/** @internal */
export const AgenticChunkerStrategy$outboundSchema: z.ZodType<
  AgenticChunkerStrategy$Outbound,
  z.ZodTypeDef,
  AgenticChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType:
    ChunkTextChunkingRequestKnowledgeBasesRequestRequestBodyReturnType$outboundSchema
      .default("chunks"),
  strategy: AgenticChunker$outboundSchema,
  model: z.string(),
  chunkSize: z.number().int().default(1024),
  candidateSize: z.number().int().default(128),
  minCharactersPerChunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    candidateSize: "candidate_size",
    minCharactersPerChunk: "min_characters_per_chunk",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AgenticChunkerStrategy$ {
  /** @deprecated use `AgenticChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = AgenticChunkerStrategy$inboundSchema;
  /** @deprecated use `AgenticChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = AgenticChunkerStrategy$outboundSchema;
  /** @deprecated use `AgenticChunkerStrategy$Outbound` instead. */
  export type Outbound = AgenticChunkerStrategy$Outbound;
}

export function agenticChunkerStrategyToJSON(
  agenticChunkerStrategy: AgenticChunkerStrategy,
): string {
  return JSON.stringify(
    AgenticChunkerStrategy$outboundSchema.parse(agenticChunkerStrategy),
  );
}

export function agenticChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<AgenticChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AgenticChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AgenticChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$inboundSchema:
  z.ZodNativeEnum<
    typeof ChunkTextChunkingRequestKnowledgeBasesRequestReturnType
  > = z.nativeEnum(ChunkTextChunkingRequestKnowledgeBasesRequestReturnType);

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$outboundSchema:
  z.ZodNativeEnum<
    typeof ChunkTextChunkingRequestKnowledgeBasesRequestReturnType
  > = ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$ {
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$inboundSchema` instead. */
  export const inboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$inboundSchema;
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$outboundSchema` instead. */
  export const outboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$outboundSchema;
}

/** @internal */
export const SDPMChunker$inboundSchema: z.ZodNativeEnum<typeof SDPMChunker> = z
  .nativeEnum(SDPMChunker);

/** @internal */
export const SDPMChunker$outboundSchema: z.ZodNativeEnum<typeof SDPMChunker> =
  SDPMChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SDPMChunker$ {
  /** @deprecated use `SDPMChunker$inboundSchema` instead. */
  export const inboundSchema = SDPMChunker$inboundSchema;
  /** @deprecated use `SDPMChunker$outboundSchema` instead. */
  export const outboundSchema = SDPMChunker$outboundSchema;
}

/** @internal */
export const ChunkTextThreshold2$inboundSchema: z.ZodNativeEnum<
  typeof ChunkTextThreshold2
> = z.nativeEnum(ChunkTextThreshold2);

/** @internal */
export const ChunkTextThreshold2$outboundSchema: z.ZodNativeEnum<
  typeof ChunkTextThreshold2
> = ChunkTextThreshold2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextThreshold2$ {
  /** @deprecated use `ChunkTextThreshold2$inboundSchema` instead. */
  export const inboundSchema = ChunkTextThreshold2$inboundSchema;
  /** @deprecated use `ChunkTextThreshold2$outboundSchema` instead. */
  export const outboundSchema = ChunkTextThreshold2$outboundSchema;
}

/** @internal */
export const ChunkingRequestThreshold$inboundSchema: z.ZodType<
  ChunkingRequestThreshold,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), ChunkTextThreshold2$inboundSchema]);

/** @internal */
export type ChunkingRequestThreshold$Outbound = number | string;

/** @internal */
export const ChunkingRequestThreshold$outboundSchema: z.ZodType<
  ChunkingRequestThreshold$Outbound,
  z.ZodTypeDef,
  ChunkingRequestThreshold
> = z.union([z.number(), ChunkTextThreshold2$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkingRequestThreshold$ {
  /** @deprecated use `ChunkingRequestThreshold$inboundSchema` instead. */
  export const inboundSchema = ChunkingRequestThreshold$inboundSchema;
  /** @deprecated use `ChunkingRequestThreshold$outboundSchema` instead. */
  export const outboundSchema = ChunkingRequestThreshold$outboundSchema;
  /** @deprecated use `ChunkingRequestThreshold$Outbound` instead. */
  export type Outbound = ChunkingRequestThreshold$Outbound;
}

export function chunkingRequestThresholdToJSON(
  chunkingRequestThreshold: ChunkingRequestThreshold,
): string {
  return JSON.stringify(
    ChunkingRequestThreshold$outboundSchema.parse(chunkingRequestThreshold),
  );
}

export function chunkingRequestThresholdFromJSON(
  jsonString: string,
): SafeParseResult<ChunkingRequestThreshold, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChunkingRequestThreshold$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChunkingRequestThreshold' from JSON`,
  );
}

/** @internal */
export const ChunkingRequestMode$inboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestMode
> = z.nativeEnum(ChunkingRequestMode);

/** @internal */
export const ChunkingRequestMode$outboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestMode
> = ChunkingRequestMode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkingRequestMode$ {
  /** @deprecated use `ChunkingRequestMode$inboundSchema` instead. */
  export const inboundSchema = ChunkingRequestMode$inboundSchema;
  /** @deprecated use `ChunkingRequestMode$outboundSchema` instead. */
  export const outboundSchema = ChunkingRequestMode$outboundSchema;
}

/** @internal */
export const SDPMChunkerStrategy$inboundSchema: z.ZodType<
  SDPMChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type:
    ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$inboundSchema
      .default("chunks"),
  strategy: SDPMChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  skip_window: z.number().int().default(1),
  threshold: z.union([z.number(), ChunkTextThreshold2$inboundSchema])
    .optional(),
  embedding_model: z.string(),
  mode: ChunkingRequestMode$inboundSchema.default("window"),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "skip_window": "skipWindow",
    "embedding_model": "embeddingModel",
  });
});

/** @internal */
export type SDPMChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  skip_window: number;
  threshold?: number | string | undefined;
  embedding_model: string;
  mode: string;
};

/** @internal */
export const SDPMChunkerStrategy$outboundSchema: z.ZodType<
  SDPMChunkerStrategy$Outbound,
  z.ZodTypeDef,
  SDPMChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType:
    ChunkTextChunkingRequestKnowledgeBasesRequestReturnType$outboundSchema
      .default("chunks"),
  strategy: SDPMChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  skipWindow: z.number().int().default(1),
  threshold: z.union([z.number(), ChunkTextThreshold2$outboundSchema])
    .optional(),
  embeddingModel: z.string(),
  mode: ChunkingRequestMode$outboundSchema.default("window"),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    skipWindow: "skip_window",
    embeddingModel: "embedding_model",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SDPMChunkerStrategy$ {
  /** @deprecated use `SDPMChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = SDPMChunkerStrategy$inboundSchema;
  /** @deprecated use `SDPMChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = SDPMChunkerStrategy$outboundSchema;
  /** @deprecated use `SDPMChunkerStrategy$Outbound` instead. */
  export type Outbound = SDPMChunkerStrategy$Outbound;
}

export function sdpmChunkerStrategyToJSON(
  sdpmChunkerStrategy: SDPMChunkerStrategy,
): string {
  return JSON.stringify(
    SDPMChunkerStrategy$outboundSchema.parse(sdpmChunkerStrategy),
  );
}

export function sdpmChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<SDPMChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SDPMChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SDPMChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesReturnType$inboundSchema:
  z.ZodNativeEnum<typeof ChunkTextChunkingRequestKnowledgeBasesReturnType> = z
    .nativeEnum(ChunkTextChunkingRequestKnowledgeBasesReturnType);

/** @internal */
export const ChunkTextChunkingRequestKnowledgeBasesReturnType$outboundSchema:
  z.ZodNativeEnum<typeof ChunkTextChunkingRequestKnowledgeBasesReturnType> =
    ChunkTextChunkingRequestKnowledgeBasesReturnType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextChunkingRequestKnowledgeBasesReturnType$ {
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesReturnType$inboundSchema` instead. */
  export const inboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesReturnType$inboundSchema;
  /** @deprecated use `ChunkTextChunkingRequestKnowledgeBasesReturnType$outboundSchema` instead. */
  export const outboundSchema =
    ChunkTextChunkingRequestKnowledgeBasesReturnType$outboundSchema;
}

/** @internal */
export const SemanticChunker$inboundSchema: z.ZodNativeEnum<
  typeof SemanticChunker
> = z.nativeEnum(SemanticChunker);

/** @internal */
export const SemanticChunker$outboundSchema: z.ZodNativeEnum<
  typeof SemanticChunker
> = SemanticChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SemanticChunker$ {
  /** @deprecated use `SemanticChunker$inboundSchema` instead. */
  export const inboundSchema = SemanticChunker$inboundSchema;
  /** @deprecated use `SemanticChunker$outboundSchema` instead. */
  export const outboundSchema = SemanticChunker$outboundSchema;
}

/** @internal */
export const Threshold2$inboundSchema: z.ZodNativeEnum<typeof Threshold2> = z
  .nativeEnum(Threshold2);

/** @internal */
export const Threshold2$outboundSchema: z.ZodNativeEnum<typeof Threshold2> =
  Threshold2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Threshold2$ {
  /** @deprecated use `Threshold2$inboundSchema` instead. */
  export const inboundSchema = Threshold2$inboundSchema;
  /** @deprecated use `Threshold2$outboundSchema` instead. */
  export const outboundSchema = Threshold2$outboundSchema;
}

/** @internal */
export const Threshold$inboundSchema: z.ZodType<
  Threshold,
  z.ZodTypeDef,
  unknown
> = z.union([z.number(), Threshold2$inboundSchema]);

/** @internal */
export type Threshold$Outbound = number | string;

/** @internal */
export const Threshold$outboundSchema: z.ZodType<
  Threshold$Outbound,
  z.ZodTypeDef,
  Threshold
> = z.union([z.number(), Threshold2$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Threshold$ {
  /** @deprecated use `Threshold$inboundSchema` instead. */
  export const inboundSchema = Threshold$inboundSchema;
  /** @deprecated use `Threshold$outboundSchema` instead. */
  export const outboundSchema = Threshold$outboundSchema;
  /** @deprecated use `Threshold$Outbound` instead. */
  export type Outbound = Threshold$Outbound;
}

export function thresholdToJSON(threshold: Threshold): string {
  return JSON.stringify(Threshold$outboundSchema.parse(threshold));
}

export function thresholdFromJSON(
  jsonString: string,
): SafeParseResult<Threshold, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Threshold$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Threshold' from JSON`,
  );
}

/** @internal */
export const Mode$inboundSchema: z.ZodNativeEnum<typeof Mode> = z.nativeEnum(
  Mode,
);

/** @internal */
export const Mode$outboundSchema: z.ZodNativeEnum<typeof Mode> =
  Mode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Mode$ {
  /** @deprecated use `Mode$inboundSchema` instead. */
  export const inboundSchema = Mode$inboundSchema;
  /** @deprecated use `Mode$outboundSchema` instead. */
  export const outboundSchema = Mode$outboundSchema;
}

/** @internal */
export const SemanticChunkerStrategy$inboundSchema: z.ZodType<
  SemanticChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ChunkTextChunkingRequestKnowledgeBasesReturnType$inboundSchema
    .default("chunks"),
  strategy: SemanticChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  threshold: z.union([z.number(), Threshold2$inboundSchema]).optional(),
  embedding_model: z.string(),
  mode: Mode$inboundSchema.default("window"),
  similarity_window: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "embedding_model": "embeddingModel",
    "similarity_window": "similarityWindow",
  });
});

/** @internal */
export type SemanticChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  threshold?: number | string | undefined;
  embedding_model: string;
  mode: string;
  similarity_window: number;
};

/** @internal */
export const SemanticChunkerStrategy$outboundSchema: z.ZodType<
  SemanticChunkerStrategy$Outbound,
  z.ZodTypeDef,
  SemanticChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ChunkTextChunkingRequestKnowledgeBasesReturnType$outboundSchema
    .default("chunks"),
  strategy: SemanticChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  threshold: z.union([z.number(), Threshold2$outboundSchema]).optional(),
  embeddingModel: z.string(),
  mode: Mode$outboundSchema.default("window"),
  similarityWindow: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    embeddingModel: "embedding_model",
    similarityWindow: "similarity_window",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SemanticChunkerStrategy$ {
  /** @deprecated use `SemanticChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = SemanticChunkerStrategy$inboundSchema;
  /** @deprecated use `SemanticChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = SemanticChunkerStrategy$outboundSchema;
  /** @deprecated use `SemanticChunkerStrategy$Outbound` instead. */
  export type Outbound = SemanticChunkerStrategy$Outbound;
}

export function semanticChunkerStrategyToJSON(
  semanticChunkerStrategy: SemanticChunkerStrategy,
): string {
  return JSON.stringify(
    SemanticChunkerStrategy$outboundSchema.parse(semanticChunkerStrategy),
  );
}

export function semanticChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<SemanticChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SemanticChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SemanticChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkTextChunkingRequestReturnType$inboundSchema: z.ZodNativeEnum<
  typeof ChunkTextChunkingRequestReturnType
> = z.nativeEnum(ChunkTextChunkingRequestReturnType);

/** @internal */
export const ChunkTextChunkingRequestReturnType$outboundSchema: z.ZodNativeEnum<
  typeof ChunkTextChunkingRequestReturnType
> = ChunkTextChunkingRequestReturnType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextChunkingRequestReturnType$ {
  /** @deprecated use `ChunkTextChunkingRequestReturnType$inboundSchema` instead. */
  export const inboundSchema = ChunkTextChunkingRequestReturnType$inboundSchema;
  /** @deprecated use `ChunkTextChunkingRequestReturnType$outboundSchema` instead. */
  export const outboundSchema =
    ChunkTextChunkingRequestReturnType$outboundSchema;
}

/** @internal */
export const RecursiveChunker$inboundSchema: z.ZodNativeEnum<
  typeof RecursiveChunker
> = z.nativeEnum(RecursiveChunker);

/** @internal */
export const RecursiveChunker$outboundSchema: z.ZodNativeEnum<
  typeof RecursiveChunker
> = RecursiveChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecursiveChunker$ {
  /** @deprecated use `RecursiveChunker$inboundSchema` instead. */
  export const inboundSchema = RecursiveChunker$inboundSchema;
  /** @deprecated use `RecursiveChunker$outboundSchema` instead. */
  export const outboundSchema = RecursiveChunker$outboundSchema;
}

/** @internal */
export const RecursiveChunkerStrategy$inboundSchema: z.ZodType<
  RecursiveChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ChunkTextChunkingRequestReturnType$inboundSchema.default(
    "chunks",
  ),
  strategy: RecursiveChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  separators: z.array(z.string()).optional(),
  min_characters_per_chunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "min_characters_per_chunk": "minCharactersPerChunk",
  });
});

/** @internal */
export type RecursiveChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  separators?: Array<string> | undefined;
  min_characters_per_chunk: number;
};

/** @internal */
export const RecursiveChunkerStrategy$outboundSchema: z.ZodType<
  RecursiveChunkerStrategy$Outbound,
  z.ZodTypeDef,
  RecursiveChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ChunkTextChunkingRequestReturnType$outboundSchema.default(
    "chunks",
  ),
  strategy: RecursiveChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  separators: z.array(z.string()).optional(),
  minCharactersPerChunk: z.number().int().default(24),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    minCharactersPerChunk: "min_characters_per_chunk",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RecursiveChunkerStrategy$ {
  /** @deprecated use `RecursiveChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = RecursiveChunkerStrategy$inboundSchema;
  /** @deprecated use `RecursiveChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = RecursiveChunkerStrategy$outboundSchema;
  /** @deprecated use `RecursiveChunkerStrategy$Outbound` instead. */
  export type Outbound = RecursiveChunkerStrategy$Outbound;
}

export function recursiveChunkerStrategyToJSON(
  recursiveChunkerStrategy: RecursiveChunkerStrategy,
): string {
  return JSON.stringify(
    RecursiveChunkerStrategy$outboundSchema.parse(recursiveChunkerStrategy),
  );
}

export function recursiveChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<RecursiveChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RecursiveChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RecursiveChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkingRequestReturnType$inboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestReturnType
> = z.nativeEnum(ChunkingRequestReturnType);

/** @internal */
export const ChunkingRequestReturnType$outboundSchema: z.ZodNativeEnum<
  typeof ChunkingRequestReturnType
> = ChunkingRequestReturnType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkingRequestReturnType$ {
  /** @deprecated use `ChunkingRequestReturnType$inboundSchema` instead. */
  export const inboundSchema = ChunkingRequestReturnType$inboundSchema;
  /** @deprecated use `ChunkingRequestReturnType$outboundSchema` instead. */
  export const outboundSchema = ChunkingRequestReturnType$outboundSchema;
}

/** @internal */
export const SentenceChunker$inboundSchema: z.ZodNativeEnum<
  typeof SentenceChunker
> = z.nativeEnum(SentenceChunker);

/** @internal */
export const SentenceChunker$outboundSchema: z.ZodNativeEnum<
  typeof SentenceChunker
> = SentenceChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SentenceChunker$ {
  /** @deprecated use `SentenceChunker$inboundSchema` instead. */
  export const inboundSchema = SentenceChunker$inboundSchema;
  /** @deprecated use `SentenceChunker$outboundSchema` instead. */
  export const outboundSchema = SentenceChunker$outboundSchema;
}

/** @internal */
export const SentenceChunkerStrategy$inboundSchema: z.ZodType<
  SentenceChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ChunkingRequestReturnType$inboundSchema.default("chunks"),
  strategy: SentenceChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  chunk_overlap: z.number().int().default(0),
  min_sentences_per_chunk: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "chunk_overlap": "chunkOverlap",
    "min_sentences_per_chunk": "minSentencesPerChunk",
  });
});

/** @internal */
export type SentenceChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  chunk_overlap: number;
  min_sentences_per_chunk: number;
};

/** @internal */
export const SentenceChunkerStrategy$outboundSchema: z.ZodType<
  SentenceChunkerStrategy$Outbound,
  z.ZodTypeDef,
  SentenceChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ChunkingRequestReturnType$outboundSchema.default("chunks"),
  strategy: SentenceChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  chunkOverlap: z.number().int().default(0),
  minSentencesPerChunk: z.number().int().default(1),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    chunkOverlap: "chunk_overlap",
    minSentencesPerChunk: "min_sentences_per_chunk",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SentenceChunkerStrategy$ {
  /** @deprecated use `SentenceChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = SentenceChunkerStrategy$inboundSchema;
  /** @deprecated use `SentenceChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = SentenceChunkerStrategy$outboundSchema;
  /** @deprecated use `SentenceChunkerStrategy$Outbound` instead. */
  export type Outbound = SentenceChunkerStrategy$Outbound;
}

export function sentenceChunkerStrategyToJSON(
  sentenceChunkerStrategy: SentenceChunkerStrategy,
): string {
  return JSON.stringify(
    SentenceChunkerStrategy$outboundSchema.parse(sentenceChunkerStrategy),
  );
}

export function sentenceChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<SentenceChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SentenceChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SentenceChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ReturnTypeT$inboundSchema: z.ZodNativeEnum<typeof ReturnTypeT> = z
  .nativeEnum(ReturnTypeT);

/** @internal */
export const ReturnTypeT$outboundSchema: z.ZodNativeEnum<typeof ReturnTypeT> =
  ReturnTypeT$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ReturnTypeT$ {
  /** @deprecated use `ReturnTypeT$inboundSchema` instead. */
  export const inboundSchema = ReturnTypeT$inboundSchema;
  /** @deprecated use `ReturnTypeT$outboundSchema` instead. */
  export const outboundSchema = ReturnTypeT$outboundSchema;
}

/** @internal */
export const TokenChunker$inboundSchema: z.ZodNativeEnum<typeof TokenChunker> =
  z.nativeEnum(TokenChunker);

/** @internal */
export const TokenChunker$outboundSchema: z.ZodNativeEnum<typeof TokenChunker> =
  TokenChunker$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenChunker$ {
  /** @deprecated use `TokenChunker$inboundSchema` instead. */
  export const inboundSchema = TokenChunker$inboundSchema;
  /** @deprecated use `TokenChunker$outboundSchema` instead. */
  export const outboundSchema = TokenChunker$outboundSchema;
}

/** @internal */
export const TokenChunkerStrategy$inboundSchema: z.ZodType<
  TokenChunkerStrategy,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  return_type: ReturnTypeT$inboundSchema.default("chunks"),
  strategy: TokenChunker$inboundSchema,
  chunk_size: z.number().int().default(512),
  chunk_overlap: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    "return_type": "returnType",
    "chunk_size": "chunkSize",
    "chunk_overlap": "chunkOverlap",
  });
});

/** @internal */
export type TokenChunkerStrategy$Outbound = {
  text: string;
  metadata: boolean;
  return_type: string;
  strategy: string;
  chunk_size: number;
  chunk_overlap: number;
};

/** @internal */
export const TokenChunkerStrategy$outboundSchema: z.ZodType<
  TokenChunkerStrategy$Outbound,
  z.ZodTypeDef,
  TokenChunkerStrategy
> = z.object({
  text: z.string(),
  metadata: z.boolean().default(true),
  returnType: ReturnTypeT$outboundSchema.default("chunks"),
  strategy: TokenChunker$outboundSchema,
  chunkSize: z.number().int().default(512),
  chunkOverlap: z.number().int().default(0),
}).transform((v) => {
  return remap$(v, {
    returnType: "return_type",
    chunkSize: "chunk_size",
    chunkOverlap: "chunk_overlap",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TokenChunkerStrategy$ {
  /** @deprecated use `TokenChunkerStrategy$inboundSchema` instead. */
  export const inboundSchema = TokenChunkerStrategy$inboundSchema;
  /** @deprecated use `TokenChunkerStrategy$outboundSchema` instead. */
  export const outboundSchema = TokenChunkerStrategy$outboundSchema;
  /** @deprecated use `TokenChunkerStrategy$Outbound` instead. */
  export type Outbound = TokenChunkerStrategy$Outbound;
}

export function tokenChunkerStrategyToJSON(
  tokenChunkerStrategy: TokenChunkerStrategy,
): string {
  return JSON.stringify(
    TokenChunkerStrategy$outboundSchema.parse(tokenChunkerStrategy),
  );
}

export function tokenChunkerStrategyFromJSON(
  jsonString: string,
): SafeParseResult<TokenChunkerStrategy, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TokenChunkerStrategy$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TokenChunkerStrategy' from JSON`,
  );
}

/** @internal */
export const ChunkTextChunkingRequest$inboundSchema: z.ZodType<
  ChunkTextChunkingRequest,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => SemanticChunkerStrategy$inboundSchema),
  z.lazy(() => SDPMChunkerStrategy$inboundSchema),
  z.lazy(() => AgenticChunkerStrategy$inboundSchema),
  z.lazy(() => TokenChunkerStrategy$inboundSchema),
  z.lazy(() => SentenceChunkerStrategy$inboundSchema),
  z.lazy(() => RecursiveChunkerStrategy$inboundSchema),
]);

/** @internal */
export type ChunkTextChunkingRequest$Outbound =
  | SemanticChunkerStrategy$Outbound
  | SDPMChunkerStrategy$Outbound
  | AgenticChunkerStrategy$Outbound
  | TokenChunkerStrategy$Outbound
  | SentenceChunkerStrategy$Outbound
  | RecursiveChunkerStrategy$Outbound;

/** @internal */
export const ChunkTextChunkingRequest$outboundSchema: z.ZodType<
  ChunkTextChunkingRequest$Outbound,
  z.ZodTypeDef,
  ChunkTextChunkingRequest
> = z.union([
  z.lazy(() => SemanticChunkerStrategy$outboundSchema),
  z.lazy(() => SDPMChunkerStrategy$outboundSchema),
  z.lazy(() => AgenticChunkerStrategy$outboundSchema),
  z.lazy(() => TokenChunkerStrategy$outboundSchema),
  z.lazy(() => SentenceChunkerStrategy$outboundSchema),
  z.lazy(() => RecursiveChunkerStrategy$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextChunkingRequest$ {
  /** @deprecated use `ChunkTextChunkingRequest$inboundSchema` instead. */
  export const inboundSchema = ChunkTextChunkingRequest$inboundSchema;
  /** @deprecated use `ChunkTextChunkingRequest$outboundSchema` instead. */
  export const outboundSchema = ChunkTextChunkingRequest$outboundSchema;
  /** @deprecated use `ChunkTextChunkingRequest$Outbound` instead. */
  export type Outbound = ChunkTextChunkingRequest$Outbound;
}

export function chunkTextChunkingRequestToJSON(
  chunkTextChunkingRequest: ChunkTextChunkingRequest,
): string {
  return JSON.stringify(
    ChunkTextChunkingRequest$outboundSchema.parse(chunkTextChunkingRequest),
  );
}

export function chunkTextChunkingRequestFromJSON(
  jsonString: string,
): SafeParseResult<ChunkTextChunkingRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChunkTextChunkingRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChunkTextChunkingRequest' from JSON`,
  );
}

/** @internal */
export const ChunkTextMetadata$inboundSchema: z.ZodType<
  ChunkTextMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  start_index: z.nullable(z.number()),
  end_index: z.nullable(z.number()),
  token_count: z.nullable(z.number()),
}).transform((v) => {
  return remap$(v, {
    "start_index": "startIndex",
    "end_index": "endIndex",
    "token_count": "tokenCount",
  });
});

/** @internal */
export type ChunkTextMetadata$Outbound = {
  start_index: number | null;
  end_index: number | null;
  token_count: number | null;
};

/** @internal */
export const ChunkTextMetadata$outboundSchema: z.ZodType<
  ChunkTextMetadata$Outbound,
  z.ZodTypeDef,
  ChunkTextMetadata
> = z.object({
  startIndex: z.nullable(z.number()),
  endIndex: z.nullable(z.number()),
  tokenCount: z.nullable(z.number()),
}).transform((v) => {
  return remap$(v, {
    startIndex: "start_index",
    endIndex: "end_index",
    tokenCount: "token_count",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextMetadata$ {
  /** @deprecated use `ChunkTextMetadata$inboundSchema` instead. */
  export const inboundSchema = ChunkTextMetadata$inboundSchema;
  /** @deprecated use `ChunkTextMetadata$outboundSchema` instead. */
  export const outboundSchema = ChunkTextMetadata$outboundSchema;
  /** @deprecated use `ChunkTextMetadata$Outbound` instead. */
  export type Outbound = ChunkTextMetadata$Outbound;
}

export function chunkTextMetadataToJSON(
  chunkTextMetadata: ChunkTextMetadata,
): string {
  return JSON.stringify(
    ChunkTextMetadata$outboundSchema.parse(chunkTextMetadata),
  );
}

export function chunkTextMetadataFromJSON(
  jsonString: string,
): SafeParseResult<ChunkTextMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChunkTextMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChunkTextMetadata' from JSON`,
  );
}

/** @internal */
export const Chunks$inboundSchema: z.ZodType<Chunks, z.ZodTypeDef, unknown> = z
  .object({
    text: z.string(),
    index: z.number(),
    metadata: z.lazy(() => ChunkTextMetadata$inboundSchema).optional(),
  });

/** @internal */
export type Chunks$Outbound = {
  text: string;
  index: number;
  metadata?: ChunkTextMetadata$Outbound | undefined;
};

/** @internal */
export const Chunks$outboundSchema: z.ZodType<
  Chunks$Outbound,
  z.ZodTypeDef,
  Chunks
> = z.object({
  text: z.string(),
  index: z.number(),
  metadata: z.lazy(() => ChunkTextMetadata$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Chunks$ {
  /** @deprecated use `Chunks$inboundSchema` instead. */
  export const inboundSchema = Chunks$inboundSchema;
  /** @deprecated use `Chunks$outboundSchema` instead. */
  export const outboundSchema = Chunks$outboundSchema;
  /** @deprecated use `Chunks$Outbound` instead. */
  export type Outbound = Chunks$Outbound;
}

export function chunksToJSON(chunks: Chunks): string {
  return JSON.stringify(Chunks$outboundSchema.parse(chunks));
}

export function chunksFromJSON(
  jsonString: string,
): SafeParseResult<Chunks, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Chunks$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Chunks' from JSON`,
  );
}

/** @internal */
export const ChunkTextResponseBody$inboundSchema: z.ZodType<
  ChunkTextResponseBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  chunks: z.array(z.lazy(() => Chunks$inboundSchema)),
});

/** @internal */
export type ChunkTextResponseBody$Outbound = {
  chunks: Array<Chunks$Outbound>;
};

/** @internal */
export const ChunkTextResponseBody$outboundSchema: z.ZodType<
  ChunkTextResponseBody$Outbound,
  z.ZodTypeDef,
  ChunkTextResponseBody
> = z.object({
  chunks: z.array(z.lazy(() => Chunks$outboundSchema)),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ChunkTextResponseBody$ {
  /** @deprecated use `ChunkTextResponseBody$inboundSchema` instead. */
  export const inboundSchema = ChunkTextResponseBody$inboundSchema;
  /** @deprecated use `ChunkTextResponseBody$outboundSchema` instead. */
  export const outboundSchema = ChunkTextResponseBody$outboundSchema;
  /** @deprecated use `ChunkTextResponseBody$Outbound` instead. */
  export type Outbound = ChunkTextResponseBody$Outbound;
}

export function chunkTextResponseBodyToJSON(
  chunkTextResponseBody: ChunkTextResponseBody,
): string {
  return JSON.stringify(
    ChunkTextResponseBody$outboundSchema.parse(chunkTextResponseBody),
  );
}

export function chunkTextResponseBodyFromJSON(
  jsonString: string,
): SafeParseResult<ChunkTextResponseBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ChunkTextResponseBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ChunkTextResponseBody' from JSON`,
  );
}
