/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { ClosedEnum } from "../../types/enums.js";
import {
  AudioContentPartSchema,
  AudioContentPartSchema$Outbound,
  AudioContentPartSchema$outboundSchema,
} from "./audiocontentpartschema.js";
import {
  FileContentPartSchema,
  FileContentPartSchema$Outbound,
  FileContentPartSchema$outboundSchema,
} from "./filecontentpartschema.js";
import {
  ImageContentPartSchema,
  ImageContentPartSchema$Outbound,
  ImageContentPartSchema$outboundSchema,
} from "./imagecontentpartschema.js";
import {
  ReasoningPartSchema,
  ReasoningPartSchema$Outbound,
  ReasoningPartSchema$outboundSchema,
} from "./reasoningpartschema.js";
import {
  RedactedReasoningPartSchema,
  RedactedReasoningPartSchema$Outbound,
  RedactedReasoningPartSchema$outboundSchema,
} from "./redactedreasoningpartschema.js";
import {
  RefusalPartSchema,
  RefusalPartSchema$Outbound,
  RefusalPartSchema$outboundSchema,
} from "./refusalpartschema.js";
import {
  TextContentPartSchema,
  TextContentPartSchema$Outbound,
  TextContentPartSchema$outboundSchema,
} from "./textcontentpartschema.js";

export type InvokeDeploymentRequestContent2 = TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type InvokeDeploymentRequestPrefixMessages5Content =
  | string
  | Array<TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const InvokeDeploymentRequestPrefixMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type InvokeDeploymentRequestPrefixMessagesType = ClosedEnum<
  typeof InvokeDeploymentRequestPrefixMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const PrefixMessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type PrefixMessagesTtl = ClosedEnum<typeof PrefixMessagesTtl>;

export type PrefixMessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: InvokeDeploymentRequestPrefixMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: PrefixMessagesTtl | undefined;
};

export type ToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: PrefixMessagesCacheControl | undefined;
};

export type Content2 =
  | (TextContentPartSchema & { type: "text" })
  | RefusalPartSchema
  | ReasoningPartSchema
  | RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type InvokeDeploymentRequestPrefixMessages4Content =
  | string
  | Array<
    | (TextContentPartSchema & { type: "text" })
    | RefusalPartSchema
    | ReasoningPartSchema
    | RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type Audio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const PrefixMessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type PrefixMessagesType = ClosedEnum<typeof PrefixMessagesType>;

export type PrefixMessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type ToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: PrefixMessagesType;
  function: PrefixMessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type AssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (TextContentPartSchema & { type: "text" })
      | RefusalPartSchema
      | ReasoningPartSchema
      | RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: Audio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<ToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const InvokeDeploymentRequest2PrefixMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type InvokeDeploymentRequest2PrefixMessagesType = ClosedEnum<
  typeof InvokeDeploymentRequest2PrefixMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const TwoTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type TwoTtl = ClosedEnum<typeof TwoTtl>;

export type TwoCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: InvokeDeploymentRequest2PrefixMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: TwoTtl | undefined;
};

export type Four = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: TwoCacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: FileContentPartSchema;
};

export type Two =
  | (TextContentPartSchema & { type: "text" })
  | ImageContentPartSchema
  | AudioContentPartSchema
  | Four;

/**
 * The contents of the user message.
 */
export type InvokeDeploymentRequestPrefixMessagesContent =
  | string
  | Array<
    | (TextContentPartSchema & { type: "text" })
    | ImageContentPartSchema
    | AudioContentPartSchema
    | Four
  >;

export type UserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (TextContentPartSchema & { type: "text" })
      | ImageContentPartSchema
      | AudioContentPartSchema
      | Four
    >;
};

/**
 * The contents of the developer message.
 */
export type PrefixMessagesContent = string | Array<TextContentPartSchema>;

export type DeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type Content = string | Array<TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type SystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type PrefixMessages =
  | SystemMessage
  | DeveloperMessage
  | UserMessage
  | AssistantMessage
  | ToolMessage;

export type InvokeDeploymentRequestContentMessages52 = TextContentPartSchema;

/**
 * The contents of the tool message.
 */
export type InvokeDeploymentRequestMessages5Content =
  | string
  | Array<TextContentPartSchema>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const InvokeDeploymentRequestMessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type InvokeDeploymentRequestMessagesType = ClosedEnum<
  typeof InvokeDeploymentRequestMessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const MessagesTtl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type MessagesTtl = ClosedEnum<typeof MessagesTtl>;

export type MessagesCacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: InvokeDeploymentRequestMessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: MessagesTtl | undefined;
};

export type MessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: "tool";
  /**
   * The contents of the tool message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string | null;
  cacheControl?: MessagesCacheControl | undefined;
};

export type InvokeDeploymentRequestContentMessages42 =
  | (TextContentPartSchema & { type: "text" })
  | RefusalPartSchema
  | ReasoningPartSchema
  | RedactedReasoningPartSchema;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type InvokeDeploymentRequestMessages4Content =
  | string
  | Array<
    | (TextContentPartSchema & { type: "text" })
    | RefusalPartSchema
    | ReasoningPartSchema
    | RedactedReasoningPartSchema
  >;

/**
 * Data about a previous audio response from the model.
 */
export type MessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const MessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type MessagesType = ClosedEnum<typeof MessagesType>;

export type MessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type MessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: MessagesType;
  function: MessagesFunction;
  /**
   * Encrypted representation of the model internal reasoning state during function calling. Required by Gemini 3 models when continuing a conversation after a tool call.
   */
  thoughtSignature?: string | undefined;
};

export type MessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<
      | (TextContentPartSchema & { type: "text" })
      | RefusalPartSchema
      | ReasoningPartSchema
      | RedactedReasoningPartSchema
    >
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: "assistant";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: MessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<MessagesToolCalls> | undefined;
};

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const InvokeDeploymentRequest2MessagesType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type InvokeDeploymentRequest2MessagesType = ClosedEnum<
  typeof InvokeDeploymentRequest2MessagesType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const InvokeDeploymentRequest2Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type InvokeDeploymentRequest2Ttl = ClosedEnum<
  typeof InvokeDeploymentRequest2Ttl
>;

export type InvokeDeploymentRequest2CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: InvokeDeploymentRequest2MessagesType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: InvokeDeploymentRequest2Ttl | undefined;
};

export type Two4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: "file";
  cacheControl?: InvokeDeploymentRequest2CacheControl | undefined;
  /**
   * File data for the content part. Must contain either file_data or uri, but not both.
   */
  file: FileContentPartSchema;
};

export type InvokeDeploymentRequestContentMessages2 =
  | (TextContentPartSchema & { type: "text" })
  | ImageContentPartSchema
  | AudioContentPartSchema
  | Two4;

/**
 * The contents of the user message.
 */
export type InvokeDeploymentRequestMessages3Content =
  | string
  | Array<
    | (TextContentPartSchema & { type: "text" })
    | ImageContentPartSchema
    | AudioContentPartSchema
    | Two4
  >;

export type MessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: "user";
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content:
    | string
    | Array<
      | (TextContentPartSchema & { type: "text" })
      | ImageContentPartSchema
      | AudioContentPartSchema
      | Two4
    >;
};

/**
 * The contents of the developer message.
 */
export type InvokeDeploymentRequestMessagesContent =
  | string
  | Array<TextContentPartSchema>;

export type MessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: "developer";
  /**
   * The contents of the developer message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The contents of the system message.
 */
export type MessagesContent = string | Array<TextContentPartSchema>;

/**
 * Developer-provided instructions that the model should follow, regardless of messages sent by the user.
 */
export type MessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: "system";
  /**
   * The contents of the system message.
   */
  content: string | Array<TextContentPartSchema>;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type Messages =
  | MessagesSystemMessage
  | MessagesDeveloperMessage
  | MessagesUserMessage
  | MessagesAssistantMessage
  | MessagesToolMessage;

/**
 * Metadata about the document
 */
export type InvokeDeploymentRequestMetadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: InvokeDeploymentRequestMetadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
  /**
   * Whether to include the usage metrics in the response.
   */
  includeUsage?: boolean | undefined;
  /**
   * A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage.
   */
  mockResponse?: string | undefined;
};

export type Thread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Exists
 */
export type OrExists = {
  exists: boolean;
};

export type OrNin = string | number | boolean;

/**
 * Not in
 */
export type InvokeDeploymentRequestOrNin = {
  nin: Array<string | number | boolean>;
};

export type OrIn = string | number | boolean;

/**
 * In
 */
export type InvokeDeploymentRequestOrIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type OrLte = {
  lte: number;
};

/**
 * Less than
 */
export type OrLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type OrGte = {
  gte: number;
};

/**
 * Greater than
 */
export type OrGt = {
  gt: number;
};

export type OrNe = string | number | boolean;

/**
 * Not equal to
 */
export type InvokeDeploymentRequestOrNe = {
  ne: string | number | boolean;
};

export type OrEq = string | number | boolean;

/**
 * Equal to
 */
export type InvokeDeploymentRequestOrEq = {
  eq: string | number | boolean;
};

export type Or =
  | InvokeDeploymentRequestOrEq
  | InvokeDeploymentRequestOrNe
  | OrGt
  | OrGte
  | OrLt
  | OrLte
  | InvokeDeploymentRequestOrIn
  | InvokeDeploymentRequestOrNin
  | OrExists;

/**
 * Or
 */
export type KnowledgeFilterOr = {
  or: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestOrEq
        | InvokeDeploymentRequestOrNe
        | OrGt
        | OrGte
        | OrLt
        | OrLte
        | InvokeDeploymentRequestOrIn
        | InvokeDeploymentRequestOrNin
        | OrExists;
    }
  >;
};

/**
 * Exists
 */
export type AndExists = {
  exists: boolean;
};

export type AndNin = string | number | boolean;

/**
 * Not in
 */
export type InvokeDeploymentRequestAndNin = {
  nin: Array<string | number | boolean>;
};

export type AndIn = string | number | boolean;

/**
 * In
 */
export type InvokeDeploymentRequestAndIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type AndLte = {
  lte: number;
};

/**
 * Less than
 */
export type AndLt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type AndGte = {
  gte: number;
};

/**
 * Greater than
 */
export type AndGt = {
  gt: number;
};

export type AndNe = string | number | boolean;

/**
 * Not equal to
 */
export type InvokeDeploymentRequestAndNe = {
  ne: string | number | boolean;
};

export type AndEq = string | number | boolean;

/**
 * Equal to
 */
export type InvokeDeploymentRequestAndEq = {
  eq: string | number | boolean;
};

export type And =
  | InvokeDeploymentRequestAndEq
  | InvokeDeploymentRequestAndNe
  | AndGt
  | AndGte
  | AndLt
  | AndLte
  | InvokeDeploymentRequestAndIn
  | InvokeDeploymentRequestAndNin
  | AndExists;

/**
 * And
 */
export type KnowledgeFilterAnd = {
  and: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestAndEq
        | InvokeDeploymentRequestAndNe
        | AndGt
        | AndGte
        | AndLt
        | AndLte
        | InvokeDeploymentRequestAndIn
        | InvokeDeploymentRequestAndNin
        | AndExists;
    }
  >;
};

/**
 * Exists
 */
export type Exists = {
  exists: boolean;
};

export type Nin = string | number | boolean;

/**
 * Not in
 */
export type OneNin = {
  nin: Array<string | number | boolean>;
};

export type In = string | number | boolean;

/**
 * In
 */
export type OneIn = {
  in: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type Lte = {
  lte: number;
};

/**
 * Less than
 */
export type Lt = {
  lt: number;
};

/**
 * Greater than or equal to
 */
export type Gte = {
  gte: number;
};

/**
 * Greater than
 */
export type Gt = {
  gt: number;
};

export type Ne = string | number | boolean;

/**
 * Not equal to
 */
export type OneNe = {
  ne: string | number | boolean;
};

export type Eq = string | number | boolean;

/**
 * Equal to
 */
export type OneEq = {
  eq: string | number | boolean;
};

export type One = OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;

/**
 * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
 */
export type KnowledgeFilter = KnowledgeFilterAnd | KnowledgeFilterOr | {
  [k: string]: OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;
};

/**
 * The deployment request payload
 */
export type InvokeDeploymentRequest = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * If set, partial message content will be sent. Tokens will be sent as data-only `server-sent events` as they become available, with the stream terminated by a `data: [DONE]` message.
   */
  stream?: boolean | undefined;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: any } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your deployment routing configuration
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?:
    | Array<
      | SystemMessage
      | DeveloperMessage
      | UserMessage
      | AssistantMessage
      | ToolMessage
    >
    | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?:
    | Array<
      | MessagesSystemMessage
      | MessagesDeveloperMessage
      | MessagesUserMessage
      | MessagesAssistantMessage
      | MessagesToolMessage
    >
    | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of documents from your external knowledge base (e.g., chunks retrieved from your own vector database or RAG pipeline) that provide context for the model response. These documents can be used by evaluators and guardrails to assess the relevance and accuracy of the model output against the provided context.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
  thread?: Thread | undefined;
  /**
   * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
   */
  knowledgeFilter?: KnowledgeFilterAnd | KnowledgeFilterOr | {
    [k: string]: OneEq | OneNe | Gt | Gte | Lt | Lte | OneIn | OneNin | Exists;
  } | undefined;
};

/** @internal */
export type InvokeDeploymentRequestContent2$Outbound =
  TextContentPartSchema$Outbound;

/** @internal */
export const InvokeDeploymentRequestContent2$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContent2$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContent2
> = TextContentPartSchema$outboundSchema;

export function invokeDeploymentRequestContent2ToJSON(
  invokeDeploymentRequestContent2: InvokeDeploymentRequestContent2,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContent2$outboundSchema.parse(
      invokeDeploymentRequestContent2,
    ),
  );
}

/** @internal */
export type InvokeDeploymentRequestPrefixMessages5Content$Outbound =
  | string
  | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const InvokeDeploymentRequestPrefixMessages5Content$outboundSchema:
  z.ZodType<
    InvokeDeploymentRequestPrefixMessages5Content$Outbound,
    z.ZodTypeDef,
    InvokeDeploymentRequestPrefixMessages5Content
  > = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function invokeDeploymentRequestPrefixMessages5ContentToJSON(
  invokeDeploymentRequestPrefixMessages5Content:
    InvokeDeploymentRequestPrefixMessages5Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestPrefixMessages5Content$outboundSchema.parse(
      invokeDeploymentRequestPrefixMessages5Content,
    ),
  );
}

/** @internal */
export const InvokeDeploymentRequestPrefixMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestPrefixMessagesType> = z
    .nativeEnum(InvokeDeploymentRequestPrefixMessagesType);

/** @internal */
export const PrefixMessagesTtl$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesTtl
> = z.nativeEnum(PrefixMessagesTtl);

/** @internal */
export type PrefixMessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const PrefixMessagesCacheControl$outboundSchema: z.ZodType<
  PrefixMessagesCacheControl$Outbound,
  z.ZodTypeDef,
  PrefixMessagesCacheControl
> = z.object({
  type: InvokeDeploymentRequestPrefixMessagesType$outboundSchema,
  ttl: PrefixMessagesTtl$outboundSchema.default("5m"),
});

export function prefixMessagesCacheControlToJSON(
  prefixMessagesCacheControl: PrefixMessagesCacheControl,
): string {
  return JSON.stringify(
    PrefixMessagesCacheControl$outboundSchema.parse(prefixMessagesCacheControl),
  );
}

/** @internal */
export type ToolMessage$Outbound = {
  role: "tool";
  content: string | Array<TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: PrefixMessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const ToolMessage$outboundSchema: z.ZodType<
  ToolMessage$Outbound,
  z.ZodTypeDef,
  ToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() => PrefixMessagesCacheControl$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function toolMessageToJSON(toolMessage: ToolMessage): string {
  return JSON.stringify(ToolMessage$outboundSchema.parse(toolMessage));
}

/** @internal */
export type Content2$Outbound =
  | (TextContentPartSchema$Outbound & { type: "text" })
  | RefusalPartSchema$Outbound
  | ReasoningPartSchema$Outbound
  | RedactedReasoningPartSchema$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  RefusalPartSchema$outboundSchema,
  ReasoningPartSchema$outboundSchema,
  RedactedReasoningPartSchema$outboundSchema,
]);

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}

/** @internal */
export type InvokeDeploymentRequestPrefixMessages4Content$Outbound =
  | string
  | Array<
    | (TextContentPartSchema$Outbound & { type: "text" })
    | RefusalPartSchema$Outbound
    | ReasoningPartSchema$Outbound
    | RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const InvokeDeploymentRequestPrefixMessages4Content$outboundSchema:
  z.ZodType<
    InvokeDeploymentRequestPrefixMessages4Content$Outbound,
    z.ZodTypeDef,
    InvokeDeploymentRequestPrefixMessages4Content
  > = z.union([
    z.string(),
    z.array(
      z.union([
        TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        RefusalPartSchema$outboundSchema,
        ReasoningPartSchema$outboundSchema,
        RedactedReasoningPartSchema$outboundSchema,
      ]),
    ),
  ]);

export function invokeDeploymentRequestPrefixMessages4ContentToJSON(
  invokeDeploymentRequestPrefixMessages4Content:
    InvokeDeploymentRequestPrefixMessages4Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestPrefixMessages4Content$outboundSchema.parse(
      invokeDeploymentRequestPrefixMessages4Content,
    ),
  );
}

/** @internal */
export type Audio$Outbound = {
  id: string;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
});

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}

/** @internal */
export const PrefixMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesType
> = z.nativeEnum(PrefixMessagesType);

/** @internal */
export type PrefixMessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const PrefixMessagesFunction$outboundSchema: z.ZodType<
  PrefixMessagesFunction$Outbound,
  z.ZodTypeDef,
  PrefixMessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function prefixMessagesFunctionToJSON(
  prefixMessagesFunction: PrefixMessagesFunction,
): string {
  return JSON.stringify(
    PrefixMessagesFunction$outboundSchema.parse(prefixMessagesFunction),
  );
}

/** @internal */
export type ToolCalls$Outbound = {
  id: string;
  type: string;
  function: PrefixMessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const ToolCalls$outboundSchema: z.ZodType<
  ToolCalls$Outbound,
  z.ZodTypeDef,
  ToolCalls
> = z.object({
  id: z.string(),
  type: PrefixMessagesType$outboundSchema,
  function: z.lazy(() => PrefixMessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function toolCallsToJSON(toolCalls: ToolCalls): string {
  return JSON.stringify(ToolCalls$outboundSchema.parse(toolCalls));
}

/** @internal */
export type AssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (TextContentPartSchema$Outbound & { type: "text" })
      | RefusalPartSchema$Outbound
      | ReasoningPartSchema$Outbound
      | RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: Audio$Outbound | null | undefined;
  tool_calls?: Array<ToolCalls$Outbound> | undefined;
};

/** @internal */
export const AssistantMessage$outboundSchema: z.ZodType<
  AssistantMessage$Outbound,
  z.ZodTypeDef,
  AssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          RefusalPartSchema$outboundSchema,
          ReasoningPartSchema$outboundSchema,
          RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => ToolCalls$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function assistantMessageToJSON(
  assistantMessage: AssistantMessage,
): string {
  return JSON.stringify(
    AssistantMessage$outboundSchema.parse(assistantMessage),
  );
}

/** @internal */
export const InvokeDeploymentRequest2PrefixMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2PrefixMessagesType> = z
    .nativeEnum(InvokeDeploymentRequest2PrefixMessagesType);

/** @internal */
export const TwoTtl$outboundSchema: z.ZodNativeEnum<typeof TwoTtl> = z
  .nativeEnum(TwoTtl);

/** @internal */
export type TwoCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const TwoCacheControl$outboundSchema: z.ZodType<
  TwoCacheControl$Outbound,
  z.ZodTypeDef,
  TwoCacheControl
> = z.object({
  type: InvokeDeploymentRequest2PrefixMessagesType$outboundSchema,
  ttl: TwoTtl$outboundSchema.default("5m"),
});

export function twoCacheControlToJSON(
  twoCacheControl: TwoCacheControl,
): string {
  return JSON.stringify(TwoCacheControl$outboundSchema.parse(twoCacheControl));
}

/** @internal */
export type Four$Outbound = {
  type: "file";
  cache_control?: TwoCacheControl$Outbound | undefined;
  file: FileContentPartSchema$Outbound;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() => TwoCacheControl$outboundSchema).optional(),
    file: FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

/** @internal */
export type Two$Outbound =
  | (TextContentPartSchema$Outbound & { type: "text" })
  | ImageContentPartSchema$Outbound
  | AudioContentPartSchema$Outbound
  | Four$Outbound;

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .union([
    TextContentPartSchema$outboundSchema.and(
      z.object({ type: z.literal("text") }),
    ),
    ImageContentPartSchema$outboundSchema,
    AudioContentPartSchema$outboundSchema,
    z.lazy(() => Four$outboundSchema),
  ]);

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

/** @internal */
export type InvokeDeploymentRequestPrefixMessagesContent$Outbound =
  | string
  | Array<
    | (TextContentPartSchema$Outbound & { type: "text" })
    | ImageContentPartSchema$Outbound
    | AudioContentPartSchema$Outbound
    | Four$Outbound
  >;

/** @internal */
export const InvokeDeploymentRequestPrefixMessagesContent$outboundSchema:
  z.ZodType<
    InvokeDeploymentRequestPrefixMessagesContent$Outbound,
    z.ZodTypeDef,
    InvokeDeploymentRequestPrefixMessagesContent
  > = z.union([
    z.string(),
    z.array(
      z.union([
        TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        ImageContentPartSchema$outboundSchema,
        AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]);

export function invokeDeploymentRequestPrefixMessagesContentToJSON(
  invokeDeploymentRequestPrefixMessagesContent:
    InvokeDeploymentRequestPrefixMessagesContent,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestPrefixMessagesContent$outboundSchema.parse(
      invokeDeploymentRequestPrefixMessagesContent,
    ),
  );
}

/** @internal */
export type UserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (TextContentPartSchema$Outbound & { type: "text" })
      | ImageContentPartSchema$Outbound
      | AudioContentPartSchema$Outbound
      | Four$Outbound
    >;
};

/** @internal */
export const UserMessage$outboundSchema: z.ZodType<
  UserMessage$Outbound,
  z.ZodTypeDef,
  UserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        ImageContentPartSchema$outboundSchema,
        AudioContentPartSchema$outboundSchema,
        z.lazy(() => Four$outboundSchema),
      ]),
    ),
  ]),
});

export function userMessageToJSON(userMessage: UserMessage): string {
  return JSON.stringify(UserMessage$outboundSchema.parse(userMessage));
}

/** @internal */
export type PrefixMessagesContent$Outbound =
  | string
  | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const PrefixMessagesContent$outboundSchema: z.ZodType<
  PrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  PrefixMessagesContent
> = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function prefixMessagesContentToJSON(
  prefixMessagesContent: PrefixMessagesContent,
): string {
  return JSON.stringify(
    PrefixMessagesContent$outboundSchema.parse(prefixMessagesContent),
  );
}

/** @internal */
export type DeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const DeveloperMessage$outboundSchema: z.ZodType<
  DeveloperMessage$Outbound,
  z.ZodTypeDef,
  DeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  name: z.string().optional(),
});

export function developerMessageToJSON(
  developerMessage: DeveloperMessage,
): string {
  return JSON.stringify(
    DeveloperMessage$outboundSchema.parse(developerMessage),
  );
}

/** @internal */
export type Content$Outbound = string | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

/** @internal */
export type SystemMessage$Outbound = {
  role: "system";
  content: string | Array<TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const SystemMessage$outboundSchema: z.ZodType<
  SystemMessage$Outbound,
  z.ZodTypeDef,
  SystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  name: z.string().optional(),
});

export function systemMessageToJSON(systemMessage: SystemMessage): string {
  return JSON.stringify(SystemMessage$outboundSchema.parse(systemMessage));
}

/** @internal */
export type PrefixMessages$Outbound =
  | SystemMessage$Outbound
  | DeveloperMessage$Outbound
  | UserMessage$Outbound
  | AssistantMessage$Outbound
  | ToolMessage$Outbound;

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.union([
  z.lazy(() => SystemMessage$outboundSchema),
  z.lazy(() => DeveloperMessage$outboundSchema),
  z.lazy(() => UserMessage$outboundSchema),
  z.lazy(() => AssistantMessage$outboundSchema),
  z.lazy(() => ToolMessage$outboundSchema),
]);

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}

/** @internal */
export type InvokeDeploymentRequestContentMessages52$Outbound =
  TextContentPartSchema$Outbound;

/** @internal */
export const InvokeDeploymentRequestContentMessages52$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContentMessages52$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContentMessages52
> = TextContentPartSchema$outboundSchema;

export function invokeDeploymentRequestContentMessages52ToJSON(
  invokeDeploymentRequestContentMessages52:
    InvokeDeploymentRequestContentMessages52,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContentMessages52$outboundSchema.parse(
      invokeDeploymentRequestContentMessages52,
    ),
  );
}

/** @internal */
export type InvokeDeploymentRequestMessages5Content$Outbound =
  | string
  | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const InvokeDeploymentRequestMessages5Content$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessages5Content$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessages5Content
> = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function invokeDeploymentRequestMessages5ContentToJSON(
  invokeDeploymentRequestMessages5Content:
    InvokeDeploymentRequestMessages5Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessages5Content$outboundSchema.parse(
      invokeDeploymentRequestMessages5Content,
    ),
  );
}

/** @internal */
export const InvokeDeploymentRequestMessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequestMessagesType> = z.nativeEnum(
    InvokeDeploymentRequestMessagesType,
  );

/** @internal */
export const MessagesTtl$outboundSchema: z.ZodNativeEnum<typeof MessagesTtl> = z
  .nativeEnum(MessagesTtl);

/** @internal */
export type MessagesCacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const MessagesCacheControl$outboundSchema: z.ZodType<
  MessagesCacheControl$Outbound,
  z.ZodTypeDef,
  MessagesCacheControl
> = z.object({
  type: InvokeDeploymentRequestMessagesType$outboundSchema,
  ttl: MessagesTtl$outboundSchema.default("5m"),
});

export function messagesCacheControlToJSON(
  messagesCacheControl: MessagesCacheControl,
): string {
  return JSON.stringify(
    MessagesCacheControl$outboundSchema.parse(messagesCacheControl),
  );
}

/** @internal */
export type MessagesToolMessage$Outbound = {
  role: "tool";
  content: string | Array<TextContentPartSchema$Outbound>;
  tool_call_id: string | null;
  cache_control?: MessagesCacheControl$Outbound | undefined;
};

/** @internal */
export const MessagesToolMessage$outboundSchema: z.ZodType<
  MessagesToolMessage$Outbound,
  z.ZodTypeDef,
  MessagesToolMessage
> = z.object({
  role: z.literal("tool"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  toolCallId: z.nullable(z.string()),
  cacheControl: z.lazy(() => MessagesCacheControl$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
    cacheControl: "cache_control",
  });
});

export function messagesToolMessageToJSON(
  messagesToolMessage: MessagesToolMessage,
): string {
  return JSON.stringify(
    MessagesToolMessage$outboundSchema.parse(messagesToolMessage),
  );
}

/** @internal */
export type InvokeDeploymentRequestContentMessages42$Outbound =
  | (TextContentPartSchema$Outbound & { type: "text" })
  | RefusalPartSchema$Outbound
  | ReasoningPartSchema$Outbound
  | RedactedReasoningPartSchema$Outbound;

/** @internal */
export const InvokeDeploymentRequestContentMessages42$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContentMessages42$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContentMessages42
> = z.union([
  TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  RefusalPartSchema$outboundSchema,
  ReasoningPartSchema$outboundSchema,
  RedactedReasoningPartSchema$outboundSchema,
]);

export function invokeDeploymentRequestContentMessages42ToJSON(
  invokeDeploymentRequestContentMessages42:
    InvokeDeploymentRequestContentMessages42,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContentMessages42$outboundSchema.parse(
      invokeDeploymentRequestContentMessages42,
    ),
  );
}

/** @internal */
export type InvokeDeploymentRequestMessages4Content$Outbound =
  | string
  | Array<
    | (TextContentPartSchema$Outbound & { type: "text" })
    | RefusalPartSchema$Outbound
    | ReasoningPartSchema$Outbound
    | RedactedReasoningPartSchema$Outbound
  >;

/** @internal */
export const InvokeDeploymentRequestMessages4Content$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessages4Content$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessages4Content
> = z.union([
  z.string(),
  z.array(
    z.union([
      TextContentPartSchema$outboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      RefusalPartSchema$outboundSchema,
      ReasoningPartSchema$outboundSchema,
      RedactedReasoningPartSchema$outboundSchema,
    ]),
  ),
]);

export function invokeDeploymentRequestMessages4ContentToJSON(
  invokeDeploymentRequestMessages4Content:
    InvokeDeploymentRequestMessages4Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessages4Content$outboundSchema.parse(
      invokeDeploymentRequestMessages4Content,
    ),
  );
}

/** @internal */
export type MessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const MessagesAudio$outboundSchema: z.ZodType<
  MessagesAudio$Outbound,
  z.ZodTypeDef,
  MessagesAudio
> = z.object({
  id: z.string(),
});

export function messagesAudioToJSON(messagesAudio: MessagesAudio): string {
  return JSON.stringify(MessagesAudio$outboundSchema.parse(messagesAudio));
}

/** @internal */
export const MessagesType$outboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  z.nativeEnum(MessagesType);

/** @internal */
export type MessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const MessagesFunction$outboundSchema: z.ZodType<
  MessagesFunction$Outbound,
  z.ZodTypeDef,
  MessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function messagesFunctionToJSON(
  messagesFunction: MessagesFunction,
): string {
  return JSON.stringify(
    MessagesFunction$outboundSchema.parse(messagesFunction),
  );
}

/** @internal */
export type MessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: MessagesFunction$Outbound;
  thought_signature?: string | undefined;
};

/** @internal */
export const MessagesToolCalls$outboundSchema: z.ZodType<
  MessagesToolCalls$Outbound,
  z.ZodTypeDef,
  MessagesToolCalls
> = z.object({
  id: z.string(),
  type: MessagesType$outboundSchema,
  function: z.lazy(() => MessagesFunction$outboundSchema),
  thoughtSignature: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    thoughtSignature: "thought_signature",
  });
});

export function messagesToolCallsToJSON(
  messagesToolCalls: MessagesToolCalls,
): string {
  return JSON.stringify(
    MessagesToolCalls$outboundSchema.parse(messagesToolCalls),
  );
}

/** @internal */
export type MessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<
      | (TextContentPartSchema$Outbound & { type: "text" })
      | RefusalPartSchema$Outbound
      | ReasoningPartSchema$Outbound
      | RedactedReasoningPartSchema$Outbound
    >
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: "assistant";
  name?: string | undefined;
  audio?: MessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<MessagesToolCalls$Outbound> | undefined;
};

/** @internal */
export const MessagesAssistantMessage$outboundSchema: z.ZodType<
  MessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  MessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          TextContentPartSchema$outboundSchema.and(
            z.object({ type: z.literal("text") }),
          ),
          RefusalPartSchema$outboundSchema,
          ReasoningPartSchema$outboundSchema,
          RedactedReasoningPartSchema$outboundSchema,
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: z.literal("assistant"),
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => MessagesToolCalls$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

export function messagesAssistantMessageToJSON(
  messagesAssistantMessage: MessagesAssistantMessage,
): string {
  return JSON.stringify(
    MessagesAssistantMessage$outboundSchema.parse(messagesAssistantMessage),
  );
}

/** @internal */
export const InvokeDeploymentRequest2MessagesType$outboundSchema:
  z.ZodNativeEnum<typeof InvokeDeploymentRequest2MessagesType> = z.nativeEnum(
    InvokeDeploymentRequest2MessagesType,
  );

/** @internal */
export const InvokeDeploymentRequest2Ttl$outboundSchema: z.ZodNativeEnum<
  typeof InvokeDeploymentRequest2Ttl
> = z.nativeEnum(InvokeDeploymentRequest2Ttl);

/** @internal */
export type InvokeDeploymentRequest2CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const InvokeDeploymentRequest2CacheControl$outboundSchema: z.ZodType<
  InvokeDeploymentRequest2CacheControl$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequest2CacheControl
> = z.object({
  type: InvokeDeploymentRequest2MessagesType$outboundSchema,
  ttl: InvokeDeploymentRequest2Ttl$outboundSchema.default("5m"),
});

export function invokeDeploymentRequest2CacheControlToJSON(
  invokeDeploymentRequest2CacheControl: InvokeDeploymentRequest2CacheControl,
): string {
  return JSON.stringify(
    InvokeDeploymentRequest2CacheControl$outboundSchema.parse(
      invokeDeploymentRequest2CacheControl,
    ),
  );
}

/** @internal */
export type Two4$Outbound = {
  type: "file";
  cache_control?: InvokeDeploymentRequest2CacheControl$Outbound | undefined;
  file: FileContentPartSchema$Outbound;
};

/** @internal */
export const Two4$outboundSchema: z.ZodType<Two4$Outbound, z.ZodTypeDef, Two4> =
  z.object({
    type: z.literal("file"),
    cacheControl: z.lazy(() =>
      InvokeDeploymentRequest2CacheControl$outboundSchema
    ).optional(),
    file: FileContentPartSchema$outboundSchema,
  }).transform((v) => {
    return remap$(v, {
      cacheControl: "cache_control",
    });
  });

export function two4ToJSON(two4: Two4): string {
  return JSON.stringify(Two4$outboundSchema.parse(two4));
}

/** @internal */
export type InvokeDeploymentRequestContentMessages2$Outbound =
  | (TextContentPartSchema$Outbound & { type: "text" })
  | ImageContentPartSchema$Outbound
  | AudioContentPartSchema$Outbound
  | Two4$Outbound;

/** @internal */
export const InvokeDeploymentRequestContentMessages2$outboundSchema: z.ZodType<
  InvokeDeploymentRequestContentMessages2$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestContentMessages2
> = z.union([
  TextContentPartSchema$outboundSchema.and(
    z.object({ type: z.literal("text") }),
  ),
  ImageContentPartSchema$outboundSchema,
  AudioContentPartSchema$outboundSchema,
  z.lazy(() => Two4$outboundSchema),
]);

export function invokeDeploymentRequestContentMessages2ToJSON(
  invokeDeploymentRequestContentMessages2:
    InvokeDeploymentRequestContentMessages2,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestContentMessages2$outboundSchema.parse(
      invokeDeploymentRequestContentMessages2,
    ),
  );
}

/** @internal */
export type InvokeDeploymentRequestMessages3Content$Outbound =
  | string
  | Array<
    | (TextContentPartSchema$Outbound & { type: "text" })
    | ImageContentPartSchema$Outbound
    | AudioContentPartSchema$Outbound
    | Two4$Outbound
  >;

/** @internal */
export const InvokeDeploymentRequestMessages3Content$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessages3Content$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessages3Content
> = z.union([
  z.string(),
  z.array(
    z.union([
      TextContentPartSchema$outboundSchema.and(
        z.object({ type: z.literal("text") }),
      ),
      ImageContentPartSchema$outboundSchema,
      AudioContentPartSchema$outboundSchema,
      z.lazy(() => Two4$outboundSchema),
    ]),
  ),
]);

export function invokeDeploymentRequestMessages3ContentToJSON(
  invokeDeploymentRequestMessages3Content:
    InvokeDeploymentRequestMessages3Content,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessages3Content$outboundSchema.parse(
      invokeDeploymentRequestMessages3Content,
    ),
  );
}

/** @internal */
export type MessagesUserMessage$Outbound = {
  role: "user";
  name?: string | undefined;
  content:
    | string
    | Array<
      | (TextContentPartSchema$Outbound & { type: "text" })
      | ImageContentPartSchema$Outbound
      | AudioContentPartSchema$Outbound
      | Two4$Outbound
    >;
};

/** @internal */
export const MessagesUserMessage$outboundSchema: z.ZodType<
  MessagesUserMessage$Outbound,
  z.ZodTypeDef,
  MessagesUserMessage
> = z.object({
  role: z.literal("user"),
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(
      z.union([
        TextContentPartSchema$outboundSchema.and(
          z.object({ type: z.literal("text") }),
        ),
        ImageContentPartSchema$outboundSchema,
        AudioContentPartSchema$outboundSchema,
        z.lazy(() => Two4$outboundSchema),
      ]),
    ),
  ]),
});

export function messagesUserMessageToJSON(
  messagesUserMessage: MessagesUserMessage,
): string {
  return JSON.stringify(
    MessagesUserMessage$outboundSchema.parse(messagesUserMessage),
  );
}

/** @internal */
export type InvokeDeploymentRequestMessagesContent$Outbound =
  | string
  | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const InvokeDeploymentRequestMessagesContent$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMessagesContent$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMessagesContent
> = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function invokeDeploymentRequestMessagesContentToJSON(
  invokeDeploymentRequestMessagesContent:
    InvokeDeploymentRequestMessagesContent,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMessagesContent$outboundSchema.parse(
      invokeDeploymentRequestMessagesContent,
    ),
  );
}

/** @internal */
export type MessagesDeveloperMessage$Outbound = {
  role: "developer";
  content: string | Array<TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesDeveloperMessage$outboundSchema: z.ZodType<
  MessagesDeveloperMessage$Outbound,
  z.ZodTypeDef,
  MessagesDeveloperMessage
> = z.object({
  role: z.literal("developer"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  name: z.string().optional(),
});

export function messagesDeveloperMessageToJSON(
  messagesDeveloperMessage: MessagesDeveloperMessage,
): string {
  return JSON.stringify(
    MessagesDeveloperMessage$outboundSchema.parse(messagesDeveloperMessage),
  );
}

/** @internal */
export type MessagesContent$Outbound =
  | string
  | Array<TextContentPartSchema$Outbound>;

/** @internal */
export const MessagesContent$outboundSchema: z.ZodType<
  MessagesContent$Outbound,
  z.ZodTypeDef,
  MessagesContent
> = z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]);

export function messagesContentToJSON(
  messagesContent: MessagesContent,
): string {
  return JSON.stringify(MessagesContent$outboundSchema.parse(messagesContent));
}

/** @internal */
export type MessagesSystemMessage$Outbound = {
  role: "system";
  content: string | Array<TextContentPartSchema$Outbound>;
  name?: string | undefined;
};

/** @internal */
export const MessagesSystemMessage$outboundSchema: z.ZodType<
  MessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  MessagesSystemMessage
> = z.object({
  role: z.literal("system"),
  content: z.union([z.string(), z.array(TextContentPartSchema$outboundSchema)]),
  name: z.string().optional(),
});

export function messagesSystemMessageToJSON(
  messagesSystemMessage: MessagesSystemMessage,
): string {
  return JSON.stringify(
    MessagesSystemMessage$outboundSchema.parse(messagesSystemMessage),
  );
}

/** @internal */
export type Messages$Outbound =
  | MessagesSystemMessage$Outbound
  | MessagesDeveloperMessage$Outbound
  | MessagesUserMessage$Outbound
  | MessagesAssistantMessage$Outbound
  | MessagesToolMessage$Outbound;

/** @internal */
export const Messages$outboundSchema: z.ZodType<
  Messages$Outbound,
  z.ZodTypeDef,
  Messages
> = z.union([
  z.lazy(() => MessagesSystemMessage$outboundSchema),
  z.lazy(() => MessagesDeveloperMessage$outboundSchema),
  z.lazy(() => MessagesUserMessage$outboundSchema),
  z.lazy(() => MessagesAssistantMessage$outboundSchema),
  z.lazy(() => MessagesToolMessage$outboundSchema),
]);

export function messagesToJSON(messages: Messages): string {
  return JSON.stringify(Messages$outboundSchema.parse(messages));
}

/** @internal */
export type InvokeDeploymentRequestMetadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const InvokeDeploymentRequestMetadata$outboundSchema: z.ZodType<
  InvokeDeploymentRequestMetadata$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestMetadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

export function invokeDeploymentRequestMetadataToJSON(
  invokeDeploymentRequestMetadata: InvokeDeploymentRequestMetadata,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestMetadata$outboundSchema.parse(
      invokeDeploymentRequestMetadata,
    ),
  );
}

/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: InvokeDeploymentRequestMetadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => InvokeDeploymentRequestMetadata$outboundSchema)
    .optional(),
});

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}

/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
  include_usage: boolean;
  mock_response?: string | undefined;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
  includeUsage: z.boolean().default(false),
  mockResponse: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
    includeUsage: "include_usage",
    mockResponse: "mock_response",
  });
});

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}

/** @internal */
export type Thread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Thread$outboundSchema: z.ZodType<
  Thread$Outbound,
  z.ZodTypeDef,
  Thread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

export function threadToJSON(thread: Thread): string {
  return JSON.stringify(Thread$outboundSchema.parse(thread));
}

/** @internal */
export type OrExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const OrExists$outboundSchema: z.ZodType<
  OrExists$Outbound,
  z.ZodTypeDef,
  OrExists
> = z.object({
  exists: z.boolean(),
});

export function orExistsToJSON(orExists: OrExists): string {
  return JSON.stringify(OrExists$outboundSchema.parse(orExists));
}

/** @internal */
export type OrNin$Outbound = string | number | boolean;

/** @internal */
export const OrNin$outboundSchema: z.ZodType<
  OrNin$Outbound,
  z.ZodTypeDef,
  OrNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function orNinToJSON(orNin: OrNin): string {
  return JSON.stringify(OrNin$outboundSchema.parse(orNin));
}

/** @internal */
export type InvokeDeploymentRequestOrNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestOrNin$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNin$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestOrNinToJSON(
  invokeDeploymentRequestOrNin: InvokeDeploymentRequestOrNin,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrNin$outboundSchema.parse(
      invokeDeploymentRequestOrNin,
    ),
  );
}

/** @internal */
export type OrIn$Outbound = string | number | boolean;

/** @internal */
export const OrIn$outboundSchema: z.ZodType<OrIn$Outbound, z.ZodTypeDef, OrIn> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orInToJSON(orIn: OrIn): string {
  return JSON.stringify(OrIn$outboundSchema.parse(orIn));
}

/** @internal */
export type InvokeDeploymentRequestOrIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestOrIn$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrIn$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestOrInToJSON(
  invokeDeploymentRequestOrIn: InvokeDeploymentRequestOrIn,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrIn$outboundSchema.parse(
      invokeDeploymentRequestOrIn,
    ),
  );
}

/** @internal */
export type OrLte$Outbound = {
  lte: number;
};

/** @internal */
export const OrLte$outboundSchema: z.ZodType<
  OrLte$Outbound,
  z.ZodTypeDef,
  OrLte
> = z.object({
  lte: z.number(),
});

export function orLteToJSON(orLte: OrLte): string {
  return JSON.stringify(OrLte$outboundSchema.parse(orLte));
}

/** @internal */
export type OrLt$Outbound = {
  lt: number;
};

/** @internal */
export const OrLt$outboundSchema: z.ZodType<OrLt$Outbound, z.ZodTypeDef, OrLt> =
  z.object({
    lt: z.number(),
  });

export function orLtToJSON(orLt: OrLt): string {
  return JSON.stringify(OrLt$outboundSchema.parse(orLt));
}

/** @internal */
export type OrGte$Outbound = {
  gte: number;
};

/** @internal */
export const OrGte$outboundSchema: z.ZodType<
  OrGte$Outbound,
  z.ZodTypeDef,
  OrGte
> = z.object({
  gte: z.number(),
});

export function orGteToJSON(orGte: OrGte): string {
  return JSON.stringify(OrGte$outboundSchema.parse(orGte));
}

/** @internal */
export type OrGt$Outbound = {
  gt: number;
};

/** @internal */
export const OrGt$outboundSchema: z.ZodType<OrGt$Outbound, z.ZodTypeDef, OrGt> =
  z.object({
    gt: z.number(),
  });

export function orGtToJSON(orGt: OrGt): string {
  return JSON.stringify(OrGt$outboundSchema.parse(orGt));
}

/** @internal */
export type OrNe$Outbound = string | number | boolean;

/** @internal */
export const OrNe$outboundSchema: z.ZodType<OrNe$Outbound, z.ZodTypeDef, OrNe> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orNeToJSON(orNe: OrNe): string {
  return JSON.stringify(OrNe$outboundSchema.parse(orNe));
}

/** @internal */
export type InvokeDeploymentRequestOrNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestOrNe$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrNe$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestOrNeToJSON(
  invokeDeploymentRequestOrNe: InvokeDeploymentRequestOrNe,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrNe$outboundSchema.parse(
      invokeDeploymentRequestOrNe,
    ),
  );
}

/** @internal */
export type OrEq$Outbound = string | number | boolean;

/** @internal */
export const OrEq$outboundSchema: z.ZodType<OrEq$Outbound, z.ZodTypeDef, OrEq> =
  z.union([z.string(), z.number(), z.boolean()]);

export function orEqToJSON(orEq: OrEq): string {
  return JSON.stringify(OrEq$outboundSchema.parse(orEq));
}

/** @internal */
export type InvokeDeploymentRequestOrEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestOrEq$outboundSchema: z.ZodType<
  InvokeDeploymentRequestOrEq$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestOrEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestOrEqToJSON(
  invokeDeploymentRequestOrEq: InvokeDeploymentRequestOrEq,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestOrEq$outboundSchema.parse(
      invokeDeploymentRequestOrEq,
    ),
  );
}

/** @internal */
export type Or$Outbound =
  | InvokeDeploymentRequestOrEq$Outbound
  | InvokeDeploymentRequestOrNe$Outbound
  | OrGt$Outbound
  | OrGte$Outbound
  | OrLt$Outbound
  | OrLte$Outbound
  | InvokeDeploymentRequestOrIn$Outbound
  | InvokeDeploymentRequestOrNin$Outbound
  | OrExists$Outbound;

/** @internal */
export const Or$outboundSchema: z.ZodType<Or$Outbound, z.ZodTypeDef, Or> = z
  .union([
    z.lazy(() => InvokeDeploymentRequestOrEq$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrNe$outboundSchema),
    z.lazy(() => OrGt$outboundSchema),
    z.lazy(() => OrGte$outboundSchema),
    z.lazy(() => OrLt$outboundSchema),
    z.lazy(() => OrLte$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrIn$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestOrNin$outboundSchema),
    z.lazy(() => OrExists$outboundSchema),
  ]);

export function orToJSON(or: Or): string {
  return JSON.stringify(Or$outboundSchema.parse(or));
}

/** @internal */
export type KnowledgeFilterOr$Outbound = {
  or: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestOrEq$Outbound
        | InvokeDeploymentRequestOrNe$Outbound
        | OrGt$Outbound
        | OrGte$Outbound
        | OrLt$Outbound
        | OrLte$Outbound
        | InvokeDeploymentRequestOrIn$Outbound
        | InvokeDeploymentRequestOrNin$Outbound
        | OrExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterOr$outboundSchema: z.ZodType<
  KnowledgeFilterOr$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterOr
> = z.object({
  or: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestOrEq$outboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestOrNe$outboundSchema
      ),
      z.lazy(() => OrGt$outboundSchema),
      z.lazy(() => OrGte$outboundSchema),
      z.lazy(() => OrLt$outboundSchema),
      z.lazy(() => OrLte$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrIn$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestOrNin$outboundSchema),
      z.lazy(() => OrExists$outboundSchema),
    ])),
  ),
});

export function knowledgeFilterOrToJSON(
  knowledgeFilterOr: KnowledgeFilterOr,
): string {
  return JSON.stringify(
    KnowledgeFilterOr$outboundSchema.parse(knowledgeFilterOr),
  );
}

/** @internal */
export type AndExists$Outbound = {
  exists: boolean;
};

/** @internal */
export const AndExists$outboundSchema: z.ZodType<
  AndExists$Outbound,
  z.ZodTypeDef,
  AndExists
> = z.object({
  exists: z.boolean(),
});

export function andExistsToJSON(andExists: AndExists): string {
  return JSON.stringify(AndExists$outboundSchema.parse(andExists));
}

/** @internal */
export type AndNin$Outbound = string | number | boolean;

/** @internal */
export const AndNin$outboundSchema: z.ZodType<
  AndNin$Outbound,
  z.ZodTypeDef,
  AndNin
> = z.union([z.string(), z.number(), z.boolean()]);

export function andNinToJSON(andNin: AndNin): string {
  return JSON.stringify(AndNin$outboundSchema.parse(andNin));
}

/** @internal */
export type InvokeDeploymentRequestAndNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestAndNin$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNin$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestAndNinToJSON(
  invokeDeploymentRequestAndNin: InvokeDeploymentRequestAndNin,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndNin$outboundSchema.parse(
      invokeDeploymentRequestAndNin,
    ),
  );
}

/** @internal */
export type AndIn$Outbound = string | number | boolean;

/** @internal */
export const AndIn$outboundSchema: z.ZodType<
  AndIn$Outbound,
  z.ZodTypeDef,
  AndIn
> = z.union([z.string(), z.number(), z.boolean()]);

export function andInToJSON(andIn: AndIn): string {
  return JSON.stringify(AndIn$outboundSchema.parse(andIn));
}

/** @internal */
export type InvokeDeploymentRequestAndIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const InvokeDeploymentRequestAndIn$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndIn$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function invokeDeploymentRequestAndInToJSON(
  invokeDeploymentRequestAndIn: InvokeDeploymentRequestAndIn,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndIn$outboundSchema.parse(
      invokeDeploymentRequestAndIn,
    ),
  );
}

/** @internal */
export type AndLte$Outbound = {
  lte: number;
};

/** @internal */
export const AndLte$outboundSchema: z.ZodType<
  AndLte$Outbound,
  z.ZodTypeDef,
  AndLte
> = z.object({
  lte: z.number(),
});

export function andLteToJSON(andLte: AndLte): string {
  return JSON.stringify(AndLte$outboundSchema.parse(andLte));
}

/** @internal */
export type AndLt$Outbound = {
  lt: number;
};

/** @internal */
export const AndLt$outboundSchema: z.ZodType<
  AndLt$Outbound,
  z.ZodTypeDef,
  AndLt
> = z.object({
  lt: z.number(),
});

export function andLtToJSON(andLt: AndLt): string {
  return JSON.stringify(AndLt$outboundSchema.parse(andLt));
}

/** @internal */
export type AndGte$Outbound = {
  gte: number;
};

/** @internal */
export const AndGte$outboundSchema: z.ZodType<
  AndGte$Outbound,
  z.ZodTypeDef,
  AndGte
> = z.object({
  gte: z.number(),
});

export function andGteToJSON(andGte: AndGte): string {
  return JSON.stringify(AndGte$outboundSchema.parse(andGte));
}

/** @internal */
export type AndGt$Outbound = {
  gt: number;
};

/** @internal */
export const AndGt$outboundSchema: z.ZodType<
  AndGt$Outbound,
  z.ZodTypeDef,
  AndGt
> = z.object({
  gt: z.number(),
});

export function andGtToJSON(andGt: AndGt): string {
  return JSON.stringify(AndGt$outboundSchema.parse(andGt));
}

/** @internal */
export type AndNe$Outbound = string | number | boolean;

/** @internal */
export const AndNe$outboundSchema: z.ZodType<
  AndNe$Outbound,
  z.ZodTypeDef,
  AndNe
> = z.union([z.string(), z.number(), z.boolean()]);

export function andNeToJSON(andNe: AndNe): string {
  return JSON.stringify(AndNe$outboundSchema.parse(andNe));
}

/** @internal */
export type InvokeDeploymentRequestAndNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestAndNe$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndNe$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestAndNeToJSON(
  invokeDeploymentRequestAndNe: InvokeDeploymentRequestAndNe,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndNe$outboundSchema.parse(
      invokeDeploymentRequestAndNe,
    ),
  );
}

/** @internal */
export type AndEq$Outbound = string | number | boolean;

/** @internal */
export const AndEq$outboundSchema: z.ZodType<
  AndEq$Outbound,
  z.ZodTypeDef,
  AndEq
> = z.union([z.string(), z.number(), z.boolean()]);

export function andEqToJSON(andEq: AndEq): string {
  return JSON.stringify(AndEq$outboundSchema.parse(andEq));
}

/** @internal */
export type InvokeDeploymentRequestAndEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const InvokeDeploymentRequestAndEq$outboundSchema: z.ZodType<
  InvokeDeploymentRequestAndEq$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequestAndEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function invokeDeploymentRequestAndEqToJSON(
  invokeDeploymentRequestAndEq: InvokeDeploymentRequestAndEq,
): string {
  return JSON.stringify(
    InvokeDeploymentRequestAndEq$outboundSchema.parse(
      invokeDeploymentRequestAndEq,
    ),
  );
}

/** @internal */
export type And$Outbound =
  | InvokeDeploymentRequestAndEq$Outbound
  | InvokeDeploymentRequestAndNe$Outbound
  | AndGt$Outbound
  | AndGte$Outbound
  | AndLt$Outbound
  | AndLte$Outbound
  | InvokeDeploymentRequestAndIn$Outbound
  | InvokeDeploymentRequestAndNin$Outbound
  | AndExists$Outbound;

/** @internal */
export const And$outboundSchema: z.ZodType<And$Outbound, z.ZodTypeDef, And> = z
  .union([
    z.lazy(() => InvokeDeploymentRequestAndEq$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNe$outboundSchema),
    z.lazy(() => AndGt$outboundSchema),
    z.lazy(() => AndGte$outboundSchema),
    z.lazy(() => AndLt$outboundSchema),
    z.lazy(() => AndLte$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndIn$outboundSchema),
    z.lazy(() => InvokeDeploymentRequestAndNin$outboundSchema),
    z.lazy(() => AndExists$outboundSchema),
  ]);

export function andToJSON(and: And): string {
  return JSON.stringify(And$outboundSchema.parse(and));
}

/** @internal */
export type KnowledgeFilterAnd$Outbound = {
  and: Array<
    {
      [k: string]:
        | InvokeDeploymentRequestAndEq$Outbound
        | InvokeDeploymentRequestAndNe$Outbound
        | AndGt$Outbound
        | AndGte$Outbound
        | AndLt$Outbound
        | AndLte$Outbound
        | InvokeDeploymentRequestAndIn$Outbound
        | InvokeDeploymentRequestAndNin$Outbound
        | AndExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterAnd$outboundSchema: z.ZodType<
  KnowledgeFilterAnd$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterAnd
> = z.object({
  and: z.array(
    z.record(z.union([
      z.lazy(() => InvokeDeploymentRequestAndEq$outboundSchema),
      z.lazy(() =>
        InvokeDeploymentRequestAndNe$outboundSchema
      ),
      z.lazy(() => AndGt$outboundSchema),
      z.lazy(() => AndGte$outboundSchema),
      z.lazy(() => AndLt$outboundSchema),
      z.lazy(() => AndLte$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndIn$outboundSchema),
      z.lazy(() => InvokeDeploymentRequestAndNin$outboundSchema),
      z.lazy(() => AndExists$outboundSchema),
    ])),
  ),
});

export function knowledgeFilterAndToJSON(
  knowledgeFilterAnd: KnowledgeFilterAnd,
): string {
  return JSON.stringify(
    KnowledgeFilterAnd$outboundSchema.parse(knowledgeFilterAnd),
  );
}

/** @internal */
export type Exists$Outbound = {
  exists: boolean;
};

/** @internal */
export const Exists$outboundSchema: z.ZodType<
  Exists$Outbound,
  z.ZodTypeDef,
  Exists
> = z.object({
  exists: z.boolean(),
});

export function existsToJSON(exists: Exists): string {
  return JSON.stringify(Exists$outboundSchema.parse(exists));
}

/** @internal */
export type Nin$Outbound = string | number | boolean;

/** @internal */
export const Nin$outboundSchema: z.ZodType<Nin$Outbound, z.ZodTypeDef, Nin> = z
  .union([z.string(), z.number(), z.boolean()]);

export function ninToJSON(nin: Nin): string {
  return JSON.stringify(Nin$outboundSchema.parse(nin));
}

/** @internal */
export type OneNin$Outbound = {
  nin: Array<string | number | boolean>;
};

/** @internal */
export const OneNin$outboundSchema: z.ZodType<
  OneNin$Outbound,
  z.ZodTypeDef,
  OneNin
> = z.object({
  nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function oneNinToJSON(oneNin: OneNin): string {
  return JSON.stringify(OneNin$outboundSchema.parse(oneNin));
}

/** @internal */
export type In$Outbound = string | number | boolean;

/** @internal */
export const In$outboundSchema: z.ZodType<In$Outbound, z.ZodTypeDef, In> = z
  .union([z.string(), z.number(), z.boolean()]);

export function inToJSON(value: In): string {
  return JSON.stringify(In$outboundSchema.parse(value));
}

/** @internal */
export type OneIn$Outbound = {
  in: Array<string | number | boolean>;
};

/** @internal */
export const OneIn$outboundSchema: z.ZodType<
  OneIn$Outbound,
  z.ZodTypeDef,
  OneIn
> = z.object({
  in: z.array(z.union([z.string(), z.number(), z.boolean()])),
});

export function oneInToJSON(oneIn: OneIn): string {
  return JSON.stringify(OneIn$outboundSchema.parse(oneIn));
}

/** @internal */
export type Lte$Outbound = {
  lte: number;
};

/** @internal */
export const Lte$outboundSchema: z.ZodType<Lte$Outbound, z.ZodTypeDef, Lte> = z
  .object({
    lte: z.number(),
  });

export function lteToJSON(lte: Lte): string {
  return JSON.stringify(Lte$outboundSchema.parse(lte));
}

/** @internal */
export type Lt$Outbound = {
  lt: number;
};

/** @internal */
export const Lt$outboundSchema: z.ZodType<Lt$Outbound, z.ZodTypeDef, Lt> = z
  .object({
    lt: z.number(),
  });

export function ltToJSON(lt: Lt): string {
  return JSON.stringify(Lt$outboundSchema.parse(lt));
}

/** @internal */
export type Gte$Outbound = {
  gte: number;
};

/** @internal */
export const Gte$outboundSchema: z.ZodType<Gte$Outbound, z.ZodTypeDef, Gte> = z
  .object({
    gte: z.number(),
  });

export function gteToJSON(gte: Gte): string {
  return JSON.stringify(Gte$outboundSchema.parse(gte));
}

/** @internal */
export type Gt$Outbound = {
  gt: number;
};

/** @internal */
export const Gt$outboundSchema: z.ZodType<Gt$Outbound, z.ZodTypeDef, Gt> = z
  .object({
    gt: z.number(),
  });

export function gtToJSON(gt: Gt): string {
  return JSON.stringify(Gt$outboundSchema.parse(gt));
}

/** @internal */
export type Ne$Outbound = string | number | boolean;

/** @internal */
export const Ne$outboundSchema: z.ZodType<Ne$Outbound, z.ZodTypeDef, Ne> = z
  .union([z.string(), z.number(), z.boolean()]);

export function neToJSON(ne: Ne): string {
  return JSON.stringify(Ne$outboundSchema.parse(ne));
}

/** @internal */
export type OneNe$Outbound = {
  ne: string | number | boolean;
};

/** @internal */
export const OneNe$outboundSchema: z.ZodType<
  OneNe$Outbound,
  z.ZodTypeDef,
  OneNe
> = z.object({
  ne: z.union([z.string(), z.number(), z.boolean()]),
});

export function oneNeToJSON(oneNe: OneNe): string {
  return JSON.stringify(OneNe$outboundSchema.parse(oneNe));
}

/** @internal */
export type Eq$Outbound = string | number | boolean;

/** @internal */
export const Eq$outboundSchema: z.ZodType<Eq$Outbound, z.ZodTypeDef, Eq> = z
  .union([z.string(), z.number(), z.boolean()]);

export function eqToJSON(eq: Eq): string {
  return JSON.stringify(Eq$outboundSchema.parse(eq));
}

/** @internal */
export type OneEq$Outbound = {
  eq: string | number | boolean;
};

/** @internal */
export const OneEq$outboundSchema: z.ZodType<
  OneEq$Outbound,
  z.ZodTypeDef,
  OneEq
> = z.object({
  eq: z.union([z.string(), z.number(), z.boolean()]),
});

export function oneEqToJSON(oneEq: OneEq): string {
  return JSON.stringify(OneEq$outboundSchema.parse(oneEq));
}

/** @internal */
export type One$Outbound =
  | OneEq$Outbound
  | OneNe$Outbound
  | Gt$Outbound
  | Gte$Outbound
  | Lt$Outbound
  | Lte$Outbound
  | OneIn$Outbound
  | OneNin$Outbound
  | Exists$Outbound;

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .union([
    z.lazy(() => OneEq$outboundSchema),
    z.lazy(() => OneNe$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => OneIn$outboundSchema),
    z.lazy(() => OneNin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ]);

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

/** @internal */
export type KnowledgeFilter$Outbound =
  | KnowledgeFilterAnd$Outbound
  | KnowledgeFilterOr$Outbound
  | {
    [k: string]:
      | OneEq$Outbound
      | OneNe$Outbound
      | Gt$Outbound
      | Gte$Outbound
      | Lt$Outbound
      | Lte$Outbound
      | OneIn$Outbound
      | OneNin$Outbound
      | Exists$Outbound;
  };

/** @internal */
export const KnowledgeFilter$outboundSchema: z.ZodType<
  KnowledgeFilter$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter
> = z.union([
  z.lazy(() => KnowledgeFilterAnd$outboundSchema),
  z.lazy(() => KnowledgeFilterOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => OneEq$outboundSchema),
    z.lazy(() => OneNe$outboundSchema),
    z.lazy(() => Gt$outboundSchema),
    z.lazy(() => Gte$outboundSchema),
    z.lazy(() => Lt$outboundSchema),
    z.lazy(() => Lte$outboundSchema),
    z.lazy(() => OneIn$outboundSchema),
    z.lazy(() => OneNin$outboundSchema),
    z.lazy(() => Exists$outboundSchema),
  ])),
]);

export function knowledgeFilterToJSON(
  knowledgeFilter: KnowledgeFilter,
): string {
  return JSON.stringify(KnowledgeFilter$outboundSchema.parse(knowledgeFilter));
}

/** @internal */
export type InvokeDeploymentRequest$Outbound = {
  key: string;
  stream: boolean;
  inputs?: { [k: string]: any } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?:
    | Array<
      | SystemMessage$Outbound
      | DeveloperMessage$Outbound
      | UserMessage$Outbound
      | AssistantMessage$Outbound
      | ToolMessage$Outbound
    >
    | undefined;
  messages?:
    | Array<
      | MessagesSystemMessage$Outbound
      | MessagesDeveloperMessage$Outbound
      | MessagesUserMessage$Outbound
      | MessagesAssistantMessage$Outbound
      | MessagesToolMessage$Outbound
    >
    | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
  thread?: Thread$Outbound | undefined;
  knowledge_filter?:
    | KnowledgeFilterAnd$Outbound
    | KnowledgeFilterOr$Outbound
    | {
      [k: string]:
        | OneEq$Outbound
        | OneNe$Outbound
        | Gt$Outbound
        | Gte$Outbound
        | Lt$Outbound
        | Lte$Outbound
        | OneIn$Outbound
        | OneNin$Outbound
        | Exists$Outbound;
    }
    | undefined;
};

/** @internal */
export const InvokeDeploymentRequest$outboundSchema: z.ZodType<
  InvokeDeploymentRequest$Outbound,
  z.ZodTypeDef,
  InvokeDeploymentRequest
> = z.object({
  key: z.string(),
  stream: z.boolean().default(false),
  inputs: z.record(z.any()).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(
    z.union([
      z.lazy(() => SystemMessage$outboundSchema),
      z.lazy(() => DeveloperMessage$outboundSchema),
      z.lazy(() => UserMessage$outboundSchema),
      z.lazy(() => AssistantMessage$outboundSchema),
      z.lazy(() => ToolMessage$outboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesSystemMessage$outboundSchema),
      z.lazy(() => MessagesDeveloperMessage$outboundSchema),
      z.lazy(() => MessagesUserMessage$outboundSchema),
      z.lazy(() => MessagesAssistantMessage$outboundSchema),
      z.lazy(() => MessagesToolMessage$outboundSchema),
    ]),
  ).optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
  thread: z.lazy(() => Thread$outboundSchema).optional(),
  knowledgeFilter: z.union([
    z.lazy(() => KnowledgeFilterAnd$outboundSchema),
    z.lazy(() => KnowledgeFilterOr$outboundSchema),
    z.record(z.union([
      z.lazy(() => OneEq$outboundSchema),
      z.lazy(() => OneNe$outboundSchema),
      z.lazy(() => Gt$outboundSchema),
      z.lazy(() => Gte$outboundSchema),
      z.lazy(() => Lt$outboundSchema),
      z.lazy(() => Lte$outboundSchema),
      z.lazy(() => OneIn$outboundSchema),
      z.lazy(() => OneNin$outboundSchema),
      z.lazy(() => Exists$outboundSchema),
    ])),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
    knowledgeFilter: "knowledge_filter",
  });
});

export function invokeDeploymentRequestToJSON(
  invokeDeploymentRequest: InvokeDeploymentRequest,
): string {
  return JSON.stringify(
    InvokeDeploymentRequest$outboundSchema.parse(invokeDeploymentRequest),
  );
}
