/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The type of the content part.
 */
export const Type = {
  Text: "text",
} as const;
/**
 * The type of the content part.
 */
export type Type = ClosedEnum<typeof Type>;

/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export const TextContentPartSchemaType = {
  Ephemeral: "ephemeral",
} as const;
/**
 * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
 */
export type TextContentPartSchemaType = ClosedEnum<
  typeof TextContentPartSchemaType
>;

/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export const Ttl = {
  Fivem: "5m",
  Oneh: "1h",
} as const;
/**
 * The time-to-live for the cache control breakpoint. This may be one of the following values:
 *
 * @remarks
 *
 * - `5m`: 5 minutes
 * - `1h`: 1 hour
 *
 * Defaults to `5m`. Only supported by `Anthropic` Claude models.
 */
export type Ttl = ClosedEnum<typeof Ttl>;

export type CacheControl = {
  /**
   * Create a cache control breakpoint at this content block. Accepts only the value "ephemeral".
   */
  type: TextContentPartSchemaType;
  /**
   * The time-to-live for the cache control breakpoint. This may be one of the following values:
   *
   * @remarks
   *
   * - `5m`: 5 minutes
   * - `1h`: 1 hour
   *
   * Defaults to `5m`. Only supported by `Anthropic` Claude models.
   */
  ttl?: Ttl | undefined;
};

/**
 * The type of the content part.
 */
export type TextContentPartSchema = {
  /**
   * The type of the content part.
   */
  type: Type;
  /**
   * The text content.
   */
  text: string;
  cacheControl?: CacheControl | undefined;
};

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);
/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/** @internal */
export const TextContentPartSchemaType$inboundSchema: z.ZodNativeEnum<
  typeof TextContentPartSchemaType
> = z.nativeEnum(TextContentPartSchemaType);
/** @internal */
export const TextContentPartSchemaType$outboundSchema: z.ZodNativeEnum<
  typeof TextContentPartSchemaType
> = TextContentPartSchemaType$inboundSchema;

/** @internal */
export const Ttl$inboundSchema: z.ZodNativeEnum<typeof Ttl> = z.nativeEnum(Ttl);
/** @internal */
export const Ttl$outboundSchema: z.ZodNativeEnum<typeof Ttl> =
  Ttl$inboundSchema;

/** @internal */
export const CacheControl$inboundSchema: z.ZodType<
  CacheControl,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: TextContentPartSchemaType$inboundSchema,
  ttl: Ttl$inboundSchema.default("5m"),
});
/** @internal */
export type CacheControl$Outbound = {
  type: string;
  ttl: string;
};

/** @internal */
export const CacheControl$outboundSchema: z.ZodType<
  CacheControl$Outbound,
  z.ZodTypeDef,
  CacheControl
> = z.object({
  type: TextContentPartSchemaType$outboundSchema,
  ttl: Ttl$outboundSchema.default("5m"),
});

export function cacheControlToJSON(cacheControl: CacheControl): string {
  return JSON.stringify(CacheControl$outboundSchema.parse(cacheControl));
}
export function cacheControlFromJSON(
  jsonString: string,
): SafeParseResult<CacheControl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CacheControl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CacheControl' from JSON`,
  );
}

/** @internal */
export const TextContentPartSchema$inboundSchema: z.ZodType<
  TextContentPartSchema,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Type$inboundSchema,
  text: z.string(),
  cache_control: z.lazy(() => CacheControl$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "cache_control": "cacheControl",
  });
});
/** @internal */
export type TextContentPartSchema$Outbound = {
  type: string;
  text: string;
  cache_control?: CacheControl$Outbound | undefined;
};

/** @internal */
export const TextContentPartSchema$outboundSchema: z.ZodType<
  TextContentPartSchema$Outbound,
  z.ZodTypeDef,
  TextContentPartSchema
> = z.object({
  type: Type$outboundSchema,
  text: z.string(),
  cacheControl: z.lazy(() => CacheControl$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    cacheControl: "cache_control",
  });
});

export function textContentPartSchemaToJSON(
  textContentPartSchema: TextContentPartSchema,
): string {
  return JSON.stringify(
    TextContentPartSchema$outboundSchema.parse(textContentPartSchema),
  );
}
export function textContentPartSchemaFromJSON(
  jsonString: string,
): SafeParseResult<TextContentPartSchema, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextContentPartSchema$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextContentPartSchema' from JSON`,
  );
}
