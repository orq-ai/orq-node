/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AgentResponseMessage,
  AgentResponseMessage$inboundSchema,
} from "./agentresponsemessage.js";

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the agent execution
 */
export type Usage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | null | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

/**
 * The reason why the agent stopped generating
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
  MaxIterations: "max_iterations",
  MaxTime: "max_time",
} as const;
/**
 * The reason why the agent stopped generating
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export const CreateAgentResponseType = {
  Function: "function",
} as const;
export type CreateAgentResponseType = ClosedEnum<
  typeof CreateAgentResponseType
>;

export type FunctionT = {
  name?: string | undefined;
  arguments?: string | undefined;
};

export type PendingToolCalls = {
  id: string;
  type: CreateAgentResponseType;
  function: FunctionT;
};

/**
 * Response type from the create-response endpoint.
 */
export type CreateAgentResponse = {
  /**
   * The unique response ID
   */
  id: string;
  /**
   * The agent execution task ID
   */
  taskId: string;
  /**
   * Array of messages from the agent execution
   */
  output: Array<AgentResponseMessage>;
  /**
   * ISO timestamp of response creation
   */
  createdAt: string;
  /**
   * Model used in provider/model format
   */
  model: string;
  /**
   * Token usage from the agent execution
   */
  usage?: Usage | null | undefined;
  /**
   * The reason why the agent stopped generating
   */
  finishReason?: FinishReason | undefined;
  /**
   * Tool calls awaiting user response (when finish_reason is function_call)
   */
  pendingToolCalls?: Array<PendingToolCalls> | undefined;
};

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  cache_creation_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "cache_creation_tokens": "cacheCreationTokens",
    "audio_tokens": "audioTokens",
  });
});

export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});

export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, z.ZodTypeDef, unknown> = z
  .object({
    completion_tokens: z.number().optional(),
    prompt_tokens: z.number().optional(),
    total_tokens: z.number().optional(),
    prompt_tokens_details: z.nullable(
      z.lazy(() => PromptTokensDetails$inboundSchema),
    ).optional(),
    completion_tokens_details: z.nullable(
      z.lazy(() => CompletionTokensDetails$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "completion_tokens": "completionTokens",
      "prompt_tokens": "promptTokens",
      "total_tokens": "totalTokens",
      "prompt_tokens_details": "promptTokensDetails",
      "completion_tokens_details": "completionTokensDetails",
    });
  });

export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);

/** @internal */
export const CreateAgentResponseType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseType
> = z.nativeEnum(CreateAgentResponseType);

/** @internal */
export const FunctionT$inboundSchema: z.ZodType<
  FunctionT,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function functionFromJSON(
  jsonString: string,
): SafeParseResult<FunctionT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionT' from JSON`,
  );
}

/** @internal */
export const PendingToolCalls$inboundSchema: z.ZodType<
  PendingToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateAgentResponseType$inboundSchema,
  function: z.lazy(() => FunctionT$inboundSchema),
});

export function pendingToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<PendingToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponse$inboundSchema: z.ZodType<
  CreateAgentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  task_id: z.string(),
  output: z.array(AgentResponseMessage$inboundSchema),
  created_at: z.string(),
  model: z.string(),
  usage: z.nullable(z.lazy(() => Usage$inboundSchema)).optional(),
  finish_reason: FinishReason$inboundSchema.optional(),
  pending_tool_calls: z.array(z.lazy(() => PendingToolCalls$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "task_id": "taskId",
    "created_at": "createdAt",
    "finish_reason": "finishReason",
    "pending_tool_calls": "pendingToolCalls",
  });
});

export function createAgentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponse' from JSON`,
  );
}
