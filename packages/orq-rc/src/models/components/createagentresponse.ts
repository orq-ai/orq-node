/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AgentResponseMessage,
  AgentResponseMessage$inboundSchema,
  AgentResponseMessage$Outbound,
  AgentResponseMessage$outboundSchema,
} from "./agentresponsemessage.js";

export type PromptTokensDetails = {
  cachedTokens?: number | null | undefined;
  cacheCreationTokens?: number | null | undefined;
  /**
   * The number of audio input tokens consumed by the request.
   */
  audioTokens?: number | null | undefined;
};

export type CompletionTokensDetails = {
  reasoningTokens?: number | null | undefined;
  acceptedPredictionTokens?: number | null | undefined;
  rejectedPredictionTokens?: number | null | undefined;
  /**
   * The number of audio output tokens produced by the response.
   */
  audioTokens?: number | null | undefined;
};

/**
 * Token usage from the agent execution
 */
export type Usage = {
  /**
   * Number of tokens in the generated completion.
   */
  completionTokens?: number | undefined;
  /**
   * Number of tokens in the prompt.
   */
  promptTokens?: number | undefined;
  /**
   * Total number of tokens used in the request (prompt + completion).
   */
  totalTokens?: number | undefined;
  promptTokensDetails?: PromptTokensDetails | null | undefined;
  completionTokensDetails?: CompletionTokensDetails | null | undefined;
};

/**
 * The reason why the agent stopped generating
 */
export const FinishReason = {
  Stop: "stop",
  Length: "length",
  ToolCalls: "tool_calls",
  ContentFilter: "content_filter",
  FunctionCall: "function_call",
  MaxIterations: "max_iterations",
  MaxTime: "max_time",
} as const;
/**
 * The reason why the agent stopped generating
 */
export type FinishReason = ClosedEnum<typeof FinishReason>;

export const CreateAgentResponseType = {
  Function: "function",
} as const;
export type CreateAgentResponseType = ClosedEnum<
  typeof CreateAgentResponseType
>;

export type FunctionT = {
  name?: string | undefined;
  arguments?: string | undefined;
};

export type PendingToolCalls = {
  id: string;
  type: CreateAgentResponseType;
  function: FunctionT;
};

/**
 * Response type from the create-response endpoint.
 */
export type CreateAgentResponse = {
  /**
   * The unique response ID
   */
  id: string;
  /**
   * The agent execution task ID
   */
  taskId: string;
  /**
   * Array of messages from the agent execution
   */
  output: Array<AgentResponseMessage>;
  /**
   * ISO timestamp of response creation
   */
  createdAt: string;
  /**
   * Model used in provider/model format
   */
  model: string;
  /**
   * Token usage from the agent execution
   */
  usage?: Usage | null | undefined;
  /**
   * The reason why the agent stopped generating
   */
  finishReason?: FinishReason | undefined;
  /**
   * Tool calls awaiting user response (when finish_reason is function_call)
   */
  pendingToolCalls?: Array<PendingToolCalls> | undefined;
};

/** @internal */
export const PromptTokensDetails$inboundSchema: z.ZodType<
  PromptTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  cached_tokens: z.nullable(z.number().int()).optional(),
  cache_creation_tokens: z.nullable(z.number().int()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "cached_tokens": "cachedTokens",
    "cache_creation_tokens": "cacheCreationTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type PromptTokensDetails$Outbound = {
  cached_tokens?: number | null | undefined;
  cache_creation_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const PromptTokensDetails$outboundSchema: z.ZodType<
  PromptTokensDetails$Outbound,
  z.ZodTypeDef,
  PromptTokensDetails
> = z.object({
  cachedTokens: z.nullable(z.number().int()).optional(),
  cacheCreationTokens: z.nullable(z.number().int()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    cachedTokens: "cached_tokens",
    cacheCreationTokens: "cache_creation_tokens",
    audioTokens: "audio_tokens",
  });
});

export function promptTokensDetailsToJSON(
  promptTokensDetails: PromptTokensDetails,
): string {
  return JSON.stringify(
    PromptTokensDetails$outboundSchema.parse(promptTokensDetails),
  );
}
export function promptTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<PromptTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PromptTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PromptTokensDetails' from JSON`,
  );
}

/** @internal */
export const CompletionTokensDetails$inboundSchema: z.ZodType<
  CompletionTokensDetails,
  z.ZodTypeDef,
  unknown
> = z.object({
  reasoning_tokens: z.nullable(z.number()).optional(),
  accepted_prediction_tokens: z.nullable(z.number()).optional(),
  rejected_prediction_tokens: z.nullable(z.number()).optional(),
  audio_tokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    "reasoning_tokens": "reasoningTokens",
    "accepted_prediction_tokens": "acceptedPredictionTokens",
    "rejected_prediction_tokens": "rejectedPredictionTokens",
    "audio_tokens": "audioTokens",
  });
});
/** @internal */
export type CompletionTokensDetails$Outbound = {
  reasoning_tokens?: number | null | undefined;
  accepted_prediction_tokens?: number | null | undefined;
  rejected_prediction_tokens?: number | null | undefined;
  audio_tokens?: number | null | undefined;
};

/** @internal */
export const CompletionTokensDetails$outboundSchema: z.ZodType<
  CompletionTokensDetails$Outbound,
  z.ZodTypeDef,
  CompletionTokensDetails
> = z.object({
  reasoningTokens: z.nullable(z.number()).optional(),
  acceptedPredictionTokens: z.nullable(z.number()).optional(),
  rejectedPredictionTokens: z.nullable(z.number()).optional(),
  audioTokens: z.nullable(z.number().int()).optional(),
}).transform((v) => {
  return remap$(v, {
    reasoningTokens: "reasoning_tokens",
    acceptedPredictionTokens: "accepted_prediction_tokens",
    rejectedPredictionTokens: "rejected_prediction_tokens",
    audioTokens: "audio_tokens",
  });
});

export function completionTokensDetailsToJSON(
  completionTokensDetails: CompletionTokensDetails,
): string {
  return JSON.stringify(
    CompletionTokensDetails$outboundSchema.parse(completionTokensDetails),
  );
}
export function completionTokensDetailsFromJSON(
  jsonString: string,
): SafeParseResult<CompletionTokensDetails, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CompletionTokensDetails$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CompletionTokensDetails' from JSON`,
  );
}

/** @internal */
export const Usage$inboundSchema: z.ZodType<Usage, z.ZodTypeDef, unknown> = z
  .object({
    completion_tokens: z.number().optional(),
    prompt_tokens: z.number().optional(),
    total_tokens: z.number().optional(),
    prompt_tokens_details: z.nullable(
      z.lazy(() => PromptTokensDetails$inboundSchema),
    ).optional(),
    completion_tokens_details: z.nullable(
      z.lazy(() => CompletionTokensDetails$inboundSchema),
    ).optional(),
  }).transform((v) => {
    return remap$(v, {
      "completion_tokens": "completionTokens",
      "prompt_tokens": "promptTokens",
      "total_tokens": "totalTokens",
      "prompt_tokens_details": "promptTokensDetails",
      "completion_tokens_details": "completionTokensDetails",
    });
  });
/** @internal */
export type Usage$Outbound = {
  completion_tokens?: number | undefined;
  prompt_tokens?: number | undefined;
  total_tokens?: number | undefined;
  prompt_tokens_details?: PromptTokensDetails$Outbound | null | undefined;
  completion_tokens_details?:
    | CompletionTokensDetails$Outbound
    | null
    | undefined;
};

/** @internal */
export const Usage$outboundSchema: z.ZodType<
  Usage$Outbound,
  z.ZodTypeDef,
  Usage
> = z.object({
  completionTokens: z.number().optional(),
  promptTokens: z.number().optional(),
  totalTokens: z.number().optional(),
  promptTokensDetails: z.nullable(
    z.lazy(() => PromptTokensDetails$outboundSchema),
  ).optional(),
  completionTokensDetails: z.nullable(
    z.lazy(() => CompletionTokensDetails$outboundSchema),
  ).optional(),
}).transform((v) => {
  return remap$(v, {
    completionTokens: "completion_tokens",
    promptTokens: "prompt_tokens",
    totalTokens: "total_tokens",
    promptTokensDetails: "prompt_tokens_details",
    completionTokensDetails: "completion_tokens_details",
  });
});

export function usageToJSON(usage: Usage): string {
  return JSON.stringify(Usage$outboundSchema.parse(usage));
}
export function usageFromJSON(
  jsonString: string,
): SafeParseResult<Usage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Usage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Usage' from JSON`,
  );
}

/** @internal */
export const FinishReason$inboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  z.nativeEnum(FinishReason);
/** @internal */
export const FinishReason$outboundSchema: z.ZodNativeEnum<typeof FinishReason> =
  FinishReason$inboundSchema;

/** @internal */
export const CreateAgentResponseType$inboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseType
> = z.nativeEnum(CreateAgentResponseType);
/** @internal */
export const CreateAgentResponseType$outboundSchema: z.ZodNativeEnum<
  typeof CreateAgentResponseType
> = CreateAgentResponseType$inboundSchema;

/** @internal */
export const FunctionT$inboundSchema: z.ZodType<
  FunctionT,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});
/** @internal */
export type FunctionT$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const FunctionT$outboundSchema: z.ZodType<
  FunctionT$Outbound,
  z.ZodTypeDef,
  FunctionT
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

export function functionToJSON(functionT: FunctionT): string {
  return JSON.stringify(FunctionT$outboundSchema.parse(functionT));
}
export function functionFromJSON(
  jsonString: string,
): SafeParseResult<FunctionT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionT' from JSON`,
  );
}

/** @internal */
export const PendingToolCalls$inboundSchema: z.ZodType<
  PendingToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: CreateAgentResponseType$inboundSchema,
  function: z.lazy(() => FunctionT$inboundSchema),
});
/** @internal */
export type PendingToolCalls$Outbound = {
  id: string;
  type: string;
  function: FunctionT$Outbound;
};

/** @internal */
export const PendingToolCalls$outboundSchema: z.ZodType<
  PendingToolCalls$Outbound,
  z.ZodTypeDef,
  PendingToolCalls
> = z.object({
  id: z.string(),
  type: CreateAgentResponseType$outboundSchema,
  function: z.lazy(() => FunctionT$outboundSchema),
});

export function pendingToolCallsToJSON(
  pendingToolCalls: PendingToolCalls,
): string {
  return JSON.stringify(
    PendingToolCalls$outboundSchema.parse(pendingToolCalls),
  );
}
export function pendingToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<PendingToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PendingToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PendingToolCalls' from JSON`,
  );
}

/** @internal */
export const CreateAgentResponse$inboundSchema: z.ZodType<
  CreateAgentResponse,
  z.ZodTypeDef,
  unknown
> = z.object({
  _id: z.string(),
  task_id: z.string(),
  output: z.array(AgentResponseMessage$inboundSchema),
  created_at: z.string(),
  model: z.string(),
  usage: z.nullable(z.lazy(() => Usage$inboundSchema)).optional(),
  finish_reason: FinishReason$inboundSchema.optional(),
  pending_tool_calls: z.array(z.lazy(() => PendingToolCalls$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "_id": "id",
    "task_id": "taskId",
    "created_at": "createdAt",
    "finish_reason": "finishReason",
    "pending_tool_calls": "pendingToolCalls",
  });
});
/** @internal */
export type CreateAgentResponse$Outbound = {
  _id: string;
  task_id: string;
  output: Array<AgentResponseMessage$Outbound>;
  created_at: string;
  model: string;
  usage?: Usage$Outbound | null | undefined;
  finish_reason?: string | undefined;
  pending_tool_calls?: Array<PendingToolCalls$Outbound> | undefined;
};

/** @internal */
export const CreateAgentResponse$outboundSchema: z.ZodType<
  CreateAgentResponse$Outbound,
  z.ZodTypeDef,
  CreateAgentResponse
> = z.object({
  id: z.string(),
  taskId: z.string(),
  output: z.array(AgentResponseMessage$outboundSchema),
  createdAt: z.string(),
  model: z.string(),
  usage: z.nullable(z.lazy(() => Usage$outboundSchema)).optional(),
  finishReason: FinishReason$outboundSchema.optional(),
  pendingToolCalls: z.array(z.lazy(() => PendingToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    id: "_id",
    taskId: "task_id",
    createdAt: "created_at",
    finishReason: "finish_reason",
    pendingToolCalls: "pending_tool_calls",
  });
});

export function createAgentResponseToJSON(
  createAgentResponse: CreateAgentResponse,
): string {
  return JSON.stringify(
    CreateAgentResponse$outboundSchema.parse(createAgentResponse),
  );
}
export function createAgentResponseFromJSON(
  jsonString: string,
): SafeParseResult<CreateAgentResponse, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateAgentResponse$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateAgentResponse' from JSON`,
  );
}
