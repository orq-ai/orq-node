/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type Inputs = string | number | boolean;

/**
 * The role of the messages author, in this case tool.
 */
export const DeploymentsPrefixMessages5Role = {
  Tool: "tool",
} as const;
/**
 * The role of the messages author, in this case tool.
 */
export type DeploymentsPrefixMessages5Role = ClosedEnum<
  typeof DeploymentsPrefixMessages5Role
>;

/**
 * The contents of the tool message.
 */
export type DeploymentsPrefixMessagesContent = string | Array<string>;

export type ToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: DeploymentsPrefixMessages5Role;
  /**
   * The contents of the tool message.
   */
  content: string | Array<string>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
};

/**
 * The type of the content part.
 */
export const Deployments2PrefixMessages4ContentType = {
  Refusal: "refusal",
} as const;
/**
 * The type of the content part.
 */
export type Deployments2PrefixMessages4ContentType = ClosedEnum<
  typeof Deployments2PrefixMessages4ContentType
>;

export type RefusalContentPart = {
  /**
   * The type of the content part.
   */
  type: Deployments2PrefixMessages4ContentType;
  /**
   * The refusal message generated by the model.
   */
  refusal: string;
};

/**
 * The type of the content part.
 */
export const Deployments2PrefixMessages4Type = {
  Text: "text",
} as const;
/**
 * The type of the content part.
 */
export type Deployments2PrefixMessages4Type = ClosedEnum<
  typeof Deployments2PrefixMessages4Type
>;

export type TextContentPart = {
  /**
   * The type of the content part.
   */
  type: Deployments2PrefixMessages4Type;
  /**
   * The text content.
   */
  text: string;
};

export type Content2 = TextContentPart | RefusalContentPart;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type PrefixMessagesContent =
  | string
  | Array<TextContentPart | RefusalContentPart>;

/**
 * The role of the messages author, in this case `assistant`.
 */
export const DeploymentsPrefixMessages4Role = {
  Assistant: "assistant",
} as const;
/**
 * The role of the messages author, in this case `assistant`.
 */
export type DeploymentsPrefixMessages4Role = ClosedEnum<
  typeof DeploymentsPrefixMessages4Role
>;

/**
 * Data about a previous audio response from the model.
 */
export type Audio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const Type = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type Type = ClosedEnum<typeof Type>;

export type FunctionT = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type ToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: Type;
  function: FunctionT;
};

export type AssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<TextContentPart | RefusalContentPart>
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: DeploymentsPrefixMessages4Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: Audio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<ToolCalls> | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the messages author, in this case `user`.
 */
export const DeploymentsPrefixMessagesRole = {
  User: "user",
} as const;
/**
 * The role of the messages author, in this case `user`.
 */
export type DeploymentsPrefixMessagesRole = ClosedEnum<
  typeof DeploymentsPrefixMessagesRole
>;

/**
 * The type of the content part. Always `file`.
 */
export const Deployments2PrefixMessagesType = {
  File: "file",
} as const;
/**
 * The type of the content part. Always `file`.
 */
export type Deployments2PrefixMessagesType = ClosedEnum<
  typeof Deployments2PrefixMessagesType
>;

export type FileT = {
  /**
   * The base64 encoded file data, used when passing the file to the model as a string.
   */
  fileData: string;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Four = {
  /**
   * The type of the content part. Always `file`.
   */
  type: Deployments2PrefixMessagesType;
  file: FileT;
};

export const Deployments2Type = {
  InputAudio: "input_audio",
} as const;
export type Deployments2Type = ClosedEnum<typeof Deployments2Type>;

/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export const Format = {
  Mp3: "mp3",
  Wav: "wav",
} as const;
/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export type Format = ClosedEnum<typeof Format>;

export type InputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports `wav` and `mp3`.
   */
  format: Format;
};

export type Deployments23 = {
  type: Deployments2Type;
  inputAudio: InputAudio;
};

export const TwoType = {
  ImageUrl: "image_url",
} as const;
export type TwoType = ClosedEnum<typeof TwoType>;

/**
 * Specifies the detail level of the image.
 */
export const Detail = {
  Low: "low",
  High: "high",
  Auto: "auto",
} as const;
/**
 * Specifies the detail level of the image.
 */
export type Detail = ClosedEnum<typeof Detail>;

export type ImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded image data.
   */
  url: string;
  /**
   * Specifies the detail level of the image.
   */
  detail?: Detail | undefined;
};

export type Two2 = {
  type: TwoType;
  imageUrl: ImageUrl;
};

export const Deployments2PrefixMessages3Type = {
  Text: "text",
} as const;
export type Deployments2PrefixMessages3Type = ClosedEnum<
  typeof Deployments2PrefixMessages3Type
>;

export type Deployments21 = {
  type: Deployments2PrefixMessages3Type;
  text: string;
};

export type Two = Deployments21 | Two2 | Deployments23 | Four;

/**
 * The contents of the user message.
 */
export type Content =
  | string
  | Array<Deployments21 | Two2 | Deployments23 | Four>;

export type UserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: DeploymentsPrefixMessagesRole;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content: string | Array<Deployments21 | Two2 | Deployments23 | Four>;
};

/**
 * The role of the messages author, in this case `system`.
 */
export const PrefixMessagesRole = {
  System: "system",
} as const;
/**
 * The role of the messages author, in this case `system`.
 */
export type PrefixMessagesRole = ClosedEnum<typeof PrefixMessagesRole>;

export type SystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: PrefixMessagesRole;
  /**
   * The contents of the system message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The role of the messages author, in this case  `developer`.
 */
export const Role = {
  Developer: "developer",
} as const;
/**
 * The role of the messages author, in this case  `developer`.
 */
export type Role = ClosedEnum<typeof Role>;

export type DeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: Role;
  /**
   * The contents of the developer message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type PrefixMessages =
  | DeveloperMessage
  | SystemMessage
  | UserMessage
  | ToolMessage
  | AssistantMessage;

/**
 * The role of the messages author, in this case tool.
 */
export const DeploymentsMessages5Role = {
  Tool: "tool",
} as const;
/**
 * The role of the messages author, in this case tool.
 */
export type DeploymentsMessages5Role = ClosedEnum<
  typeof DeploymentsMessages5Role
>;

/**
 * The contents of the tool message.
 */
export type DeploymentsMessages5Content = string | Array<string>;

export type MessagesToolMessage = {
  /**
   * The role of the messages author, in this case tool.
   */
  role: DeploymentsMessages5Role;
  /**
   * The contents of the tool message.
   */
  content: string | Array<string>;
  /**
   * Tool call that this message is responding to.
   */
  toolCallId: string;
};

/**
 * The type of the content part.
 */
export const Deployments2Messages4ContentType = {
  Refusal: "refusal",
} as const;
/**
 * The type of the content part.
 */
export type Deployments2Messages4ContentType = ClosedEnum<
  typeof Deployments2Messages4ContentType
>;

export type TwoRefusalContentPart = {
  /**
   * The type of the content part.
   */
  type: Deployments2Messages4ContentType;
  /**
   * The refusal message generated by the model.
   */
  refusal: string;
};

/**
 * The type of the content part.
 */
export const Deployments2Messages4Type = {
  Text: "text",
} as const;
/**
 * The type of the content part.
 */
export type Deployments2Messages4Type = ClosedEnum<
  typeof Deployments2Messages4Type
>;

export type TwoTextContentPart = {
  /**
   * The type of the content part.
   */
  type: Deployments2Messages4Type;
  /**
   * The text content.
   */
  text: string;
};

export type DeploymentsContentMessages2 =
  | TwoTextContentPart
  | TwoRefusalContentPart;

/**
 * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
 */
export type DeploymentsMessagesContent =
  | string
  | Array<TwoTextContentPart | TwoRefusalContentPart>;

/**
 * The role of the messages author, in this case `assistant`.
 */
export const DeploymentsMessages4Role = {
  Assistant: "assistant",
} as const;
/**
 * The role of the messages author, in this case `assistant`.
 */
export type DeploymentsMessages4Role = ClosedEnum<
  typeof DeploymentsMessages4Role
>;

/**
 * Data about a previous audio response from the model.
 */
export type MessagesAudio = {
  /**
   * Unique identifier for a previous audio response from the model.
   */
  id: string;
};

/**
 * The type of the tool. Currently, only `function` is supported.
 */
export const MessagesType = {
  Function: "function",
} as const;
/**
 * The type of the tool. Currently, only `function` is supported.
 */
export type MessagesType = ClosedEnum<typeof MessagesType>;

export type MessagesFunction = {
  /**
   * The name of the function to call.
   */
  name?: string | undefined;
  /**
   * The arguments to call the function with, as generated by the model in JSON format. Note that the model does not always generate valid JSON, and may hallucinate parameters not defined by your function schema. Validate the arguments in your code before calling your function.
   */
  arguments?: string | undefined;
};

export type MessagesToolCalls = {
  /**
   * The ID of the tool call.
   */
  id: string;
  /**
   * The type of the tool. Currently, only `function` is supported.
   */
  type: MessagesType;
  function: MessagesFunction;
};

export type MessagesAssistantMessage = {
  /**
   * The contents of the assistant message. Required unless `tool_calls` or `function_call` is specified.
   */
  content?:
    | string
    | Array<TwoTextContentPart | TwoRefusalContentPart>
    | null
    | undefined;
  /**
   * The refusal message by the assistant.
   */
  refusal?: string | null | undefined;
  /**
   * The role of the messages author, in this case `assistant`.
   */
  role: DeploymentsMessages4Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * Data about a previous audio response from the model.
   */
  audio?: MessagesAudio | null | undefined;
  /**
   * The tool calls generated by the model, such as function calls.
   */
  toolCalls?: Array<MessagesToolCalls> | undefined;
  /**
   * Internal thought process of the model
   */
  reasoning?: string | undefined;
  /**
   * The signature holds a cryptographic token which verifies that the thinking block was generated by the model, and is verified when thinking is part of a multiturn conversation. This value should not be modified and should always be sent to the API when the reasoning is redacted. Currently only supported by `Anthropic`.
   */
  reasoningSignature?: string | undefined;
  /**
   * Occasionally the model's internal reasoning will be flagged by the safety systems of the provider. When this occurs, the provider will encrypt the reasoning. These redacted reasoning is decrypted when passed back to the API, allowing the model to continue its response without losing context.
   */
  redactedReasoning?: string | undefined;
};

/**
 * The role of the messages author, in this case `user`.
 */
export const DeploymentsMessages3Role = {
  User: "user",
} as const;
/**
 * The role of the messages author, in this case `user`.
 */
export type DeploymentsMessages3Role = ClosedEnum<
  typeof DeploymentsMessages3Role
>;

/**
 * The type of the content part. Always `file`.
 */
export const Deployments2Messages3Content4Type = {
  File: "file",
} as const;
/**
 * The type of the content part. Always `file`.
 */
export type Deployments2Messages3Content4Type = ClosedEnum<
  typeof Deployments2Messages3Content4Type
>;

export type TwoFile = {
  /**
   * The base64 encoded file data, used when passing the file to the model as a string.
   */
  fileData: string;
  /**
   * The name of the file, used when passing the file to the model as a string.
   */
  filename?: string | undefined;
};

export type Two4 = {
  /**
   * The type of the content part. Always `file`.
   */
  type: Deployments2Messages3Content4Type;
  file: TwoFile;
};

export const Deployments2Messages3ContentType = {
  InputAudio: "input_audio",
} as const;
export type Deployments2Messages3ContentType = ClosedEnum<
  typeof Deployments2Messages3ContentType
>;

/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export const TwoFormat = {
  Mp3: "mp3",
  Wav: "wav",
} as const;
/**
 * The format of the encoded audio data. Currently supports `wav` and `mp3`.
 */
export type TwoFormat = ClosedEnum<typeof TwoFormat>;

export type TwoInputAudio = {
  /**
   * Base64 encoded audio data.
   */
  data: string;
  /**
   * The format of the encoded audio data. Currently supports `wav` and `mp3`.
   */
  format: TwoFormat;
};

export type Two3 = {
  type: Deployments2Messages3ContentType;
  inputAudio: TwoInputAudio;
};

export const Deployments2Messages3Type = {
  ImageUrl: "image_url",
} as const;
export type Deployments2Messages3Type = ClosedEnum<
  typeof Deployments2Messages3Type
>;

/**
 * Specifies the detail level of the image.
 */
export const TwoDetail = {
  Low: "low",
  High: "high",
  Auto: "auto",
} as const;
/**
 * Specifies the detail level of the image.
 */
export type TwoDetail = ClosedEnum<typeof TwoDetail>;

export type TwoImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded image data.
   */
  url: string;
  /**
   * Specifies the detail level of the image.
   */
  detail?: TwoDetail | undefined;
};

export type Deployments22 = {
  type: Deployments2Messages3Type;
  imageUrl: TwoImageUrl;
};

export const Deployments2MessagesType = {
  Text: "text",
} as const;
export type Deployments2MessagesType = ClosedEnum<
  typeof Deployments2MessagesType
>;

export type Two1 = {
  type: Deployments2MessagesType;
  text: string;
};

export type DeploymentsContent2 = Two1 | Deployments22 | Two3 | Two4;

/**
 * The contents of the user message.
 */
export type MessagesContent =
  | string
  | Array<Two1 | Deployments22 | Two3 | Two4>;

export type MessagesUserMessage = {
  /**
   * The role of the messages author, in this case `user`.
   */
  role: DeploymentsMessages3Role;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
  /**
   * The contents of the user message.
   */
  content: string | Array<Two1 | Deployments22 | Two3 | Two4>;
};

/**
 * The role of the messages author, in this case `system`.
 */
export const DeploymentsMessagesRole = {
  System: "system",
} as const;
/**
 * The role of the messages author, in this case `system`.
 */
export type DeploymentsMessagesRole = ClosedEnum<
  typeof DeploymentsMessagesRole
>;

export type MessagesSystemMessage = {
  /**
   * The role of the messages author, in this case `system`.
   */
  role: DeploymentsMessagesRole;
  /**
   * The contents of the system message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

/**
 * The role of the messages author, in this case  `developer`.
 */
export const MessagesRole = {
  Developer: "developer",
} as const;
/**
 * The role of the messages author, in this case  `developer`.
 */
export type MessagesRole = ClosedEnum<typeof MessagesRole>;

export type MessagesDeveloperMessage = {
  /**
   * The role of the messages author, in this case  `developer`.
   */
  role: MessagesRole;
  /**
   * The contents of the developer message.
   */
  content: string;
  /**
   * An optional name for the participant. Provides the model information to differentiate between participants of the same role.
   */
  name?: string | undefined;
};

export type Messages =
  | MessagesDeveloperMessage
  | MessagesSystemMessage
  | MessagesUserMessage
  | MessagesToolMessage
  | MessagesAssistantMessage;

/**
 * Metadata about the document
 */
export type Metadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: Metadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
  /**
   * A mock response to use instead of calling the LLM API. This is useful for testing purposes. When provided, the system will return a response object with this content as the completion, without making an actual API call to the LLM provider. This works for both streaming and non-streaming requests. Mock responses will not generate logs, traces or be counted for your plan usage.
   */
  mockResponse?: string | undefined;
};

export type Thread = {
  /**
   * Unique thread identifier to group related invocations.
   */
  id: string;
  /**
   * Optional tags to differentiate or categorize threads
   */
  tags?: Array<string> | undefined;
};

/**
 * Exists
 */
export type DollarOrDollarExists = {
  dollarExists: boolean;
};

export type DollarOrDollarNin = string | number | boolean;

/**
 * Not in
 */
export type DeploymentsDollarOrDollarNin = {
  dollarNin: Array<string | number | boolean>;
};

export type DollarOrDollarIn = string | number | boolean;

/**
 * In
 */
export type DeploymentsDollarOrDollarIn = {
  dollarIn: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type DollarOrDollarLte = {
  dollarLte: number;
};

/**
 * Less than
 */
export type DollarOrDollarLt = {
  dollarLt: number;
};

/**
 * Greater than or equal to
 */
export type DollarOrDollarGte = {
  dollarGte: number;
};

export type DollarOr3 = {
  dollarGt: number;
};

export type DollarOrDollarNe = string | number | boolean;

/**
 * Not equal to
 */
export type DeploymentsDollarOrDollarNe = {
  dollarNe: string | number | boolean;
};

export type DollarOrDollarEq = string | number | boolean;

/**
 * Equal to
 */
export type DeploymentsDollarOrDollarEq = {
  dollarEq: string | number | boolean;
};

export type DollarOr =
  | DeploymentsDollarOrDollarEq
  | DeploymentsDollarOrDollarNe
  | DollarOr3
  | DollarOrDollarGte
  | DollarOrDollarLt
  | DollarOrDollarLte
  | DeploymentsDollarOrDollarIn
  | DeploymentsDollarOrDollarNin
  | DollarOrDollarExists;

/**
 * Or
 */
export type KnowledgeFilterDollarOr = {
  dollarOr: Array<
    {
      [k: string]:
        | DeploymentsDollarOrDollarEq
        | DeploymentsDollarOrDollarNe
        | DollarOr3
        | DollarOrDollarGte
        | DollarOrDollarLt
        | DollarOrDollarLte
        | DeploymentsDollarOrDollarIn
        | DeploymentsDollarOrDollarNin
        | DollarOrDollarExists;
    }
  >;
};

/**
 * Exists
 */
export type DollarAndDollarExists = {
  dollarExists: boolean;
};

export type DollarAndDollarNin = string | number | boolean;

/**
 * Not in
 */
export type DeploymentsDollarAndDollarNin = {
  dollarNin: Array<string | number | boolean>;
};

export type DollarAndDollarIn = string | number | boolean;

/**
 * In
 */
export type DeploymentsDollarAndDollarIn = {
  dollarIn: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type DollarAndDollarLte = {
  dollarLte: number;
};

/**
 * Less than
 */
export type DollarAndDollarLt = {
  dollarLt: number;
};

/**
 * Greater than or equal to
 */
export type DollarAndDollarGte = {
  dollarGte: number;
};

export type DollarAnd3 = {
  dollarGt: number;
};

export type DollarAndDollarNe = string | number | boolean;

/**
 * Not equal to
 */
export type DeploymentsDollarAndDollarNe = {
  dollarNe: string | number | boolean;
};

export type DollarAndDollarEq = string | number | boolean;

/**
 * Equal to
 */
export type DeploymentsDollarAndDollarEq = {
  dollarEq: string | number | boolean;
};

export type DollarAnd =
  | DeploymentsDollarAndDollarEq
  | DeploymentsDollarAndDollarNe
  | DollarAnd3
  | DollarAndDollarGte
  | DollarAndDollarLt
  | DollarAndDollarLte
  | DeploymentsDollarAndDollarIn
  | DeploymentsDollarAndDollarNin
  | DollarAndDollarExists;

/**
 * And
 */
export type KnowledgeFilterDollarAnd = {
  dollarAnd: Array<
    {
      [k: string]:
        | DeploymentsDollarAndDollarEq
        | DeploymentsDollarAndDollarNe
        | DollarAnd3
        | DollarAndDollarGte
        | DollarAndDollarLt
        | DollarAndDollarLte
        | DeploymentsDollarAndDollarIn
        | DeploymentsDollarAndDollarNin
        | DollarAndDollarExists;
    }
  >;
};

/**
 * Exists
 */
export type DollarExists = {
  dollarExists: boolean;
};

export type DollarNin = string | number | boolean;

/**
 * Not in
 */
export type OneDollarNin = {
  dollarNin: Array<string | number | boolean>;
};

export type DollarIn = string | number | boolean;

/**
 * In
 */
export type OneDollarIn = {
  dollarIn: Array<string | number | boolean>;
};

/**
 * Less than or equal to
 */
export type DollarLte = {
  dollarLte: number;
};

/**
 * Less than
 */
export type DollarLt = {
  dollarLt: number;
};

/**
 * Greater than or equal to
 */
export type DollarGte = {
  dollarGte: number;
};

export type Three = {
  dollarGt: number;
};

export type DollarNe = string | number | boolean;

/**
 * Not equal to
 */
export type OneDollarNe = {
  dollarNe: string | number | boolean;
};

export type DollarEq = string | number | boolean;

/**
 * Equal to
 */
export type OneDollarEq = {
  dollarEq: string | number | boolean;
};

export type One =
  | OneDollarEq
  | OneDollarNe
  | Three
  | DollarGte
  | DollarLt
  | DollarLte
  | OneDollarIn
  | OneDollarNin
  | DollarExists;

/**
 * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
 */
export type KnowledgeFilter =
  | KnowledgeFilterDollarAnd
  | KnowledgeFilterDollarOr
  | {
    [k: string]:
      | OneDollarEq
      | OneDollarNe
      | Three
      | DollarGte
      | DollarLt
      | DollarLte
      | OneDollarIn
      | OneDollarNin
      | DollarExists;
  };

/**
 * The deployment request payload
 */
export type Deployments = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: string | number | boolean } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your deployment routing configuration
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?:
    | Array<
      | DeveloperMessage
      | SystemMessage
      | UserMessage
      | ToolMessage
      | AssistantMessage
    >
    | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?:
    | Array<
      | MessagesDeveloperMessage
      | MessagesSystemMessage
      | MessagesUserMessage
      | MessagesToolMessage
      | MessagesAssistantMessage
    >
    | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
  thread?: Thread | undefined;
  /**
   * A filter to apply to the knowledge base chunk metadata when using  knowledge bases in the deployment.
   */
  knowledgeFilter?: KnowledgeFilterDollarAnd | KnowledgeFilterDollarOr | {
    [k: string]:
      | OneDollarEq
      | OneDollarNe
      | Three
      | DollarGte
      | DollarLt
      | DollarLte
      | OneDollarIn
      | OneDollarNin
      | DollarExists;
  } | undefined;
};

/** @internal */
export const Inputs$inboundSchema: z.ZodType<Inputs, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type Inputs$Outbound = string | number | boolean;

/** @internal */
export const Inputs$outboundSchema: z.ZodType<
  Inputs$Outbound,
  z.ZodTypeDef,
  Inputs
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Inputs$ {
  /** @deprecated use `Inputs$inboundSchema` instead. */
  export const inboundSchema = Inputs$inboundSchema;
  /** @deprecated use `Inputs$outboundSchema` instead. */
  export const outboundSchema = Inputs$outboundSchema;
  /** @deprecated use `Inputs$Outbound` instead. */
  export type Outbound = Inputs$Outbound;
}

export function inputsToJSON(inputs: Inputs): string {
  return JSON.stringify(Inputs$outboundSchema.parse(inputs));
}

export function inputsFromJSON(
  jsonString: string,
): SafeParseResult<Inputs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Inputs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Inputs' from JSON`,
  );
}

/** @internal */
export const DeploymentsPrefixMessages5Role$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessages5Role
> = z.nativeEnum(DeploymentsPrefixMessages5Role);

/** @internal */
export const DeploymentsPrefixMessages5Role$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessages5Role
> = DeploymentsPrefixMessages5Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsPrefixMessages5Role$ {
  /** @deprecated use `DeploymentsPrefixMessages5Role$inboundSchema` instead. */
  export const inboundSchema = DeploymentsPrefixMessages5Role$inboundSchema;
  /** @deprecated use `DeploymentsPrefixMessages5Role$outboundSchema` instead. */
  export const outboundSchema = DeploymentsPrefixMessages5Role$outboundSchema;
}

/** @internal */
export const DeploymentsPrefixMessagesContent$inboundSchema: z.ZodType<
  DeploymentsPrefixMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type DeploymentsPrefixMessagesContent$Outbound = string | Array<string>;

/** @internal */
export const DeploymentsPrefixMessagesContent$outboundSchema: z.ZodType<
  DeploymentsPrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentsPrefixMessagesContent
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsPrefixMessagesContent$ {
  /** @deprecated use `DeploymentsPrefixMessagesContent$inboundSchema` instead. */
  export const inboundSchema = DeploymentsPrefixMessagesContent$inboundSchema;
  /** @deprecated use `DeploymentsPrefixMessagesContent$outboundSchema` instead. */
  export const outboundSchema = DeploymentsPrefixMessagesContent$outboundSchema;
  /** @deprecated use `DeploymentsPrefixMessagesContent$Outbound` instead. */
  export type Outbound = DeploymentsPrefixMessagesContent$Outbound;
}

export function deploymentsPrefixMessagesContentToJSON(
  deploymentsPrefixMessagesContent: DeploymentsPrefixMessagesContent,
): string {
  return JSON.stringify(
    DeploymentsPrefixMessagesContent$outboundSchema.parse(
      deploymentsPrefixMessagesContent,
    ),
  );
}

export function deploymentsPrefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsPrefixMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsPrefixMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsPrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const ToolMessage$inboundSchema: z.ZodType<
  ToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsPrefixMessages5Role$inboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  tool_call_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});

/** @internal */
export type ToolMessage$Outbound = {
  role: string;
  content: string | Array<string>;
  tool_call_id: string;
};

/** @internal */
export const ToolMessage$outboundSchema: z.ZodType<
  ToolMessage$Outbound,
  z.ZodTypeDef,
  ToolMessage
> = z.object({
  role: DeploymentsPrefixMessages5Role$outboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  toolCallId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolMessage$ {
  /** @deprecated use `ToolMessage$inboundSchema` instead. */
  export const inboundSchema = ToolMessage$inboundSchema;
  /** @deprecated use `ToolMessage$outboundSchema` instead. */
  export const outboundSchema = ToolMessage$outboundSchema;
  /** @deprecated use `ToolMessage$Outbound` instead. */
  export type Outbound = ToolMessage$Outbound;
}

export function toolMessageToJSON(toolMessage: ToolMessage): string {
  return JSON.stringify(ToolMessage$outboundSchema.parse(toolMessage));
}

export function toolMessageFromJSON(
  jsonString: string,
): SafeParseResult<ToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolMessage' from JSON`,
  );
}

/** @internal */
export const Deployments2PrefixMessages4ContentType$inboundSchema:
  z.ZodNativeEnum<typeof Deployments2PrefixMessages4ContentType> = z.nativeEnum(
    Deployments2PrefixMessages4ContentType,
  );

/** @internal */
export const Deployments2PrefixMessages4ContentType$outboundSchema:
  z.ZodNativeEnum<typeof Deployments2PrefixMessages4ContentType> =
    Deployments2PrefixMessages4ContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2PrefixMessages4ContentType$ {
  /** @deprecated use `Deployments2PrefixMessages4ContentType$inboundSchema` instead. */
  export const inboundSchema =
    Deployments2PrefixMessages4ContentType$inboundSchema;
  /** @deprecated use `Deployments2PrefixMessages4ContentType$outboundSchema` instead. */
  export const outboundSchema =
    Deployments2PrefixMessages4ContentType$outboundSchema;
}

/** @internal */
export const RefusalContentPart$inboundSchema: z.ZodType<
  RefusalContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2PrefixMessages4ContentType$inboundSchema,
  refusal: z.string(),
});

/** @internal */
export type RefusalContentPart$Outbound = {
  type: string;
  refusal: string;
};

/** @internal */
export const RefusalContentPart$outboundSchema: z.ZodType<
  RefusalContentPart$Outbound,
  z.ZodTypeDef,
  RefusalContentPart
> = z.object({
  type: Deployments2PrefixMessages4ContentType$outboundSchema,
  refusal: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RefusalContentPart$ {
  /** @deprecated use `RefusalContentPart$inboundSchema` instead. */
  export const inboundSchema = RefusalContentPart$inboundSchema;
  /** @deprecated use `RefusalContentPart$outboundSchema` instead. */
  export const outboundSchema = RefusalContentPart$outboundSchema;
  /** @deprecated use `RefusalContentPart$Outbound` instead. */
  export type Outbound = RefusalContentPart$Outbound;
}

export function refusalContentPartToJSON(
  refusalContentPart: RefusalContentPart,
): string {
  return JSON.stringify(
    RefusalContentPart$outboundSchema.parse(refusalContentPart),
  );
}

export function refusalContentPartFromJSON(
  jsonString: string,
): SafeParseResult<RefusalContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RefusalContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RefusalContentPart' from JSON`,
  );
}

/** @internal */
export const Deployments2PrefixMessages4Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessages4Type
> = z.nativeEnum(Deployments2PrefixMessages4Type);

/** @internal */
export const Deployments2PrefixMessages4Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessages4Type
> = Deployments2PrefixMessages4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2PrefixMessages4Type$ {
  /** @deprecated use `Deployments2PrefixMessages4Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2PrefixMessages4Type$inboundSchema;
  /** @deprecated use `Deployments2PrefixMessages4Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2PrefixMessages4Type$outboundSchema;
}

/** @internal */
export const TextContentPart$inboundSchema: z.ZodType<
  TextContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2PrefixMessages4Type$inboundSchema,
  text: z.string(),
});

/** @internal */
export type TextContentPart$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const TextContentPart$outboundSchema: z.ZodType<
  TextContentPart$Outbound,
  z.ZodTypeDef,
  TextContentPart
> = z.object({
  type: Deployments2PrefixMessages4Type$outboundSchema,
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TextContentPart$ {
  /** @deprecated use `TextContentPart$inboundSchema` instead. */
  export const inboundSchema = TextContentPart$inboundSchema;
  /** @deprecated use `TextContentPart$outboundSchema` instead. */
  export const outboundSchema = TextContentPart$outboundSchema;
  /** @deprecated use `TextContentPart$Outbound` instead. */
  export type Outbound = TextContentPart$Outbound;
}

export function textContentPartToJSON(
  textContentPart: TextContentPart,
): string {
  return JSON.stringify(TextContentPart$outboundSchema.parse(textContentPart));
}

export function textContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TextContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TextContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TextContentPart' from JSON`,
  );
}

/** @internal */
export const Content2$inboundSchema: z.ZodType<
  Content2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TextContentPart$inboundSchema),
  z.lazy(() => RefusalContentPart$inboundSchema),
]);

/** @internal */
export type Content2$Outbound =
  | TextContentPart$Outbound
  | RefusalContentPart$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  z.lazy(() => TextContentPart$outboundSchema),
  z.lazy(() => RefusalContentPart$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content2$ {
  /** @deprecated use `Content2$inboundSchema` instead. */
  export const inboundSchema = Content2$inboundSchema;
  /** @deprecated use `Content2$outboundSchema` instead. */
  export const outboundSchema = Content2$outboundSchema;
  /** @deprecated use `Content2$Outbound` instead. */
  export type Outbound = Content2$Outbound;
}

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}

export function content2FromJSON(
  jsonString: string,
): SafeParseResult<Content2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content2' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesContent$inboundSchema: z.ZodType<
  PrefixMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TextContentPart$inboundSchema),
    z.lazy(() => RefusalContentPart$inboundSchema),
  ])),
]);

/** @internal */
export type PrefixMessagesContent$Outbound =
  | string
  | Array<TextContentPart$Outbound | RefusalContentPart$Outbound>;

/** @internal */
export const PrefixMessagesContent$outboundSchema: z.ZodType<
  PrefixMessagesContent$Outbound,
  z.ZodTypeDef,
  PrefixMessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TextContentPart$outboundSchema),
    z.lazy(() => RefusalContentPart$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixMessagesContent$ {
  /** @deprecated use `PrefixMessagesContent$inboundSchema` instead. */
  export const inboundSchema = PrefixMessagesContent$inboundSchema;
  /** @deprecated use `PrefixMessagesContent$outboundSchema` instead. */
  export const outboundSchema = PrefixMessagesContent$outboundSchema;
  /** @deprecated use `PrefixMessagesContent$Outbound` instead. */
  export type Outbound = PrefixMessagesContent$Outbound;
}

export function prefixMessagesContentToJSON(
  prefixMessagesContent: PrefixMessagesContent,
): string {
  return JSON.stringify(
    PrefixMessagesContent$outboundSchema.parse(prefixMessagesContent),
  );
}

export function prefixMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessagesContent' from JSON`,
  );
}

/** @internal */
export const DeploymentsPrefixMessages4Role$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessages4Role
> = z.nativeEnum(DeploymentsPrefixMessages4Role);

/** @internal */
export const DeploymentsPrefixMessages4Role$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessages4Role
> = DeploymentsPrefixMessages4Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsPrefixMessages4Role$ {
  /** @deprecated use `DeploymentsPrefixMessages4Role$inboundSchema` instead. */
  export const inboundSchema = DeploymentsPrefixMessages4Role$inboundSchema;
  /** @deprecated use `DeploymentsPrefixMessages4Role$outboundSchema` instead. */
  export const outboundSchema = DeploymentsPrefixMessages4Role$outboundSchema;
}

/** @internal */
export const Audio$inboundSchema: z.ZodType<Audio, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
  });

/** @internal */
export type Audio$Outbound = {
  id: string;
};

/** @internal */
export const Audio$outboundSchema: z.ZodType<
  Audio$Outbound,
  z.ZodTypeDef,
  Audio
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Audio$ {
  /** @deprecated use `Audio$inboundSchema` instead. */
  export const inboundSchema = Audio$inboundSchema;
  /** @deprecated use `Audio$outboundSchema` instead. */
  export const outboundSchema = Audio$outboundSchema;
  /** @deprecated use `Audio$Outbound` instead. */
  export type Outbound = Audio$Outbound;
}

export function audioToJSON(audio: Audio): string {
  return JSON.stringify(Audio$outboundSchema.parse(audio));
}

export function audioFromJSON(
  jsonString: string,
): SafeParseResult<Audio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Audio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Audio' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const FunctionT$inboundSchema: z.ZodType<
  FunctionT,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

/** @internal */
export type FunctionT$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const FunctionT$outboundSchema: z.ZodType<
  FunctionT$Outbound,
  z.ZodTypeDef,
  FunctionT
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FunctionT$ {
  /** @deprecated use `FunctionT$inboundSchema` instead. */
  export const inboundSchema = FunctionT$inboundSchema;
  /** @deprecated use `FunctionT$outboundSchema` instead. */
  export const outboundSchema = FunctionT$outboundSchema;
  /** @deprecated use `FunctionT$Outbound` instead. */
  export type Outbound = FunctionT$Outbound;
}

export function functionToJSON(functionT: FunctionT): string {
  return JSON.stringify(FunctionT$outboundSchema.parse(functionT));
}

export function functionFromJSON(
  jsonString: string,
): SafeParseResult<FunctionT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionT' from JSON`,
  );
}

/** @internal */
export const ToolCalls$inboundSchema: z.ZodType<
  ToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: Type$inboundSchema,
  function: z.lazy(() => FunctionT$inboundSchema),
});

/** @internal */
export type ToolCalls$Outbound = {
  id: string;
  type: string;
  function: FunctionT$Outbound;
};

/** @internal */
export const ToolCalls$outboundSchema: z.ZodType<
  ToolCalls$Outbound,
  z.ZodTypeDef,
  ToolCalls
> = z.object({
  id: z.string(),
  type: Type$outboundSchema,
  function: z.lazy(() => FunctionT$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolCalls$ {
  /** @deprecated use `ToolCalls$inboundSchema` instead. */
  export const inboundSchema = ToolCalls$inboundSchema;
  /** @deprecated use `ToolCalls$outboundSchema` instead. */
  export const outboundSchema = ToolCalls$outboundSchema;
  /** @deprecated use `ToolCalls$Outbound` instead. */
  export type Outbound = ToolCalls$Outbound;
}

export function toolCallsToJSON(toolCalls: ToolCalls): string {
  return JSON.stringify(ToolCalls$outboundSchema.parse(toolCalls));
}

export function toolCallsFromJSON(
  jsonString: string,
): SafeParseResult<ToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolCalls' from JSON`,
  );
}

/** @internal */
export const AssistantMessage$inboundSchema: z.ZodType<
  AssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(z.union([
        z.lazy(() => TextContentPart$inboundSchema),
        z.lazy(() => RefusalContentPart$inboundSchema),
      ])),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: DeploymentsPrefixMessages4Role$inboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => ToolCalls$inboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});

/** @internal */
export type AssistantMessage$Outbound = {
  content?:
    | string
    | Array<TextContentPart$Outbound | RefusalContentPart$Outbound>
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: string;
  name?: string | undefined;
  audio?: Audio$Outbound | null | undefined;
  tool_calls?: Array<ToolCalls$Outbound> | undefined;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const AssistantMessage$outboundSchema: z.ZodType<
  AssistantMessage$Outbound,
  z.ZodTypeDef,
  AssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TextContentPart$outboundSchema),
          z.lazy(() => RefusalContentPart$outboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: DeploymentsPrefixMessages4Role$outboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => Audio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => ToolCalls$outboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AssistantMessage$ {
  /** @deprecated use `AssistantMessage$inboundSchema` instead. */
  export const inboundSchema = AssistantMessage$inboundSchema;
  /** @deprecated use `AssistantMessage$outboundSchema` instead. */
  export const outboundSchema = AssistantMessage$outboundSchema;
  /** @deprecated use `AssistantMessage$Outbound` instead. */
  export type Outbound = AssistantMessage$Outbound;
}

export function assistantMessageToJSON(
  assistantMessage: AssistantMessage,
): string {
  return JSON.stringify(
    AssistantMessage$outboundSchema.parse(assistantMessage),
  );
}

export function assistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<AssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => AssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'AssistantMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentsPrefixMessagesRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessagesRole
> = z.nativeEnum(DeploymentsPrefixMessagesRole);

/** @internal */
export const DeploymentsPrefixMessagesRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsPrefixMessagesRole
> = DeploymentsPrefixMessagesRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsPrefixMessagesRole$ {
  /** @deprecated use `DeploymentsPrefixMessagesRole$inboundSchema` instead. */
  export const inboundSchema = DeploymentsPrefixMessagesRole$inboundSchema;
  /** @deprecated use `DeploymentsPrefixMessagesRole$outboundSchema` instead. */
  export const outboundSchema = DeploymentsPrefixMessagesRole$outboundSchema;
}

/** @internal */
export const Deployments2PrefixMessagesType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessagesType
> = z.nativeEnum(Deployments2PrefixMessagesType);

/** @internal */
export const Deployments2PrefixMessagesType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessagesType
> = Deployments2PrefixMessagesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2PrefixMessagesType$ {
  /** @deprecated use `Deployments2PrefixMessagesType$inboundSchema` instead. */
  export const inboundSchema = Deployments2PrefixMessagesType$inboundSchema;
  /** @deprecated use `Deployments2PrefixMessagesType$outboundSchema` instead. */
  export const outboundSchema = Deployments2PrefixMessagesType$outboundSchema;
}

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    file_data: z.string(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });

/** @internal */
export type FileT$Outbound = {
  file_data: string;
  filename?: string | undefined;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileData: z.string(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FileT$ {
  /** @deprecated use `FileT$inboundSchema` instead. */
  export const inboundSchema = FileT$inboundSchema;
  /** @deprecated use `FileT$outboundSchema` instead. */
  export const outboundSchema = FileT$outboundSchema;
  /** @deprecated use `FileT$Outbound` instead. */
  export type Outbound = FileT$Outbound;
}

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const Four$inboundSchema: z.ZodType<Four, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2PrefixMessagesType$inboundSchema,
    file: z.lazy(() => FileT$inboundSchema),
  });

/** @internal */
export type Four$Outbound = {
  type: string;
  file: FileT$Outbound;
};

/** @internal */
export const Four$outboundSchema: z.ZodType<Four$Outbound, z.ZodTypeDef, Four> =
  z.object({
    type: Deployments2PrefixMessagesType$outboundSchema,
    file: z.lazy(() => FileT$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Four$ {
  /** @deprecated use `Four$inboundSchema` instead. */
  export const inboundSchema = Four$inboundSchema;
  /** @deprecated use `Four$outboundSchema` instead. */
  export const outboundSchema = Four$outboundSchema;
  /** @deprecated use `Four$Outbound` instead. */
  export type Outbound = Four$Outbound;
}

export function fourToJSON(four: Four): string {
  return JSON.stringify(Four$outboundSchema.parse(four));
}

export function fourFromJSON(
  jsonString: string,
): SafeParseResult<Four, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Four$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Four' from JSON`,
  );
}

/** @internal */
export const Deployments2Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = z.nativeEnum(Deployments2Type);

/** @internal */
export const Deployments2Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = Deployments2Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Type$ {
  /** @deprecated use `Deployments2Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2Type$inboundSchema;
  /** @deprecated use `Deployments2Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2Type$outboundSchema;
}

/** @internal */
export const Format$inboundSchema: z.ZodNativeEnum<typeof Format> = z
  .nativeEnum(Format);

/** @internal */
export const Format$outboundSchema: z.ZodNativeEnum<typeof Format> =
  Format$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Format$ {
  /** @deprecated use `Format$inboundSchema` instead. */
  export const inboundSchema = Format$inboundSchema;
  /** @deprecated use `Format$outboundSchema` instead. */
  export const outboundSchema = Format$outboundSchema;
}

/** @internal */
export const InputAudio$inboundSchema: z.ZodType<
  InputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: Format$inboundSchema,
});

/** @internal */
export type InputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const InputAudio$outboundSchema: z.ZodType<
  InputAudio$Outbound,
  z.ZodTypeDef,
  InputAudio
> = z.object({
  data: z.string(),
  format: Format$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InputAudio$ {
  /** @deprecated use `InputAudio$inboundSchema` instead. */
  export const inboundSchema = InputAudio$inboundSchema;
  /** @deprecated use `InputAudio$outboundSchema` instead. */
  export const outboundSchema = InputAudio$outboundSchema;
  /** @deprecated use `InputAudio$Outbound` instead. */
  export type Outbound = InputAudio$Outbound;
}

export function inputAudioToJSON(inputAudio: InputAudio): string {
  return JSON.stringify(InputAudio$outboundSchema.parse(inputAudio));
}

export function inputAudioFromJSON(
  jsonString: string,
): SafeParseResult<InputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InputAudio' from JSON`,
  );
}

/** @internal */
export const Deployments23$inboundSchema: z.ZodType<
  Deployments23,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2Type$inboundSchema,
  input_audio: z.lazy(() => InputAudio$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "input_audio": "inputAudio",
  });
});

/** @internal */
export type Deployments23$Outbound = {
  type: string;
  input_audio: InputAudio$Outbound;
};

/** @internal */
export const Deployments23$outboundSchema: z.ZodType<
  Deployments23$Outbound,
  z.ZodTypeDef,
  Deployments23
> = z.object({
  type: Deployments2Type$outboundSchema,
  inputAudio: z.lazy(() => InputAudio$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    inputAudio: "input_audio",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments23$ {
  /** @deprecated use `Deployments23$inboundSchema` instead. */
  export const inboundSchema = Deployments23$inboundSchema;
  /** @deprecated use `Deployments23$outboundSchema` instead. */
  export const outboundSchema = Deployments23$outboundSchema;
  /** @deprecated use `Deployments23$Outbound` instead. */
  export type Outbound = Deployments23$Outbound;
}

export function deployments23ToJSON(deployments23: Deployments23): string {
  return JSON.stringify(Deployments23$outboundSchema.parse(deployments23));
}

export function deployments23FromJSON(
  jsonString: string,
): SafeParseResult<Deployments23, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments23$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments23' from JSON`,
  );
}

/** @internal */
export const TwoType$inboundSchema: z.ZodNativeEnum<typeof TwoType> = z
  .nativeEnum(TwoType);

/** @internal */
export const TwoType$outboundSchema: z.ZodNativeEnum<typeof TwoType> =
  TwoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoType$ {
  /** @deprecated use `TwoType$inboundSchema` instead. */
  export const inboundSchema = TwoType$inboundSchema;
  /** @deprecated use `TwoType$outboundSchema` instead. */
  export const outboundSchema = TwoType$outboundSchema;
}

/** @internal */
export const Detail$inboundSchema: z.ZodNativeEnum<typeof Detail> = z
  .nativeEnum(Detail);

/** @internal */
export const Detail$outboundSchema: z.ZodNativeEnum<typeof Detail> =
  Detail$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Detail$ {
  /** @deprecated use `Detail$inboundSchema` instead. */
  export const inboundSchema = Detail$inboundSchema;
  /** @deprecated use `Detail$outboundSchema` instead. */
  export const outboundSchema = Detail$outboundSchema;
}

/** @internal */
export const ImageUrl$inboundSchema: z.ZodType<
  ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: Detail$inboundSchema.optional(),
});

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({
  url: z.string(),
  detail: Detail$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageUrl$ {
  /** @deprecated use `ImageUrl$inboundSchema` instead. */
  export const inboundSchema = ImageUrl$inboundSchema;
  /** @deprecated use `ImageUrl$outboundSchema` instead. */
  export const outboundSchema = ImageUrl$outboundSchema;
  /** @deprecated use `ImageUrl$Outbound` instead. */
  export type Outbound = ImageUrl$Outbound;
}

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

export function imageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageUrl' from JSON`,
  );
}

/** @internal */
export const Two2$inboundSchema: z.ZodType<Two2, z.ZodTypeDef, unknown> = z
  .object({
    type: TwoType$inboundSchema,
    image_url: z.lazy(() => ImageUrl$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "image_url": "imageUrl",
    });
  });

/** @internal */
export type Two2$Outbound = {
  type: string;
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const Two2$outboundSchema: z.ZodType<Two2$Outbound, z.ZodTypeDef, Two2> =
  z.object({
    type: TwoType$outboundSchema,
    imageUrl: z.lazy(() => ImageUrl$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      imageUrl: "image_url",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two2$ {
  /** @deprecated use `Two2$inboundSchema` instead. */
  export const inboundSchema = Two2$inboundSchema;
  /** @deprecated use `Two2$outboundSchema` instead. */
  export const outboundSchema = Two2$outboundSchema;
  /** @deprecated use `Two2$Outbound` instead. */
  export type Outbound = Two2$Outbound;
}

export function two2ToJSON(two2: Two2): string {
  return JSON.stringify(Two2$outboundSchema.parse(two2));
}

export function two2FromJSON(
  jsonString: string,
): SafeParseResult<Two2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two2' from JSON`,
  );
}

/** @internal */
export const Deployments2PrefixMessages3Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessages3Type
> = z.nativeEnum(Deployments2PrefixMessages3Type);

/** @internal */
export const Deployments2PrefixMessages3Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2PrefixMessages3Type
> = Deployments2PrefixMessages3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2PrefixMessages3Type$ {
  /** @deprecated use `Deployments2PrefixMessages3Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2PrefixMessages3Type$inboundSchema;
  /** @deprecated use `Deployments2PrefixMessages3Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2PrefixMessages3Type$outboundSchema;
}

/** @internal */
export const Deployments21$inboundSchema: z.ZodType<
  Deployments21,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2PrefixMessages3Type$inboundSchema,
  text: z.string(),
});

/** @internal */
export type Deployments21$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const Deployments21$outboundSchema: z.ZodType<
  Deployments21$Outbound,
  z.ZodTypeDef,
  Deployments21
> = z.object({
  type: Deployments2PrefixMessages3Type$outboundSchema,
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments21$ {
  /** @deprecated use `Deployments21$inboundSchema` instead. */
  export const inboundSchema = Deployments21$inboundSchema;
  /** @deprecated use `Deployments21$outboundSchema` instead. */
  export const outboundSchema = Deployments21$outboundSchema;
  /** @deprecated use `Deployments21$Outbound` instead. */
  export type Outbound = Deployments21$Outbound;
}

export function deployments21ToJSON(deployments21: Deployments21): string {
  return JSON.stringify(Deployments21$outboundSchema.parse(deployments21));
}

export function deployments21FromJSON(
  jsonString: string,
): SafeParseResult<Deployments21, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments21$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments21' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => Deployments21$inboundSchema),
    z.lazy(() => Two2$inboundSchema),
    z.lazy(() => Deployments23$inboundSchema),
    z.lazy(() => Four$inboundSchema),
  ],
);

/** @internal */
export type Two$Outbound =
  | Deployments21$Outbound
  | Two2$Outbound
  | Deployments23$Outbound
  | Four$Outbound;

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .union([
    z.lazy(() => Deployments21$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Deployments23$outboundSchema),
    z.lazy(() => Four$outboundSchema),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Content$inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> =
  z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Deployments21$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
      z.lazy(() => Deployments23$inboundSchema),
      z.lazy(() => Four$inboundSchema),
    ])),
  ]);

/** @internal */
export type Content$Outbound =
  | string
  | Array<
    | Deployments21$Outbound
    | Two2$Outbound
    | Deployments23$Outbound
    | Four$Outbound
  >;

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Deployments21$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
    z.lazy(() => Deployments23$outboundSchema),
    z.lazy(() => Four$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content$ {
  /** @deprecated use `Content$inboundSchema` instead. */
  export const inboundSchema = Content$inboundSchema;
  /** @deprecated use `Content$outboundSchema` instead. */
  export const outboundSchema = Content$outboundSchema;
  /** @deprecated use `Content$Outbound` instead. */
  export type Outbound = Content$Outbound;
}

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

export function contentFromJSON(
  jsonString: string,
): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`,
  );
}

/** @internal */
export const UserMessage$inboundSchema: z.ZodType<
  UserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsPrefixMessagesRole$inboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Deployments21$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
      z.lazy(() => Deployments23$inboundSchema),
      z.lazy(() => Four$inboundSchema),
    ])),
  ]),
});

/** @internal */
export type UserMessage$Outbound = {
  role: string;
  name?: string | undefined;
  content:
    | string
    | Array<
      | Deployments21$Outbound
      | Two2$Outbound
      | Deployments23$Outbound
      | Four$Outbound
    >;
};

/** @internal */
export const UserMessage$outboundSchema: z.ZodType<
  UserMessage$Outbound,
  z.ZodTypeDef,
  UserMessage
> = z.object({
  role: DeploymentsPrefixMessagesRole$outboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Deployments21$outboundSchema),
      z.lazy(() => Two2$outboundSchema),
      z.lazy(() => Deployments23$outboundSchema),
      z.lazy(() => Four$outboundSchema),
    ])),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserMessage$ {
  /** @deprecated use `UserMessage$inboundSchema` instead. */
  export const inboundSchema = UserMessage$inboundSchema;
  /** @deprecated use `UserMessage$outboundSchema` instead. */
  export const outboundSchema = UserMessage$outboundSchema;
  /** @deprecated use `UserMessage$Outbound` instead. */
  export type Outbound = UserMessage$Outbound;
}

export function userMessageToJSON(userMessage: UserMessage): string {
  return JSON.stringify(UserMessage$outboundSchema.parse(userMessage));
}

export function userMessageFromJSON(
  jsonString: string,
): SafeParseResult<UserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => UserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'UserMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessagesRole$inboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesRole
> = z.nativeEnum(PrefixMessagesRole);

/** @internal */
export const PrefixMessagesRole$outboundSchema: z.ZodNativeEnum<
  typeof PrefixMessagesRole
> = PrefixMessagesRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixMessagesRole$ {
  /** @deprecated use `PrefixMessagesRole$inboundSchema` instead. */
  export const inboundSchema = PrefixMessagesRole$inboundSchema;
  /** @deprecated use `PrefixMessagesRole$outboundSchema` instead. */
  export const outboundSchema = PrefixMessagesRole$outboundSchema;
}

/** @internal */
export const SystemMessage$inboundSchema: z.ZodType<
  SystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: PrefixMessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/** @internal */
export type SystemMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const SystemMessage$outboundSchema: z.ZodType<
  SystemMessage$Outbound,
  z.ZodTypeDef,
  SystemMessage
> = z.object({
  role: PrefixMessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SystemMessage$ {
  /** @deprecated use `SystemMessage$inboundSchema` instead. */
  export const inboundSchema = SystemMessage$inboundSchema;
  /** @deprecated use `SystemMessage$outboundSchema` instead. */
  export const outboundSchema = SystemMessage$outboundSchema;
  /** @deprecated use `SystemMessage$Outbound` instead. */
  export type Outbound = SystemMessage$Outbound;
}

export function systemMessageToJSON(systemMessage: SystemMessage): string {
  return JSON.stringify(SystemMessage$outboundSchema.parse(systemMessage));
}

export function systemMessageFromJSON(
  jsonString: string,
): SafeParseResult<SystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SystemMessage' from JSON`,
  );
}

/** @internal */
export const Role$inboundSchema: z.ZodNativeEnum<typeof Role> = z.nativeEnum(
  Role,
);

/** @internal */
export const Role$outboundSchema: z.ZodNativeEnum<typeof Role> =
  Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Role$ {
  /** @deprecated use `Role$inboundSchema` instead. */
  export const inboundSchema = Role$inboundSchema;
  /** @deprecated use `Role$outboundSchema` instead. */
  export const outboundSchema = Role$outboundSchema;
}

/** @internal */
export const DeveloperMessage$inboundSchema: z.ZodType<
  DeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: Role$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/** @internal */
export type DeveloperMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const DeveloperMessage$outboundSchema: z.ZodType<
  DeveloperMessage$Outbound,
  z.ZodTypeDef,
  DeveloperMessage
> = z.object({
  role: Role$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeveloperMessage$ {
  /** @deprecated use `DeveloperMessage$inboundSchema` instead. */
  export const inboundSchema = DeveloperMessage$inboundSchema;
  /** @deprecated use `DeveloperMessage$outboundSchema` instead. */
  export const outboundSchema = DeveloperMessage$outboundSchema;
  /** @deprecated use `DeveloperMessage$Outbound` instead. */
  export type Outbound = DeveloperMessage$Outbound;
}

export function developerMessageToJSON(
  developerMessage: DeveloperMessage,
): string {
  return JSON.stringify(
    DeveloperMessage$outboundSchema.parse(developerMessage),
  );
}

export function developerMessageFromJSON(
  jsonString: string,
): SafeParseResult<DeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeveloperMessage' from JSON`,
  );
}

/** @internal */
export const PrefixMessages$inboundSchema: z.ZodType<
  PrefixMessages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DeveloperMessage$inboundSchema),
  z.lazy(() => SystemMessage$inboundSchema),
  z.lazy(() => UserMessage$inboundSchema),
  z.lazy(() => ToolMessage$inboundSchema),
  z.lazy(() => AssistantMessage$inboundSchema),
]);

/** @internal */
export type PrefixMessages$Outbound =
  | DeveloperMessage$Outbound
  | SystemMessage$Outbound
  | UserMessage$Outbound
  | ToolMessage$Outbound
  | AssistantMessage$Outbound;

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.union([
  z.lazy(() => DeveloperMessage$outboundSchema),
  z.lazy(() => SystemMessage$outboundSchema),
  z.lazy(() => UserMessage$outboundSchema),
  z.lazy(() => ToolMessage$outboundSchema),
  z.lazy(() => AssistantMessage$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixMessages$ {
  /** @deprecated use `PrefixMessages$inboundSchema` instead. */
  export const inboundSchema = PrefixMessages$inboundSchema;
  /** @deprecated use `PrefixMessages$outboundSchema` instead. */
  export const outboundSchema = PrefixMessages$outboundSchema;
  /** @deprecated use `PrefixMessages$Outbound` instead. */
  export type Outbound = PrefixMessages$Outbound;
}

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}

export function prefixMessagesFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessages5Role$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages5Role
> = z.nativeEnum(DeploymentsMessages5Role);

/** @internal */
export const DeploymentsMessages5Role$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages5Role
> = DeploymentsMessages5Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessages5Role$ {
  /** @deprecated use `DeploymentsMessages5Role$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessages5Role$inboundSchema;
  /** @deprecated use `DeploymentsMessages5Role$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessages5Role$outboundSchema;
}

/** @internal */
export const DeploymentsMessages5Content$inboundSchema: z.ZodType<
  DeploymentsMessages5Content,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.array(z.string())]);

/** @internal */
export type DeploymentsMessages5Content$Outbound = string | Array<string>;

/** @internal */
export const DeploymentsMessages5Content$outboundSchema: z.ZodType<
  DeploymentsMessages5Content$Outbound,
  z.ZodTypeDef,
  DeploymentsMessages5Content
> = z.union([z.string(), z.array(z.string())]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessages5Content$ {
  /** @deprecated use `DeploymentsMessages5Content$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessages5Content$inboundSchema;
  /** @deprecated use `DeploymentsMessages5Content$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessages5Content$outboundSchema;
  /** @deprecated use `DeploymentsMessages5Content$Outbound` instead. */
  export type Outbound = DeploymentsMessages5Content$Outbound;
}

export function deploymentsMessages5ContentToJSON(
  deploymentsMessages5Content: DeploymentsMessages5Content,
): string {
  return JSON.stringify(
    DeploymentsMessages5Content$outboundSchema.parse(
      deploymentsMessages5Content,
    ),
  );
}

export function deploymentsMessages5ContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsMessages5Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsMessages5Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsMessages5Content' from JSON`,
  );
}

/** @internal */
export const MessagesToolMessage$inboundSchema: z.ZodType<
  MessagesToolMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsMessages5Role$inboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  tool_call_id: z.string(),
}).transform((v) => {
  return remap$(v, {
    "tool_call_id": "toolCallId",
  });
});

/** @internal */
export type MessagesToolMessage$Outbound = {
  role: string;
  content: string | Array<string>;
  tool_call_id: string;
};

/** @internal */
export const MessagesToolMessage$outboundSchema: z.ZodType<
  MessagesToolMessage$Outbound,
  z.ZodTypeDef,
  MessagesToolMessage
> = z.object({
  role: DeploymentsMessages5Role$outboundSchema,
  content: z.union([z.string(), z.array(z.string())]),
  toolCallId: z.string(),
}).transform((v) => {
  return remap$(v, {
    toolCallId: "tool_call_id",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesToolMessage$ {
  /** @deprecated use `MessagesToolMessage$inboundSchema` instead. */
  export const inboundSchema = MessagesToolMessage$inboundSchema;
  /** @deprecated use `MessagesToolMessage$outboundSchema` instead. */
  export const outboundSchema = MessagesToolMessage$outboundSchema;
  /** @deprecated use `MessagesToolMessage$Outbound` instead. */
  export type Outbound = MessagesToolMessage$Outbound;
}

export function messagesToolMessageToJSON(
  messagesToolMessage: MessagesToolMessage,
): string {
  return JSON.stringify(
    MessagesToolMessage$outboundSchema.parse(messagesToolMessage),
  );
}

export function messagesToolMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolMessage' from JSON`,
  );
}

/** @internal */
export const Deployments2Messages4ContentType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages4ContentType
> = z.nativeEnum(Deployments2Messages4ContentType);

/** @internal */
export const Deployments2Messages4ContentType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages4ContentType
> = Deployments2Messages4ContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Messages4ContentType$ {
  /** @deprecated use `Deployments2Messages4ContentType$inboundSchema` instead. */
  export const inboundSchema = Deployments2Messages4ContentType$inboundSchema;
  /** @deprecated use `Deployments2Messages4ContentType$outboundSchema` instead. */
  export const outboundSchema = Deployments2Messages4ContentType$outboundSchema;
}

/** @internal */
export const TwoRefusalContentPart$inboundSchema: z.ZodType<
  TwoRefusalContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2Messages4ContentType$inboundSchema,
  refusal: z.string(),
});

/** @internal */
export type TwoRefusalContentPart$Outbound = {
  type: string;
  refusal: string;
};

/** @internal */
export const TwoRefusalContentPart$outboundSchema: z.ZodType<
  TwoRefusalContentPart$Outbound,
  z.ZodTypeDef,
  TwoRefusalContentPart
> = z.object({
  type: Deployments2Messages4ContentType$outboundSchema,
  refusal: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoRefusalContentPart$ {
  /** @deprecated use `TwoRefusalContentPart$inboundSchema` instead. */
  export const inboundSchema = TwoRefusalContentPart$inboundSchema;
  /** @deprecated use `TwoRefusalContentPart$outboundSchema` instead. */
  export const outboundSchema = TwoRefusalContentPart$outboundSchema;
  /** @deprecated use `TwoRefusalContentPart$Outbound` instead. */
  export type Outbound = TwoRefusalContentPart$Outbound;
}

export function twoRefusalContentPartToJSON(
  twoRefusalContentPart: TwoRefusalContentPart,
): string {
  return JSON.stringify(
    TwoRefusalContentPart$outboundSchema.parse(twoRefusalContentPart),
  );
}

export function twoRefusalContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TwoRefusalContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoRefusalContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoRefusalContentPart' from JSON`,
  );
}

/** @internal */
export const Deployments2Messages4Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages4Type
> = z.nativeEnum(Deployments2Messages4Type);

/** @internal */
export const Deployments2Messages4Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages4Type
> = Deployments2Messages4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Messages4Type$ {
  /** @deprecated use `Deployments2Messages4Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2Messages4Type$inboundSchema;
  /** @deprecated use `Deployments2Messages4Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2Messages4Type$outboundSchema;
}

/** @internal */
export const TwoTextContentPart$inboundSchema: z.ZodType<
  TwoTextContentPart,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2Messages4Type$inboundSchema,
  text: z.string(),
});

/** @internal */
export type TwoTextContentPart$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const TwoTextContentPart$outboundSchema: z.ZodType<
  TwoTextContentPart$Outbound,
  z.ZodTypeDef,
  TwoTextContentPart
> = z.object({
  type: Deployments2Messages4Type$outboundSchema,
  text: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoTextContentPart$ {
  /** @deprecated use `TwoTextContentPart$inboundSchema` instead. */
  export const inboundSchema = TwoTextContentPart$inboundSchema;
  /** @deprecated use `TwoTextContentPart$outboundSchema` instead. */
  export const outboundSchema = TwoTextContentPart$outboundSchema;
  /** @deprecated use `TwoTextContentPart$Outbound` instead. */
  export type Outbound = TwoTextContentPart$Outbound;
}

export function twoTextContentPartToJSON(
  twoTextContentPart: TwoTextContentPart,
): string {
  return JSON.stringify(
    TwoTextContentPart$outboundSchema.parse(twoTextContentPart),
  );
}

export function twoTextContentPartFromJSON(
  jsonString: string,
): SafeParseResult<TwoTextContentPart, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoTextContentPart$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoTextContentPart' from JSON`,
  );
}

/** @internal */
export const DeploymentsContentMessages2$inboundSchema: z.ZodType<
  DeploymentsContentMessages2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => TwoTextContentPart$inboundSchema),
  z.lazy(() => TwoRefusalContentPart$inboundSchema),
]);

/** @internal */
export type DeploymentsContentMessages2$Outbound =
  | TwoTextContentPart$Outbound
  | TwoRefusalContentPart$Outbound;

/** @internal */
export const DeploymentsContentMessages2$outboundSchema: z.ZodType<
  DeploymentsContentMessages2$Outbound,
  z.ZodTypeDef,
  DeploymentsContentMessages2
> = z.union([
  z.lazy(() => TwoTextContentPart$outboundSchema),
  z.lazy(() => TwoRefusalContentPart$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsContentMessages2$ {
  /** @deprecated use `DeploymentsContentMessages2$inboundSchema` instead. */
  export const inboundSchema = DeploymentsContentMessages2$inboundSchema;
  /** @deprecated use `DeploymentsContentMessages2$outboundSchema` instead. */
  export const outboundSchema = DeploymentsContentMessages2$outboundSchema;
  /** @deprecated use `DeploymentsContentMessages2$Outbound` instead. */
  export type Outbound = DeploymentsContentMessages2$Outbound;
}

export function deploymentsContentMessages2ToJSON(
  deploymentsContentMessages2: DeploymentsContentMessages2,
): string {
  return JSON.stringify(
    DeploymentsContentMessages2$outboundSchema.parse(
      deploymentsContentMessages2,
    ),
  );
}

export function deploymentsContentMessages2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsContentMessages2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsContentMessages2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsContentMessages2' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessagesContent$inboundSchema: z.ZodType<
  DeploymentsMessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TwoTextContentPart$inboundSchema),
    z.lazy(() => TwoRefusalContentPart$inboundSchema),
  ])),
]);

/** @internal */
export type DeploymentsMessagesContent$Outbound =
  | string
  | Array<TwoTextContentPart$Outbound | TwoRefusalContentPart$Outbound>;

/** @internal */
export const DeploymentsMessagesContent$outboundSchema: z.ZodType<
  DeploymentsMessagesContent$Outbound,
  z.ZodTypeDef,
  DeploymentsMessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => TwoTextContentPart$outboundSchema),
    z.lazy(() => TwoRefusalContentPart$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessagesContent$ {
  /** @deprecated use `DeploymentsMessagesContent$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessagesContent$inboundSchema;
  /** @deprecated use `DeploymentsMessagesContent$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessagesContent$outboundSchema;
  /** @deprecated use `DeploymentsMessagesContent$Outbound` instead. */
  export type Outbound = DeploymentsMessagesContent$Outbound;
}

export function deploymentsMessagesContentToJSON(
  deploymentsMessagesContent: DeploymentsMessagesContent,
): string {
  return JSON.stringify(
    DeploymentsMessagesContent$outboundSchema.parse(deploymentsMessagesContent),
  );
}

export function deploymentsMessagesContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsMessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsMessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsMessagesContent' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessages4Role$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages4Role
> = z.nativeEnum(DeploymentsMessages4Role);

/** @internal */
export const DeploymentsMessages4Role$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages4Role
> = DeploymentsMessages4Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessages4Role$ {
  /** @deprecated use `DeploymentsMessages4Role$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessages4Role$inboundSchema;
  /** @deprecated use `DeploymentsMessages4Role$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessages4Role$outboundSchema;
}

/** @internal */
export const MessagesAudio$inboundSchema: z.ZodType<
  MessagesAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
});

/** @internal */
export type MessagesAudio$Outbound = {
  id: string;
};

/** @internal */
export const MessagesAudio$outboundSchema: z.ZodType<
  MessagesAudio$Outbound,
  z.ZodTypeDef,
  MessagesAudio
> = z.object({
  id: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesAudio$ {
  /** @deprecated use `MessagesAudio$inboundSchema` instead. */
  export const inboundSchema = MessagesAudio$inboundSchema;
  /** @deprecated use `MessagesAudio$outboundSchema` instead. */
  export const outboundSchema = MessagesAudio$outboundSchema;
  /** @deprecated use `MessagesAudio$Outbound` instead. */
  export type Outbound = MessagesAudio$Outbound;
}

export function messagesAudioToJSON(messagesAudio: MessagesAudio): string {
  return JSON.stringify(MessagesAudio$outboundSchema.parse(messagesAudio));
}

export function messagesAudioFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAudio' from JSON`,
  );
}

/** @internal */
export const MessagesType$inboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  z.nativeEnum(MessagesType);

/** @internal */
export const MessagesType$outboundSchema: z.ZodNativeEnum<typeof MessagesType> =
  MessagesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesType$ {
  /** @deprecated use `MessagesType$inboundSchema` instead. */
  export const inboundSchema = MessagesType$inboundSchema;
  /** @deprecated use `MessagesType$outboundSchema` instead. */
  export const outboundSchema = MessagesType$outboundSchema;
}

/** @internal */
export const MessagesFunction$inboundSchema: z.ZodType<
  MessagesFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

/** @internal */
export type MessagesFunction$Outbound = {
  name?: string | undefined;
  arguments?: string | undefined;
};

/** @internal */
export const MessagesFunction$outboundSchema: z.ZodType<
  MessagesFunction$Outbound,
  z.ZodTypeDef,
  MessagesFunction
> = z.object({
  name: z.string().optional(),
  arguments: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesFunction$ {
  /** @deprecated use `MessagesFunction$inboundSchema` instead. */
  export const inboundSchema = MessagesFunction$inboundSchema;
  /** @deprecated use `MessagesFunction$outboundSchema` instead. */
  export const outboundSchema = MessagesFunction$outboundSchema;
  /** @deprecated use `MessagesFunction$Outbound` instead. */
  export type Outbound = MessagesFunction$Outbound;
}

export function messagesFunctionToJSON(
  messagesFunction: MessagesFunction,
): string {
  return JSON.stringify(
    MessagesFunction$outboundSchema.parse(messagesFunction),
  );
}

export function messagesFunctionFromJSON(
  jsonString: string,
): SafeParseResult<MessagesFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesFunction' from JSON`,
  );
}

/** @internal */
export const MessagesToolCalls$inboundSchema: z.ZodType<
  MessagesToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string(),
  type: MessagesType$inboundSchema,
  function: z.lazy(() => MessagesFunction$inboundSchema),
});

/** @internal */
export type MessagesToolCalls$Outbound = {
  id: string;
  type: string;
  function: MessagesFunction$Outbound;
};

/** @internal */
export const MessagesToolCalls$outboundSchema: z.ZodType<
  MessagesToolCalls$Outbound,
  z.ZodTypeDef,
  MessagesToolCalls
> = z.object({
  id: z.string(),
  type: MessagesType$outboundSchema,
  function: z.lazy(() => MessagesFunction$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesToolCalls$ {
  /** @deprecated use `MessagesToolCalls$inboundSchema` instead. */
  export const inboundSchema = MessagesToolCalls$inboundSchema;
  /** @deprecated use `MessagesToolCalls$outboundSchema` instead. */
  export const outboundSchema = MessagesToolCalls$outboundSchema;
  /** @deprecated use `MessagesToolCalls$Outbound` instead. */
  export type Outbound = MessagesToolCalls$Outbound;
}

export function messagesToolCallsToJSON(
  messagesToolCalls: MessagesToolCalls,
): string {
  return JSON.stringify(
    MessagesToolCalls$outboundSchema.parse(messagesToolCalls),
  );
}

export function messagesToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<MessagesToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesToolCalls' from JSON`,
  );
}

/** @internal */
export const MessagesAssistantMessage$inboundSchema: z.ZodType<
  MessagesAssistantMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TwoTextContentPart$inboundSchema),
          z.lazy(() => TwoRefusalContentPart$inboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: DeploymentsMessages4Role$inboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$inboundSchema)).optional(),
  tool_calls: z.array(z.lazy(() => MessagesToolCalls$inboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoning_signature: z.string().optional(),
  redacted_reasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
    "reasoning_signature": "reasoningSignature",
    "redacted_reasoning": "redactedReasoning",
  });
});

/** @internal */
export type MessagesAssistantMessage$Outbound = {
  content?:
    | string
    | Array<TwoTextContentPart$Outbound | TwoRefusalContentPart$Outbound>
    | null
    | undefined;
  refusal?: string | null | undefined;
  role: string;
  name?: string | undefined;
  audio?: MessagesAudio$Outbound | null | undefined;
  tool_calls?: Array<MessagesToolCalls$Outbound> | undefined;
  reasoning?: string | undefined;
  reasoning_signature?: string | undefined;
  redacted_reasoning?: string | undefined;
};

/** @internal */
export const MessagesAssistantMessage$outboundSchema: z.ZodType<
  MessagesAssistantMessage$Outbound,
  z.ZodTypeDef,
  MessagesAssistantMessage
> = z.object({
  content: z.nullable(
    z.union([
      z.string(),
      z.array(
        z.union([
          z.lazy(() => TwoTextContentPart$outboundSchema),
          z.lazy(() => TwoRefusalContentPart$outboundSchema),
        ]),
      ),
    ]),
  ).optional(),
  refusal: z.nullable(z.string()).optional(),
  role: DeploymentsMessages4Role$outboundSchema,
  name: z.string().optional(),
  audio: z.nullable(z.lazy(() => MessagesAudio$outboundSchema)).optional(),
  toolCalls: z.array(z.lazy(() => MessagesToolCalls$outboundSchema)).optional(),
  reasoning: z.string().optional(),
  reasoningSignature: z.string().optional(),
  redactedReasoning: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
    reasoningSignature: "reasoning_signature",
    redactedReasoning: "redacted_reasoning",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesAssistantMessage$ {
  /** @deprecated use `MessagesAssistantMessage$inboundSchema` instead. */
  export const inboundSchema = MessagesAssistantMessage$inboundSchema;
  /** @deprecated use `MessagesAssistantMessage$outboundSchema` instead. */
  export const outboundSchema = MessagesAssistantMessage$outboundSchema;
  /** @deprecated use `MessagesAssistantMessage$Outbound` instead. */
  export type Outbound = MessagesAssistantMessage$Outbound;
}

export function messagesAssistantMessageToJSON(
  messagesAssistantMessage: MessagesAssistantMessage,
): string {
  return JSON.stringify(
    MessagesAssistantMessage$outboundSchema.parse(messagesAssistantMessage),
  );
}

export function messagesAssistantMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesAssistantMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesAssistantMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesAssistantMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessages3Role$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages3Role
> = z.nativeEnum(DeploymentsMessages3Role);

/** @internal */
export const DeploymentsMessages3Role$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessages3Role
> = DeploymentsMessages3Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessages3Role$ {
  /** @deprecated use `DeploymentsMessages3Role$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessages3Role$inboundSchema;
  /** @deprecated use `DeploymentsMessages3Role$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessages3Role$outboundSchema;
}

/** @internal */
export const Deployments2Messages3Content4Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3Content4Type
> = z.nativeEnum(Deployments2Messages3Content4Type);

/** @internal */
export const Deployments2Messages3Content4Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3Content4Type
> = Deployments2Messages3Content4Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Messages3Content4Type$ {
  /** @deprecated use `Deployments2Messages3Content4Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2Messages3Content4Type$inboundSchema;
  /** @deprecated use `Deployments2Messages3Content4Type$outboundSchema` instead. */
  export const outboundSchema =
    Deployments2Messages3Content4Type$outboundSchema;
}

/** @internal */
export const TwoFile$inboundSchema: z.ZodType<TwoFile, z.ZodTypeDef, unknown> =
  z.object({
    file_data: z.string(),
    filename: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "file_data": "fileData",
    });
  });

/** @internal */
export type TwoFile$Outbound = {
  file_data: string;
  filename?: string | undefined;
};

/** @internal */
export const TwoFile$outboundSchema: z.ZodType<
  TwoFile$Outbound,
  z.ZodTypeDef,
  TwoFile
> = z.object({
  fileData: z.string(),
  filename: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    fileData: "file_data",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoFile$ {
  /** @deprecated use `TwoFile$inboundSchema` instead. */
  export const inboundSchema = TwoFile$inboundSchema;
  /** @deprecated use `TwoFile$outboundSchema` instead. */
  export const outboundSchema = TwoFile$outboundSchema;
  /** @deprecated use `TwoFile$Outbound` instead. */
  export type Outbound = TwoFile$Outbound;
}

export function twoFileToJSON(twoFile: TwoFile): string {
  return JSON.stringify(TwoFile$outboundSchema.parse(twoFile));
}

export function twoFileFromJSON(
  jsonString: string,
): SafeParseResult<TwoFile, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoFile$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoFile' from JSON`,
  );
}

/** @internal */
export const Two4$inboundSchema: z.ZodType<Two4, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2Messages3Content4Type$inboundSchema,
    file: z.lazy(() => TwoFile$inboundSchema),
  });

/** @internal */
export type Two4$Outbound = {
  type: string;
  file: TwoFile$Outbound;
};

/** @internal */
export const Two4$outboundSchema: z.ZodType<Two4$Outbound, z.ZodTypeDef, Two4> =
  z.object({
    type: Deployments2Messages3Content4Type$outboundSchema,
    file: z.lazy(() => TwoFile$outboundSchema),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two4$ {
  /** @deprecated use `Two4$inboundSchema` instead. */
  export const inboundSchema = Two4$inboundSchema;
  /** @deprecated use `Two4$outboundSchema` instead. */
  export const outboundSchema = Two4$outboundSchema;
  /** @deprecated use `Two4$Outbound` instead. */
  export type Outbound = Two4$Outbound;
}

export function two4ToJSON(two4: Two4): string {
  return JSON.stringify(Two4$outboundSchema.parse(two4));
}

export function two4FromJSON(
  jsonString: string,
): SafeParseResult<Two4, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two4$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two4' from JSON`,
  );
}

/** @internal */
export const Deployments2Messages3ContentType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3ContentType
> = z.nativeEnum(Deployments2Messages3ContentType);

/** @internal */
export const Deployments2Messages3ContentType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3ContentType
> = Deployments2Messages3ContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Messages3ContentType$ {
  /** @deprecated use `Deployments2Messages3ContentType$inboundSchema` instead. */
  export const inboundSchema = Deployments2Messages3ContentType$inboundSchema;
  /** @deprecated use `Deployments2Messages3ContentType$outboundSchema` instead. */
  export const outboundSchema = Deployments2Messages3ContentType$outboundSchema;
}

/** @internal */
export const TwoFormat$inboundSchema: z.ZodNativeEnum<typeof TwoFormat> = z
  .nativeEnum(TwoFormat);

/** @internal */
export const TwoFormat$outboundSchema: z.ZodNativeEnum<typeof TwoFormat> =
  TwoFormat$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoFormat$ {
  /** @deprecated use `TwoFormat$inboundSchema` instead. */
  export const inboundSchema = TwoFormat$inboundSchema;
  /** @deprecated use `TwoFormat$outboundSchema` instead. */
  export const outboundSchema = TwoFormat$outboundSchema;
}

/** @internal */
export const TwoInputAudio$inboundSchema: z.ZodType<
  TwoInputAudio,
  z.ZodTypeDef,
  unknown
> = z.object({
  data: z.string(),
  format: TwoFormat$inboundSchema,
});

/** @internal */
export type TwoInputAudio$Outbound = {
  data: string;
  format: string;
};

/** @internal */
export const TwoInputAudio$outboundSchema: z.ZodType<
  TwoInputAudio$Outbound,
  z.ZodTypeDef,
  TwoInputAudio
> = z.object({
  data: z.string(),
  format: TwoFormat$outboundSchema,
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoInputAudio$ {
  /** @deprecated use `TwoInputAudio$inboundSchema` instead. */
  export const inboundSchema = TwoInputAudio$inboundSchema;
  /** @deprecated use `TwoInputAudio$outboundSchema` instead. */
  export const outboundSchema = TwoInputAudio$outboundSchema;
  /** @deprecated use `TwoInputAudio$Outbound` instead. */
  export type Outbound = TwoInputAudio$Outbound;
}

export function twoInputAudioToJSON(twoInputAudio: TwoInputAudio): string {
  return JSON.stringify(TwoInputAudio$outboundSchema.parse(twoInputAudio));
}

export function twoInputAudioFromJSON(
  jsonString: string,
): SafeParseResult<TwoInputAudio, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoInputAudio$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoInputAudio' from JSON`,
  );
}

/** @internal */
export const Two3$inboundSchema: z.ZodType<Two3, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2Messages3ContentType$inboundSchema,
    input_audio: z.lazy(() => TwoInputAudio$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "input_audio": "inputAudio",
    });
  });

/** @internal */
export type Two3$Outbound = {
  type: string;
  input_audio: TwoInputAudio$Outbound;
};

/** @internal */
export const Two3$outboundSchema: z.ZodType<Two3$Outbound, z.ZodTypeDef, Two3> =
  z.object({
    type: Deployments2Messages3ContentType$outboundSchema,
    inputAudio: z.lazy(() => TwoInputAudio$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      inputAudio: "input_audio",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two3$ {
  /** @deprecated use `Two3$inboundSchema` instead. */
  export const inboundSchema = Two3$inboundSchema;
  /** @deprecated use `Two3$outboundSchema` instead. */
  export const outboundSchema = Two3$outboundSchema;
  /** @deprecated use `Two3$Outbound` instead. */
  export type Outbound = Two3$Outbound;
}

export function two3ToJSON(two3: Two3): string {
  return JSON.stringify(Two3$outboundSchema.parse(two3));
}

export function two3FromJSON(
  jsonString: string,
): SafeParseResult<Two3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two3' from JSON`,
  );
}

/** @internal */
export const Deployments2Messages3Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3Type
> = z.nativeEnum(Deployments2Messages3Type);

/** @internal */
export const Deployments2Messages3Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Messages3Type
> = Deployments2Messages3Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Messages3Type$ {
  /** @deprecated use `Deployments2Messages3Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2Messages3Type$inboundSchema;
  /** @deprecated use `Deployments2Messages3Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2Messages3Type$outboundSchema;
}

/** @internal */
export const TwoDetail$inboundSchema: z.ZodNativeEnum<typeof TwoDetail> = z
  .nativeEnum(TwoDetail);

/** @internal */
export const TwoDetail$outboundSchema: z.ZodNativeEnum<typeof TwoDetail> =
  TwoDetail$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoDetail$ {
  /** @deprecated use `TwoDetail$inboundSchema` instead. */
  export const inboundSchema = TwoDetail$inboundSchema;
  /** @deprecated use `TwoDetail$outboundSchema` instead. */
  export const outboundSchema = TwoDetail$outboundSchema;
}

/** @internal */
export const TwoImageUrl$inboundSchema: z.ZodType<
  TwoImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: TwoDetail$inboundSchema.optional(),
});

/** @internal */
export type TwoImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const TwoImageUrl$outboundSchema: z.ZodType<
  TwoImageUrl$Outbound,
  z.ZodTypeDef,
  TwoImageUrl
> = z.object({
  url: z.string(),
  detail: TwoDetail$outboundSchema.optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoImageUrl$ {
  /** @deprecated use `TwoImageUrl$inboundSchema` instead. */
  export const inboundSchema = TwoImageUrl$inboundSchema;
  /** @deprecated use `TwoImageUrl$outboundSchema` instead. */
  export const outboundSchema = TwoImageUrl$outboundSchema;
  /** @deprecated use `TwoImageUrl$Outbound` instead. */
  export type Outbound = TwoImageUrl$Outbound;
}

export function twoImageUrlToJSON(twoImageUrl: TwoImageUrl): string {
  return JSON.stringify(TwoImageUrl$outboundSchema.parse(twoImageUrl));
}

export function twoImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<TwoImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoImageUrl' from JSON`,
  );
}

/** @internal */
export const Deployments22$inboundSchema: z.ZodType<
  Deployments22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2Messages3Type$inboundSchema,
  image_url: z.lazy(() => TwoImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

/** @internal */
export type Deployments22$Outbound = {
  type: string;
  image_url: TwoImageUrl$Outbound;
};

/** @internal */
export const Deployments22$outboundSchema: z.ZodType<
  Deployments22$Outbound,
  z.ZodTypeDef,
  Deployments22
> = z.object({
  type: Deployments2Messages3Type$outboundSchema,
  imageUrl: z.lazy(() => TwoImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments22$ {
  /** @deprecated use `Deployments22$inboundSchema` instead. */
  export const inboundSchema = Deployments22$inboundSchema;
  /** @deprecated use `Deployments22$outboundSchema` instead. */
  export const outboundSchema = Deployments22$outboundSchema;
  /** @deprecated use `Deployments22$Outbound` instead. */
  export type Outbound = Deployments22$Outbound;
}

export function deployments22ToJSON(deployments22: Deployments22): string {
  return JSON.stringify(Deployments22$outboundSchema.parse(deployments22));
}

export function deployments22FromJSON(
  jsonString: string,
): SafeParseResult<Deployments22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments22' from JSON`,
  );
}

/** @internal */
export const Deployments2MessagesType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesType
> = z.nativeEnum(Deployments2MessagesType);

/** @internal */
export const Deployments2MessagesType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesType
> = Deployments2MessagesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2MessagesType$ {
  /** @deprecated use `Deployments2MessagesType$inboundSchema` instead. */
  export const inboundSchema = Deployments2MessagesType$inboundSchema;
  /** @deprecated use `Deployments2MessagesType$outboundSchema` instead. */
  export const outboundSchema = Deployments2MessagesType$outboundSchema;
}

/** @internal */
export const Two1$inboundSchema: z.ZodType<Two1, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2MessagesType$inboundSchema,
    text: z.string(),
  });

/** @internal */
export type Two1$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const Two1$outboundSchema: z.ZodType<Two1$Outbound, z.ZodTypeDef, Two1> =
  z.object({
    type: Deployments2MessagesType$outboundSchema,
    text: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two1$ {
  /** @deprecated use `Two1$inboundSchema` instead. */
  export const inboundSchema = Two1$inboundSchema;
  /** @deprecated use `Two1$outboundSchema` instead. */
  export const outboundSchema = Two1$outboundSchema;
  /** @deprecated use `Two1$Outbound` instead. */
  export type Outbound = Two1$Outbound;
}

export function two1ToJSON(two1: Two1): string {
  return JSON.stringify(Two1$outboundSchema.parse(two1));
}

export function two1FromJSON(
  jsonString: string,
): SafeParseResult<Two1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two1' from JSON`,
  );
}

/** @internal */
export const DeploymentsContent2$inboundSchema: z.ZodType<
  DeploymentsContent2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Two1$inboundSchema),
  z.lazy(() => Deployments22$inboundSchema),
  z.lazy(() => Two3$inboundSchema),
  z.lazy(() => Two4$inboundSchema),
]);

/** @internal */
export type DeploymentsContent2$Outbound =
  | Two1$Outbound
  | Deployments22$Outbound
  | Two3$Outbound
  | Two4$Outbound;

/** @internal */
export const DeploymentsContent2$outboundSchema: z.ZodType<
  DeploymentsContent2$Outbound,
  z.ZodTypeDef,
  DeploymentsContent2
> = z.union([
  z.lazy(() => Two1$outboundSchema),
  z.lazy(() => Deployments22$outboundSchema),
  z.lazy(() => Two3$outboundSchema),
  z.lazy(() => Two4$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsContent2$ {
  /** @deprecated use `DeploymentsContent2$inboundSchema` instead. */
  export const inboundSchema = DeploymentsContent2$inboundSchema;
  /** @deprecated use `DeploymentsContent2$outboundSchema` instead. */
  export const outboundSchema = DeploymentsContent2$outboundSchema;
  /** @deprecated use `DeploymentsContent2$Outbound` instead. */
  export type Outbound = DeploymentsContent2$Outbound;
}

export function deploymentsContent2ToJSON(
  deploymentsContent2: DeploymentsContent2,
): string {
  return JSON.stringify(
    DeploymentsContent2$outboundSchema.parse(deploymentsContent2),
  );
}

export function deploymentsContent2FromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsContent2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsContent2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsContent2' from JSON`,
  );
}

/** @internal */
export const MessagesContent$inboundSchema: z.ZodType<
  MessagesContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$inboundSchema),
    z.lazy(() => Deployments22$inboundSchema),
    z.lazy(() => Two3$inboundSchema),
    z.lazy(() => Two4$inboundSchema),
  ])),
]);

/** @internal */
export type MessagesContent$Outbound =
  | string
  | Array<
    Two1$Outbound | Deployments22$Outbound | Two3$Outbound | Two4$Outbound
  >;

/** @internal */
export const MessagesContent$outboundSchema: z.ZodType<
  MessagesContent$Outbound,
  z.ZodTypeDef,
  MessagesContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$outboundSchema),
    z.lazy(() => Deployments22$outboundSchema),
    z.lazy(() => Two3$outboundSchema),
    z.lazy(() => Two4$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesContent$ {
  /** @deprecated use `MessagesContent$inboundSchema` instead. */
  export const inboundSchema = MessagesContent$inboundSchema;
  /** @deprecated use `MessagesContent$outboundSchema` instead. */
  export const outboundSchema = MessagesContent$outboundSchema;
  /** @deprecated use `MessagesContent$Outbound` instead. */
  export type Outbound = MessagesContent$Outbound;
}

export function messagesContentToJSON(
  messagesContent: MessagesContent,
): string {
  return JSON.stringify(MessagesContent$outboundSchema.parse(messagesContent));
}

export function messagesContentFromJSON(
  jsonString: string,
): SafeParseResult<MessagesContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesContent' from JSON`,
  );
}

/** @internal */
export const MessagesUserMessage$inboundSchema: z.ZodType<
  MessagesUserMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsMessages3Role$inboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$inboundSchema),
      z.lazy(() => Deployments22$inboundSchema),
      z.lazy(() => Two3$inboundSchema),
      z.lazy(() => Two4$inboundSchema),
    ])),
  ]),
});

/** @internal */
export type MessagesUserMessage$Outbound = {
  role: string;
  name?: string | undefined;
  content:
    | string
    | Array<
      Two1$Outbound | Deployments22$Outbound | Two3$Outbound | Two4$Outbound
    >;
};

/** @internal */
export const MessagesUserMessage$outboundSchema: z.ZodType<
  MessagesUserMessage$Outbound,
  z.ZodTypeDef,
  MessagesUserMessage
> = z.object({
  role: DeploymentsMessages3Role$outboundSchema,
  name: z.string().optional(),
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$outboundSchema),
      z.lazy(() => Deployments22$outboundSchema),
      z.lazy(() => Two3$outboundSchema),
      z.lazy(() => Two4$outboundSchema),
    ])),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesUserMessage$ {
  /** @deprecated use `MessagesUserMessage$inboundSchema` instead. */
  export const inboundSchema = MessagesUserMessage$inboundSchema;
  /** @deprecated use `MessagesUserMessage$outboundSchema` instead. */
  export const outboundSchema = MessagesUserMessage$outboundSchema;
  /** @deprecated use `MessagesUserMessage$Outbound` instead. */
  export type Outbound = MessagesUserMessage$Outbound;
}

export function messagesUserMessageToJSON(
  messagesUserMessage: MessagesUserMessage,
): string {
  return JSON.stringify(
    MessagesUserMessage$outboundSchema.parse(messagesUserMessage),
  );
}

export function messagesUserMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesUserMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesUserMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesUserMessage' from JSON`,
  );
}

/** @internal */
export const DeploymentsMessagesRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessagesRole
> = z.nativeEnum(DeploymentsMessagesRole);

/** @internal */
export const DeploymentsMessagesRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsMessagesRole
> = DeploymentsMessagesRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsMessagesRole$ {
  /** @deprecated use `DeploymentsMessagesRole$inboundSchema` instead. */
  export const inboundSchema = DeploymentsMessagesRole$inboundSchema;
  /** @deprecated use `DeploymentsMessagesRole$outboundSchema` instead. */
  export const outboundSchema = DeploymentsMessagesRole$outboundSchema;
}

/** @internal */
export const MessagesSystemMessage$inboundSchema: z.ZodType<
  MessagesSystemMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsMessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/** @internal */
export type MessagesSystemMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const MessagesSystemMessage$outboundSchema: z.ZodType<
  MessagesSystemMessage$Outbound,
  z.ZodTypeDef,
  MessagesSystemMessage
> = z.object({
  role: DeploymentsMessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesSystemMessage$ {
  /** @deprecated use `MessagesSystemMessage$inboundSchema` instead. */
  export const inboundSchema = MessagesSystemMessage$inboundSchema;
  /** @deprecated use `MessagesSystemMessage$outboundSchema` instead. */
  export const outboundSchema = MessagesSystemMessage$outboundSchema;
  /** @deprecated use `MessagesSystemMessage$Outbound` instead. */
  export type Outbound = MessagesSystemMessage$Outbound;
}

export function messagesSystemMessageToJSON(
  messagesSystemMessage: MessagesSystemMessage,
): string {
  return JSON.stringify(
    MessagesSystemMessage$outboundSchema.parse(messagesSystemMessage),
  );
}

export function messagesSystemMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesSystemMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesSystemMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesSystemMessage' from JSON`,
  );
}

/** @internal */
export const MessagesRole$inboundSchema: z.ZodNativeEnum<typeof MessagesRole> =
  z.nativeEnum(MessagesRole);

/** @internal */
export const MessagesRole$outboundSchema: z.ZodNativeEnum<typeof MessagesRole> =
  MessagesRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesRole$ {
  /** @deprecated use `MessagesRole$inboundSchema` instead. */
  export const inboundSchema = MessagesRole$inboundSchema;
  /** @deprecated use `MessagesRole$outboundSchema` instead. */
  export const outboundSchema = MessagesRole$outboundSchema;
}

/** @internal */
export const MessagesDeveloperMessage$inboundSchema: z.ZodType<
  MessagesDeveloperMessage,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: MessagesRole$inboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/** @internal */
export type MessagesDeveloperMessage$Outbound = {
  role: string;
  content: string;
  name?: string | undefined;
};

/** @internal */
export const MessagesDeveloperMessage$outboundSchema: z.ZodType<
  MessagesDeveloperMessage$Outbound,
  z.ZodTypeDef,
  MessagesDeveloperMessage
> = z.object({
  role: MessagesRole$outboundSchema,
  content: z.string(),
  name: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace MessagesDeveloperMessage$ {
  /** @deprecated use `MessagesDeveloperMessage$inboundSchema` instead. */
  export const inboundSchema = MessagesDeveloperMessage$inboundSchema;
  /** @deprecated use `MessagesDeveloperMessage$outboundSchema` instead. */
  export const outboundSchema = MessagesDeveloperMessage$outboundSchema;
  /** @deprecated use `MessagesDeveloperMessage$Outbound` instead. */
  export type Outbound = MessagesDeveloperMessage$Outbound;
}

export function messagesDeveloperMessageToJSON(
  messagesDeveloperMessage: MessagesDeveloperMessage,
): string {
  return JSON.stringify(
    MessagesDeveloperMessage$outboundSchema.parse(messagesDeveloperMessage),
  );
}

export function messagesDeveloperMessageFromJSON(
  jsonString: string,
): SafeParseResult<MessagesDeveloperMessage, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => MessagesDeveloperMessage$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'MessagesDeveloperMessage' from JSON`,
  );
}

/** @internal */
export const Messages$inboundSchema: z.ZodType<
  Messages,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => MessagesDeveloperMessage$inboundSchema),
  z.lazy(() => MessagesSystemMessage$inboundSchema),
  z.lazy(() => MessagesUserMessage$inboundSchema),
  z.lazy(() => MessagesToolMessage$inboundSchema),
  z.lazy(() => MessagesAssistantMessage$inboundSchema),
]);

/** @internal */
export type Messages$Outbound =
  | MessagesDeveloperMessage$Outbound
  | MessagesSystemMessage$Outbound
  | MessagesUserMessage$Outbound
  | MessagesToolMessage$Outbound
  | MessagesAssistantMessage$Outbound;

/** @internal */
export const Messages$outboundSchema: z.ZodType<
  Messages$Outbound,
  z.ZodTypeDef,
  Messages
> = z.union([
  z.lazy(() => MessagesDeveloperMessage$outboundSchema),
  z.lazy(() => MessagesSystemMessage$outboundSchema),
  z.lazy(() => MessagesUserMessage$outboundSchema),
  z.lazy(() => MessagesToolMessage$outboundSchema),
  z.lazy(() => MessagesAssistantMessage$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Messages$ {
  /** @deprecated use `Messages$inboundSchema` instead. */
  export const inboundSchema = Messages$inboundSchema;
  /** @deprecated use `Messages$outboundSchema` instead. */
  export const outboundSchema = Messages$outboundSchema;
  /** @deprecated use `Messages$Outbound` instead. */
  export type Outbound = Messages$Outbound;
}

export function messagesToJSON(messages: Messages): string {
  return JSON.stringify(Messages$outboundSchema.parse(messages));
}

export function messagesFromJSON(
  jsonString: string,
): SafeParseResult<Messages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Messages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Messages' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string().optional(),
  file_type: z.string().optional(),
  page_number: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "file_type": "fileType",
    "page_number": "pageNumber",
  });
});

/** @internal */
export type Metadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const Documents$inboundSchema: z.ZodType<
  Documents,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$inboundSchema).optional(),
});

/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Documents$ {
  /** @deprecated use `Documents$inboundSchema` instead. */
  export const inboundSchema = Documents$inboundSchema;
  /** @deprecated use `Documents$outboundSchema` instead. */
  export const outboundSchema = Documents$outboundSchema;
  /** @deprecated use `Documents$Outbound` instead. */
  export type Outbound = Documents$Outbound;
}

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}

export function documentsFromJSON(
  jsonString: string,
): SafeParseResult<Documents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Documents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Documents' from JSON`,
  );
}

/** @internal */
export const InvokeOptions$inboundSchema: z.ZodType<
  InvokeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_retrievals: z.boolean().default(false),
  mock_response: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "include_retrievals": "includeRetrievals",
    "mock_response": "mockResponse",
  });
});

/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
  mock_response?: string | undefined;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
  mockResponse: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
    mockResponse: "mock_response",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InvokeOptions$ {
  /** @deprecated use `InvokeOptions$inboundSchema` instead. */
  export const inboundSchema = InvokeOptions$inboundSchema;
  /** @deprecated use `InvokeOptions$outboundSchema` instead. */
  export const outboundSchema = InvokeOptions$outboundSchema;
  /** @deprecated use `InvokeOptions$Outbound` instead. */
  export type Outbound = InvokeOptions$Outbound;
}

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}

export function invokeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<InvokeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeOptions' from JSON`,
  );
}

/** @internal */
export const Thread$inboundSchema: z.ZodType<Thread, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    tags: z.array(z.string()).optional(),
  });

/** @internal */
export type Thread$Outbound = {
  id: string;
  tags?: Array<string> | undefined;
};

/** @internal */
export const Thread$outboundSchema: z.ZodType<
  Thread$Outbound,
  z.ZodTypeDef,
  Thread
> = z.object({
  id: z.string(),
  tags: z.array(z.string()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Thread$ {
  /** @deprecated use `Thread$inboundSchema` instead. */
  export const inboundSchema = Thread$inboundSchema;
  /** @deprecated use `Thread$outboundSchema` instead. */
  export const outboundSchema = Thread$outboundSchema;
  /** @deprecated use `Thread$Outbound` instead. */
  export type Outbound = Thread$Outbound;
}

export function threadToJSON(thread: Thread): string {
  return JSON.stringify(Thread$outboundSchema.parse(thread));
}

export function threadFromJSON(
  jsonString: string,
): SafeParseResult<Thread, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Thread$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Thread' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarExists$inboundSchema: z.ZodType<
  DollarOrDollarExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  $exists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "$exists": "dollarExists",
  });
});

/** @internal */
export type DollarOrDollarExists$Outbound = {
  $exists: boolean;
};

/** @internal */
export const DollarOrDollarExists$outboundSchema: z.ZodType<
  DollarOrDollarExists$Outbound,
  z.ZodTypeDef,
  DollarOrDollarExists
> = z.object({
  dollarExists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    dollarExists: "$exists",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarExists$ {
  /** @deprecated use `DollarOrDollarExists$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarExists$inboundSchema;
  /** @deprecated use `DollarOrDollarExists$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarExists$outboundSchema;
  /** @deprecated use `DollarOrDollarExists$Outbound` instead. */
  export type Outbound = DollarOrDollarExists$Outbound;
}

export function dollarOrDollarExistsToJSON(
  dollarOrDollarExists: DollarOrDollarExists,
): string {
  return JSON.stringify(
    DollarOrDollarExists$outboundSchema.parse(dollarOrDollarExists),
  );
}

export function dollarOrDollarExistsFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarExists' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarNin$inboundSchema: z.ZodType<
  DollarOrDollarNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarOrDollarNin$Outbound = string | number | boolean;

/** @internal */
export const DollarOrDollarNin$outboundSchema: z.ZodType<
  DollarOrDollarNin$Outbound,
  z.ZodTypeDef,
  DollarOrDollarNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarNin$ {
  /** @deprecated use `DollarOrDollarNin$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarNin$inboundSchema;
  /** @deprecated use `DollarOrDollarNin$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarNin$outboundSchema;
  /** @deprecated use `DollarOrDollarNin$Outbound` instead. */
  export type Outbound = DollarOrDollarNin$Outbound;
}

export function dollarOrDollarNinToJSON(
  dollarOrDollarNin: DollarOrDollarNin,
): string {
  return JSON.stringify(
    DollarOrDollarNin$outboundSchema.parse(dollarOrDollarNin),
  );
}

export function dollarOrDollarNinFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarNin' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarOrDollarNin$inboundSchema: z.ZodType<
  DeploymentsDollarOrDollarNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  $nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$nin": "dollarNin",
  });
});

/** @internal */
export type DeploymentsDollarOrDollarNin$Outbound = {
  $nin: Array<string | number | boolean>;
};

/** @internal */
export const DeploymentsDollarOrDollarNin$outboundSchema: z.ZodType<
  DeploymentsDollarOrDollarNin$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarOrDollarNin
> = z.object({
  dollarNin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarNin: "$nin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarOrDollarNin$ {
  /** @deprecated use `DeploymentsDollarOrDollarNin$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarOrDollarNin$inboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarNin$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarOrDollarNin$outboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarNin$Outbound` instead. */
  export type Outbound = DeploymentsDollarOrDollarNin$Outbound;
}

export function deploymentsDollarOrDollarNinToJSON(
  deploymentsDollarOrDollarNin: DeploymentsDollarOrDollarNin,
): string {
  return JSON.stringify(
    DeploymentsDollarOrDollarNin$outboundSchema.parse(
      deploymentsDollarOrDollarNin,
    ),
  );
}

export function deploymentsDollarOrDollarNinFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarOrDollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarOrDollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarOrDollarNin' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarIn$inboundSchema: z.ZodType<
  DollarOrDollarIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarOrDollarIn$Outbound = string | number | boolean;

/** @internal */
export const DollarOrDollarIn$outboundSchema: z.ZodType<
  DollarOrDollarIn$Outbound,
  z.ZodTypeDef,
  DollarOrDollarIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarIn$ {
  /** @deprecated use `DollarOrDollarIn$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarIn$inboundSchema;
  /** @deprecated use `DollarOrDollarIn$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarIn$outboundSchema;
  /** @deprecated use `DollarOrDollarIn$Outbound` instead. */
  export type Outbound = DollarOrDollarIn$Outbound;
}

export function dollarOrDollarInToJSON(
  dollarOrDollarIn: DollarOrDollarIn,
): string {
  return JSON.stringify(
    DollarOrDollarIn$outboundSchema.parse(dollarOrDollarIn),
  );
}

export function dollarOrDollarInFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarIn' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarOrDollarIn$inboundSchema: z.ZodType<
  DeploymentsDollarOrDollarIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  $in: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$in": "dollarIn",
  });
});

/** @internal */
export type DeploymentsDollarOrDollarIn$Outbound = {
  $in: Array<string | number | boolean>;
};

/** @internal */
export const DeploymentsDollarOrDollarIn$outboundSchema: z.ZodType<
  DeploymentsDollarOrDollarIn$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarOrDollarIn
> = z.object({
  dollarIn: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarIn: "$in",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarOrDollarIn$ {
  /** @deprecated use `DeploymentsDollarOrDollarIn$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarOrDollarIn$inboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarIn$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarOrDollarIn$outboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarIn$Outbound` instead. */
  export type Outbound = DeploymentsDollarOrDollarIn$Outbound;
}

export function deploymentsDollarOrDollarInToJSON(
  deploymentsDollarOrDollarIn: DeploymentsDollarOrDollarIn,
): string {
  return JSON.stringify(
    DeploymentsDollarOrDollarIn$outboundSchema.parse(
      deploymentsDollarOrDollarIn,
    ),
  );
}

export function deploymentsDollarOrDollarInFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarOrDollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarOrDollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarOrDollarIn' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarLte$inboundSchema: z.ZodType<
  DollarOrDollarLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lte": "dollarLte",
  });
});

/** @internal */
export type DollarOrDollarLte$Outbound = {
  $lte: number;
};

/** @internal */
export const DollarOrDollarLte$outboundSchema: z.ZodType<
  DollarOrDollarLte$Outbound,
  z.ZodTypeDef,
  DollarOrDollarLte
> = z.object({
  dollarLte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLte: "$lte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarLte$ {
  /** @deprecated use `DollarOrDollarLte$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarLte$inboundSchema;
  /** @deprecated use `DollarOrDollarLte$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarLte$outboundSchema;
  /** @deprecated use `DollarOrDollarLte$Outbound` instead. */
  export type Outbound = DollarOrDollarLte$Outbound;
}

export function dollarOrDollarLteToJSON(
  dollarOrDollarLte: DollarOrDollarLte,
): string {
  return JSON.stringify(
    DollarOrDollarLte$outboundSchema.parse(dollarOrDollarLte),
  );
}

export function dollarOrDollarLteFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarLte' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarLt$inboundSchema: z.ZodType<
  DollarOrDollarLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lt: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lt": "dollarLt",
  });
});

/** @internal */
export type DollarOrDollarLt$Outbound = {
  $lt: number;
};

/** @internal */
export const DollarOrDollarLt$outboundSchema: z.ZodType<
  DollarOrDollarLt$Outbound,
  z.ZodTypeDef,
  DollarOrDollarLt
> = z.object({
  dollarLt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLt: "$lt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarLt$ {
  /** @deprecated use `DollarOrDollarLt$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarLt$inboundSchema;
  /** @deprecated use `DollarOrDollarLt$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarLt$outboundSchema;
  /** @deprecated use `DollarOrDollarLt$Outbound` instead. */
  export type Outbound = DollarOrDollarLt$Outbound;
}

export function dollarOrDollarLtToJSON(
  dollarOrDollarLt: DollarOrDollarLt,
): string {
  return JSON.stringify(
    DollarOrDollarLt$outboundSchema.parse(dollarOrDollarLt),
  );
}

export function dollarOrDollarLtFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarLt' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarGte$inboundSchema: z.ZodType<
  DollarOrDollarGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $gte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$gte": "dollarGte",
  });
});

/** @internal */
export type DollarOrDollarGte$Outbound = {
  $gte: number;
};

/** @internal */
export const DollarOrDollarGte$outboundSchema: z.ZodType<
  DollarOrDollarGte$Outbound,
  z.ZodTypeDef,
  DollarOrDollarGte
> = z.object({
  dollarGte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGte: "$gte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarGte$ {
  /** @deprecated use `DollarOrDollarGte$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarGte$inboundSchema;
  /** @deprecated use `DollarOrDollarGte$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarGte$outboundSchema;
  /** @deprecated use `DollarOrDollarGte$Outbound` instead. */
  export type Outbound = DollarOrDollarGte$Outbound;
}

export function dollarOrDollarGteToJSON(
  dollarOrDollarGte: DollarOrDollarGte,
): string {
  return JSON.stringify(
    DollarOrDollarGte$outboundSchema.parse(dollarOrDollarGte),
  );
}

export function dollarOrDollarGteFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarGte' from JSON`,
  );
}

/** @internal */
export const DollarOr3$inboundSchema: z.ZodType<
  DollarOr3,
  z.ZodTypeDef,
  unknown
> = z.object({
  $gt: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$gt": "dollarGt",
  });
});

/** @internal */
export type DollarOr3$Outbound = {
  $gt: number;
};

/** @internal */
export const DollarOr3$outboundSchema: z.ZodType<
  DollarOr3$Outbound,
  z.ZodTypeDef,
  DollarOr3
> = z.object({
  dollarGt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGt: "$gt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOr3$ {
  /** @deprecated use `DollarOr3$inboundSchema` instead. */
  export const inboundSchema = DollarOr3$inboundSchema;
  /** @deprecated use `DollarOr3$outboundSchema` instead. */
  export const outboundSchema = DollarOr3$outboundSchema;
  /** @deprecated use `DollarOr3$Outbound` instead. */
  export type Outbound = DollarOr3$Outbound;
}

export function dollarOr3ToJSON(dollarOr3: DollarOr3): string {
  return JSON.stringify(DollarOr3$outboundSchema.parse(dollarOr3));
}

export function dollarOr3FromJSON(
  jsonString: string,
): SafeParseResult<DollarOr3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOr3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOr3' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarNe$inboundSchema: z.ZodType<
  DollarOrDollarNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarOrDollarNe$Outbound = string | number | boolean;

/** @internal */
export const DollarOrDollarNe$outboundSchema: z.ZodType<
  DollarOrDollarNe$Outbound,
  z.ZodTypeDef,
  DollarOrDollarNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarNe$ {
  /** @deprecated use `DollarOrDollarNe$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarNe$inboundSchema;
  /** @deprecated use `DollarOrDollarNe$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarNe$outboundSchema;
  /** @deprecated use `DollarOrDollarNe$Outbound` instead. */
  export type Outbound = DollarOrDollarNe$Outbound;
}

export function dollarOrDollarNeToJSON(
  dollarOrDollarNe: DollarOrDollarNe,
): string {
  return JSON.stringify(
    DollarOrDollarNe$outboundSchema.parse(dollarOrDollarNe),
  );
}

export function dollarOrDollarNeFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarNe' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarOrDollarNe$inboundSchema: z.ZodType<
  DeploymentsDollarOrDollarNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  $ne: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$ne": "dollarNe",
  });
});

/** @internal */
export type DeploymentsDollarOrDollarNe$Outbound = {
  $ne: string | number | boolean;
};

/** @internal */
export const DeploymentsDollarOrDollarNe$outboundSchema: z.ZodType<
  DeploymentsDollarOrDollarNe$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarOrDollarNe
> = z.object({
  dollarNe: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarNe: "$ne",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarOrDollarNe$ {
  /** @deprecated use `DeploymentsDollarOrDollarNe$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarOrDollarNe$inboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarNe$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarOrDollarNe$outboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarNe$Outbound` instead. */
  export type Outbound = DeploymentsDollarOrDollarNe$Outbound;
}

export function deploymentsDollarOrDollarNeToJSON(
  deploymentsDollarOrDollarNe: DeploymentsDollarOrDollarNe,
): string {
  return JSON.stringify(
    DeploymentsDollarOrDollarNe$outboundSchema.parse(
      deploymentsDollarOrDollarNe,
    ),
  );
}

export function deploymentsDollarOrDollarNeFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarOrDollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarOrDollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarOrDollarNe' from JSON`,
  );
}

/** @internal */
export const DollarOrDollarEq$inboundSchema: z.ZodType<
  DollarOrDollarEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarOrDollarEq$Outbound = string | number | boolean;

/** @internal */
export const DollarOrDollarEq$outboundSchema: z.ZodType<
  DollarOrDollarEq$Outbound,
  z.ZodTypeDef,
  DollarOrDollarEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOrDollarEq$ {
  /** @deprecated use `DollarOrDollarEq$inboundSchema` instead. */
  export const inboundSchema = DollarOrDollarEq$inboundSchema;
  /** @deprecated use `DollarOrDollarEq$outboundSchema` instead. */
  export const outboundSchema = DollarOrDollarEq$outboundSchema;
  /** @deprecated use `DollarOrDollarEq$Outbound` instead. */
  export type Outbound = DollarOrDollarEq$Outbound;
}

export function dollarOrDollarEqToJSON(
  dollarOrDollarEq: DollarOrDollarEq,
): string {
  return JSON.stringify(
    DollarOrDollarEq$outboundSchema.parse(dollarOrDollarEq),
  );
}

export function dollarOrDollarEqFromJSON(
  jsonString: string,
): SafeParseResult<DollarOrDollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOrDollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOrDollarEq' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarOrDollarEq$inboundSchema: z.ZodType<
  DeploymentsDollarOrDollarEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  $eq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$eq": "dollarEq",
  });
});

/** @internal */
export type DeploymentsDollarOrDollarEq$Outbound = {
  $eq: string | number | boolean;
};

/** @internal */
export const DeploymentsDollarOrDollarEq$outboundSchema: z.ZodType<
  DeploymentsDollarOrDollarEq$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarOrDollarEq
> = z.object({
  dollarEq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarEq: "$eq",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarOrDollarEq$ {
  /** @deprecated use `DeploymentsDollarOrDollarEq$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarOrDollarEq$inboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarEq$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarOrDollarEq$outboundSchema;
  /** @deprecated use `DeploymentsDollarOrDollarEq$Outbound` instead. */
  export type Outbound = DeploymentsDollarOrDollarEq$Outbound;
}

export function deploymentsDollarOrDollarEqToJSON(
  deploymentsDollarOrDollarEq: DeploymentsDollarOrDollarEq,
): string {
  return JSON.stringify(
    DeploymentsDollarOrDollarEq$outboundSchema.parse(
      deploymentsDollarOrDollarEq,
    ),
  );
}

export function deploymentsDollarOrDollarEqFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarOrDollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarOrDollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarOrDollarEq' from JSON`,
  );
}

/** @internal */
export const DollarOr$inboundSchema: z.ZodType<
  DollarOr,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DeploymentsDollarOrDollarEq$inboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarNe$inboundSchema),
  z.lazy(() => DollarOr3$inboundSchema),
  z.lazy(() => DollarOrDollarGte$inboundSchema),
  z.lazy(() => DollarOrDollarLt$inboundSchema),
  z.lazy(() => DollarOrDollarLte$inboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarIn$inboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarNin$inboundSchema),
  z.lazy(() => DollarOrDollarExists$inboundSchema),
]);

/** @internal */
export type DollarOr$Outbound =
  | DeploymentsDollarOrDollarEq$Outbound
  | DeploymentsDollarOrDollarNe$Outbound
  | DollarOr3$Outbound
  | DollarOrDollarGte$Outbound
  | DollarOrDollarLt$Outbound
  | DollarOrDollarLte$Outbound
  | DeploymentsDollarOrDollarIn$Outbound
  | DeploymentsDollarOrDollarNin$Outbound
  | DollarOrDollarExists$Outbound;

/** @internal */
export const DollarOr$outboundSchema: z.ZodType<
  DollarOr$Outbound,
  z.ZodTypeDef,
  DollarOr
> = z.union([
  z.lazy(() => DeploymentsDollarOrDollarEq$outboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarNe$outboundSchema),
  z.lazy(() => DollarOr3$outboundSchema),
  z.lazy(() => DollarOrDollarGte$outboundSchema),
  z.lazy(() => DollarOrDollarLt$outboundSchema),
  z.lazy(() => DollarOrDollarLte$outboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarIn$outboundSchema),
  z.lazy(() => DeploymentsDollarOrDollarNin$outboundSchema),
  z.lazy(() => DollarOrDollarExists$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarOr$ {
  /** @deprecated use `DollarOr$inboundSchema` instead. */
  export const inboundSchema = DollarOr$inboundSchema;
  /** @deprecated use `DollarOr$outboundSchema` instead. */
  export const outboundSchema = DollarOr$outboundSchema;
  /** @deprecated use `DollarOr$Outbound` instead. */
  export type Outbound = DollarOr$Outbound;
}

export function dollarOrToJSON(dollarOr: DollarOr): string {
  return JSON.stringify(DollarOr$outboundSchema.parse(dollarOr));
}

export function dollarOrFromJSON(
  jsonString: string,
): SafeParseResult<DollarOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarOr' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterDollarOr$inboundSchema: z.ZodType<
  KnowledgeFilterDollarOr,
  z.ZodTypeDef,
  unknown
> = z.object({
  $or: z.array(
    z.record(z.union([
      z.lazy(() => DeploymentsDollarOrDollarEq$inboundSchema),
      z.lazy(() =>
        DeploymentsDollarOrDollarNe$inboundSchema
      ),
      z.lazy(() => DollarOr3$inboundSchema),
      z.lazy(() => DollarOrDollarGte$inboundSchema),
      z.lazy(() => DollarOrDollarLt$inboundSchema),
      z.lazy(() => DollarOrDollarLte$inboundSchema),
      z.lazy(() => DeploymentsDollarOrDollarIn$inboundSchema),
      z.lazy(() => DeploymentsDollarOrDollarNin$inboundSchema),
      z.lazy(() => DollarOrDollarExists$inboundSchema),
    ])),
  ),
}).transform((v) => {
  return remap$(v, {
    "$or": "dollarOr",
  });
});

/** @internal */
export type KnowledgeFilterDollarOr$Outbound = {
  $or: Array<
    {
      [k: string]:
        | DeploymentsDollarOrDollarEq$Outbound
        | DeploymentsDollarOrDollarNe$Outbound
        | DollarOr3$Outbound
        | DollarOrDollarGte$Outbound
        | DollarOrDollarLt$Outbound
        | DollarOrDollarLte$Outbound
        | DeploymentsDollarOrDollarIn$Outbound
        | DeploymentsDollarOrDollarNin$Outbound
        | DollarOrDollarExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterDollarOr$outboundSchema: z.ZodType<
  KnowledgeFilterDollarOr$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterDollarOr
> = z.object({
  dollarOr: z.array(
    z.record(z.union([
      z.lazy(() => DeploymentsDollarOrDollarEq$outboundSchema),
      z.lazy(() =>
        DeploymentsDollarOrDollarNe$outboundSchema
      ),
      z.lazy(() => DollarOr3$outboundSchema),
      z.lazy(() => DollarOrDollarGte$outboundSchema),
      z.lazy(() => DollarOrDollarLt$outboundSchema),
      z.lazy(() => DollarOrDollarLte$outboundSchema),
      z.lazy(() => DeploymentsDollarOrDollarIn$outboundSchema),
      z.lazy(() => DeploymentsDollarOrDollarNin$outboundSchema),
      z.lazy(() => DollarOrDollarExists$outboundSchema),
    ])),
  ),
}).transform((v) => {
  return remap$(v, {
    dollarOr: "$or",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeFilterDollarOr$ {
  /** @deprecated use `KnowledgeFilterDollarOr$inboundSchema` instead. */
  export const inboundSchema = KnowledgeFilterDollarOr$inboundSchema;
  /** @deprecated use `KnowledgeFilterDollarOr$outboundSchema` instead. */
  export const outboundSchema = KnowledgeFilterDollarOr$outboundSchema;
  /** @deprecated use `KnowledgeFilterDollarOr$Outbound` instead. */
  export type Outbound = KnowledgeFilterDollarOr$Outbound;
}

export function knowledgeFilterDollarOrToJSON(
  knowledgeFilterDollarOr: KnowledgeFilterDollarOr,
): string {
  return JSON.stringify(
    KnowledgeFilterDollarOr$outboundSchema.parse(knowledgeFilterDollarOr),
  );
}

export function knowledgeFilterDollarOrFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterDollarOr, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterDollarOr$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterDollarOr' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarExists$inboundSchema: z.ZodType<
  DollarAndDollarExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  $exists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "$exists": "dollarExists",
  });
});

/** @internal */
export type DollarAndDollarExists$Outbound = {
  $exists: boolean;
};

/** @internal */
export const DollarAndDollarExists$outboundSchema: z.ZodType<
  DollarAndDollarExists$Outbound,
  z.ZodTypeDef,
  DollarAndDollarExists
> = z.object({
  dollarExists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    dollarExists: "$exists",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarExists$ {
  /** @deprecated use `DollarAndDollarExists$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarExists$inboundSchema;
  /** @deprecated use `DollarAndDollarExists$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarExists$outboundSchema;
  /** @deprecated use `DollarAndDollarExists$Outbound` instead. */
  export type Outbound = DollarAndDollarExists$Outbound;
}

export function dollarAndDollarExistsToJSON(
  dollarAndDollarExists: DollarAndDollarExists,
): string {
  return JSON.stringify(
    DollarAndDollarExists$outboundSchema.parse(dollarAndDollarExists),
  );
}

export function dollarAndDollarExistsFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarExists' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarNin$inboundSchema: z.ZodType<
  DollarAndDollarNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarAndDollarNin$Outbound = string | number | boolean;

/** @internal */
export const DollarAndDollarNin$outboundSchema: z.ZodType<
  DollarAndDollarNin$Outbound,
  z.ZodTypeDef,
  DollarAndDollarNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarNin$ {
  /** @deprecated use `DollarAndDollarNin$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarNin$inboundSchema;
  /** @deprecated use `DollarAndDollarNin$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarNin$outboundSchema;
  /** @deprecated use `DollarAndDollarNin$Outbound` instead. */
  export type Outbound = DollarAndDollarNin$Outbound;
}

export function dollarAndDollarNinToJSON(
  dollarAndDollarNin: DollarAndDollarNin,
): string {
  return JSON.stringify(
    DollarAndDollarNin$outboundSchema.parse(dollarAndDollarNin),
  );
}

export function dollarAndDollarNinFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarNin' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarAndDollarNin$inboundSchema: z.ZodType<
  DeploymentsDollarAndDollarNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  $nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$nin": "dollarNin",
  });
});

/** @internal */
export type DeploymentsDollarAndDollarNin$Outbound = {
  $nin: Array<string | number | boolean>;
};

/** @internal */
export const DeploymentsDollarAndDollarNin$outboundSchema: z.ZodType<
  DeploymentsDollarAndDollarNin$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarAndDollarNin
> = z.object({
  dollarNin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarNin: "$nin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarAndDollarNin$ {
  /** @deprecated use `DeploymentsDollarAndDollarNin$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarAndDollarNin$inboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarNin$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarAndDollarNin$outboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarNin$Outbound` instead. */
  export type Outbound = DeploymentsDollarAndDollarNin$Outbound;
}

export function deploymentsDollarAndDollarNinToJSON(
  deploymentsDollarAndDollarNin: DeploymentsDollarAndDollarNin,
): string {
  return JSON.stringify(
    DeploymentsDollarAndDollarNin$outboundSchema.parse(
      deploymentsDollarAndDollarNin,
    ),
  );
}

export function deploymentsDollarAndDollarNinFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarAndDollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarAndDollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarAndDollarNin' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarIn$inboundSchema: z.ZodType<
  DollarAndDollarIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarAndDollarIn$Outbound = string | number | boolean;

/** @internal */
export const DollarAndDollarIn$outboundSchema: z.ZodType<
  DollarAndDollarIn$Outbound,
  z.ZodTypeDef,
  DollarAndDollarIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarIn$ {
  /** @deprecated use `DollarAndDollarIn$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarIn$inboundSchema;
  /** @deprecated use `DollarAndDollarIn$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarIn$outboundSchema;
  /** @deprecated use `DollarAndDollarIn$Outbound` instead. */
  export type Outbound = DollarAndDollarIn$Outbound;
}

export function dollarAndDollarInToJSON(
  dollarAndDollarIn: DollarAndDollarIn,
): string {
  return JSON.stringify(
    DollarAndDollarIn$outboundSchema.parse(dollarAndDollarIn),
  );
}

export function dollarAndDollarInFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarIn' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarAndDollarIn$inboundSchema: z.ZodType<
  DeploymentsDollarAndDollarIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  $in: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$in": "dollarIn",
  });
});

/** @internal */
export type DeploymentsDollarAndDollarIn$Outbound = {
  $in: Array<string | number | boolean>;
};

/** @internal */
export const DeploymentsDollarAndDollarIn$outboundSchema: z.ZodType<
  DeploymentsDollarAndDollarIn$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarAndDollarIn
> = z.object({
  dollarIn: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarIn: "$in",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarAndDollarIn$ {
  /** @deprecated use `DeploymentsDollarAndDollarIn$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarAndDollarIn$inboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarIn$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarAndDollarIn$outboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarIn$Outbound` instead. */
  export type Outbound = DeploymentsDollarAndDollarIn$Outbound;
}

export function deploymentsDollarAndDollarInToJSON(
  deploymentsDollarAndDollarIn: DeploymentsDollarAndDollarIn,
): string {
  return JSON.stringify(
    DeploymentsDollarAndDollarIn$outboundSchema.parse(
      deploymentsDollarAndDollarIn,
    ),
  );
}

export function deploymentsDollarAndDollarInFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarAndDollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarAndDollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarAndDollarIn' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarLte$inboundSchema: z.ZodType<
  DollarAndDollarLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lte": "dollarLte",
  });
});

/** @internal */
export type DollarAndDollarLte$Outbound = {
  $lte: number;
};

/** @internal */
export const DollarAndDollarLte$outboundSchema: z.ZodType<
  DollarAndDollarLte$Outbound,
  z.ZodTypeDef,
  DollarAndDollarLte
> = z.object({
  dollarLte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLte: "$lte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarLte$ {
  /** @deprecated use `DollarAndDollarLte$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarLte$inboundSchema;
  /** @deprecated use `DollarAndDollarLte$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarLte$outboundSchema;
  /** @deprecated use `DollarAndDollarLte$Outbound` instead. */
  export type Outbound = DollarAndDollarLte$Outbound;
}

export function dollarAndDollarLteToJSON(
  dollarAndDollarLte: DollarAndDollarLte,
): string {
  return JSON.stringify(
    DollarAndDollarLte$outboundSchema.parse(dollarAndDollarLte),
  );
}

export function dollarAndDollarLteFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarLte' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarLt$inboundSchema: z.ZodType<
  DollarAndDollarLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lt: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lt": "dollarLt",
  });
});

/** @internal */
export type DollarAndDollarLt$Outbound = {
  $lt: number;
};

/** @internal */
export const DollarAndDollarLt$outboundSchema: z.ZodType<
  DollarAndDollarLt$Outbound,
  z.ZodTypeDef,
  DollarAndDollarLt
> = z.object({
  dollarLt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLt: "$lt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarLt$ {
  /** @deprecated use `DollarAndDollarLt$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarLt$inboundSchema;
  /** @deprecated use `DollarAndDollarLt$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarLt$outboundSchema;
  /** @deprecated use `DollarAndDollarLt$Outbound` instead. */
  export type Outbound = DollarAndDollarLt$Outbound;
}

export function dollarAndDollarLtToJSON(
  dollarAndDollarLt: DollarAndDollarLt,
): string {
  return JSON.stringify(
    DollarAndDollarLt$outboundSchema.parse(dollarAndDollarLt),
  );
}

export function dollarAndDollarLtFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarLt' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarGte$inboundSchema: z.ZodType<
  DollarAndDollarGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $gte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$gte": "dollarGte",
  });
});

/** @internal */
export type DollarAndDollarGte$Outbound = {
  $gte: number;
};

/** @internal */
export const DollarAndDollarGte$outboundSchema: z.ZodType<
  DollarAndDollarGte$Outbound,
  z.ZodTypeDef,
  DollarAndDollarGte
> = z.object({
  dollarGte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGte: "$gte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarGte$ {
  /** @deprecated use `DollarAndDollarGte$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarGte$inboundSchema;
  /** @deprecated use `DollarAndDollarGte$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarGte$outboundSchema;
  /** @deprecated use `DollarAndDollarGte$Outbound` instead. */
  export type Outbound = DollarAndDollarGte$Outbound;
}

export function dollarAndDollarGteToJSON(
  dollarAndDollarGte: DollarAndDollarGte,
): string {
  return JSON.stringify(
    DollarAndDollarGte$outboundSchema.parse(dollarAndDollarGte),
  );
}

export function dollarAndDollarGteFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarGte' from JSON`,
  );
}

/** @internal */
export const DollarAnd3$inboundSchema: z.ZodType<
  DollarAnd3,
  z.ZodTypeDef,
  unknown
> = z.object({
  $gt: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$gt": "dollarGt",
  });
});

/** @internal */
export type DollarAnd3$Outbound = {
  $gt: number;
};

/** @internal */
export const DollarAnd3$outboundSchema: z.ZodType<
  DollarAnd3$Outbound,
  z.ZodTypeDef,
  DollarAnd3
> = z.object({
  dollarGt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGt: "$gt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAnd3$ {
  /** @deprecated use `DollarAnd3$inboundSchema` instead. */
  export const inboundSchema = DollarAnd3$inboundSchema;
  /** @deprecated use `DollarAnd3$outboundSchema` instead. */
  export const outboundSchema = DollarAnd3$outboundSchema;
  /** @deprecated use `DollarAnd3$Outbound` instead. */
  export type Outbound = DollarAnd3$Outbound;
}

export function dollarAnd3ToJSON(dollarAnd3: DollarAnd3): string {
  return JSON.stringify(DollarAnd3$outboundSchema.parse(dollarAnd3));
}

export function dollarAnd3FromJSON(
  jsonString: string,
): SafeParseResult<DollarAnd3, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAnd3$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAnd3' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarNe$inboundSchema: z.ZodType<
  DollarAndDollarNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarAndDollarNe$Outbound = string | number | boolean;

/** @internal */
export const DollarAndDollarNe$outboundSchema: z.ZodType<
  DollarAndDollarNe$Outbound,
  z.ZodTypeDef,
  DollarAndDollarNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarNe$ {
  /** @deprecated use `DollarAndDollarNe$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarNe$inboundSchema;
  /** @deprecated use `DollarAndDollarNe$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarNe$outboundSchema;
  /** @deprecated use `DollarAndDollarNe$Outbound` instead. */
  export type Outbound = DollarAndDollarNe$Outbound;
}

export function dollarAndDollarNeToJSON(
  dollarAndDollarNe: DollarAndDollarNe,
): string {
  return JSON.stringify(
    DollarAndDollarNe$outboundSchema.parse(dollarAndDollarNe),
  );
}

export function dollarAndDollarNeFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarNe' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarAndDollarNe$inboundSchema: z.ZodType<
  DeploymentsDollarAndDollarNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  $ne: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$ne": "dollarNe",
  });
});

/** @internal */
export type DeploymentsDollarAndDollarNe$Outbound = {
  $ne: string | number | boolean;
};

/** @internal */
export const DeploymentsDollarAndDollarNe$outboundSchema: z.ZodType<
  DeploymentsDollarAndDollarNe$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarAndDollarNe
> = z.object({
  dollarNe: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarNe: "$ne",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarAndDollarNe$ {
  /** @deprecated use `DeploymentsDollarAndDollarNe$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarAndDollarNe$inboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarNe$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarAndDollarNe$outboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarNe$Outbound` instead. */
  export type Outbound = DeploymentsDollarAndDollarNe$Outbound;
}

export function deploymentsDollarAndDollarNeToJSON(
  deploymentsDollarAndDollarNe: DeploymentsDollarAndDollarNe,
): string {
  return JSON.stringify(
    DeploymentsDollarAndDollarNe$outboundSchema.parse(
      deploymentsDollarAndDollarNe,
    ),
  );
}

export function deploymentsDollarAndDollarNeFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarAndDollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarAndDollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarAndDollarNe' from JSON`,
  );
}

/** @internal */
export const DollarAndDollarEq$inboundSchema: z.ZodType<
  DollarAndDollarEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarAndDollarEq$Outbound = string | number | boolean;

/** @internal */
export const DollarAndDollarEq$outboundSchema: z.ZodType<
  DollarAndDollarEq$Outbound,
  z.ZodTypeDef,
  DollarAndDollarEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAndDollarEq$ {
  /** @deprecated use `DollarAndDollarEq$inboundSchema` instead. */
  export const inboundSchema = DollarAndDollarEq$inboundSchema;
  /** @deprecated use `DollarAndDollarEq$outboundSchema` instead. */
  export const outboundSchema = DollarAndDollarEq$outboundSchema;
  /** @deprecated use `DollarAndDollarEq$Outbound` instead. */
  export type Outbound = DollarAndDollarEq$Outbound;
}

export function dollarAndDollarEqToJSON(
  dollarAndDollarEq: DollarAndDollarEq,
): string {
  return JSON.stringify(
    DollarAndDollarEq$outboundSchema.parse(dollarAndDollarEq),
  );
}

export function dollarAndDollarEqFromJSON(
  jsonString: string,
): SafeParseResult<DollarAndDollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAndDollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAndDollarEq' from JSON`,
  );
}

/** @internal */
export const DeploymentsDollarAndDollarEq$inboundSchema: z.ZodType<
  DeploymentsDollarAndDollarEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  $eq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$eq": "dollarEq",
  });
});

/** @internal */
export type DeploymentsDollarAndDollarEq$Outbound = {
  $eq: string | number | boolean;
};

/** @internal */
export const DeploymentsDollarAndDollarEq$outboundSchema: z.ZodType<
  DeploymentsDollarAndDollarEq$Outbound,
  z.ZodTypeDef,
  DeploymentsDollarAndDollarEq
> = z.object({
  dollarEq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarEq: "$eq",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsDollarAndDollarEq$ {
  /** @deprecated use `DeploymentsDollarAndDollarEq$inboundSchema` instead. */
  export const inboundSchema = DeploymentsDollarAndDollarEq$inboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarEq$outboundSchema` instead. */
  export const outboundSchema = DeploymentsDollarAndDollarEq$outboundSchema;
  /** @deprecated use `DeploymentsDollarAndDollarEq$Outbound` instead. */
  export type Outbound = DeploymentsDollarAndDollarEq$Outbound;
}

export function deploymentsDollarAndDollarEqToJSON(
  deploymentsDollarAndDollarEq: DeploymentsDollarAndDollarEq,
): string {
  return JSON.stringify(
    DeploymentsDollarAndDollarEq$outboundSchema.parse(
      deploymentsDollarAndDollarEq,
    ),
  );
}

export function deploymentsDollarAndDollarEqFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsDollarAndDollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsDollarAndDollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsDollarAndDollarEq' from JSON`,
  );
}

/** @internal */
export const DollarAnd$inboundSchema: z.ZodType<
  DollarAnd,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => DeploymentsDollarAndDollarEq$inboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarNe$inboundSchema),
  z.lazy(() => DollarAnd3$inboundSchema),
  z.lazy(() => DollarAndDollarGte$inboundSchema),
  z.lazy(() => DollarAndDollarLt$inboundSchema),
  z.lazy(() => DollarAndDollarLte$inboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarIn$inboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarNin$inboundSchema),
  z.lazy(() => DollarAndDollarExists$inboundSchema),
]);

/** @internal */
export type DollarAnd$Outbound =
  | DeploymentsDollarAndDollarEq$Outbound
  | DeploymentsDollarAndDollarNe$Outbound
  | DollarAnd3$Outbound
  | DollarAndDollarGte$Outbound
  | DollarAndDollarLt$Outbound
  | DollarAndDollarLte$Outbound
  | DeploymentsDollarAndDollarIn$Outbound
  | DeploymentsDollarAndDollarNin$Outbound
  | DollarAndDollarExists$Outbound;

/** @internal */
export const DollarAnd$outboundSchema: z.ZodType<
  DollarAnd$Outbound,
  z.ZodTypeDef,
  DollarAnd
> = z.union([
  z.lazy(() => DeploymentsDollarAndDollarEq$outboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarNe$outboundSchema),
  z.lazy(() => DollarAnd3$outboundSchema),
  z.lazy(() => DollarAndDollarGte$outboundSchema),
  z.lazy(() => DollarAndDollarLt$outboundSchema),
  z.lazy(() => DollarAndDollarLte$outboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarIn$outboundSchema),
  z.lazy(() => DeploymentsDollarAndDollarNin$outboundSchema),
  z.lazy(() => DollarAndDollarExists$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarAnd$ {
  /** @deprecated use `DollarAnd$inboundSchema` instead. */
  export const inboundSchema = DollarAnd$inboundSchema;
  /** @deprecated use `DollarAnd$outboundSchema` instead. */
  export const outboundSchema = DollarAnd$outboundSchema;
  /** @deprecated use `DollarAnd$Outbound` instead. */
  export type Outbound = DollarAnd$Outbound;
}

export function dollarAndToJSON(dollarAnd: DollarAnd): string {
  return JSON.stringify(DollarAnd$outboundSchema.parse(dollarAnd));
}

export function dollarAndFromJSON(
  jsonString: string,
): SafeParseResult<DollarAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarAnd' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilterDollarAnd$inboundSchema: z.ZodType<
  KnowledgeFilterDollarAnd,
  z.ZodTypeDef,
  unknown
> = z.object({
  $and: z.array(
    z.record(z.union([
      z.lazy(() => DeploymentsDollarAndDollarEq$inboundSchema),
      z.lazy(() =>
        DeploymentsDollarAndDollarNe$inboundSchema
      ),
      z.lazy(() => DollarAnd3$inboundSchema),
      z.lazy(() => DollarAndDollarGte$inboundSchema),
      z.lazy(() => DollarAndDollarLt$inboundSchema),
      z.lazy(() => DollarAndDollarLte$inboundSchema),
      z.lazy(() => DeploymentsDollarAndDollarIn$inboundSchema),
      z.lazy(() => DeploymentsDollarAndDollarNin$inboundSchema),
      z.lazy(() => DollarAndDollarExists$inboundSchema),
    ])),
  ),
}).transform((v) => {
  return remap$(v, {
    "$and": "dollarAnd",
  });
});

/** @internal */
export type KnowledgeFilterDollarAnd$Outbound = {
  $and: Array<
    {
      [k: string]:
        | DeploymentsDollarAndDollarEq$Outbound
        | DeploymentsDollarAndDollarNe$Outbound
        | DollarAnd3$Outbound
        | DollarAndDollarGte$Outbound
        | DollarAndDollarLt$Outbound
        | DollarAndDollarLte$Outbound
        | DeploymentsDollarAndDollarIn$Outbound
        | DeploymentsDollarAndDollarNin$Outbound
        | DollarAndDollarExists$Outbound;
    }
  >;
};

/** @internal */
export const KnowledgeFilterDollarAnd$outboundSchema: z.ZodType<
  KnowledgeFilterDollarAnd$Outbound,
  z.ZodTypeDef,
  KnowledgeFilterDollarAnd
> = z.object({
  dollarAnd: z.array(
    z.record(z.union([
      z.lazy(() => DeploymentsDollarAndDollarEq$outboundSchema),
      z.lazy(() =>
        DeploymentsDollarAndDollarNe$outboundSchema
      ),
      z.lazy(() => DollarAnd3$outboundSchema),
      z.lazy(() => DollarAndDollarGte$outboundSchema),
      z.lazy(() => DollarAndDollarLt$outboundSchema),
      z.lazy(() => DollarAndDollarLte$outboundSchema),
      z.lazy(() => DeploymentsDollarAndDollarIn$outboundSchema),
      z.lazy(() => DeploymentsDollarAndDollarNin$outboundSchema),
      z.lazy(() => DollarAndDollarExists$outboundSchema),
    ])),
  ),
}).transform((v) => {
  return remap$(v, {
    dollarAnd: "$and",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeFilterDollarAnd$ {
  /** @deprecated use `KnowledgeFilterDollarAnd$inboundSchema` instead. */
  export const inboundSchema = KnowledgeFilterDollarAnd$inboundSchema;
  /** @deprecated use `KnowledgeFilterDollarAnd$outboundSchema` instead. */
  export const outboundSchema = KnowledgeFilterDollarAnd$outboundSchema;
  /** @deprecated use `KnowledgeFilterDollarAnd$Outbound` instead. */
  export type Outbound = KnowledgeFilterDollarAnd$Outbound;
}

export function knowledgeFilterDollarAndToJSON(
  knowledgeFilterDollarAnd: KnowledgeFilterDollarAnd,
): string {
  return JSON.stringify(
    KnowledgeFilterDollarAnd$outboundSchema.parse(knowledgeFilterDollarAnd),
  );
}

export function knowledgeFilterDollarAndFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilterDollarAnd, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilterDollarAnd$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilterDollarAnd' from JSON`,
  );
}

/** @internal */
export const DollarExists$inboundSchema: z.ZodType<
  DollarExists,
  z.ZodTypeDef,
  unknown
> = z.object({
  $exists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    "$exists": "dollarExists",
  });
});

/** @internal */
export type DollarExists$Outbound = {
  $exists: boolean;
};

/** @internal */
export const DollarExists$outboundSchema: z.ZodType<
  DollarExists$Outbound,
  z.ZodTypeDef,
  DollarExists
> = z.object({
  dollarExists: z.boolean(),
}).transform((v) => {
  return remap$(v, {
    dollarExists: "$exists",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarExists$ {
  /** @deprecated use `DollarExists$inboundSchema` instead. */
  export const inboundSchema = DollarExists$inboundSchema;
  /** @deprecated use `DollarExists$outboundSchema` instead. */
  export const outboundSchema = DollarExists$outboundSchema;
  /** @deprecated use `DollarExists$Outbound` instead. */
  export type Outbound = DollarExists$Outbound;
}

export function dollarExistsToJSON(dollarExists: DollarExists): string {
  return JSON.stringify(DollarExists$outboundSchema.parse(dollarExists));
}

export function dollarExistsFromJSON(
  jsonString: string,
): SafeParseResult<DollarExists, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarExists$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarExists' from JSON`,
  );
}

/** @internal */
export const DollarNin$inboundSchema: z.ZodType<
  DollarNin,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarNin$Outbound = string | number | boolean;

/** @internal */
export const DollarNin$outboundSchema: z.ZodType<
  DollarNin$Outbound,
  z.ZodTypeDef,
  DollarNin
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarNin$ {
  /** @deprecated use `DollarNin$inboundSchema` instead. */
  export const inboundSchema = DollarNin$inboundSchema;
  /** @deprecated use `DollarNin$outboundSchema` instead. */
  export const outboundSchema = DollarNin$outboundSchema;
  /** @deprecated use `DollarNin$Outbound` instead. */
  export type Outbound = DollarNin$Outbound;
}

export function dollarNinToJSON(dollarNin: DollarNin): string {
  return JSON.stringify(DollarNin$outboundSchema.parse(dollarNin));
}

export function dollarNinFromJSON(
  jsonString: string,
): SafeParseResult<DollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarNin' from JSON`,
  );
}

/** @internal */
export const OneDollarNin$inboundSchema: z.ZodType<
  OneDollarNin,
  z.ZodTypeDef,
  unknown
> = z.object({
  $nin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$nin": "dollarNin",
  });
});

/** @internal */
export type OneDollarNin$Outbound = {
  $nin: Array<string | number | boolean>;
};

/** @internal */
export const OneDollarNin$outboundSchema: z.ZodType<
  OneDollarNin$Outbound,
  z.ZodTypeDef,
  OneDollarNin
> = z.object({
  dollarNin: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarNin: "$nin",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OneDollarNin$ {
  /** @deprecated use `OneDollarNin$inboundSchema` instead. */
  export const inboundSchema = OneDollarNin$inboundSchema;
  /** @deprecated use `OneDollarNin$outboundSchema` instead. */
  export const outboundSchema = OneDollarNin$outboundSchema;
  /** @deprecated use `OneDollarNin$Outbound` instead. */
  export type Outbound = OneDollarNin$Outbound;
}

export function oneDollarNinToJSON(oneDollarNin: OneDollarNin): string {
  return JSON.stringify(OneDollarNin$outboundSchema.parse(oneDollarNin));
}

export function oneDollarNinFromJSON(
  jsonString: string,
): SafeParseResult<OneDollarNin, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneDollarNin$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneDollarNin' from JSON`,
  );
}

/** @internal */
export const DollarIn$inboundSchema: z.ZodType<
  DollarIn,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarIn$Outbound = string | number | boolean;

/** @internal */
export const DollarIn$outboundSchema: z.ZodType<
  DollarIn$Outbound,
  z.ZodTypeDef,
  DollarIn
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarIn$ {
  /** @deprecated use `DollarIn$inboundSchema` instead. */
  export const inboundSchema = DollarIn$inboundSchema;
  /** @deprecated use `DollarIn$outboundSchema` instead. */
  export const outboundSchema = DollarIn$outboundSchema;
  /** @deprecated use `DollarIn$Outbound` instead. */
  export type Outbound = DollarIn$Outbound;
}

export function dollarInToJSON(dollarIn: DollarIn): string {
  return JSON.stringify(DollarIn$outboundSchema.parse(dollarIn));
}

export function dollarInFromJSON(
  jsonString: string,
): SafeParseResult<DollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarIn' from JSON`,
  );
}

/** @internal */
export const OneDollarIn$inboundSchema: z.ZodType<
  OneDollarIn,
  z.ZodTypeDef,
  unknown
> = z.object({
  $in: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    "$in": "dollarIn",
  });
});

/** @internal */
export type OneDollarIn$Outbound = {
  $in: Array<string | number | boolean>;
};

/** @internal */
export const OneDollarIn$outboundSchema: z.ZodType<
  OneDollarIn$Outbound,
  z.ZodTypeDef,
  OneDollarIn
> = z.object({
  dollarIn: z.array(z.union([z.string(), z.number(), z.boolean()])),
}).transform((v) => {
  return remap$(v, {
    dollarIn: "$in",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OneDollarIn$ {
  /** @deprecated use `OneDollarIn$inboundSchema` instead. */
  export const inboundSchema = OneDollarIn$inboundSchema;
  /** @deprecated use `OneDollarIn$outboundSchema` instead. */
  export const outboundSchema = OneDollarIn$outboundSchema;
  /** @deprecated use `OneDollarIn$Outbound` instead. */
  export type Outbound = OneDollarIn$Outbound;
}

export function oneDollarInToJSON(oneDollarIn: OneDollarIn): string {
  return JSON.stringify(OneDollarIn$outboundSchema.parse(oneDollarIn));
}

export function oneDollarInFromJSON(
  jsonString: string,
): SafeParseResult<OneDollarIn, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneDollarIn$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneDollarIn' from JSON`,
  );
}

/** @internal */
export const DollarLte$inboundSchema: z.ZodType<
  DollarLte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lte": "dollarLte",
  });
});

/** @internal */
export type DollarLte$Outbound = {
  $lte: number;
};

/** @internal */
export const DollarLte$outboundSchema: z.ZodType<
  DollarLte$Outbound,
  z.ZodTypeDef,
  DollarLte
> = z.object({
  dollarLte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLte: "$lte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarLte$ {
  /** @deprecated use `DollarLte$inboundSchema` instead. */
  export const inboundSchema = DollarLte$inboundSchema;
  /** @deprecated use `DollarLte$outboundSchema` instead. */
  export const outboundSchema = DollarLte$outboundSchema;
  /** @deprecated use `DollarLte$Outbound` instead. */
  export type Outbound = DollarLte$Outbound;
}

export function dollarLteToJSON(dollarLte: DollarLte): string {
  return JSON.stringify(DollarLte$outboundSchema.parse(dollarLte));
}

export function dollarLteFromJSON(
  jsonString: string,
): SafeParseResult<DollarLte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarLte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarLte' from JSON`,
  );
}

/** @internal */
export const DollarLt$inboundSchema: z.ZodType<
  DollarLt,
  z.ZodTypeDef,
  unknown
> = z.object({
  $lt: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$lt": "dollarLt",
  });
});

/** @internal */
export type DollarLt$Outbound = {
  $lt: number;
};

/** @internal */
export const DollarLt$outboundSchema: z.ZodType<
  DollarLt$Outbound,
  z.ZodTypeDef,
  DollarLt
> = z.object({
  dollarLt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarLt: "$lt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarLt$ {
  /** @deprecated use `DollarLt$inboundSchema` instead. */
  export const inboundSchema = DollarLt$inboundSchema;
  /** @deprecated use `DollarLt$outboundSchema` instead. */
  export const outboundSchema = DollarLt$outboundSchema;
  /** @deprecated use `DollarLt$Outbound` instead. */
  export type Outbound = DollarLt$Outbound;
}

export function dollarLtToJSON(dollarLt: DollarLt): string {
  return JSON.stringify(DollarLt$outboundSchema.parse(dollarLt));
}

export function dollarLtFromJSON(
  jsonString: string,
): SafeParseResult<DollarLt, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarLt$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarLt' from JSON`,
  );
}

/** @internal */
export const DollarGte$inboundSchema: z.ZodType<
  DollarGte,
  z.ZodTypeDef,
  unknown
> = z.object({
  $gte: z.number(),
}).transform((v) => {
  return remap$(v, {
    "$gte": "dollarGte",
  });
});

/** @internal */
export type DollarGte$Outbound = {
  $gte: number;
};

/** @internal */
export const DollarGte$outboundSchema: z.ZodType<
  DollarGte$Outbound,
  z.ZodTypeDef,
  DollarGte
> = z.object({
  dollarGte: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGte: "$gte",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarGte$ {
  /** @deprecated use `DollarGte$inboundSchema` instead. */
  export const inboundSchema = DollarGte$inboundSchema;
  /** @deprecated use `DollarGte$outboundSchema` instead. */
  export const outboundSchema = DollarGte$outboundSchema;
  /** @deprecated use `DollarGte$Outbound` instead. */
  export type Outbound = DollarGte$Outbound;
}

export function dollarGteToJSON(dollarGte: DollarGte): string {
  return JSON.stringify(DollarGte$outboundSchema.parse(dollarGte));
}

export function dollarGteFromJSON(
  jsonString: string,
): SafeParseResult<DollarGte, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarGte$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarGte' from JSON`,
  );
}

/** @internal */
export const Three$inboundSchema: z.ZodType<Three, z.ZodTypeDef, unknown> = z
  .object({
    $gt: z.number(),
  }).transform((v) => {
    return remap$(v, {
      "$gt": "dollarGt",
    });
  });

/** @internal */
export type Three$Outbound = {
  $gt: number;
};

/** @internal */
export const Three$outboundSchema: z.ZodType<
  Three$Outbound,
  z.ZodTypeDef,
  Three
> = z.object({
  dollarGt: z.number(),
}).transform((v) => {
  return remap$(v, {
    dollarGt: "$gt",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Three$ {
  /** @deprecated use `Three$inboundSchema` instead. */
  export const inboundSchema = Three$inboundSchema;
  /** @deprecated use `Three$outboundSchema` instead. */
  export const outboundSchema = Three$outboundSchema;
  /** @deprecated use `Three$Outbound` instead. */
  export type Outbound = Three$Outbound;
}

export function threeToJSON(three: Three): string {
  return JSON.stringify(Three$outboundSchema.parse(three));
}

export function threeFromJSON(
  jsonString: string,
): SafeParseResult<Three, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Three$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Three' from JSON`,
  );
}

/** @internal */
export const DollarNe$inboundSchema: z.ZodType<
  DollarNe,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarNe$Outbound = string | number | boolean;

/** @internal */
export const DollarNe$outboundSchema: z.ZodType<
  DollarNe$Outbound,
  z.ZodTypeDef,
  DollarNe
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarNe$ {
  /** @deprecated use `DollarNe$inboundSchema` instead. */
  export const inboundSchema = DollarNe$inboundSchema;
  /** @deprecated use `DollarNe$outboundSchema` instead. */
  export const outboundSchema = DollarNe$outboundSchema;
  /** @deprecated use `DollarNe$Outbound` instead. */
  export type Outbound = DollarNe$Outbound;
}

export function dollarNeToJSON(dollarNe: DollarNe): string {
  return JSON.stringify(DollarNe$outboundSchema.parse(dollarNe));
}

export function dollarNeFromJSON(
  jsonString: string,
): SafeParseResult<DollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarNe' from JSON`,
  );
}

/** @internal */
export const OneDollarNe$inboundSchema: z.ZodType<
  OneDollarNe,
  z.ZodTypeDef,
  unknown
> = z.object({
  $ne: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$ne": "dollarNe",
  });
});

/** @internal */
export type OneDollarNe$Outbound = {
  $ne: string | number | boolean;
};

/** @internal */
export const OneDollarNe$outboundSchema: z.ZodType<
  OneDollarNe$Outbound,
  z.ZodTypeDef,
  OneDollarNe
> = z.object({
  dollarNe: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarNe: "$ne",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OneDollarNe$ {
  /** @deprecated use `OneDollarNe$inboundSchema` instead. */
  export const inboundSchema = OneDollarNe$inboundSchema;
  /** @deprecated use `OneDollarNe$outboundSchema` instead. */
  export const outboundSchema = OneDollarNe$outboundSchema;
  /** @deprecated use `OneDollarNe$Outbound` instead. */
  export type Outbound = OneDollarNe$Outbound;
}

export function oneDollarNeToJSON(oneDollarNe: OneDollarNe): string {
  return JSON.stringify(OneDollarNe$outboundSchema.parse(oneDollarNe));
}

export function oneDollarNeFromJSON(
  jsonString: string,
): SafeParseResult<OneDollarNe, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneDollarNe$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneDollarNe' from JSON`,
  );
}

/** @internal */
export const DollarEq$inboundSchema: z.ZodType<
  DollarEq,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type DollarEq$Outbound = string | number | boolean;

/** @internal */
export const DollarEq$outboundSchema: z.ZodType<
  DollarEq$Outbound,
  z.ZodTypeDef,
  DollarEq
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DollarEq$ {
  /** @deprecated use `DollarEq$inboundSchema` instead. */
  export const inboundSchema = DollarEq$inboundSchema;
  /** @deprecated use `DollarEq$outboundSchema` instead. */
  export const outboundSchema = DollarEq$outboundSchema;
  /** @deprecated use `DollarEq$Outbound` instead. */
  export type Outbound = DollarEq$Outbound;
}

export function dollarEqToJSON(dollarEq: DollarEq): string {
  return JSON.stringify(DollarEq$outboundSchema.parse(dollarEq));
}

export function dollarEqFromJSON(
  jsonString: string,
): SafeParseResult<DollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DollarEq' from JSON`,
  );
}

/** @internal */
export const OneDollarEq$inboundSchema: z.ZodType<
  OneDollarEq,
  z.ZodTypeDef,
  unknown
> = z.object({
  $eq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    "$eq": "dollarEq",
  });
});

/** @internal */
export type OneDollarEq$Outbound = {
  $eq: string | number | boolean;
};

/** @internal */
export const OneDollarEq$outboundSchema: z.ZodType<
  OneDollarEq$Outbound,
  z.ZodTypeDef,
  OneDollarEq
> = z.object({
  dollarEq: z.union([z.string(), z.number(), z.boolean()]),
}).transform((v) => {
  return remap$(v, {
    dollarEq: "$eq",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace OneDollarEq$ {
  /** @deprecated use `OneDollarEq$inboundSchema` instead. */
  export const inboundSchema = OneDollarEq$inboundSchema;
  /** @deprecated use `OneDollarEq$outboundSchema` instead. */
  export const outboundSchema = OneDollarEq$outboundSchema;
  /** @deprecated use `OneDollarEq$Outbound` instead. */
  export type Outbound = OneDollarEq$Outbound;
}

export function oneDollarEqToJSON(oneDollarEq: OneDollarEq): string {
  return JSON.stringify(OneDollarEq$outboundSchema.parse(oneDollarEq));
}

export function oneDollarEqFromJSON(
  jsonString: string,
): SafeParseResult<OneDollarEq, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => OneDollarEq$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'OneDollarEq' from JSON`,
  );
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z.union(
  [
    z.lazy(() => OneDollarEq$inboundSchema),
    z.lazy(() => OneDollarNe$inboundSchema),
    z.lazy(() => Three$inboundSchema),
    z.lazy(() => DollarGte$inboundSchema),
    z.lazy(() => DollarLt$inboundSchema),
    z.lazy(() => DollarLte$inboundSchema),
    z.lazy(() => OneDollarIn$inboundSchema),
    z.lazy(() => OneDollarNin$inboundSchema),
    z.lazy(() => DollarExists$inboundSchema),
  ],
);

/** @internal */
export type One$Outbound =
  | OneDollarEq$Outbound
  | OneDollarNe$Outbound
  | Three$Outbound
  | DollarGte$Outbound
  | DollarLt$Outbound
  | DollarLte$Outbound
  | OneDollarIn$Outbound
  | OneDollarNin$Outbound
  | DollarExists$Outbound;

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .union([
    z.lazy(() => OneDollarEq$outboundSchema),
    z.lazy(() => OneDollarNe$outboundSchema),
    z.lazy(() => Three$outboundSchema),
    z.lazy(() => DollarGte$outboundSchema),
    z.lazy(() => DollarLt$outboundSchema),
    z.lazy(() => DollarLte$outboundSchema),
    z.lazy(() => OneDollarIn$outboundSchema),
    z.lazy(() => OneDollarNin$outboundSchema),
    z.lazy(() => DollarExists$outboundSchema),
  ]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const KnowledgeFilter$inboundSchema: z.ZodType<
  KnowledgeFilter,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => KnowledgeFilterDollarAnd$inboundSchema),
  z.lazy(() => KnowledgeFilterDollarOr$inboundSchema),
  z.record(z.union([
    z.lazy(() => OneDollarEq$inboundSchema),
    z.lazy(() => OneDollarNe$inboundSchema),
    z.lazy(() => Three$inboundSchema),
    z.lazy(() => DollarGte$inboundSchema),
    z.lazy(() => DollarLt$inboundSchema),
    z.lazy(() => DollarLte$inboundSchema),
    z.lazy(() => OneDollarIn$inboundSchema),
    z.lazy(() => OneDollarNin$inboundSchema),
    z.lazy(() => DollarExists$inboundSchema),
  ])),
]);

/** @internal */
export type KnowledgeFilter$Outbound =
  | KnowledgeFilterDollarAnd$Outbound
  | KnowledgeFilterDollarOr$Outbound
  | {
    [k: string]:
      | OneDollarEq$Outbound
      | OneDollarNe$Outbound
      | Three$Outbound
      | DollarGte$Outbound
      | DollarLt$Outbound
      | DollarLte$Outbound
      | OneDollarIn$Outbound
      | OneDollarNin$Outbound
      | DollarExists$Outbound;
  };

/** @internal */
export const KnowledgeFilter$outboundSchema: z.ZodType<
  KnowledgeFilter$Outbound,
  z.ZodTypeDef,
  KnowledgeFilter
> = z.union([
  z.lazy(() => KnowledgeFilterDollarAnd$outboundSchema),
  z.lazy(() => KnowledgeFilterDollarOr$outboundSchema),
  z.record(z.union([
    z.lazy(() => OneDollarEq$outboundSchema),
    z.lazy(() => OneDollarNe$outboundSchema),
    z.lazy(() => Three$outboundSchema),
    z.lazy(() => DollarGte$outboundSchema),
    z.lazy(() => DollarLt$outboundSchema),
    z.lazy(() => DollarLte$outboundSchema),
    z.lazy(() => OneDollarIn$outboundSchema),
    z.lazy(() => OneDollarNin$outboundSchema),
    z.lazy(() => DollarExists$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace KnowledgeFilter$ {
  /** @deprecated use `KnowledgeFilter$inboundSchema` instead. */
  export const inboundSchema = KnowledgeFilter$inboundSchema;
  /** @deprecated use `KnowledgeFilter$outboundSchema` instead. */
  export const outboundSchema = KnowledgeFilter$outboundSchema;
  /** @deprecated use `KnowledgeFilter$Outbound` instead. */
  export type Outbound = KnowledgeFilter$Outbound;
}

export function knowledgeFilterToJSON(
  knowledgeFilter: KnowledgeFilter,
): string {
  return JSON.stringify(KnowledgeFilter$outboundSchema.parse(knowledgeFilter));
}

export function knowledgeFilterFromJSON(
  jsonString: string,
): SafeParseResult<KnowledgeFilter, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => KnowledgeFilter$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'KnowledgeFilter' from JSON`,
  );
}

/** @internal */
export const Deployments$inboundSchema: z.ZodType<
  Deployments,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  inputs: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  context: z.record(z.any()).optional(),
  prefix_messages: z.array(
    z.union([
      z.lazy(() => DeveloperMessage$inboundSchema),
      z.lazy(() => SystemMessage$inboundSchema),
      z.lazy(() => UserMessage$inboundSchema),
      z.lazy(() => ToolMessage$inboundSchema),
      z.lazy(() => AssistantMessage$inboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesDeveloperMessage$inboundSchema),
      z.lazy(() => MessagesSystemMessage$inboundSchema),
      z.lazy(() => MessagesUserMessage$inboundSchema),
      z.lazy(() => MessagesToolMessage$inboundSchema),
      z.lazy(() => MessagesAssistantMessage$inboundSchema),
    ]),
  ).optional(),
  file_ids: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extra_params: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$inboundSchema)).optional(),
  invoke_options: z.lazy(() => InvokeOptions$inboundSchema).optional(),
  thread: z.lazy(() => Thread$inboundSchema).optional(),
  knowledge_filter: z.union([
    z.lazy(() => KnowledgeFilterDollarAnd$inboundSchema),
    z.lazy(() => KnowledgeFilterDollarOr$inboundSchema),
    z.record(
      z.union([
        z.lazy(() => OneDollarEq$inboundSchema),
        z.lazy(() => OneDollarNe$inboundSchema),
        z.lazy(() => Three$inboundSchema),
        z.lazy(() => DollarGte$inboundSchema),
        z.lazy(() => DollarLt$inboundSchema),
        z.lazy(() => DollarLte$inboundSchema),
        z.lazy(() => OneDollarIn$inboundSchema),
        z.lazy(() => OneDollarNin$inboundSchema),
        z.lazy(() => DollarExists$inboundSchema),
      ]),
    ),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    "prefix_messages": "prefixMessages",
    "file_ids": "fileIds",
    "extra_params": "extraParams",
    "invoke_options": "invokeOptions",
    "knowledge_filter": "knowledgeFilter",
  });
});

/** @internal */
export type Deployments$Outbound = {
  key: string;
  inputs?: { [k: string]: string | number | boolean } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?:
    | Array<
      | DeveloperMessage$Outbound
      | SystemMessage$Outbound
      | UserMessage$Outbound
      | ToolMessage$Outbound
      | AssistantMessage$Outbound
    >
    | undefined;
  messages?:
    | Array<
      | MessagesDeveloperMessage$Outbound
      | MessagesSystemMessage$Outbound
      | MessagesUserMessage$Outbound
      | MessagesToolMessage$Outbound
      | MessagesAssistantMessage$Outbound
    >
    | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
  thread?: Thread$Outbound | undefined;
  knowledge_filter?:
    | KnowledgeFilterDollarAnd$Outbound
    | KnowledgeFilterDollarOr$Outbound
    | {
      [k: string]:
        | OneDollarEq$Outbound
        | OneDollarNe$Outbound
        | Three$Outbound
        | DollarGte$Outbound
        | DollarLt$Outbound
        | DollarLte$Outbound
        | OneDollarIn$Outbound
        | OneDollarNin$Outbound
        | DollarExists$Outbound;
    }
    | undefined;
};

/** @internal */
export const Deployments$outboundSchema: z.ZodType<
  Deployments$Outbound,
  z.ZodTypeDef,
  Deployments
> = z.object({
  key: z.string(),
  inputs: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(
    z.union([
      z.lazy(() => DeveloperMessage$outboundSchema),
      z.lazy(() => SystemMessage$outboundSchema),
      z.lazy(() => UserMessage$outboundSchema),
      z.lazy(() => ToolMessage$outboundSchema),
      z.lazy(() => AssistantMessage$outboundSchema),
    ]),
  ).optional(),
  messages: z.array(
    z.union([
      z.lazy(() => MessagesDeveloperMessage$outboundSchema),
      z.lazy(() => MessagesSystemMessage$outboundSchema),
      z.lazy(() => MessagesUserMessage$outboundSchema),
      z.lazy(() => MessagesToolMessage$outboundSchema),
      z.lazy(() => MessagesAssistantMessage$outboundSchema),
    ]),
  ).optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
  thread: z.lazy(() => Thread$outboundSchema).optional(),
  knowledgeFilter: z.union([
    z.lazy(() => KnowledgeFilterDollarAnd$outboundSchema),
    z.lazy(() => KnowledgeFilterDollarOr$outboundSchema),
    z.record(
      z.union([
        z.lazy(() => OneDollarEq$outboundSchema),
        z.lazy(() => OneDollarNe$outboundSchema),
        z.lazy(() => Three$outboundSchema),
        z.lazy(() => DollarGte$outboundSchema),
        z.lazy(() => DollarLt$outboundSchema),
        z.lazy(() => DollarLte$outboundSchema),
        z.lazy(() => OneDollarIn$outboundSchema),
        z.lazy(() => OneDollarNin$outboundSchema),
        z.lazy(() => DollarExists$outboundSchema),
      ]),
    ),
  ]).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
    knowledgeFilter: "knowledge_filter",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments$ {
  /** @deprecated use `Deployments$inboundSchema` instead. */
  export const inboundSchema = Deployments$inboundSchema;
  /** @deprecated use `Deployments$outboundSchema` instead. */
  export const outboundSchema = Deployments$outboundSchema;
  /** @deprecated use `Deployments$Outbound` instead. */
  export type Outbound = Deployments$Outbound;
}

export function deploymentsToJSON(deployments: Deployments): string {
  return JSON.stringify(Deployments$outboundSchema.parse(deployments));
}

export function deploymentsFromJSON(
  jsonString: string,
): SafeParseResult<Deployments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments' from JSON`,
  );
}
