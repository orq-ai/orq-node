/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type Inputs = string | number | boolean;

/**
 * The role of the prompt message
 */
export const Role = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type Role = ClosedEnum<typeof Role>;

export const TwoType = {
  ImageUrl: "image_url",
} as const;
export type TwoType = ClosedEnum<typeof TwoType>;

export type ImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type Two2 = {
  type: TwoType;
  imageUrl: ImageUrl;
};

export const Deployments2Type = {
  Text: "text",
} as const;
export type Deployments2Type = ClosedEnum<typeof Deployments2Type>;

/**
 * Text content part of a prompt message
 */
export type One = {
  type: Deployments2Type;
  text: string;
};

export type Two = One | Two2;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts.
 */
export type Content = string | Array<One | Two2>;

export const Type = {
  Function: "function",
} as const;
export type Type = ClosedEnum<typeof Type>;

export type FunctionT = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type ToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: Type;
  function: FunctionT;
};

export type PrefixMessages = {
  /**
   * The role of the prompt message
   */
  role: Role;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts.
   */
  content: string | Array<One | Two2>;
  toolCalls?: Array<ToolCalls> | undefined;
};

/**
 * The role of the prompt message
 */
export const DeploymentsRole = {
  System: "system",
  Assistant: "assistant",
  User: "user",
  Exception: "exception",
  Tool: "tool",
  Prompt: "prompt",
  Correction: "correction",
  ExpectedOutput: "expected_output",
} as const;
/**
 * The role of the prompt message
 */
export type DeploymentsRole = ClosedEnum<typeof DeploymentsRole>;

export const Deployments2MessagesContentType = {
  ImageUrl: "image_url",
} as const;
export type Deployments2MessagesContentType = ClosedEnum<
  typeof Deployments2MessagesContentType
>;

export type TwoImageUrl = {
  /**
   * Either a URL of the image or the base64 encoded data URI.
   */
  url: string;
  /**
   * Specifies the detail level of the image. Currently only supported with OpenAI models
   */
  detail?: string | undefined;
};

/**
 * The image part of the prompt message. Only supported with vision models.
 */
export type Deployments22 = {
  type: Deployments2MessagesContentType;
  imageUrl: TwoImageUrl;
};

export const Deployments2MessagesType = {
  Text: "text",
} as const;
export type Deployments2MessagesType = ClosedEnum<
  typeof Deployments2MessagesType
>;

/**
 * Text content part of a prompt message
 */
export type Two1 = {
  type: Deployments2MessagesType;
  text: string;
};

export type Content2 = Two1 | Deployments22;

/**
 * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts.
 */
export type DeploymentsContent = string | Array<Two1 | Deployments22>;

export const DeploymentsType = {
  Function: "function",
} as const;
export type DeploymentsType = ClosedEnum<typeof DeploymentsType>;

export type DeploymentsFunction = {
  name: string;
  /**
   * JSON string arguments for the functions
   */
  arguments: string;
};

export type DeploymentsToolCalls = {
  id?: string | undefined;
  index?: number | undefined;
  type: DeploymentsType;
  function: DeploymentsFunction;
};

export type Messages = {
  /**
   * The role of the prompt message
   */
  role: DeploymentsRole;
  /**
   * The contents of the user message. Either the text content of the message or an array of content parts with a defined type, each can be of type `text` or `image_url` when passing in images. You can pass multiple images by adding multiple `image_url` content parts.
   */
  content: string | Array<Two1 | Deployments22>;
  toolCalls?: Array<DeploymentsToolCalls> | undefined;
};

/**
 * Metadata about the document
 */
export type Metadata = {
  /**
   * Name of the file the text is from.
   */
  fileName?: string | undefined;
  /**
   * Content type of the file the text is from.
   */
  fileType?: string | undefined;
  /**
   * The page number the text is from.
   */
  pageNumber?: number | undefined;
};

export type Documents = {
  /**
   * The text content of the document
   */
  text: string;
  /**
   * Metadata about the document
   */
  metadata?: Metadata | undefined;
};

export type InvokeOptions = {
  /**
   * Whether to include the retrieved knowledge chunks in the response.
   */
  includeRetrievals?: boolean | undefined;
};

/**
 * The deployment request payload
 */
export type Deployments = {
  /**
   * The deployment key to invoke
   */
  key: string;
  /**
   * Key-value pairs variables to replace in your prompts. If a variable is not provided that is defined in the prompt, the default variables are used.
   */
  inputs?: { [k: string]: string | number | boolean } | undefined;
  /**
   * Key-value pairs that match your data model and fields declared in your configuration matrix. If you send multiple prompt keys, the context will be applied to the evaluation of each key.
   */
  context?: { [k: string]: any } | undefined;
  /**
   * A list of messages to include after the `System` message, but before the  `User` and `Assistant` pairs configured in your deployment.
   */
  prefixMessages?: Array<PrefixMessages> | undefined;
  /**
   * A list of messages to send to the deployment.
   */
  messages?: Array<Messages> | undefined;
  /**
   * A list of file IDs that are associated with the deployment request.
   */
  fileIds?: Array<string> | undefined;
  /**
   * Key-value pairs that you want to attach to the log generated by this request.
   */
  metadata?: { [k: string]: any } | undefined;
  /**
   * Utilized for passing additional parameters to the model provider. Exercise caution when using this feature, as the included parameters will overwrite any parameters specified in the deployment prompt configuration.
   */
  extraParams?: { [k: string]: any } | undefined;
  /**
   * A list of relevant documents that evaluators and guardrails can cite to evaluate the user input or the model response based on your deployment settings.
   */
  documents?: Array<Documents> | undefined;
  invokeOptions?: InvokeOptions | undefined;
};

/** @internal */
export const Inputs$inboundSchema: z.ZodType<Inputs, z.ZodTypeDef, unknown> = z
  .union([z.string(), z.number(), z.boolean()]);

/** @internal */
export type Inputs$Outbound = string | number | boolean;

/** @internal */
export const Inputs$outboundSchema: z.ZodType<
  Inputs$Outbound,
  z.ZodTypeDef,
  Inputs
> = z.union([z.string(), z.number(), z.boolean()]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Inputs$ {
  /** @deprecated use `Inputs$inboundSchema` instead. */
  export const inboundSchema = Inputs$inboundSchema;
  /** @deprecated use `Inputs$outboundSchema` instead. */
  export const outboundSchema = Inputs$outboundSchema;
  /** @deprecated use `Inputs$Outbound` instead. */
  export type Outbound = Inputs$Outbound;
}

export function inputsToJSON(inputs: Inputs): string {
  return JSON.stringify(Inputs$outboundSchema.parse(inputs));
}

export function inputsFromJSON(
  jsonString: string,
): SafeParseResult<Inputs, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Inputs$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Inputs' from JSON`,
  );
}

/** @internal */
export const Role$inboundSchema: z.ZodNativeEnum<typeof Role> = z.nativeEnum(
  Role,
);

/** @internal */
export const Role$outboundSchema: z.ZodNativeEnum<typeof Role> =
  Role$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Role$ {
  /** @deprecated use `Role$inboundSchema` instead. */
  export const inboundSchema = Role$inboundSchema;
  /** @deprecated use `Role$outboundSchema` instead. */
  export const outboundSchema = Role$outboundSchema;
}

/** @internal */
export const TwoType$inboundSchema: z.ZodNativeEnum<typeof TwoType> = z
  .nativeEnum(TwoType);

/** @internal */
export const TwoType$outboundSchema: z.ZodNativeEnum<typeof TwoType> =
  TwoType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoType$ {
  /** @deprecated use `TwoType$inboundSchema` instead. */
  export const inboundSchema = TwoType$inboundSchema;
  /** @deprecated use `TwoType$outboundSchema` instead. */
  export const outboundSchema = TwoType$outboundSchema;
}

/** @internal */
export const ImageUrl$inboundSchema: z.ZodType<
  ImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/** @internal */
export type ImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const ImageUrl$outboundSchema: z.ZodType<
  ImageUrl$Outbound,
  z.ZodTypeDef,
  ImageUrl
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ImageUrl$ {
  /** @deprecated use `ImageUrl$inboundSchema` instead. */
  export const inboundSchema = ImageUrl$inboundSchema;
  /** @deprecated use `ImageUrl$outboundSchema` instead. */
  export const outboundSchema = ImageUrl$outboundSchema;
  /** @deprecated use `ImageUrl$Outbound` instead. */
  export type Outbound = ImageUrl$Outbound;
}

export function imageUrlToJSON(imageUrl: ImageUrl): string {
  return JSON.stringify(ImageUrl$outboundSchema.parse(imageUrl));
}

export function imageUrlFromJSON(
  jsonString: string,
): SafeParseResult<ImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ImageUrl' from JSON`,
  );
}

/** @internal */
export const Two2$inboundSchema: z.ZodType<Two2, z.ZodTypeDef, unknown> = z
  .object({
    type: TwoType$inboundSchema,
    image_url: z.lazy(() => ImageUrl$inboundSchema),
  }).transform((v) => {
    return remap$(v, {
      "image_url": "imageUrl",
    });
  });

/** @internal */
export type Two2$Outbound = {
  type: string;
  image_url: ImageUrl$Outbound;
};

/** @internal */
export const Two2$outboundSchema: z.ZodType<Two2$Outbound, z.ZodTypeDef, Two2> =
  z.object({
    type: TwoType$outboundSchema,
    imageUrl: z.lazy(() => ImageUrl$outboundSchema),
  }).transform((v) => {
    return remap$(v, {
      imageUrl: "image_url",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two2$ {
  /** @deprecated use `Two2$inboundSchema` instead. */
  export const inboundSchema = Two2$inboundSchema;
  /** @deprecated use `Two2$outboundSchema` instead. */
  export const outboundSchema = Two2$outboundSchema;
  /** @deprecated use `Two2$Outbound` instead. */
  export type Outbound = Two2$Outbound;
}

export function two2ToJSON(two2: Two2): string {
  return JSON.stringify(Two2$outboundSchema.parse(two2));
}

export function two2FromJSON(
  jsonString: string,
): SafeParseResult<Two2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two2' from JSON`,
  );
}

/** @internal */
export const Deployments2Type$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = z.nativeEnum(Deployments2Type);

/** @internal */
export const Deployments2Type$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2Type
> = Deployments2Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2Type$ {
  /** @deprecated use `Deployments2Type$inboundSchema` instead. */
  export const inboundSchema = Deployments2Type$inboundSchema;
  /** @deprecated use `Deployments2Type$outboundSchema` instead. */
  export const outboundSchema = Deployments2Type$outboundSchema;
}

/** @internal */
export const One$inboundSchema: z.ZodType<One, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2Type$inboundSchema,
    text: z.string(),
  });

/** @internal */
export type One$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const One$outboundSchema: z.ZodType<One$Outbound, z.ZodTypeDef, One> = z
  .object({
    type: Deployments2Type$outboundSchema,
    text: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace One$ {
  /** @deprecated use `One$inboundSchema` instead. */
  export const inboundSchema = One$inboundSchema;
  /** @deprecated use `One$outboundSchema` instead. */
  export const outboundSchema = One$outboundSchema;
  /** @deprecated use `One$Outbound` instead. */
  export type Outbound = One$Outbound;
}

export function oneToJSON(one: One): string {
  return JSON.stringify(One$outboundSchema.parse(one));
}

export function oneFromJSON(
  jsonString: string,
): SafeParseResult<One, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => One$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'One' from JSON`,
  );
}

/** @internal */
export const Two$inboundSchema: z.ZodType<Two, z.ZodTypeDef, unknown> = z.union(
  [z.lazy(() => One$inboundSchema), z.lazy(() => Two2$inboundSchema)],
);

/** @internal */
export type Two$Outbound = One$Outbound | Two2$Outbound;

/** @internal */
export const Two$outboundSchema: z.ZodType<Two$Outbound, z.ZodTypeDef, Two> = z
  .union([z.lazy(() => One$outboundSchema), z.lazy(() => Two2$outboundSchema)]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two$ {
  /** @deprecated use `Two$inboundSchema` instead. */
  export const inboundSchema = Two$inboundSchema;
  /** @deprecated use `Two$outboundSchema` instead. */
  export const outboundSchema = Two$outboundSchema;
  /** @deprecated use `Two$Outbound` instead. */
  export type Outbound = Two$Outbound;
}

export function twoToJSON(two: Two): string {
  return JSON.stringify(Two$outboundSchema.parse(two));
}

export function twoFromJSON(
  jsonString: string,
): SafeParseResult<Two, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two' from JSON`,
  );
}

/** @internal */
export const Content$inboundSchema: z.ZodType<Content, z.ZodTypeDef, unknown> =
  z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => One$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
    ])),
  ]);

/** @internal */
export type Content$Outbound = string | Array<One$Outbound | Two2$Outbound>;

/** @internal */
export const Content$outboundSchema: z.ZodType<
  Content$Outbound,
  z.ZodTypeDef,
  Content
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => One$outboundSchema),
    z.lazy(() => Two2$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content$ {
  /** @deprecated use `Content$inboundSchema` instead. */
  export const inboundSchema = Content$inboundSchema;
  /** @deprecated use `Content$outboundSchema` instead. */
  export const outboundSchema = Content$outboundSchema;
  /** @deprecated use `Content$Outbound` instead. */
  export type Outbound = Content$Outbound;
}

export function contentToJSON(content: Content): string {
  return JSON.stringify(Content$outboundSchema.parse(content));
}

export function contentFromJSON(
  jsonString: string,
): SafeParseResult<Content, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content' from JSON`,
  );
}

/** @internal */
export const Type$inboundSchema: z.ZodNativeEnum<typeof Type> = z.nativeEnum(
  Type,
);

/** @internal */
export const Type$outboundSchema: z.ZodNativeEnum<typeof Type> =
  Type$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Type$ {
  /** @deprecated use `Type$inboundSchema` instead. */
  export const inboundSchema = Type$inboundSchema;
  /** @deprecated use `Type$outboundSchema` instead. */
  export const outboundSchema = Type$outboundSchema;
}

/** @internal */
export const FunctionT$inboundSchema: z.ZodType<
  FunctionT,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

/** @internal */
export type FunctionT$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const FunctionT$outboundSchema: z.ZodType<
  FunctionT$Outbound,
  z.ZodTypeDef,
  FunctionT
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FunctionT$ {
  /** @deprecated use `FunctionT$inboundSchema` instead. */
  export const inboundSchema = FunctionT$inboundSchema;
  /** @deprecated use `FunctionT$outboundSchema` instead. */
  export const outboundSchema = FunctionT$outboundSchema;
  /** @deprecated use `FunctionT$Outbound` instead. */
  export type Outbound = FunctionT$Outbound;
}

export function functionToJSON(functionT: FunctionT): string {
  return JSON.stringify(FunctionT$outboundSchema.parse(functionT));
}

export function functionFromJSON(
  jsonString: string,
): SafeParseResult<FunctionT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FunctionT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FunctionT' from JSON`,
  );
}

/** @internal */
export const ToolCalls$inboundSchema: z.ZodType<
  ToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: Type$inboundSchema,
  function: z.lazy(() => FunctionT$inboundSchema),
});

/** @internal */
export type ToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: FunctionT$Outbound;
};

/** @internal */
export const ToolCalls$outboundSchema: z.ZodType<
  ToolCalls$Outbound,
  z.ZodTypeDef,
  ToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: Type$outboundSchema,
  function: z.lazy(() => FunctionT$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ToolCalls$ {
  /** @deprecated use `ToolCalls$inboundSchema` instead. */
  export const inboundSchema = ToolCalls$inboundSchema;
  /** @deprecated use `ToolCalls$outboundSchema` instead. */
  export const outboundSchema = ToolCalls$outboundSchema;
  /** @deprecated use `ToolCalls$Outbound` instead. */
  export type Outbound = ToolCalls$Outbound;
}

export function toolCallsToJSON(toolCalls: ToolCalls): string {
  return JSON.stringify(ToolCalls$outboundSchema.parse(toolCalls));
}

export function toolCallsFromJSON(
  jsonString: string,
): SafeParseResult<ToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolCalls' from JSON`,
  );
}

/** @internal */
export const PrefixMessages$inboundSchema: z.ZodType<
  PrefixMessages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: Role$inboundSchema,
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => One$inboundSchema),
      z.lazy(() => Two2$inboundSchema),
    ])),
  ]),
  tool_calls: z.array(z.lazy(() => ToolCalls$inboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});

/** @internal */
export type PrefixMessages$Outbound = {
  role: string;
  content: string | Array<One$Outbound | Two2$Outbound>;
  tool_calls?: Array<ToolCalls$Outbound> | undefined;
};

/** @internal */
export const PrefixMessages$outboundSchema: z.ZodType<
  PrefixMessages$Outbound,
  z.ZodTypeDef,
  PrefixMessages
> = z.object({
  role: Role$outboundSchema,
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => One$outboundSchema),
      z.lazy(() => Two2$outboundSchema),
    ])),
  ]),
  toolCalls: z.array(z.lazy(() => ToolCalls$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrefixMessages$ {
  /** @deprecated use `PrefixMessages$inboundSchema` instead. */
  export const inboundSchema = PrefixMessages$inboundSchema;
  /** @deprecated use `PrefixMessages$outboundSchema` instead. */
  export const outboundSchema = PrefixMessages$outboundSchema;
  /** @deprecated use `PrefixMessages$Outbound` instead. */
  export type Outbound = PrefixMessages$Outbound;
}

export function prefixMessagesToJSON(prefixMessages: PrefixMessages): string {
  return JSON.stringify(PrefixMessages$outboundSchema.parse(prefixMessages));
}

export function prefixMessagesFromJSON(
  jsonString: string,
): SafeParseResult<PrefixMessages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => PrefixMessages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'PrefixMessages' from JSON`,
  );
}

/** @internal */
export const DeploymentsRole$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsRole
> = z.nativeEnum(DeploymentsRole);

/** @internal */
export const DeploymentsRole$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsRole
> = DeploymentsRole$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsRole$ {
  /** @deprecated use `DeploymentsRole$inboundSchema` instead. */
  export const inboundSchema = DeploymentsRole$inboundSchema;
  /** @deprecated use `DeploymentsRole$outboundSchema` instead. */
  export const outboundSchema = DeploymentsRole$outboundSchema;
}

/** @internal */
export const Deployments2MessagesContentType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesContentType
> = z.nativeEnum(Deployments2MessagesContentType);

/** @internal */
export const Deployments2MessagesContentType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesContentType
> = Deployments2MessagesContentType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2MessagesContentType$ {
  /** @deprecated use `Deployments2MessagesContentType$inboundSchema` instead. */
  export const inboundSchema = Deployments2MessagesContentType$inboundSchema;
  /** @deprecated use `Deployments2MessagesContentType$outboundSchema` instead. */
  export const outboundSchema = Deployments2MessagesContentType$outboundSchema;
}

/** @internal */
export const TwoImageUrl$inboundSchema: z.ZodType<
  TwoImageUrl,
  z.ZodTypeDef,
  unknown
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/** @internal */
export type TwoImageUrl$Outbound = {
  url: string;
  detail?: string | undefined;
};

/** @internal */
export const TwoImageUrl$outboundSchema: z.ZodType<
  TwoImageUrl$Outbound,
  z.ZodTypeDef,
  TwoImageUrl
> = z.object({
  url: z.string(),
  detail: z.string().optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TwoImageUrl$ {
  /** @deprecated use `TwoImageUrl$inboundSchema` instead. */
  export const inboundSchema = TwoImageUrl$inboundSchema;
  /** @deprecated use `TwoImageUrl$outboundSchema` instead. */
  export const outboundSchema = TwoImageUrl$outboundSchema;
  /** @deprecated use `TwoImageUrl$Outbound` instead. */
  export type Outbound = TwoImageUrl$Outbound;
}

export function twoImageUrlToJSON(twoImageUrl: TwoImageUrl): string {
  return JSON.stringify(TwoImageUrl$outboundSchema.parse(twoImageUrl));
}

export function twoImageUrlFromJSON(
  jsonString: string,
): SafeParseResult<TwoImageUrl, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => TwoImageUrl$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'TwoImageUrl' from JSON`,
  );
}

/** @internal */
export const Deployments22$inboundSchema: z.ZodType<
  Deployments22,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: Deployments2MessagesContentType$inboundSchema,
  image_url: z.lazy(() => TwoImageUrl$inboundSchema),
}).transform((v) => {
  return remap$(v, {
    "image_url": "imageUrl",
  });
});

/** @internal */
export type Deployments22$Outbound = {
  type: string;
  image_url: TwoImageUrl$Outbound;
};

/** @internal */
export const Deployments22$outboundSchema: z.ZodType<
  Deployments22$Outbound,
  z.ZodTypeDef,
  Deployments22
> = z.object({
  type: Deployments2MessagesContentType$outboundSchema,
  imageUrl: z.lazy(() => TwoImageUrl$outboundSchema),
}).transform((v) => {
  return remap$(v, {
    imageUrl: "image_url",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments22$ {
  /** @deprecated use `Deployments22$inboundSchema` instead. */
  export const inboundSchema = Deployments22$inboundSchema;
  /** @deprecated use `Deployments22$outboundSchema` instead. */
  export const outboundSchema = Deployments22$outboundSchema;
  /** @deprecated use `Deployments22$Outbound` instead. */
  export type Outbound = Deployments22$Outbound;
}

export function deployments22ToJSON(deployments22: Deployments22): string {
  return JSON.stringify(Deployments22$outboundSchema.parse(deployments22));
}

export function deployments22FromJSON(
  jsonString: string,
): SafeParseResult<Deployments22, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments22$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments22' from JSON`,
  );
}

/** @internal */
export const Deployments2MessagesType$inboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesType
> = z.nativeEnum(Deployments2MessagesType);

/** @internal */
export const Deployments2MessagesType$outboundSchema: z.ZodNativeEnum<
  typeof Deployments2MessagesType
> = Deployments2MessagesType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments2MessagesType$ {
  /** @deprecated use `Deployments2MessagesType$inboundSchema` instead. */
  export const inboundSchema = Deployments2MessagesType$inboundSchema;
  /** @deprecated use `Deployments2MessagesType$outboundSchema` instead. */
  export const outboundSchema = Deployments2MessagesType$outboundSchema;
}

/** @internal */
export const Two1$inboundSchema: z.ZodType<Two1, z.ZodTypeDef, unknown> = z
  .object({
    type: Deployments2MessagesType$inboundSchema,
    text: z.string(),
  });

/** @internal */
export type Two1$Outbound = {
  type: string;
  text: string;
};

/** @internal */
export const Two1$outboundSchema: z.ZodType<Two1$Outbound, z.ZodTypeDef, Two1> =
  z.object({
    type: Deployments2MessagesType$outboundSchema,
    text: z.string(),
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Two1$ {
  /** @deprecated use `Two1$inboundSchema` instead. */
  export const inboundSchema = Two1$inboundSchema;
  /** @deprecated use `Two1$outboundSchema` instead. */
  export const outboundSchema = Two1$outboundSchema;
  /** @deprecated use `Two1$Outbound` instead. */
  export type Outbound = Two1$Outbound;
}

export function two1ToJSON(two1: Two1): string {
  return JSON.stringify(Two1$outboundSchema.parse(two1));
}

export function two1FromJSON(
  jsonString: string,
): SafeParseResult<Two1, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Two1$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Two1' from JSON`,
  );
}

/** @internal */
export const Content2$inboundSchema: z.ZodType<
  Content2,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.lazy(() => Two1$inboundSchema),
  z.lazy(() => Deployments22$inboundSchema),
]);

/** @internal */
export type Content2$Outbound = Two1$Outbound | Deployments22$Outbound;

/** @internal */
export const Content2$outboundSchema: z.ZodType<
  Content2$Outbound,
  z.ZodTypeDef,
  Content2
> = z.union([
  z.lazy(() => Two1$outboundSchema),
  z.lazy(() => Deployments22$outboundSchema),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Content2$ {
  /** @deprecated use `Content2$inboundSchema` instead. */
  export const inboundSchema = Content2$inboundSchema;
  /** @deprecated use `Content2$outboundSchema` instead. */
  export const outboundSchema = Content2$outboundSchema;
  /** @deprecated use `Content2$Outbound` instead. */
  export type Outbound = Content2$Outbound;
}

export function content2ToJSON(content2: Content2): string {
  return JSON.stringify(Content2$outboundSchema.parse(content2));
}

export function content2FromJSON(
  jsonString: string,
): SafeParseResult<Content2, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Content2$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Content2' from JSON`,
  );
}

/** @internal */
export const DeploymentsContent$inboundSchema: z.ZodType<
  DeploymentsContent,
  z.ZodTypeDef,
  unknown
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$inboundSchema),
    z.lazy(() => Deployments22$inboundSchema),
  ])),
]);

/** @internal */
export type DeploymentsContent$Outbound =
  | string
  | Array<Two1$Outbound | Deployments22$Outbound>;

/** @internal */
export const DeploymentsContent$outboundSchema: z.ZodType<
  DeploymentsContent$Outbound,
  z.ZodTypeDef,
  DeploymentsContent
> = z.union([
  z.string(),
  z.array(z.union([
    z.lazy(() => Two1$outboundSchema),
    z.lazy(() => Deployments22$outboundSchema),
  ])),
]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsContent$ {
  /** @deprecated use `DeploymentsContent$inboundSchema` instead. */
  export const inboundSchema = DeploymentsContent$inboundSchema;
  /** @deprecated use `DeploymentsContent$outboundSchema` instead. */
  export const outboundSchema = DeploymentsContent$outboundSchema;
  /** @deprecated use `DeploymentsContent$Outbound` instead. */
  export type Outbound = DeploymentsContent$Outbound;
}

export function deploymentsContentToJSON(
  deploymentsContent: DeploymentsContent,
): string {
  return JSON.stringify(
    DeploymentsContent$outboundSchema.parse(deploymentsContent),
  );
}

export function deploymentsContentFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsContent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsContent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsContent' from JSON`,
  );
}

/** @internal */
export const DeploymentsType$inboundSchema: z.ZodNativeEnum<
  typeof DeploymentsType
> = z.nativeEnum(DeploymentsType);

/** @internal */
export const DeploymentsType$outboundSchema: z.ZodNativeEnum<
  typeof DeploymentsType
> = DeploymentsType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsType$ {
  /** @deprecated use `DeploymentsType$inboundSchema` instead. */
  export const inboundSchema = DeploymentsType$inboundSchema;
  /** @deprecated use `DeploymentsType$outboundSchema` instead. */
  export const outboundSchema = DeploymentsType$outboundSchema;
}

/** @internal */
export const DeploymentsFunction$inboundSchema: z.ZodType<
  DeploymentsFunction,
  z.ZodTypeDef,
  unknown
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

/** @internal */
export type DeploymentsFunction$Outbound = {
  name: string;
  arguments: string;
};

/** @internal */
export const DeploymentsFunction$outboundSchema: z.ZodType<
  DeploymentsFunction$Outbound,
  z.ZodTypeDef,
  DeploymentsFunction
> = z.object({
  name: z.string(),
  arguments: z.string(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsFunction$ {
  /** @deprecated use `DeploymentsFunction$inboundSchema` instead. */
  export const inboundSchema = DeploymentsFunction$inboundSchema;
  /** @deprecated use `DeploymentsFunction$outboundSchema` instead. */
  export const outboundSchema = DeploymentsFunction$outboundSchema;
  /** @deprecated use `DeploymentsFunction$Outbound` instead. */
  export type Outbound = DeploymentsFunction$Outbound;
}

export function deploymentsFunctionToJSON(
  deploymentsFunction: DeploymentsFunction,
): string {
  return JSON.stringify(
    DeploymentsFunction$outboundSchema.parse(deploymentsFunction),
  );
}

export function deploymentsFunctionFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsFunction, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsFunction$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsFunction' from JSON`,
  );
}

/** @internal */
export const DeploymentsToolCalls$inboundSchema: z.ZodType<
  DeploymentsToolCalls,
  z.ZodTypeDef,
  unknown
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentsType$inboundSchema,
  function: z.lazy(() => DeploymentsFunction$inboundSchema),
});

/** @internal */
export type DeploymentsToolCalls$Outbound = {
  id?: string | undefined;
  index?: number | undefined;
  type: string;
  function: DeploymentsFunction$Outbound;
};

/** @internal */
export const DeploymentsToolCalls$outboundSchema: z.ZodType<
  DeploymentsToolCalls$Outbound,
  z.ZodTypeDef,
  DeploymentsToolCalls
> = z.object({
  id: z.string().optional(),
  index: z.number().optional(),
  type: DeploymentsType$outboundSchema,
  function: z.lazy(() => DeploymentsFunction$outboundSchema),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace DeploymentsToolCalls$ {
  /** @deprecated use `DeploymentsToolCalls$inboundSchema` instead. */
  export const inboundSchema = DeploymentsToolCalls$inboundSchema;
  /** @deprecated use `DeploymentsToolCalls$outboundSchema` instead. */
  export const outboundSchema = DeploymentsToolCalls$outboundSchema;
  /** @deprecated use `DeploymentsToolCalls$Outbound` instead. */
  export type Outbound = DeploymentsToolCalls$Outbound;
}

export function deploymentsToolCallsToJSON(
  deploymentsToolCalls: DeploymentsToolCalls,
): string {
  return JSON.stringify(
    DeploymentsToolCalls$outboundSchema.parse(deploymentsToolCalls),
  );
}

export function deploymentsToolCallsFromJSON(
  jsonString: string,
): SafeParseResult<DeploymentsToolCalls, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => DeploymentsToolCalls$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'DeploymentsToolCalls' from JSON`,
  );
}

/** @internal */
export const Messages$inboundSchema: z.ZodType<
  Messages,
  z.ZodTypeDef,
  unknown
> = z.object({
  role: DeploymentsRole$inboundSchema,
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$inboundSchema),
      z.lazy(() => Deployments22$inboundSchema),
    ])),
  ]),
  tool_calls: z.array(z.lazy(() => DeploymentsToolCalls$inboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_calls": "toolCalls",
  });
});

/** @internal */
export type Messages$Outbound = {
  role: string;
  content: string | Array<Two1$Outbound | Deployments22$Outbound>;
  tool_calls?: Array<DeploymentsToolCalls$Outbound> | undefined;
};

/** @internal */
export const Messages$outboundSchema: z.ZodType<
  Messages$Outbound,
  z.ZodTypeDef,
  Messages
> = z.object({
  role: DeploymentsRole$outboundSchema,
  content: z.union([
    z.string(),
    z.array(z.union([
      z.lazy(() => Two1$outboundSchema),
      z.lazy(() => Deployments22$outboundSchema),
    ])),
  ]),
  toolCalls: z.array(z.lazy(() => DeploymentsToolCalls$outboundSchema))
    .optional(),
}).transform((v) => {
  return remap$(v, {
    toolCalls: "tool_calls",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Messages$ {
  /** @deprecated use `Messages$inboundSchema` instead. */
  export const inboundSchema = Messages$inboundSchema;
  /** @deprecated use `Messages$outboundSchema` instead. */
  export const outboundSchema = Messages$outboundSchema;
  /** @deprecated use `Messages$Outbound` instead. */
  export type Outbound = Messages$Outbound;
}

export function messagesToJSON(messages: Messages): string {
  return JSON.stringify(Messages$outboundSchema.parse(messages));
}

export function messagesFromJSON(
  jsonString: string,
): SafeParseResult<Messages, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Messages$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Messages' from JSON`,
  );
}

/** @internal */
export const Metadata$inboundSchema: z.ZodType<
  Metadata,
  z.ZodTypeDef,
  unknown
> = z.object({
  file_name: z.string().optional(),
  file_type: z.string().optional(),
  page_number: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    "file_name": "fileName",
    "file_type": "fileType",
    "page_number": "pageNumber",
  });
});

/** @internal */
export type Metadata$Outbound = {
  file_name?: string | undefined;
  file_type?: string | undefined;
  page_number?: number | undefined;
};

/** @internal */
export const Metadata$outboundSchema: z.ZodType<
  Metadata$Outbound,
  z.ZodTypeDef,
  Metadata
> = z.object({
  fileName: z.string().optional(),
  fileType: z.string().optional(),
  pageNumber: z.number().optional(),
}).transform((v) => {
  return remap$(v, {
    fileName: "file_name",
    fileType: "file_type",
    pageNumber: "page_number",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Metadata$ {
  /** @deprecated use `Metadata$inboundSchema` instead. */
  export const inboundSchema = Metadata$inboundSchema;
  /** @deprecated use `Metadata$outboundSchema` instead. */
  export const outboundSchema = Metadata$outboundSchema;
  /** @deprecated use `Metadata$Outbound` instead. */
  export type Outbound = Metadata$Outbound;
}

export function metadataToJSON(metadata: Metadata): string {
  return JSON.stringify(Metadata$outboundSchema.parse(metadata));
}

export function metadataFromJSON(
  jsonString: string,
): SafeParseResult<Metadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Metadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Metadata' from JSON`,
  );
}

/** @internal */
export const Documents$inboundSchema: z.ZodType<
  Documents,
  z.ZodTypeDef,
  unknown
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$inboundSchema).optional(),
});

/** @internal */
export type Documents$Outbound = {
  text: string;
  metadata?: Metadata$Outbound | undefined;
};

/** @internal */
export const Documents$outboundSchema: z.ZodType<
  Documents$Outbound,
  z.ZodTypeDef,
  Documents
> = z.object({
  text: z.string(),
  metadata: z.lazy(() => Metadata$outboundSchema).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Documents$ {
  /** @deprecated use `Documents$inboundSchema` instead. */
  export const inboundSchema = Documents$inboundSchema;
  /** @deprecated use `Documents$outboundSchema` instead. */
  export const outboundSchema = Documents$outboundSchema;
  /** @deprecated use `Documents$Outbound` instead. */
  export type Outbound = Documents$Outbound;
}

export function documentsToJSON(documents: Documents): string {
  return JSON.stringify(Documents$outboundSchema.parse(documents));
}

export function documentsFromJSON(
  jsonString: string,
): SafeParseResult<Documents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Documents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Documents' from JSON`,
  );
}

/** @internal */
export const InvokeOptions$inboundSchema: z.ZodType<
  InvokeOptions,
  z.ZodTypeDef,
  unknown
> = z.object({
  include_retrievals: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    "include_retrievals": "includeRetrievals",
  });
});

/** @internal */
export type InvokeOptions$Outbound = {
  include_retrievals: boolean;
};

/** @internal */
export const InvokeOptions$outboundSchema: z.ZodType<
  InvokeOptions$Outbound,
  z.ZodTypeDef,
  InvokeOptions
> = z.object({
  includeRetrievals: z.boolean().default(false),
}).transform((v) => {
  return remap$(v, {
    includeRetrievals: "include_retrievals",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace InvokeOptions$ {
  /** @deprecated use `InvokeOptions$inboundSchema` instead. */
  export const inboundSchema = InvokeOptions$inboundSchema;
  /** @deprecated use `InvokeOptions$outboundSchema` instead. */
  export const outboundSchema = InvokeOptions$outboundSchema;
  /** @deprecated use `InvokeOptions$Outbound` instead. */
  export type Outbound = InvokeOptions$Outbound;
}

export function invokeOptionsToJSON(invokeOptions: InvokeOptions): string {
  return JSON.stringify(InvokeOptions$outboundSchema.parse(invokeOptions));
}

export function invokeOptionsFromJSON(
  jsonString: string,
): SafeParseResult<InvokeOptions, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => InvokeOptions$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'InvokeOptions' from JSON`,
  );
}

/** @internal */
export const Deployments$inboundSchema: z.ZodType<
  Deployments,
  z.ZodTypeDef,
  unknown
> = z.object({
  key: z.string(),
  inputs: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  context: z.record(z.any()).optional(),
  prefix_messages: z.array(z.lazy(() => PrefixMessages$inboundSchema))
    .optional(),
  messages: z.array(z.lazy(() => Messages$inboundSchema)).optional(),
  file_ids: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extra_params: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$inboundSchema)).optional(),
  invoke_options: z.lazy(() => InvokeOptions$inboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    "prefix_messages": "prefixMessages",
    "file_ids": "fileIds",
    "extra_params": "extraParams",
    "invoke_options": "invokeOptions",
  });
});

/** @internal */
export type Deployments$Outbound = {
  key: string;
  inputs?: { [k: string]: string | number | boolean } | undefined;
  context?: { [k: string]: any } | undefined;
  prefix_messages?: Array<PrefixMessages$Outbound> | undefined;
  messages?: Array<Messages$Outbound> | undefined;
  file_ids?: Array<string> | undefined;
  metadata?: { [k: string]: any } | undefined;
  extra_params?: { [k: string]: any } | undefined;
  documents?: Array<Documents$Outbound> | undefined;
  invoke_options?: InvokeOptions$Outbound | undefined;
};

/** @internal */
export const Deployments$outboundSchema: z.ZodType<
  Deployments$Outbound,
  z.ZodTypeDef,
  Deployments
> = z.object({
  key: z.string(),
  inputs: z.record(z.union([z.string(), z.number(), z.boolean()])).optional(),
  context: z.record(z.any()).optional(),
  prefixMessages: z.array(z.lazy(() => PrefixMessages$outboundSchema))
    .optional(),
  messages: z.array(z.lazy(() => Messages$outboundSchema)).optional(),
  fileIds: z.array(z.string()).optional(),
  metadata: z.record(z.any()).optional(),
  extraParams: z.record(z.any()).optional(),
  documents: z.array(z.lazy(() => Documents$outboundSchema)).optional(),
  invokeOptions: z.lazy(() => InvokeOptions$outboundSchema).optional(),
}).transform((v) => {
  return remap$(v, {
    prefixMessages: "prefix_messages",
    fileIds: "file_ids",
    extraParams: "extra_params",
    invokeOptions: "invoke_options",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Deployments$ {
  /** @deprecated use `Deployments$inboundSchema` instead. */
  export const inboundSchema = Deployments$inboundSchema;
  /** @deprecated use `Deployments$outboundSchema` instead. */
  export const outboundSchema = Deployments$outboundSchema;
  /** @deprecated use `Deployments$Outbound` instead. */
  export type Outbound = Deployments$Outbound;
}

export function deploymentsToJSON(deployments: Deployments): string {
  return JSON.stringify(Deployments$outboundSchema.parse(deployments));
}

export function deploymentsFromJSON(
  jsonString: string,
): SafeParseResult<Deployments, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Deployments$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Deployments' from JSON`,
  );
}
