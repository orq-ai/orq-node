/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Orquesta product
 */
export const Product = {
  Remoteconfigs: "remoteconfigs",
  Deployments: "deployments",
  Experiments: "experiments",
  Playgrounds: "playgrounds",
  Spreadsheets: "spreadsheets",
  SpreadsheetRun: "spreadsheet_run",
  LlmEvaluator: "llm_evaluator",
  Knowledge: "knowledge",
  Router: "router",
  Workflows: "workflows",
  ExternalEvents: "external_events",
  Agents: "agents",
  MemoryStores: "memory-stores",
  Generic: "generic",
  Evaluators: "evaluators",
  Otel: "otel",
  AiChat: "ai-chat",
} as const;
/**
 * Orquesta product
 */
export type Product = ClosedEnum<typeof Product>;

export type Memory = {
  entityId: string;
};

export type ToolExecutionContext = {
  actionId: string;
  agentToolCallId: string;
  workspaceId: string;
  agentManifestId: string;
  agentExecutionId: string;
  /**
   * Orquesta product
   */
  product: Product;
  memory?: Memory | undefined;
  parentId?: string | undefined;
};

export type ToolExecutionStartedStreamingEventData = {
  toolId: string;
  toolKey?: string | undefined;
  toolDisplayName?: string | undefined;
  actionType: string;
  toolArguments: { [k: string]: any };
  toolExecutionContext: ToolExecutionContext;
  responseId?: string | undefined;
  workflowRunId: string;
  stream?: boolean | undefined;
};

/**
 * Emitted when a tool begins execution. Contains the tool ID, name, action type, input arguments, and execution context.
 */
export type ToolExecutionStartedStreamingEvent = {
  type: "event.workflow_events.tool_execution_started";
  /**
   * ISO timestamp of the event
   */
  timestamp: string;
  data: ToolExecutionStartedStreamingEventData;
};

/** @internal */
export const Product$inboundSchema: z.ZodNativeEnum<typeof Product> = z
  .nativeEnum(Product);
/** @internal */
export const Product$outboundSchema: z.ZodNativeEnum<typeof Product> =
  Product$inboundSchema;

/** @internal */
export const Memory$inboundSchema: z.ZodType<Memory, z.ZodTypeDef, unknown> = z
  .object({
    entity_id: z.string(),
  }).transform((v) => {
    return remap$(v, {
      "entity_id": "entityId",
    });
  });
/** @internal */
export type Memory$Outbound = {
  entity_id: string;
};

/** @internal */
export const Memory$outboundSchema: z.ZodType<
  Memory$Outbound,
  z.ZodTypeDef,
  Memory
> = z.object({
  entityId: z.string(),
}).transform((v) => {
  return remap$(v, {
    entityId: "entity_id",
  });
});

export function memoryToJSON(memory: Memory): string {
  return JSON.stringify(Memory$outboundSchema.parse(memory));
}
export function memoryFromJSON(
  jsonString: string,
): SafeParseResult<Memory, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Memory$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Memory' from JSON`,
  );
}

/** @internal */
export const ToolExecutionContext$inboundSchema: z.ZodType<
  ToolExecutionContext,
  z.ZodTypeDef,
  unknown
> = z.object({
  action_id: z.string(),
  agent_tool_call_id: z.string(),
  workspace_id: z.string(),
  agent_manifest_id: z.string(),
  agent_execution_id: z.string(),
  product: Product$inboundSchema,
  memory: z.lazy(() => Memory$inboundSchema).optional(),
  parent_id: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    "action_id": "actionId",
    "agent_tool_call_id": "agentToolCallId",
    "workspace_id": "workspaceId",
    "agent_manifest_id": "agentManifestId",
    "agent_execution_id": "agentExecutionId",
    "parent_id": "parentId",
  });
});
/** @internal */
export type ToolExecutionContext$Outbound = {
  action_id: string;
  agent_tool_call_id: string;
  workspace_id: string;
  agent_manifest_id: string;
  agent_execution_id: string;
  product: string;
  memory?: Memory$Outbound | undefined;
  parent_id?: string | undefined;
};

/** @internal */
export const ToolExecutionContext$outboundSchema: z.ZodType<
  ToolExecutionContext$Outbound,
  z.ZodTypeDef,
  ToolExecutionContext
> = z.object({
  actionId: z.string(),
  agentToolCallId: z.string(),
  workspaceId: z.string(),
  agentManifestId: z.string(),
  agentExecutionId: z.string(),
  product: Product$outboundSchema,
  memory: z.lazy(() => Memory$outboundSchema).optional(),
  parentId: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    actionId: "action_id",
    agentToolCallId: "agent_tool_call_id",
    workspaceId: "workspace_id",
    agentManifestId: "agent_manifest_id",
    agentExecutionId: "agent_execution_id",
    parentId: "parent_id",
  });
});

export function toolExecutionContextToJSON(
  toolExecutionContext: ToolExecutionContext,
): string {
  return JSON.stringify(
    ToolExecutionContext$outboundSchema.parse(toolExecutionContext),
  );
}
export function toolExecutionContextFromJSON(
  jsonString: string,
): SafeParseResult<ToolExecutionContext, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => ToolExecutionContext$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolExecutionContext' from JSON`,
  );
}

/** @internal */
export const ToolExecutionStartedStreamingEventData$inboundSchema: z.ZodType<
  ToolExecutionStartedStreamingEventData,
  z.ZodTypeDef,
  unknown
> = z.object({
  tool_id: z.string(),
  tool_key: z.string().optional(),
  tool_display_name: z.string().optional(),
  action_type: z.string(),
  tool_arguments: z.record(z.any()),
  tool_execution_context: z.lazy(() => ToolExecutionContext$inboundSchema),
  responseId: z.string().optional(),
  workflowRunId: z.string(),
  stream: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    "tool_id": "toolId",
    "tool_key": "toolKey",
    "tool_display_name": "toolDisplayName",
    "action_type": "actionType",
    "tool_arguments": "toolArguments",
    "tool_execution_context": "toolExecutionContext",
  });
});
/** @internal */
export type ToolExecutionStartedStreamingEventData$Outbound = {
  tool_id: string;
  tool_key?: string | undefined;
  tool_display_name?: string | undefined;
  action_type: string;
  tool_arguments: { [k: string]: any };
  tool_execution_context: ToolExecutionContext$Outbound;
  responseId?: string | undefined;
  workflowRunId: string;
  stream?: boolean | undefined;
};

/** @internal */
export const ToolExecutionStartedStreamingEventData$outboundSchema: z.ZodType<
  ToolExecutionStartedStreamingEventData$Outbound,
  z.ZodTypeDef,
  ToolExecutionStartedStreamingEventData
> = z.object({
  toolId: z.string(),
  toolKey: z.string().optional(),
  toolDisplayName: z.string().optional(),
  actionType: z.string(),
  toolArguments: z.record(z.any()),
  toolExecutionContext: z.lazy(() => ToolExecutionContext$outboundSchema),
  responseId: z.string().optional(),
  workflowRunId: z.string(),
  stream: z.boolean().optional(),
}).transform((v) => {
  return remap$(v, {
    toolId: "tool_id",
    toolKey: "tool_key",
    toolDisplayName: "tool_display_name",
    actionType: "action_type",
    toolArguments: "tool_arguments",
    toolExecutionContext: "tool_execution_context",
  });
});

export function toolExecutionStartedStreamingEventDataToJSON(
  toolExecutionStartedStreamingEventData:
    ToolExecutionStartedStreamingEventData,
): string {
  return JSON.stringify(
    ToolExecutionStartedStreamingEventData$outboundSchema.parse(
      toolExecutionStartedStreamingEventData,
    ),
  );
}
export function toolExecutionStartedStreamingEventDataFromJSON(
  jsonString: string,
): SafeParseResult<ToolExecutionStartedStreamingEventData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ToolExecutionStartedStreamingEventData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolExecutionStartedStreamingEventData' from JSON`,
  );
}

/** @internal */
export const ToolExecutionStartedStreamingEvent$inboundSchema: z.ZodType<
  ToolExecutionStartedStreamingEvent,
  z.ZodTypeDef,
  unknown
> = z.object({
  type: z.literal("event.workflow_events.tool_execution_started"),
  timestamp: z.string(),
  data: z.lazy(() => ToolExecutionStartedStreamingEventData$inboundSchema),
});
/** @internal */
export type ToolExecutionStartedStreamingEvent$Outbound = {
  type: "event.workflow_events.tool_execution_started";
  timestamp: string;
  data: ToolExecutionStartedStreamingEventData$Outbound;
};

/** @internal */
export const ToolExecutionStartedStreamingEvent$outboundSchema: z.ZodType<
  ToolExecutionStartedStreamingEvent$Outbound,
  z.ZodTypeDef,
  ToolExecutionStartedStreamingEvent
> = z.object({
  type: z.literal("event.workflow_events.tool_execution_started"),
  timestamp: z.string(),
  data: z.lazy(() => ToolExecutionStartedStreamingEventData$outboundSchema),
});

export function toolExecutionStartedStreamingEventToJSON(
  toolExecutionStartedStreamingEvent: ToolExecutionStartedStreamingEvent,
): string {
  return JSON.stringify(
    ToolExecutionStartedStreamingEvent$outboundSchema.parse(
      toolExecutionStartedStreamingEvent,
    ),
  );
}
export function toolExecutionStartedStreamingEventFromJSON(
  jsonString: string,
): SafeParseResult<ToolExecutionStartedStreamingEvent, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) =>
      ToolExecutionStartedStreamingEvent$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'ToolExecutionStartedStreamingEvent' from JSON`,
  );
}
